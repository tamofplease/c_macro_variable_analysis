<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/executor/nodeIndexscan.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeIndexscan.c
 *      Routines to support indexed scans of relations
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/executor/nodeIndexscan.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 * INTERFACE ROUTINES
 *        ExecIndexScan            scans a relation using an index
 *        IndexNext                retrieve next tuple using index
 *        IndexNextWithReorder    same, but recheck ORDER BY expressions
 *        ExecInitIndexScan        creates and initializes state info.
 *        ExecReScanIndexScan        rescans the indexed relation.
 *        ExecEndIndexScan        releases all storage.
 *        ExecIndexMarkPos        marks scan position.
 *        ExecIndexRestrPos        restores scan position.
 *        ExecIndexScanEstimate    estimates DSM space needed for parallel index scan
 *        ExecIndexScanInitializeDSM initialize DSM for parallel indexscan
 *		ExecIndexScanReInitializeDSM reinitialize DSM for fresh scan
 *        ExecIndexScanInitializeWorker attach to DSM info in parallel worker
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeIndexscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/pairingheap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/mls.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"audit/audit_fga.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * When an ordering operator is used, tuples fetched from the index that
 * need to be reordered are queued in a pairing heap, as ReorderTuples.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>pairingheap_node</name></type> <name>ph_node</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>htup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>orderbyvals</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>orderbynulls</name></decl>;</decl_stmt>
}</block></struct></type> <name>ReorderTuple</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>IndexNext</name><parameter_list>(<parameter><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>IndexNextWithReorder</name><parameter_list>(<parameter><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EvalOrderByExpressions</name><parameter_list>(<parameter><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IndexRecheck</name><parameter_list>(<parameter><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>cmp_orderbyvals</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Datum</name> <modifier>*</modifier></type><name>adist</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name> <modifier>*</modifier></type><name>anulls</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>Datum</name> <modifier>*</modifier></type><name>bdist</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name> <modifier>*</modifier></type><name>bnulls</name></decl></parameter>,
                <parameter><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>reorderqueue_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pairingheap_node</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>pairingheap_node</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>reorderqueue_push</name><parameter_list>(<parameter><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
                  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>orderbyvals</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>orderbynulls</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>reorderqueue_pop</name><parameter_list>(<parameter><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------------------------------------------------------------
 *        IndexNext
 *
 *        Retrieve a tuple from the IndexScan node's currentRelation
 *        using the index specified in the IndexScanState information.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>IndexNext</name><parameter_list>(<parameter><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>EState</name>       <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanDirection</name></type> <name>direction</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>scandesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

    <comment type="block">/*
     * extract necessary information from index scan node
     */</comment>
    <expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>direction</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name></expr>;</expr_stmt>
    <comment type="block">/* flip direction if this is an overall backward scan */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>IndexScan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>indexorderdir</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>direction</name> <operator>=</operator> <name>BackwardScanDirection</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>direction</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>scandesc</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>iss_ScanDesc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>scandesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We reach here if the index scan is not parallel, or if we're
         * executing a index scan that was intended to be parallel serially.
         */</comment>
        <expr_stmt><expr><name>scandesc</name> <operator>=</operator> <call><name>index_beginscan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>,
                                   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_RelationDesc</name></name></expr></argument>,
                                   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>,
                                   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumScanKeys</name></name></expr></argument>,
                                   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumOrderByKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ScanDesc</name></name> <operator>=</operator> <name>scandesc</name></expr>;</expr_stmt>

        <comment type="block">/*
         * If no run-time keys to calculate or they are ready, go ahead and
         * pass the scankeys to the index AM.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumRuntimeKeys</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>iss_RuntimeKeysReady</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>,
                         <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ScanKeys</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumScanKeys</name></name></expr></argument>,
                         <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_OrderByKeys</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumOrderByKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * ok, now that we have what we need, fetch the next tuple.
     */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>index_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Store the scanned tuple in the scan tuple slot of the scan state.
         * Note: we pass 'false' because tuples returned by amgetnext are
         * pointers onto disk pages and must not be pfree()'d.
         */</comment>
        <expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,    <comment type="block">/* tuple to store */</comment>
                       <argument><expr><name>slot</name></expr></argument>,    <comment type="block">/* slot to store in */</comment>
                       <argument><expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>,    <comment type="block">/* buffer containing tuple */</comment>
                       <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* don't pfree */</comment>

        <comment type="block">/*
         * If the index was lossy, we have to recheck the index quals using
         * the fetched tuple.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_recheck</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexqualorig</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Fails recheck, so drop it and loop back for another */</comment>
                <expr_stmt><expr><call><name>InstrCountFiltered2</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name>enable_distri_debug</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_scan_number</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><name>slot</name></expr>;</return>
    </block_content>}</block></while>

    <comment type="block">/*
     * if we get here it means the index scan failed so we are at the end of
     * the scan..
     */</comment>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ReachedEnd</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <return>return <expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        IndexNextWithReorder
 *
 *        Like IndexNext, but this version can also re-check ORDER BY
 *        expressions, and reorder the tuples as necessary.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>IndexNextWithReorder</name><parameter_list>(<parameter><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>EState</name>       <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>scandesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReorderTuple</name> <modifier>*</modifier></type><name>topmost</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>was_exact</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>lastfetched_vals</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>lastfetched_nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>cmp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Only forward scan is supported with reordering.  Note: we can get away
     * with just Asserting here because the system will not try to run the
     * plan backwards if ExecSupportsBackwardScan() says it won't work.
     * Currently, that is guaranteed because no index AMs support both
     * amcanorderbyop and amcanbackward; if any ever do,
     * ExecSupportsBackwardScan() will need to consider indexorderbys
     * explicitly.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>IndexScan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>indexorderdir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>scandesc</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>iss_ScanDesc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>scandesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We reach here if the index scan is not parallel, or if we're
         * executing a index scan that was intended to be parallel serially.
         */</comment>
        <expr_stmt><expr><name>scandesc</name> <operator>=</operator> <call><name>index_beginscan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>,
                                   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_RelationDesc</name></name></expr></argument>,
                                   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>,
                                   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumScanKeys</name></name></expr></argument>,
                                   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumOrderByKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ScanDesc</name></name> <operator>=</operator> <name>scandesc</name></expr>;</expr_stmt>

        <comment type="block">/*
         * If no run-time keys to calculate or they are ready, go ahead and
         * pass the scankeys to the index AM.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumRuntimeKeys</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>iss_RuntimeKeysReady</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>,
                         <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ScanKeys</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumScanKeys</name></name></expr></argument>,
                         <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_OrderByKeys</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumOrderByKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Check the reorder queue first.  If the topmost tuple in the queue
         * has an ORDER BY value smaller than (or equal to) the value last
         * returned by the index, we can return it now.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pairingheap_is_empty</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ReorderQueue</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>topmost</name> <operator>=</operator> <operator>(</operator><name>ReorderTuple</name> <operator>*</operator><operator>)</operator> <call><name>pairingheap_first</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ReorderQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>iss_ReachedEnd</name></name> <operator>||</operator>
                <call><name>cmp_orderbyvals</name><argument_list>(<argument><expr><name><name>topmost</name><operator>-&gt;</operator><name>orderbyvals</name></name></expr></argument>,
                                <argument><expr><name><name>topmost</name><operator>-&gt;</operator><name>orderbynulls</name></name></expr></argument>,
                                <argument><expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_orderbyvals</name></name></expr></argument>,
                                <argument><expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_orderbynulls</name></name></expr></argument>,
                                <argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>reorderqueue_pop</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Pass 'true', as the tuple in the queue is a palloc'd copy */</comment>
                <expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>slot</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>iss_ReachedEnd</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Queue is empty, and no more tuples from index.  We're done. */</comment>
            <return>return <expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Fetch next tuple from the index.
         */</comment>
<label><name>next_indextuple</name>:</label>
        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>index_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tuple</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * No more tuples from the index.  But we still need to drain any
             * remaining tuples from the queue before we're done.
             */</comment>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ReachedEnd</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Store the scanned tuple in the scan tuple slot of the scan state.
         * Note: we pass 'false' because tuples returned by amgetnext are
         * pointers onto disk pages and must not be pfree()'d.
         */</comment>
        <expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,    <comment type="block">/* tuple to store */</comment>
                       <argument><expr><name>slot</name></expr></argument>,    <comment type="block">/* slot to store in */</comment>
                       <argument><expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>,    <comment type="block">/* buffer containing tuple */</comment>
                       <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* don't pfree */</comment>

        <comment type="block">/*
         * If the index was lossy, we have to recheck the index quals and
         * ORDER BY expressions using the fetched tuple.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_recheck</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexqualorig</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Fails recheck, so drop it and loop back for another */</comment>
                <expr_stmt><expr><call><name>InstrCountFiltered2</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* allow this loop to be cancellable */</comment>
                <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>next_indextuple</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_recheckorderby</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>EvalOrderByExpressions</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Was the ORDER BY value returned by the index accurate?  The
             * recheck flag means that the index can return inaccurate values,
             * but then again, the value returned for any particular tuple
             * could also be exactly correct.  Compare the value returned by
             * the index with the recalculated value.  (If the value returned
             * by the index happened to be exact right, we can often avoid
             * pushing the tuple to the queue, just to pop it back out again.)
             */</comment>
            <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>cmp_orderbyvals</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_OrderByValues</name></name></expr></argument>,
                                  <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_OrderByNulls</name></name></expr></argument>,
                                  <argument><expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_orderbyvals</name></name></expr></argument>,
                                  <argument><expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_orderbynulls</name></name></expr></argument>,
                                  <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"index returned tuples in wrong order"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>was_exact</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>was_exact</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><name>lastfetched_vals</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>iss_OrderByValues</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>lastfetched_nulls</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>iss_OrderByNulls</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>was_exact</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>lastfetched_vals</name> <operator>=</operator> <name><name>scandesc</name><operator>-&gt;</operator><name>xs_orderbyvals</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>lastfetched_nulls</name> <operator>=</operator> <name><name>scandesc</name><operator>-&gt;</operator><name>xs_orderbynulls</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * Can we return this tuple immediately, or does it need to be pushed
         * to the reorder queue?  If the ORDER BY expression values returned
         * by the index were inaccurate, we can't return it yet, because the
         * next tuple from the index might need to come before this one. Also,
         * we can't return it yet if there are any smaller tuples in the queue
         * already.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>was_exact</name> <operator>||</operator> <operator>(</operator><name>topmost</name> <operator>&amp;&amp;</operator> <call><name>cmp_orderbyvals</name><argument_list>(<argument><expr><name>lastfetched_vals</name></expr></argument>,
                                                      <argument><expr><name>lastfetched_nulls</name></expr></argument>,
                                                      <argument><expr><name><name>topmost</name><operator>-&gt;</operator><name>orderbyvals</name></name></expr></argument>,
                                                      <argument><expr><name><name>topmost</name><operator>-&gt;</operator><name>orderbynulls</name></name></expr></argument>,
                                                      <argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Put this tuple to the queue */</comment>
            <expr_stmt><expr><call><name>reorderqueue_push</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>lastfetched_vals</name></expr></argument>, <argument><expr><name>lastfetched_nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Can return this tuple immediately. */</comment>
            <return>return <expr><name>slot</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * if we get here it means the index scan failed so we are at the end of
     * the scan..
     */</comment>
    <return>return <expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate the expressions in the ORDER BY clause, based on the heap tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EvalOrderByExpressions</name><parameter_list>(<parameter><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;indexorderbyorig</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>orderby</name> <init>= <expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>iss_OrderByValues</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name>orderby</name></expr></argument>,
                                                  <argument><expr><name>econtext</name></expr></argument>,
                                                  <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>iss_OrderByNulls</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * IndexRecheck -- access method routine to recheck a tuple in EvalPlanQual
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IndexRecheck</name><parameter_list>(<parameter><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>

    <comment type="block">/*
     * extract necessary information from index scan node
     */</comment>
    <expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>

    <comment type="block">/* Does the tuple meet the indexqual condition? */</comment>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>ExecQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexqualorig</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Compare ORDER BY expression values.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_orderbyvals</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Datum</name> <modifier>*</modifier></type><name>adist</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name> <modifier>*</modifier></type><name>anulls</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>Datum</name> <modifier>*</modifier></type><name>bdist</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name> <modifier>*</modifier></type><name>bnulls</name></decl></parameter>,
                <parameter><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>result</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>iss_NumOrderByKeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortSupport</name></type> <name>ssup</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>iss_SortSupport</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Handle nulls.  We only need to support NULLS LAST ordering, because
         * match_pathkeys_to_index() doesn't consider indexorderby
         * implementation otherwise.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>anulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>bnulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>anulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>bnulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>anulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>bnulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>ssup</name><operator>-&gt;</operator><name>comparator</name></name><argument_list>(<argument><expr><name><name>adist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bdist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>ssup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Pairing heap provides getting topmost (greatest) element while KNN provides
 * ascending sort.  That's why we invert the sort order.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>reorderqueue_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pairingheap_node</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>pairingheap_node</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
                 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderTuple</name> <modifier>*</modifier></type><name>rta</name> <init>= <expr><operator>(</operator><name>ReorderTuple</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReorderTuple</name> <modifier>*</modifier></type><name>rtb</name> <init>= <expr><operator>(</operator><name>ReorderTuple</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>IndexScanState</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

    <return>return <expr><operator>-</operator><call><name>cmp_orderbyvals</name><argument_list>(<argument><expr><name><name>rta</name><operator>-&gt;</operator><name>orderbyvals</name></name></expr></argument>, <argument><expr><name><name>rta</name><operator>-&gt;</operator><name>orderbynulls</name></name></expr></argument>,
                            <argument><expr><name><name>rtb</name><operator>-&gt;</operator><name>orderbyvals</name></name></expr></argument>, <argument><expr><name><name>rtb</name><operator>-&gt;</operator><name>orderbynulls</name></name></expr></argument>,
                            <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to push a tuple to the reorder queue.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reorderqueue_push</name><parameter_list>(<parameter><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
                  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>orderbyvals</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>orderbynulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>scandesc</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>iss_ScanDesc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EState</name>       <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReorderTuple</name> <modifier>*</modifier></type><name>rt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rt</name> <operator>=</operator> <operator>(</operator><name>ReorderTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rt</name><operator>-&gt;</operator><name>htup</name></name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rt</name><operator>-&gt;</operator><name>orderbyvals</name></name> <operator>=</operator>
        <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>scandesc</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rt</name><operator>-&gt;</operator><name>orderbynulls</name></name> <operator>=</operator>
        <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>scandesc</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>iss_NumOrderByKeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>orderbynulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>rt</name><operator>-&gt;</operator><name>orderbyvals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>orderbyvals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                           <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_OrderByTypByVals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                           <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_OrderByTypLens</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>rt</name><operator>-&gt;</operator><name>orderbyvals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name><name>rt</name><operator>-&gt;</operator><name>orderbynulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>orderbynulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>pairingheap_add</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ReorderQueue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rt</name><operator>-&gt;</operator><name>ph_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to pop the next tuple from the reorder queue.
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>reorderqueue_pop</name><parameter_list>(<parameter><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReorderTuple</name> <modifier>*</modifier></type><name>topmost</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>topmost</name> <operator>=</operator> <operator>(</operator><name>ReorderTuple</name> <operator>*</operator><operator>)</operator> <call><name>pairingheap_remove_first</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ReorderQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>topmost</name><operator>-&gt;</operator><name>htup</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>iss_NumOrderByKeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>iss_OrderByTypByVals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>topmost</name><operator>-&gt;</operator><name>orderbynulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>topmost</name><operator>-&gt;</operator><name>orderbyvals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>topmost</name><operator>-&gt;</operator><name>orderbyvals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>topmost</name><operator>-&gt;</operator><name>orderbynulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>topmost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *        ExecIndexScan(node)
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecIndexScan</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>IndexScanState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * If we have runtime keys and they've not already been set up, do it now.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumRuntimeKeys</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>iss_RuntimeKeysReady</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumOrderByKeys</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>ExecScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>,
                        <argument><expr><operator>(</operator><name>ExecScanAccessMtd</name><operator>)</operator> <name>IndexNextWithReorder</name></expr></argument>,
                        <argument><expr><operator>(</operator><name>ExecScanRecheckMtd</name><operator>)</operator> <name>IndexRecheck</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>ExecScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>,
                        <argument><expr><operator>(</operator><name>ExecScanAccessMtd</name><operator>)</operator> <name>IndexNext</name></expr></argument>,
                        <argument><expr><operator>(</operator><name>ExecScanRecheckMtd</name><operator>)</operator> <name>IndexRecheck</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecReScanIndexScan(node)
 *
 *        Recalculates the values of any scan keys whose value depends on
 *        information known at runtime, then rescans the indexed relation.
 *
 *        Updating the scan key was formerly done separately in
 *        ExecUpdateIndexScanKeys. Integrating it into ReScan makes
 *        rescans of indices and relations/general streams more uniform.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecReScanIndexScan</name><parameter_list>(<parameter><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * If we are doing runtime key calculations (ie, any of the index key
     * values weren't simple Consts), compute the new key values.  But first,
     * reset the context so we don't leak memory as each outer tuple is
     * scanned.  Note this assumes that we will recalculate *all* runtime keys
     * on each call.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumRuntimeKeys</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>iss_RuntimeContext</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExecIndexEvalRuntimeKeys</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>,
                                 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_RuntimeKeys</name></name></expr></argument>,
                                 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumRuntimeKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>iss_RuntimeKeysReady</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/* flush the reorder queue */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>iss_ReorderQueue</name></name></expr>)</condition>
    <block>{<block_content>
        <while>while <condition>(<expr><operator>!</operator><call><name>pairingheap_is_empty</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ReorderQueue</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>reorderqueue_pop</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></if></if_stmt>

	<comment type="block">/* reset index scan */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>iss_ScanDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ScanDesc</name></name></expr></argument>,
                     <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ScanKeys</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumScanKeys</name></name></expr></argument>,
                     <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_OrderByKeys</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumOrderByKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ReachedEnd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ExecScanReScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExecIndexEvalRuntimeKeys
 *        Evaluate any runtime key values, and update the scankeys.
 */</comment>
<function><type><name>void</name></type>
<name>ExecIndexEvalRuntimeKeys</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
                         <parameter><decl><type><name>IndexRuntimeKeyInfo</name> <modifier>*</modifier></type><name>runtimeKeys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numRuntimeKeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

    <comment type="block">/* We want to keep the key values in per-tuple memory */</comment>
    <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numRuntimeKeys</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ScanKey</name></type>        <name>scan_key</name> <init>= <expr><name><name>runtimeKeys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>scan_key</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>key_expr</name> <init>= <expr><name><name>runtimeKeys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>key_expr</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>scanvalue</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isNull</name></decl>;</decl_stmt>

        <comment type="block">/*
         * For each run-time key, extract the run-time expression and evaluate
         * it with respect to the current context.  We then stick the result
         * into the proper scan key.
         *
         * Note: the result of the eval could be a pass-by-ref value that's
         * stored in some outer scan's tuple, not in
         * econtext-&gt;ecxt_per_tuple_memory.  We assume that the outer tuple
         * will stay put throughout our scan.  If this is wrong, we could copy
         * the result into our context explicitly, but I think that's not
         * necessary.
         *
         * It's also entirely possible that the result of the eval is a
         * toasted value.  In this case we should forcibly detoast it, to
         * avoid repeat detoastings each time the value is examined by an
         * index support function.
         */</comment>
        <expr_stmt><expr><name>scanvalue</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name>key_expr</name></expr></argument>,
                                 <argument><expr><name>econtext</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>scan_key</name><operator>-&gt;</operator><name>sk_argument</name></name> <operator>=</operator> <name>scanvalue</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>scan_key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>|=</operator> <name>SK_ISNULL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>runtimeKeys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>key_toastable</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>scanvalue</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>scanvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>scan_key</name><operator>-&gt;</operator><name>sk_argument</name></name> <operator>=</operator> <name>scanvalue</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>scan_key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SK_ISNULL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecIndexEvalArrayKeys
 *        Evaluate any array key values, and set up to iterate through arrays.
 *
 * Returns TRUE if there are array elements to consider; FALSE means there
 * is at least one null or empty array, so no match is possible.  On TRUE
 * result, the scankeys are initialized with the first elements of the arrays.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecIndexEvalArrayKeys</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
                       <parameter><decl><type><name>IndexArrayKeyInfo</name> <modifier>*</modifier></type><name>arrayKeys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numArrayKeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

    <comment type="block">/* We want to keep the arrays in per-tuple memory */</comment>
    <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numArrayKeys</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ScanKey</name></type>        <name>scan_key</name> <init>= <expr><name><name>arrayKeys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>scan_key</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>array_expr</name> <init>= <expr><name><name>arrayKeys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>array_expr</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>arraydatum</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isNull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arrayval</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int16</name></type>        <name>elmlen</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>elmbyval</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name>elmalign</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>num_elems</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>elem_values</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>elem_nulls</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Compute and deconstruct the array expression. (Notes in
         * ExecIndexEvalRuntimeKeys() apply here too.)
         */</comment>
        <expr_stmt><expr><name>arraydatum</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name>array_expr</name></expr></argument>,
                                  <argument><expr><name>econtext</name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <break>break;</break>                <comment type="block">/* no point in evaluating more */</comment>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>arrayval</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* We could cache this data, but not clear it's worth it */</comment>
        <expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><operator>&amp;</operator><name>elmlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>,
                          <argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name>elem_values</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem_nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_elems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>num_elems</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <break>break;</break>                <comment type="block">/* no point in evaluating more */</comment>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Note: we expect the previous array data, if any, to be
         * automatically freed by resetting the per-tuple context; hence no
         * pfree's here.
         */</comment>
        <expr_stmt><expr><name><name>arrayKeys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>elem_values</name> <operator>=</operator> <name>elem_values</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arrayKeys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>elem_nulls</name> <operator>=</operator> <name>elem_nulls</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arrayKeys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>num_elems</name> <operator>=</operator> <name>num_elems</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scan_key</name><operator>-&gt;</operator><name>sk_argument</name></name> <operator>=</operator> <name><name>elem_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>elem_nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>scan_key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>|=</operator> <name>SK_ISNULL</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>scan_key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SK_ISNULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name><name>arrayKeys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>next_elem</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecIndexAdvanceArrayKeys
 *        Advance to the next set of array key values, if any.
 *
 * Returns TRUE if there is another set of values to consider, FALSE if not.
 * On TRUE result, the scankeys are initialized with the next set of values.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecIndexAdvanceArrayKeys</name><parameter_list>(<parameter><decl><type><name>IndexArrayKeyInfo</name> <modifier>*</modifier></type><name>arrayKeys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numArrayKeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Note we advance the rightmost array key most quickly, since it will
     * correspond to the lowest-order index column among the available
     * qualifications.  This is hypothesized to result in better locality of
     * access in the index.
     */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>numArrayKeys</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ScanKey</name></type>        <name>scan_key</name> <init>= <expr><name><name>arrayKeys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>scan_key</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>next_elem</name> <init>= <expr><name><name>arrayKeys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>next_elem</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>num_elems</name> <init>= <expr><name><name>arrayKeys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>num_elems</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>elem_values</name> <init>= <expr><name><name>arrayKeys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>elem_values</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>elem_nulls</name> <init>= <expr><name><name>arrayKeys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>elem_nulls</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>next_elem</name> <operator>&gt;=</operator> <name>num_elems</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>next_elem</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>        <comment type="block">/* need to advance next array key */</comment>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name><name>scan_key</name><operator>-&gt;</operator><name>sk_argument</name></name> <operator>=</operator> <name><name>elem_values</name><index>[<expr><name>next_elem</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>elem_nulls</name><index>[<expr><name>next_elem</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>scan_key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>|=</operator> <name>SK_ISNULL</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>scan_key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SK_ISNULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name><name>arrayKeys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>next_elem</name> <operator>=</operator> <name>next_elem</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *        ExecEndIndexScan
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndIndexScan</name><parameter_list>(<parameter><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>indexRelationDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>indexScanDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>relation</name></decl>;</decl_stmt>

    <comment type="block">/*
     * extract information from the node
     */</comment>
    <expr_stmt><expr><name>indexRelationDesc</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>iss_RelationDesc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>indexScanDesc</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>iss_ScanDesc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>relation</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Free the exprcontext(s) ... now dead code, see ExecFreeExprContext
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
    <expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>iss_RuntimeContext</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FreeExprContext</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_RuntimeContext</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * clear out tuple table slots
     */</comment>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * close the index relation (no-op if we didn't open it)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>indexScanDesc</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>index_endscan</name><argument_list>(<argument><expr><name>indexScanDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>indexRelationDesc</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRelationDesc</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * close the heap relation.
     */</comment>
    <expr_stmt><expr><call><name>ExecCloseScanRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecIndexMarkPos
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecIndexMarkPos</name><parameter_list>(<parameter><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>index_markpos</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ScanDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecIndexRestrPos
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecIndexRestrPos</name><parameter_list>(<parameter><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>index_restrpos</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ScanDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecInitIndexScan
 *
 *        Initializes the index scan's state information, creates
 *        scan keys, and opens the base and index relations.
 *
 *        Note: index scans have 2 sets of state information because
 *              we have to keep track of the base relation and the
 *              index relation.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>IndexScanState</name> <modifier>*</modifier></type>
<name>ExecInitIndexScan</name><parameter_list>(<parameter><decl><type><name>IndexScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>indexstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>currentRelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>relistarget</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>ListCell</name>      <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * create state structure
     */</comment>
    <expr_stmt><expr><name>indexstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexScanState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecIndexScan</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Miscellaneous initialization
     *
     * create expression context for node
     */</comment>
    <expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * initialize child expressions
     *
     * Note: we don't initialize all of the indexqual expression, only the
     * sub-parts corresponding to runtime keys (see below).  Likewise for
     * indexorderby, if any.  But the indexqualorig expression is always
     * initialized even though it will only be used in some uncommon cases ---
     * would be nice to improve that.  (Problem is that any SubPlans present
     * in the expression must be found now...)
     */</comment>
    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
        <call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>indexstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>indexqualorig</name></name> <operator>=</operator>
        <call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexqualorig</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>indexstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>indexorderbyorig</name></name> <operator>=</operator>
        <call><name>ExecInitExprList</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexorderbyorig</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>indexstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>enable_fga</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>foreach</name> <argument_list>(<argument>item</argument>, <argument>node-&gt;scan.plan.audit_fga_quals</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>AuditFgaPolicy</name> <modifier>*</modifier></type><name>audit_fga_qual</name> <init>= <expr><operator>(</operator><name>AuditFgaPolicy</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            
            <decl_stmt><decl><type><name>audit_fga_policy_state</name> <modifier>*</modifier></type> <name>audit_fga_policy_state_item</name>
                    <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>audit_fga_policy_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>audit_fga_policy_state_item</name><operator>-&gt;</operator><name>policy_name</name></name> <operator>=</operator> <name><name>audit_fga_qual</name><operator>-&gt;</operator><name>policy_name</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>audit_fga_policy_state_item</name><operator>-&gt;</operator><name>query_string</name></name> <operator>=</operator> <name><name>audit_fga_qual</name><operator>-&gt;</operator><name>query_string</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>audit_fga_policy_state_item</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> 
                <call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>audit_fga_qual</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>indexstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>audit_fga_qual</name></name> <operator>=</operator> 
                <call><name>lappend</name><argument_list>(<argument><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>audit_fga_qual</name></name></expr></argument>, <argument><expr><name>audit_fga_policy_state_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>      
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

    <comment type="block">/*
     * tuple table initialization
     */</comment>
    <expr_stmt><expr><call><name>ExecInitResultTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecInitScanTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * open the base relation and acquire appropriate lock on it.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>ispartchild</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>currentRelation</name> <operator>=</operator> <call><name>ExecOpenScanRelationPartition</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                                                <argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></argument>,
                                                <argument><expr><name>eflags</name></expr></argument>,
                                                <argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>childidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>currentRelation</name> <operator>=</operator> <call><name>ExecOpenScanRelation</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <expr_stmt><expr><call><name>mls_check_datamask_need_passby</name><argument_list>(<argument><expr><operator>(</operator><name>ScanState</name><operator>*</operator><operator>)</operator><name>indexstate</name></expr></argument>, <argument><expr><name><name>currentRelation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name> <operator>=</operator> <name>currentRelation</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentScanDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>    <comment type="block">/* no heap scan here */</comment>

    <comment type="block">/*
     * get the scan type from the relation descriptor.
     */</comment>
    <expr_stmt><expr><call><name>ExecAssignScanType</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>currentRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize result tuple type and projection info.
     */</comment>
    <expr_stmt><expr><call><name>ExecAssignResultTypeFromTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecAssignScanProjectionInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we are just doing EXPLAIN (ie, aren't going to run the plan), stop
     * here.  This allows an index-advisor plugin to EXPLAIN a plan containing
     * references to nonexistent indexes.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>indexstate</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Open the index relation.
     *
     * If the parent table is one of the target relations of the query, then
     * InitPlan already opened and write-locked the index, so we can avoid
     * taking another lock here.  Otherwise we need a normal reader's lock.
     */</comment>
    <expr_stmt><expr><name>relistarget</name> <operator>=</operator> <call><name>ExecRelationIsTargetRelation</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>iss_RelationDesc</name></name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexid</name></name></expr></argument>,
                                              <argument><expr><ternary><condition><expr><name>relistarget</name></expr> ?</condition><then> <expr><name>NoLock</name></expr> </then><else>: <expr><name>AccessShareLock</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize index-specific scan state
     */</comment>
    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>iss_RuntimeKeysReady</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>iss_RuntimeKeys</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>iss_NumRuntimeKeys</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * build the index scan keys from the index qualification
     */</comment>
    <expr_stmt><expr><call><name>ExecIndexBuildScanKeys</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>indexstate</name></expr></argument>,
                           <argument><expr><name><name>indexstate</name><operator>-&gt;</operator><name>iss_RelationDesc</name></name></expr></argument>,
                           <argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>,
                           <argument><expr><name>false</name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>iss_ScanKeys</name></name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>iss_NumScanKeys</name></name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>iss_RuntimeKeys</name></name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>iss_NumRuntimeKeys</name></name></expr></argument>,
                           <argument><expr><name>NULL</name></expr></argument>,    <comment type="block">/* no ArrayKeys */</comment>
                           <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * any ORDER BY exprs have to be turned into scankeys in the same way
     */</comment>
    <expr_stmt><expr><call><name>ExecIndexBuildScanKeys</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>indexstate</name></expr></argument>,
                           <argument><expr><name><name>indexstate</name><operator>-&gt;</operator><name>iss_RelationDesc</name></name></expr></argument>,
                           <argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexorderby</name></name></expr></argument>,
                           <argument><expr><name>true</name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>iss_OrderByKeys</name></name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>iss_NumOrderByKeys</name></name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>iss_RuntimeKeys</name></name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>iss_NumRuntimeKeys</name></name></expr></argument>,
                           <argument><expr><name>NULL</name></expr></argument>,    <comment type="block">/* no ArrayKeys */</comment>
                           <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Initialize sort support, if we need to re-check ORDER BY exprs */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>indexstate</name><operator>-&gt;</operator><name>iss_NumOrderByKeys</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>numOrderByKeys</name> <init>= <expr><name><name>indexstate</name><operator>-&gt;</operator><name>iss_NumOrderByKeys</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lco</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcx</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Prepare sort support, and look up the data type for each ORDER BY
         * expression.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numOrderByKeys</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexorderbyops</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numOrderByKeys</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexorderbyorig</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>iss_SortSupport</name></name> <operator>=</operator> <operator>(</operator><name>SortSupportData</name> <operator>*</operator><operator>)</operator>
            <call><name>palloc0</name><argument_list>(<argument><expr><name>numOrderByKeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SortSupportData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>iss_OrderByTypByVals</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator>
            <call><name>palloc</name><argument_list>(<argument><expr><name>numOrderByKeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>iss_OrderByTypLens</name></name> <operator>=</operator> <operator>(</operator><name>int16</name> <operator>*</operator><operator>)</operator>
            <call><name>palloc</name><argument_list>(<argument><expr><name>numOrderByKeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <macro><name>forboth</name><argument_list>(<argument>lco</argument>, <argument>node-&gt;indexorderbyops</argument>, <argument>lcx</argument>, <argument>node-&gt;indexorderbyorig</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>orderbyop</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lco</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>orderbyexpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>orderbyType</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>orderbyexpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>orderbyColl</name> <init>= <expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>orderbyexpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>SortSupport</name></type> <name>orderbysort</name> <init>= <expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>iss_SortSupport</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Initialize sort support */</comment>
            <expr_stmt><expr><name><name>orderbysort</name><operator>-&gt;</operator><name>ssup_cxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>orderbysort</name><operator>-&gt;</operator><name>ssup_collation</name></name> <operator>=</operator> <name>orderbyColl</name></expr>;</expr_stmt>
            <comment type="block">/* See cmp_orderbyvals() comments on NULLS LAST */</comment>
            <expr_stmt><expr><name><name>orderbysort</name><operator>-&gt;</operator><name>ssup_nulls_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <comment type="block">/* ssup_attno is unused here and elsewhere */</comment>
            <expr_stmt><expr><name><name>orderbysort</name><operator>-&gt;</operator><name>ssup_attno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <comment type="block">/* No abbreviation */</comment>
            <expr_stmt><expr><name><name>orderbysort</name><operator>-&gt;</operator><name>abbreviate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PrepareSortSupportFromOrderingOp</name><argument_list>(<argument><expr><name>orderbyop</name></expr></argument>, <argument><expr><name>orderbysort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name>orderbyType</name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>iss_OrderByTypLens</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>iss_OrderByTypByVals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block>

        <comment type="block">/* allocate arrays to hold the re-calculated distances */</comment>
        <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>iss_OrderByValues</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator>
            <call><name>palloc</name><argument_list>(<argument><expr><name>numOrderByKeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>iss_OrderByNulls</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator>
            <call><name>palloc</name><argument_list>(<argument><expr><name>numOrderByKeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* and initialize the reorder queue */</comment>
        <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>iss_ReorderQueue</name></name> <operator>=</operator> <call><name>pairingheap_allocate</name><argument_list>(<argument><expr><name>reorderqueue_cmp</name></expr></argument>,
                                                            <argument><expr><name>indexstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If we have runtime keys, we need an ExprContext to evaluate them. The
     * node's standard context won't do because we want to reset that context
     * for every tuple.  So, build another context just like the other one...
     * -tgl 7/11/00
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>indexstate</name><operator>-&gt;</operator><name>iss_NumRuntimeKeys</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>stdecontext</name> <init>= <expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>iss_RuntimeContext</name></name> <operator>=</operator> <name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name> <operator>=</operator> <name>stdecontext</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>iss_RuntimeContext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * all done.
     */</comment>
    <return>return <expr><name>indexstate</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecIndexBuildScanKeys
 *        Build the index scan keys from the index qualification expressions
 *
 * The index quals are passed to the index AM in the form of a ScanKey array.
 * This routine sets up the ScanKeys, fills in all constant fields of the
 * ScanKeys, and prepares information about the keys that have non-constant
 * comparison values.  We divide index qual expressions into five types:
 *
 * 1. Simple operator with constant comparison value ("indexkey op constant").
 * For these, we just fill in a ScanKey containing the constant value.
 *
 * 2. Simple operator with non-constant value ("indexkey op expression").
 * For these, we create a ScanKey with everything filled in except the
 * expression value, and set up an IndexRuntimeKeyInfo struct to drive
 * evaluation of the expression at the right times.
 *
 * 3. RowCompareExpr ("(indexkey, indexkey, ...) op (expr, expr, ...)").
 * For these, we create a header ScanKey plus a subsidiary ScanKey array,
 * as specified in access/skey.h.  The elements of the row comparison
 * can have either constant or non-constant comparison values.
 *
 * 4. ScalarArrayOpExpr ("indexkey op ANY (array-expression)").  If the index
 * supports amsearcharray, we handle these the same as simple operators,
 * setting the SK_SEARCHARRAY flag to tell the AM to handle them.  Otherwise,
 * we create a ScanKey with everything filled in except the comparison value,
 * and set up an IndexArrayKeyInfo struct to drive processing of the qual.
 * (Note that if we use an IndexArrayKeyInfo struct, the array expression is
 * always treated as requiring runtime evaluation, even if it's a constant.)
 *
 * 5. NullTest ("indexkey IS NULL/IS NOT NULL").  We just fill in the
 * ScanKey properly.
 *
 * This code is also used to prepare ORDER BY expressions for amcanorderbyop
 * indexes.  The behavior is exactly the same, except that we have to look up
 * the operator differently.  Note that only cases 1 and 2 are currently
 * possible for ORDER BY.
 *
 * Input params are:
 *
 * planstate: executor state node we are working for
 * index: the index we are building scan keys for
 * quals: indexquals (or indexorderbys) expressions
 * isorderby: true if processing ORDER BY exprs, false if processing quals
 * *runtimeKeys: ptr to pre-existing IndexRuntimeKeyInfos, or NULL if none
 * *numRuntimeKeys: number of pre-existing runtime keys
 *
 * Output params are:
 *
 * *scanKeys: receives ptr to array of ScanKeys
 * *numScanKeys: receives number of scankeys
 * *runtimeKeys: receives ptr to array of IndexRuntimeKeyInfos, or NULL if none
 * *numRuntimeKeys: receives number of runtime keys
 * *arrayKeys: receives ptr to array of IndexArrayKeyInfos, or NULL if none
 * *numArrayKeys: receives number of array keys
 *
 * Caller may pass NULL for arrayKeys and numArrayKeys to indicate that
 * IndexArrayKeyInfos are not supported.
 */</comment>
<function><type><name>void</name></type>
<name>ExecIndexBuildScanKeys</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>,
                       <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isorderby</name></decl></parameter>,
                       <parameter><decl><type><name>ScanKey</name> <modifier>*</modifier></type><name>scanKeys</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numScanKeys</name></decl></parameter>,
                       <parameter><decl><type><name>IndexRuntimeKeyInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>runtimeKeys</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numRuntimeKeys</name></decl></parameter>,
                       <parameter><decl><type><name>IndexArrayKeyInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>arrayKeys</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numArrayKeys</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>qual_cell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKey</name></type>        <name>scan_keys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexRuntimeKeyInfo</name> <modifier>*</modifier></type><name>runtime_keys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexArrayKeyInfo</name> <modifier>*</modifier></type><name>array_keys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>n_scan_keys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>n_runtime_keys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>max_runtime_keys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>n_array_keys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

    <comment type="block">/* Allocate array for ScanKey structs: one per qual */</comment>
    <expr_stmt><expr><name>n_scan_keys</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan_keys</name> <operator>=</operator> <operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>n_scan_keys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * runtime_keys array is dynamically resized as needed.  We handle it this
     * way so that the same runtime keys array can be shared between
     * indexquals and indexorderbys, which will be processed in separate calls
     * of this function.  Caller must be sure to pass in NULL/0 for first
     * call.
     */</comment>
    <expr_stmt><expr><name>runtime_keys</name> <operator>=</operator> <operator>*</operator><name>runtimeKeys</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>n_runtime_keys</name> <operator>=</operator> <name>max_runtime_keys</name> <operator>=</operator> <operator>*</operator><name>numRuntimeKeys</name></expr>;</expr_stmt>

    <comment type="block">/* Allocate array_keys as large as it could possibly need to be */</comment>
    <expr_stmt><expr><name>array_keys</name> <operator>=</operator> <operator>(</operator><name>IndexArrayKeyInfo</name> <operator>*</operator><operator>)</operator>
        <call><name>palloc0</name><argument_list>(<argument><expr><name>n_scan_keys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexArrayKeyInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n_array_keys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * for each opclause in the given qual, convert the opclause into a single
     * scan key
     */</comment>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>qual_cell</argument>, <argument>quals</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>qual_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ScanKey</name></type>        <name>this_scan_key</name> <init>= <expr><operator>&amp;</operator><name><name>scan_keys</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>opno</name></decl>;</decl_stmt>        <comment type="block">/* operator's OID */</comment>
        <decl_stmt><decl><type><name>RegProcedure</name></type> <name>opfuncid</name></decl>;</decl_stmt>    <comment type="block">/* operator proc id used in scan */</comment>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>opfamily</name></decl>;</decl_stmt>    <comment type="block">/* opfamily of index column */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>op_strategy</name></decl>;</decl_stmt>    <comment type="block">/* operator's strategy number */</comment>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>op_lefttype</name></decl>;</decl_stmt>    <comment type="block">/* operator's declared input types */</comment>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>op_righttype</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>leftop</name></decl>;</decl_stmt>        <comment type="block">/* expr on lhs of operator */</comment>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>rightop</name></decl>;</decl_stmt>    <comment type="block">/* expr on rhs ... */</comment>
        <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>varattno</name></decl>;</decl_stmt>    <comment type="block">/* att number used in scan */</comment>

        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* indexkey op const or indexkey op expression */</comment>
            <decl_stmt><decl><type><name>int</name></type>            <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type>        <name>scanvalue</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>opno</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>opno</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>opfuncid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>opfuncid</name></expr>;</expr_stmt>

            <comment type="block">/*
             * leftop should be the index key Var, possibly relabeled
             */</comment>
            <expr_stmt><expr><name>leftop</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>get_leftop</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>leftop</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>leftop</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leftop</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                  <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>varno</name> <operator>==</operator> <name>INDEX_VAR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"indexqual doesn't have key on left side"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>varattno</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>varattno</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>varattno</name></expr></argument> &gt;</argument_list></name> <name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnatts</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus index qualification"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * We have to look up the operator's strategy number.  This
             * provides a cross-check that the operator does match the index.
             */</comment>
            <expr_stmt><expr><name>opfamily</name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><name>varattno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>get_op_opfamily_properties</name><argument_list>(<argument><expr><name>opno</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>isorderby</name></expr></argument>,
                                       <argument><expr><operator>&amp;</operator><name>op_strategy</name></expr></argument>,
                                       <argument><expr><operator>&amp;</operator><name>op_lefttype</name></expr></argument>,
                                       <argument><expr><operator>&amp;</operator><name>op_righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>isorderby</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>SK_ORDER_BY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * rightop is the constant or variable comparison value
             */</comment>
            <expr_stmt><expr><name>rightop</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>get_rightop</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>rightop</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>rightop</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rightop</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* OK, simple constant comparison value */</comment>
                <expr_stmt><expr><name>scanvalue</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>SK_ISNULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Need to treat this one as a runtime key */</comment>
                <if_stmt><if>if <condition>(<expr><name>n_runtime_keys</name> <operator>&gt;=</operator> <name>max_runtime_keys</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>max_runtime_keys</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>max_runtime_keys</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>runtime_keys</name> <operator>=</operator> <operator>(</operator><name>IndexRuntimeKeyInfo</name> <operator>*</operator><operator>)</operator>
                            <call><name>palloc</name><argument_list>(<argument><expr><name>max_runtime_keys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexRuntimeKeyInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>max_runtime_keys</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>runtime_keys</name> <operator>=</operator> <operator>(</operator><name>IndexRuntimeKeyInfo</name> <operator>*</operator><operator>)</operator>
                            <call><name>repalloc</name><argument_list>(<argument><expr><name>runtime_keys</name></expr></argument>, <argument><expr><name>max_runtime_keys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexRuntimeKeyInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>runtime_keys</name><index>[<expr><name>n_runtime_keys</name></expr>]</index></name><operator>.</operator><name>scan_key</name> <operator>=</operator> <name>this_scan_key</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>runtime_keys</name><index>[<expr><name>n_runtime_keys</name></expr>]</index></name><operator>.</operator><name>key_expr</name> <operator>=</operator>
                    <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>runtime_keys</name><index>[<expr><name>n_runtime_keys</name></expr>]</index></name><operator>.</operator><name>key_toastable</name> <operator>=</operator>
                    <call><name>TypeIsToastable</name><argument_list>(<argument><expr><name>op_righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>n_runtime_keys</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>scanvalue</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/*
             * initialize the scan key's fields appropriately
             */</comment>
            <expr_stmt><expr><call><name>ScanKeyEntryInitialize</name><argument_list>(<argument><expr><name>this_scan_key</name></expr></argument>,
                                   <argument><expr><name>flags</name></expr></argument>,
                                   <argument><expr><name>varattno</name></expr></argument>,    <comment type="block">/* attribute number to scan */</comment>
                                   <argument><expr><name>op_strategy</name></expr></argument>, <comment type="block">/* op's strategy */</comment>
                                   <argument><expr><name>op_righttype</name></expr></argument>,    <comment type="block">/* strategy subtype */</comment>
                                   <argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>inputcollid</name></expr></argument>,    <comment type="block">/* collation */</comment>
                                   <argument><expr><name>opfuncid</name></expr></argument>,    <comment type="block">/* reg proc to use */</comment>
                                   <argument><expr><name>scanvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* constant */</comment>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>RowCompareExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* (indexkey, indexkey, ...) op (expression, expression, ...) */</comment>
            <decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><operator>(</operator><name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>largs_cell</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>largs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rargs_cell</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rargs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>opnos_cell</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>opnos</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>collids_cell</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>inputcollids</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ScanKey</name></type>        <name>first_sub_key</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>n_sub_key</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isorderby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>first_sub_key</name> <operator>=</operator> <operator>(</operator><name>ScanKey</name><operator>)</operator>
                <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>opnos</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>n_sub_key</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <comment type="block">/* Scan RowCompare columns and generate subsidiary ScanKey items */</comment>
            <while>while <condition>(<expr><name>opnos_cell</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ScanKey</name></type>        <name>this_sub_key</name> <init>= <expr><operator>&amp;</operator><name><name>first_sub_key</name><index>[<expr><name>n_sub_key</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>flags</name> <init>= <expr><name>SK_ROW_MEMBER</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Datum</name></type>        <name>scanvalue</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>inputcollation</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * leftop should be the index key Var, possibly relabeled
                 */</comment>
                <expr_stmt><expr><name>leftop</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>largs_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>largs_cell</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>largs_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>leftop</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>leftop</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leftop</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                      <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>varno</name> <operator>==</operator> <name>INDEX_VAR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"indexqual doesn't have key on left side"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>varattno</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * We have to look up the operator's associated btree support
                 * function
                 */</comment>
                <expr_stmt><expr><name>opno</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>opnos_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>opnos_cell</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>opnos_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <name>BTREE_AM_OID</name> <operator>||</operator>
                    <name><name>varattno</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>varattno</name></expr></argument> &gt;</argument_list></name> <name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnatts</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus RowCompare index qualification"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>opfamily</name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><name>varattno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>get_op_opfamily_properties</name><argument_list>(<argument><expr><name>opno</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>isorderby</name></expr></argument>,
                                           <argument><expr><operator>&amp;</operator><name>op_strategy</name></expr></argument>,
                                           <argument><expr><operator>&amp;</operator><name>op_lefttype</name></expr></argument>,
                                           <argument><expr><operator>&amp;</operator><name>op_righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>op_strategy</name> <operator>!=</operator> <name><name>rc</name><operator>-&gt;</operator><name>rctype</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"RowCompare index qualification contains wrong operator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>opfuncid</name> <operator>=</operator> <call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
                                             <argument><expr><name>op_lefttype</name></expr></argument>,
                                             <argument><expr><name>op_righttype</name></expr></argument>,
                                             <argument><expr><name>BTORDER_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RegProcedureIsValid</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing support function %d(%u,%u) in opfamily %u"</literal></expr></argument>,
                         <argument><expr><name>BTORDER_PROC</name></expr></argument>, <argument><expr><name>op_lefttype</name></expr></argument>, <argument><expr><name>op_righttype</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>inputcollation</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>collids_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>collids_cell</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>collids_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * rightop is the constant or variable comparison value
                 */</comment>
                <expr_stmt><expr><name>rightop</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rargs_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rargs_cell</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>rargs_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>rightop</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>rightop</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rightop</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* OK, simple constant comparison value */</comment>
                    <expr_stmt><expr><name>scanvalue</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>SK_ISNULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Need to treat this one as a runtime key */</comment>
                    <if_stmt><if>if <condition>(<expr><name>n_runtime_keys</name> <operator>&gt;=</operator> <name>max_runtime_keys</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>max_runtime_keys</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>max_runtime_keys</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>runtime_keys</name> <operator>=</operator> <operator>(</operator><name>IndexRuntimeKeyInfo</name> <operator>*</operator><operator>)</operator>
                                <call><name>palloc</name><argument_list>(<argument><expr><name>max_runtime_keys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexRuntimeKeyInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><name>max_runtime_keys</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>runtime_keys</name> <operator>=</operator> <operator>(</operator><name>IndexRuntimeKeyInfo</name> <operator>*</operator><operator>)</operator>
                                <call><name>repalloc</name><argument_list>(<argument><expr><name>runtime_keys</name></expr></argument>, <argument><expr><name>max_runtime_keys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexRuntimeKeyInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name><name>runtime_keys</name><index>[<expr><name>n_runtime_keys</name></expr>]</index></name><operator>.</operator><name>scan_key</name> <operator>=</operator> <name>this_sub_key</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>runtime_keys</name><index>[<expr><name>n_runtime_keys</name></expr>]</index></name><operator>.</operator><name>key_expr</name> <operator>=</operator>
                        <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>runtime_keys</name><index>[<expr><name>n_runtime_keys</name></expr>]</index></name><operator>.</operator><name>key_toastable</name> <operator>=</operator>
                        <call><name>TypeIsToastable</name><argument_list>(<argument><expr><name>op_righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>n_runtime_keys</name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name>scanvalue</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <comment type="block">/*
                 * initialize the subsidiary scan key's fields appropriately
                 */</comment>
                <expr_stmt><expr><call><name>ScanKeyEntryInitialize</name><argument_list>(<argument><expr><name>this_sub_key</name></expr></argument>,
                                       <argument><expr><name>flags</name></expr></argument>,
                                       <argument><expr><name>varattno</name></expr></argument>,    <comment type="block">/* attribute number */</comment>
                                       <argument><expr><name>op_strategy</name></expr></argument>, <comment type="block">/* op's strategy */</comment>
                                       <argument><expr><name>op_righttype</name></expr></argument>,    <comment type="block">/* strategy subtype */</comment>
                                       <argument><expr><name>inputcollation</name></expr></argument>,    <comment type="block">/* collation */</comment>
                                       <argument><expr><name>opfuncid</name></expr></argument>,    <comment type="block">/* reg proc to use */</comment>
                                       <argument><expr><name>scanvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* constant */</comment>
                <expr_stmt><expr><name>n_sub_key</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>

            <comment type="block">/* Mark the last subsidiary scankey correctly */</comment>
            <expr_stmt><expr><name><name>first_sub_key</name><index>[<expr><name>n_sub_key</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sk_flags</name> <operator>|=</operator> <name>SK_ROW_END</name></expr>;</expr_stmt>

            <comment type="block">/*
             * We don't use ScanKeyEntryInitialize for the header because it
             * isn't going to contain a valid sk_func pointer.
             */</comment>
            <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>this_scan_key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this_scan_key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>=</operator> <name>SK_ROW_HEADER</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this_scan_key</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>=</operator> <name><name>first_sub_key</name><operator>-&gt;</operator><name>sk_attno</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this_scan_key</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>rctype</name></name></expr>;</expr_stmt>
            <comment type="block">/* sk_subtype, sk_collation, sk_func not used in a header */</comment>
            <expr_stmt><expr><name><name>this_scan_key</name><operator>-&gt;</operator><name>sk_argument</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>first_sub_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* indexkey op ANY (array-expression) */</comment>
            <decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>saop</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type>        <name>scanvalue</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isorderby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>useOr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>opno</name> <operator>=</operator> <name><name>saop</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>opfuncid</name> <operator>=</operator> <name><name>saop</name><operator>-&gt;</operator><name>opfuncid</name></name></expr>;</expr_stmt>

            <comment type="block">/*
             * leftop should be the index key Var, possibly relabeled
             */</comment>
            <expr_stmt><expr><name>leftop</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>leftop</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>leftop</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leftop</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                  <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>varno</name> <operator>==</operator> <name>INDEX_VAR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"indexqual doesn't have key on left side"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>varattno</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>varattno</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>varattno</name></expr></argument> &gt;</argument_list></name> <name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnatts</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus index qualification"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * We have to look up the operator's strategy number.  This
             * provides a cross-check that the operator does match the index.
             */</comment>
            <expr_stmt><expr><name>opfamily</name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><name>varattno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>get_op_opfamily_properties</name><argument_list>(<argument><expr><name>opno</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>isorderby</name></expr></argument>,
                                       <argument><expr><operator>&amp;</operator><name>op_strategy</name></expr></argument>,
                                       <argument><expr><operator>&amp;</operator><name>op_lefttype</name></expr></argument>,
                                       <argument><expr><operator>&amp;</operator><name>op_righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * rightop is the constant or variable array value
             */</comment>
            <expr_stmt><expr><name>rightop</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>rightop</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>rightop</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rightop</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amsearcharray</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Index AM will handle this like a simple operator */</comment>
                <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>SK_SEARCHARRAY</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* OK, simple constant comparison value */</comment>
                    <expr_stmt><expr><name>scanvalue</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>SK_ISNULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Need to treat this one as a runtime key */</comment>
                    <if_stmt><if>if <condition>(<expr><name>n_runtime_keys</name> <operator>&gt;=</operator> <name>max_runtime_keys</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>max_runtime_keys</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>max_runtime_keys</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>runtime_keys</name> <operator>=</operator> <operator>(</operator><name>IndexRuntimeKeyInfo</name> <operator>*</operator><operator>)</operator>
                                <call><name>palloc</name><argument_list>(<argument><expr><name>max_runtime_keys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexRuntimeKeyInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><name>max_runtime_keys</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>runtime_keys</name> <operator>=</operator> <operator>(</operator><name>IndexRuntimeKeyInfo</name> <operator>*</operator><operator>)</operator>
                                <call><name>repalloc</name><argument_list>(<argument><expr><name>runtime_keys</name></expr></argument>, <argument><expr><name>max_runtime_keys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexRuntimeKeyInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name><name>runtime_keys</name><index>[<expr><name>n_runtime_keys</name></expr>]</index></name><operator>.</operator><name>scan_key</name> <operator>=</operator> <name>this_scan_key</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>runtime_keys</name><index>[<expr><name>n_runtime_keys</name></expr>]</index></name><operator>.</operator><name>key_expr</name> <operator>=</operator>
                        <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Careful here: the runtime expression is not of
                     * op_righttype, but rather is an array of same; so
                     * TypeIsToastable() isn't helpful.  However, we can
                     * assume that all array types are toastable.
                     */</comment>
                    <expr_stmt><expr><name><name>runtime_keys</name><index>[<expr><name>n_runtime_keys</name></expr>]</index></name><operator>.</operator><name>key_toastable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>n_runtime_keys</name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name>scanvalue</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Executor has to expand the array value */</comment>
                <expr_stmt><expr><name><name>array_keys</name><index>[<expr><name>n_array_keys</name></expr>]</index></name><operator>.</operator><name>scan_key</name> <operator>=</operator> <name>this_scan_key</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>array_keys</name><index>[<expr><name>n_array_keys</name></expr>]</index></name><operator>.</operator><name>array_expr</name> <operator>=</operator>
                    <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* the remaining fields were zeroed by palloc0 */</comment>
                <expr_stmt><expr><name>n_array_keys</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>scanvalue</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/*
             * initialize the scan key's fields appropriately
             */</comment>
            <expr_stmt><expr><call><name>ScanKeyEntryInitialize</name><argument_list>(<argument><expr><name>this_scan_key</name></expr></argument>,
                                   <argument><expr><name>flags</name></expr></argument>,
                                   <argument><expr><name>varattno</name></expr></argument>,    <comment type="block">/* attribute number to scan */</comment>
                                   <argument><expr><name>op_strategy</name></expr></argument>, <comment type="block">/* op's strategy */</comment>
                                   <argument><expr><name>op_righttype</name></expr></argument>,    <comment type="block">/* strategy subtype */</comment>
                                   <argument><expr><name><name>saop</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,    <comment type="block">/* collation */</comment>
                                   <argument><expr><name>opfuncid</name></expr></argument>,    <comment type="block">/* reg proc to use */</comment>
                                   <argument><expr><name>scanvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* constant */</comment>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* indexkey IS NULL or indexkey IS NOT NULL */</comment>
            <decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>ntest</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>flags</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isorderby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * argument should be the index key Var, possibly relabeled
             */</comment>
            <expr_stmt><expr><name>leftop</name> <operator>=</operator> <name><name>ntest</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>leftop</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>leftop</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leftop</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                  <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>varno</name> <operator>==</operator> <name>INDEX_VAR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"NullTest indexqual has wrong key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>varattno</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr>;</expr_stmt>

            <comment type="block">/*
             * initialize the scan key's fields appropriately
             */</comment>
            <switch>switch <condition>(<expr><name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>IS_NULL</name></expr>:</case>
                    <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>SK_ISNULL</name> <operator>|</operator> <name>SK_SEARCHNULL</name></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>IS_NOT_NULL</name></expr>:</case>
                    <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>SK_ISNULL</name> <operator>|</operator> <name>SK_SEARCHNOTNULL</name></expr>;</expr_stmt>
                    <break>break;</break>
                <default>default:</default>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized nulltesttype: %d"</literal></expr></argument>,
                         <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <comment type="block">/* keep compiler quiet */</comment>
                    <break>break;</break>
            </block_content>}</block></switch>

            <expr_stmt><expr><call><name>ScanKeyEntryInitialize</name><argument_list>(<argument><expr><name>this_scan_key</name></expr></argument>,
                                   <argument><expr><name>flags</name></expr></argument>,
                                   <argument><expr><name>varattno</name></expr></argument>,    <comment type="block">/* attribute number to scan */</comment>
                                   <argument><expr><name>InvalidStrategy</name></expr></argument>, <comment type="block">/* no strategy */</comment>
                                   <argument><expr><name>InvalidOid</name></expr></argument>,    <comment type="block">/* no strategy subtype */</comment>
                                   <argument><expr><name>InvalidOid</name></expr></argument>,    <comment type="block">/* no collation */</comment>
                                   <argument><expr><name>InvalidOid</name></expr></argument>,    <comment type="block">/* no reg proc for this */</comment>
                                   <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* constant */</comment>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported indexqual type: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>n_runtime_keys</name> <operator>&lt;=</operator> <name>max_runtime_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get rid of any unused arrays */</comment>
    <if_stmt><if>if <condition>(<expr><name>n_array_keys</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>array_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>array_keys</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Return info to our caller.
     */</comment>
    <expr_stmt><expr><operator>*</operator><name>scanKeys</name> <operator>=</operator> <name>scan_keys</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>numScanKeys</name> <operator>=</operator> <name>n_scan_keys</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>runtimeKeys</name> <operator>=</operator> <name>runtime_keys</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>numRuntimeKeys</name> <operator>=</operator> <name>n_runtime_keys</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>arrayKeys</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>arrayKeys</name> <operator>=</operator> <name>array_keys</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>numArrayKeys</name> <operator>=</operator> <name>n_array_keys</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>n_array_keys</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ScalarArrayOpExpr index qual found where not allowed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *                        Parallel Scan Support
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecIndexScanEstimate
 *
 *        estimates the space required to serialize indexscan node.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecIndexScanEstimate</name><parameter_list>(<parameter><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                      <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EState</name>       <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>iss_PscanLen</name></name> <operator>=</operator> <call><name>index_parallelscan_estimate</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_RelationDesc</name></name></expr></argument>,
                                                     <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_PscanLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecIndexScanInitializeDSM
 *
 *        Set up a parallel index scan descriptor.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecIndexScanInitializeDSM</name><parameter_list>(<parameter><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                           <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EState</name>       <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelIndexScanDesc</name></type> <name>piscan</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>piscan</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_PscanLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>index_parallelscan_initialize</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>,
                                  <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_RelationDesc</name></name></expr></argument>,
                                  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>,
                                  <argument><expr><name>piscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>, <argument><expr><name>piscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ScanDesc</name></name> <operator>=</operator>
        <call><name>index_beginscan_parallel</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>,
                                 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_RelationDesc</name></name></expr></argument>,
                                 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumScanKeys</name></name></expr></argument>,
                                 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumOrderByKeys</name></name></expr></argument>,
                                 <argument><expr><name>piscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If no run-time keys to calculate or they are ready, go ahead and pass
     * the scankeys to the index AM.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumRuntimeKeys</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>iss_RuntimeKeysReady</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ScanDesc</name></name></expr></argument>,
                     <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ScanKeys</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumScanKeys</name></name></expr></argument>,
                     <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_OrderByKeys</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumOrderByKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecIndexScanReInitializeDSM
 *
 *		Reset shared state before beginning a fresh scan.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecIndexScanReInitializeDSM</name><parameter_list>(<parameter><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							 <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>index_parallelrescan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ScanDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecIndexScanInitializeWorker
 *
 *        Copy relevant information from TOC into planstate.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecIndexScanInitializeWorker</name><parameter_list>(<parameter><decl><type><name>IndexScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							  <parameter><decl><type><name>ParallelWorkerContext</name> <modifier>*</modifier></type><name>pwcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParallelIndexScanDesc</name></type> <name>piscan</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>piscan</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name><name>pwcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ScanDesc</name></name> <operator>=</operator>
        <call><name>index_beginscan_parallel</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>,
                                 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_RelationDesc</name></name></expr></argument>,
                                 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumScanKeys</name></name></expr></argument>,
                                 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumOrderByKeys</name></name></expr></argument>,
                                 <argument><expr><name>piscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If no run-time keys to calculate or they are ready, go ahead and pass
     * the scankeys to the index AM.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumRuntimeKeys</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>iss_RuntimeKeysReady</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ScanDesc</name></name></expr></argument>,
                     <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_ScanKeys</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumScanKeys</name></name></expr></argument>,
                     <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_OrderByKeys</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>iss_NumOrderByKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
