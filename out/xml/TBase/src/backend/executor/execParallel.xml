<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/executor/execParallel.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execParallel.c
 *      Support routines for parallel execution.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * This file contains routines that are intended to support setting up,
 * using, and tearing down a ParallelContext from within the PostgreSQL
 * executor.  The ParallelContext machinery will handle starting the
 * workers and ensuring that their state generally matches that of the
 * leader; see src/backend/access/transam/README.parallel for details.
 * However, we must save and restore relevant executor state, such as
 * any ParamListInfo associated with the query, buffer usage info, and
 * the actual plan to be passed down to the worker.
 *
 * IDENTIFICATION
 *      src/backend/executor/execParallel.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execParallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapHeapscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeCustom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeForeignscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeIndexscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeIndexonlyscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSeqscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSort.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/tqueue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/dsa.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHashjoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAgg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/squeue.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/mls.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 * Magic numbers for parallel executor communication.  We use constants
 * greater than any 32-bit integer here so that values &lt; 2^32 can be used
 * by individual parallel nodes to store their own state.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_PLANNEDSTMT</name></cpp:macro>        <cpp:value>UINT64CONST(0xE000000000000001)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_PARAMS</name></cpp:macro>                <cpp:value>UINT64CONST(0xE000000000000002)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_BUFFER_USAGE</name></cpp:macro>        <cpp:value>UINT64CONST(0xE000000000000003)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_TUPLE_QUEUE</name></cpp:macro>        <cpp:value>UINT64CONST(0xE000000000000004)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_INSTRUMENTATION</name></cpp:macro>    <cpp:value>UINT64CONST(0xE000000000000005)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_DSA</name></cpp:macro>                <cpp:value>UINT64CONST(0xE000000000000006)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_QUERY_TEXT</name></cpp:macro>        <cpp:value>UINT64CONST(0xE000000000000007)</cpp:value></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_WORKERS_TOTAL_NUM</name></cpp:macro>  <cpp:value>UINT64CONST(0xE000000000000008)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_WORKERS_SEND</name></cpp:macro>       <cpp:value>UINT64CONST(0xE000000000000009)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_WORKERS_SEG_HANDLE</name></cpp:macro> <cpp:value>UINT64CONST(0xE00000000000000A)</cpp:value></cpp:define>

<comment type="block">/* 
  *Used as key to create dsa for each parallel worker, we assume max launched parallel
  * workers' num is 128. 
  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_FIRST_WORKER_DSA</name></cpp:macro>   <cpp:value>UINT64CONST(0xE000000000000010)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_MAX_WORKER_DSA</name></cpp:macro>     <cpp:value>UINT64CONST(0xE000000000000090)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_EXEC_PARAM_LIST</name></cpp:macro>         <cpp:value>UINT64CONST(0xE0000000000000A0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_EXEC_PARAM_VALUE</name></cpp:macro>        <cpp:value>UINT64CONST(0xE0000000000000A1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_EXEC_ERROR</name></cpp:macro>        <cpp:value>UINT64CONST(0xE0000000000000B1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_EXEC_DONE</name></cpp:macro>         <cpp:value>UINT64CONST(0xE0000000000000B2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_REMOTEINSTR_OFFSET</name></cpp:macro>    <cpp:value>UINT64CONST(0xEC00000000000000)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_TUPLE_QUEUE_SIZE</name></cpp:macro>        <cpp:value>65536</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/* dsa for parallel worker, used in execution for exchange data between workers */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>dsa_area</name>   <modifier>*</modifier><modifier>*</modifier></type><name>currentParallelWorkerArea</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>parallelExecutionError</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * DSM structure for accumulating per-PlanState instrumentation.
 *
 * instrument_options: Same meaning here as in instrument.c.
 *
 * instrument_offset: Offset, relative to the start of this structure,
 * of the first Instrumentation object.  This will depend on the length of
 * the plan_node_id array.
 *
 * num_workers: Number of workers.
 *
 * num_plan_nodes: Number of plan nodes.
 *
 * plan_node_id: Array of plan nodes for which we are gathering instrumentation
 * from parallel workers.  The length of this array is given by num_plan_nodes.
 */</comment>
<struct>struct <name>SharedExecutorInstrumentation</name>
<block>{
    <decl_stmt><decl><type><name>int</name></type>            <name>instrument_options</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>instrument_offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_workers</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_plan_nodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name><name>plan_node_id</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
    <comment type="block">/* array of num_plan_nodes * num_workers Instrumentation objects follows */</comment>
}</block>;</struct>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GetInstrumentationArray</name><parameter_list>(<parameter><type><name>sei</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>(AssertVariableIsOfTypeMacro(sei, SharedExecutorInstrumentation *), \
     (Instrumentation *) (((char *) sei) + sei-&gt;instrument_offset))</cpp:value></cpp:define>

<comment type="block">/* Context object for ExecParallelEstimate. */</comment>
<typedef>typedef <type><struct>struct <name>ExecParallelEstimateContext</name>
<block>{
    <decl_stmt><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nnodes</name></decl>;</decl_stmt>
}</block></struct></type> <name>ExecParallelEstimateContext</name>;</typedef>

<comment type="block">/* Context object for ExecParallelInitializeDSM. */</comment>
<typedef>typedef <type><struct>struct <name>ExecParallelInitializeDSMContext</name>
<block>{
    <decl_stmt><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SharedExecutorInstrumentation</name> <modifier>*</modifier></type><name>instrumentation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nnodes</name></decl>;</decl_stmt>
}</block></struct></type> <name>ExecParallelInitializeDSMContext</name>;</typedef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/* Context object for ExecParallelInitializeRemoteInstr. */</comment>
<typedef>typedef <type><struct>struct <name>ExecParallelRemoteInstrContext</name>
<block>{
	<decl_stmt><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndatanode</name></decl>;</decl_stmt>
}</block></struct></type> <name>ExecParallelRemoteInstrContext</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Helper functions that run in the parallel leader. */</comment>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>ExecSerializePlan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecParallelEstimate</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                     <parameter><decl><type><name>ExecParallelEstimateContext</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecParallelInitializeDSM</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                          <parameter><decl><type><name>ExecParallelInitializeDSMContext</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>shm_mq_handle</name> <modifier>*</modifier><modifier>*</modifier></type><name>ExecParallelSetupTupleQueues</name><parameter_list>(<parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>,
                             <parameter><decl><type><name>bool</name></type> <name>reinitialize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecParallelReInitializeDSM</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
							<parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecParallelRetrieveInstrumentation</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
                                    <parameter><decl><type><name>SharedExecutorInstrumentation</name> <modifier>*</modifier></type><name>instrumentation</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecParallelEstimateRemoteInstr</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
                                            <parameter><decl><type><name>ExecParallelRemoteInstrContext</name> <modifier>*</modifier></type><name>ri</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecParallelInitRemoteInstrDSM</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
                                           <parameter><decl><type><name>ExecParallelRemoteInstrContext</name> <modifier>*</modifier></type><name>ri</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecInitializeWorkerRemoteInstr</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>ParallelWorkerContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* Helper function that runs in the parallel worker. */</comment>
<function_decl><type><specifier>static</specifier> <name>DestReceiver</name> <modifier>*</modifier></type><name>ExecParallelGetReceiver</name><parameter_list>(<parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>, <parameter><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Create a serialized representation of the plan to be sent to each worker.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ExecSerializePlan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* We can't scribble on the original plan, so make a copy. */</comment>
    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The worker will start its own copy of the executor, and that copy will
     * insert a junk filter if the toplevel node has any resjunk entries. We
     * don't want that to happen, because while resjunk columns shouldn't be
     * sent back to the user, here the tuples are coming back to another
     * backend which may very well need them.  So mutate the target list
     * accordingly.  This is sort of a hack; there might be better ways to do
     * this...
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plan-&gt;targetlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Create a dummy PlannedStmt.  Most of the fields don't need to be valid
     * for our purposes, but the worker will need at least a minimal
     * PlannedStmt to start the executor.
     */</comment>
    <expr_stmt><expr><name>pstmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>queryId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>hasReturning</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>transientPlan</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>dependsOnRole</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>planTree</name></name> <operator>=</operator> <name>plan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>resultRelations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>nonleafResultRelations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Transfer only parallel-safe subplans, leaving a NULL "hole" in the list
     * for unsafe ones (so that the list indexes of the safe ones are
     * preserved).  This positively ensures that the worker won't try to run,
     * or even do ExecInitNode on, an unsafe subplan.  That's important to
     * protect, eg, non-parallel-aware FDWs from getting into trouble.
     */</comment>
    <expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>subplans</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>estate-&gt;es_plannedstmt-&gt;subplans</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>subplan</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>subplan</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>subplan</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>subplans</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>rewindPlanIDs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>relationOids</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>invalItems</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>    <comment type="block">/* workers can't replan anyway... */</comment>
    <expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>nParamExec</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>nParamExec</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* Return serialized copy of our dummy PlannedStmt. */</comment>
    <return>return <expr><call><name>nodeToString</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parallel-aware plan nodes (and occasionally others) may need some state
 * which is shared across all parallel workers.  Before we size the DSM, give
 * them a chance to call shm_toc_estimate_chunk or shm_toc_estimate_keys on
 * &amp;pcxt-&gt;estimator.
 *
 * While we're at it, count the number of PlanState nodes in the tree, so
 * we know how many SharedPlanStateInstrumentation structures we need.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecParallelEstimate</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>ExecParallelEstimateContext</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int</name></type> <name>previous_nworkers</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>planstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Count this node. */</comment>
    <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>nnodes</name></name><operator>++</operator></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>T_SeqScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecSeqScanEstimate</name><argument_list>(<argument><expr><operator>(</operator><name>SeqScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
                                    <argument><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>T_IndexScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecIndexScanEstimate</name><argument_list>(<argument><expr><operator>(</operator><name>IndexScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
                                      <argument><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>T_IndexOnlyScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecIndexOnlyScanEstimate</name><argument_list>(<argument><expr><operator>(</operator><name>IndexOnlyScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
                                          <argument><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>T_ForeignScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecForeignScanEstimate</name><argument_list>(<argument><expr><operator>(</operator><name>ForeignScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
                                        <argument><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>T_CustomScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecCustomScanEstimate</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
                                       <argument><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>T_BitmapHeapScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecBitmapHeapEstimate</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapHeapScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
                                       <argument><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
		<case>case <expr><name>T_HashState</name></expr>:</case>
			<comment type="block">/* even when not parallel-aware, for EXPLAIN ANALYZE */</comment>
			<expr_stmt><expr><call><name>ExecHashEstimate</name><argument_list>(<argument><expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SortState</name></expr>:</case>
			<comment type="block">/* even when not parallel-aware, for EXPLAIN ANALYZE */</comment>
			<expr_stmt><expr><call><name>ExecSortEstimate</name><argument_list>(<argument><expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ReDistributeEstimate</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
            <comment type="block">/* For remote query and remote subplan, there is no need for shared storage. */</comment>
            <case>case <expr><name>T_RemoteQueryState</name></expr>:</case>                
			<break>break;</break>
            <case>case <expr><name>T_RemoteSubplanState</name></expr>:</case>
			<comment type="block">/*
             * If we are running with instrument option, must init full plantree here,
             * to ensure e-&gt;nnodes correct. Further, we estimate per node instrument
             * for remote instrumentation.
             */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>==</operator> <name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ExecParallelRemoteInstrContext</name></type> <name>ri</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>RemoteSubplanState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>RemoteSubplanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></init></decl>;</decl_stmt>
				
				<expr_stmt><expr><name><name>ri</name><operator>.</operator><name>ndatanode</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RemoteSubplan</name> <operator>*</operator><operator>)</operator><name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>nodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ri</name><operator>.</operator><name>pcxt</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>pcxt</name></name></expr>;</expr_stmt>
				
				<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>,
				                                   <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>state</name></name></expr></argument>,
				                                   <argument><expr><name>EXEC_FLAG_EXPLAIN_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ExecParallelEstimateRemoteInstr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>combiner</name><operator>.</operator><name>remote_parallel_estimated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>T_HashJoinState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecParallelHashJoinEstimate</name><argument_list>(<argument><expr><operator>(</operator><name>HashJoinState</name><operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
                                             <argument><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>T_AggState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name> <init>= <expr><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator><name>planstate</name></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ReDistributeEstimate</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
		<case>case <expr><name>T_GatherState</name></expr>:</case>
			<expr_stmt><expr><name>previous_nworkers</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Gather</name> <operator>*</operator><operator>)</operator> <name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>num_workers</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <default>default:</default>
                <break>break;</break>
        </block_content>}</block></switch>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<expr_stmt><expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ExecParallelEstimate</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>GatherState</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>=</operator> <name>previous_nworkers</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
	<return>return <expr><name>false</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ExecParallelEstimate</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the dynamic shared memory segment that will be used to control
 * parallel execution.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecParallelInitializeDSM</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
                          <parameter><decl><type><name>ExecParallelInitializeDSMContext</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int</name></type> <name>previous_nworkers</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>planstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If instrumentation is enabled, initialize slot for this node. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>instrumentation</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>instrumentation</name><operator>-&gt;</operator><name>plan_node_id</name><index>[<expr><name><name>d</name><operator>-&gt;</operator><name>nnodes</name></name></expr>]</index></name> <operator>=</operator>
            <name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Count this node. */</comment>
    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>nnodes</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/*
	 * Call initializers for DSM-using plan nodes.
     *
	 * Most plan nodes won't do anything here, but plan nodes that allocated
	 * DSM may need to initialize shared state in the DSM before parallel
	 * workers are launched.  They can allocate the space they previously
     * estimated using shm_toc_allocate, and add the keys they previously
     * estimated using shm_toc_insert, in each case targeting pcxt-&gt;toc.
     */</comment>
        <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>T_SeqScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecSeqScanInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>SeqScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
                                         <argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>T_IndexScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecIndexScanInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>IndexScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
                                           <argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>T_IndexOnlyScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecIndexOnlyScanInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>IndexOnlyScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
                                               <argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>T_ForeignScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecForeignScanInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>ForeignScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
                                             <argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>T_CustomScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecCustomScanInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
                                            <argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>T_BitmapHeapScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecBitmapHeapInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapHeapScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
                                            <argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
		<case>case <expr><name>T_HashState</name></expr>:</case>
			<comment type="block">/* even when not parallel-aware, for EXPLAIN ANALYZE */</comment>
			<expr_stmt><expr><call><name>ExecHashInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SortState</name></expr>:</case>
			<comment type="block">/* even when not parallel-aware, for EXPLAIN ANALYZE */</comment>
			<expr_stmt><expr><call><name>ExecSortInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ReDistributeInitializeDSM</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
            <case>case <expr><name>T_RemoteQueryState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecRemoteQueryInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>RemoteQueryState</name> <operator>*</operator><operator>)</operator><name>planstate</name></expr></argument>,
                                                  <argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>T_RemoteSubplanState</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RemoteSubplanState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>RemoteSubplanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>combiner</name><operator>.</operator><name>remote_parallel_estimated</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ExecParallelRemoteInstrContext</name></type> <name>ri</name></decl>;</decl_stmt>
					
					<expr_stmt><expr><name><name>ri</name><operator>.</operator><name>ndatanode</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RemoteSubplan</name> <operator>*</operator><operator>)</operator><name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>nodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>ri</name><operator>.</operator><name>pcxt</name></name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr>;</expr_stmt>
					
					<expr_stmt><expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ExecParallelInitRemoteInstrDSM</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecRemoteSubPlanInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>RemoteSubplanState</name> <operator>*</operator><operator>)</operator><name>planstate</name></expr></argument>,
                                                  <argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
                <break>break;</break>                
            <case>case <expr><name>T_HashJoinState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecParallelHashJoinInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>HashJoinState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
                                                  <argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>T_AggState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name> <init>= <expr><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator><name>planstate</name></expr></init></decl>;</decl_stmt>
                    
                    <if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ReDistributeInitializeDSM</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
		<case>case <expr><name>T_GatherState</name></expr>:</case>
			<expr_stmt><expr><name>previous_nworkers</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Gather</name> <operator>*</operator><operator>)</operator> <name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>num_workers</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <default>default:</default>
                <break>break;</break>
        </block_content>}</block></switch>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<expr_stmt><expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ExecParallelInitializeDSM</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>GatherState</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>=</operator> <name>previous_nworkers</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
	<return>return <expr><name>false</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ExecParallelInitializeDSM</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * It sets up the response queues for backend workers to return tuples
 * to the main backend and start the workers.
 */</comment>
<function><type><specifier>static</specifier> <name>shm_mq_handle</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>ExecParallelSetupTupleQueues</name><parameter_list>(<parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>reinitialize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>shm_mq_handle</name> <modifier>*</modifier><modifier>*</modifier></type><name>responseq</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>tqueuespace</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Skip this if no workers. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Allocate memory for shared memory queue handles. */</comment>
    <expr_stmt><expr><name>responseq</name> <operator>=</operator> <operator>(</operator><name>shm_mq_handle</name> <operator>*</operator><operator>*</operator><operator>)</operator>
        <call><name>palloc</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>shm_mq_handle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If not reinitializing, allocate space from the DSM for the queues;
     * otherwise, find the already allocated space.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>reinitialize</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>tqueuespace</name> <operator>=</operator>
            <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>,
                             <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>PARALLEL_TUPLE_QUEUE_SIZE</name></expr></argument>,
                                      <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>tqueuespace</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_TUPLE_QUEUE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Create the queues, and become the receiver for each. */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>shm_mq</name>       <modifier>*</modifier></type><name>mq</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>mq</name> <operator>=</operator> <call><name>shm_mq_create</name><argument_list>(<argument><expr><name>tqueuespace</name> <operator>+</operator>
                           <operator>(</operator><operator>(</operator><name>Size</name><operator>)</operator> <name>i</name><operator>)</operator> <operator>*</operator> <name>PARALLEL_TUPLE_QUEUE_SIZE</name></expr></argument>,
                           <argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name>PARALLEL_TUPLE_QUEUE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>shm_mq_set_receiver</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>responseq</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>shm_mq_attach</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Add array of queues to shm_toc, so others can find it. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>reinitialize</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_TUPLE_QUEUE</name></expr></argument>, <argument><expr><name>tqueuespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Return array of handles. */</comment>
    <return>return <expr><name>responseq</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sets up the required infrastructure for backend workers to perform
 * execution and return results to the main backend.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><name>ParallelExecutorInfo</name> <modifier>*</modifier></type>
<name>ExecInitParallelPlan</name><argument_list>(<argument><expr><name>PlanState</name> <operator>*</operator><name>planstate</name></expr></argument>, <argument><expr><name>EState</name> <operator>*</operator><name>estate</name></expr></argument>, <argument><expr><name>int</name> <name>nworkers</name></expr></argument>, <argument><expr><name>Gather</name> <operator>*</operator><name>gather</name></expr></argument>)</argument_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<name>ParallelExecutorInfo</name> <modifier>*</modifier>
<name>ExecInitParallelPlan</name><argument_list>(<argument><expr><name>PlanState</name> <operator>*</operator><name>planstate</name></expr></argument>, <argument><expr><name>EState</name> <operator>*</operator><name>estate</name></expr></argument>, <argument><expr><name>int</name> <name>nworkers</name></expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ParallelExecutorInfo</name> <modifier>*</modifier></type><name>pei</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExecParallelEstimateContext</name></type> <name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExecParallelInitializeDSMContext</name></type> <name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>pstmt_data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>pstmt_space</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>param_space</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BufferUsage</name> <modifier>*</modifier></type><name>bufusage_space</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SharedExecutorInstrumentation</name> <modifier>*</modifier></type><name>instrumentation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>pstmt_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>param_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>instrumentation_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>instrument_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>dsa_minsize</name> <init>= <expr><call><name>dsa_minimum_size</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>query_string</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>query_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelWorkerStatus</name> <modifier>*</modifier></type><name>num_parallel_workers</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>        <modifier>*</modifier></type><name>parallel_send</name>                 <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsm_handle</name>  <modifier>*</modifier></type><name>handle</name>                        <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>StringInfoData</name></type>    <name>buf</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Allocate object for return value. */</comment>
    <expr_stmt><expr><name>pei</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelExecutorInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>finished</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>planstate</name></name> <operator>=</operator> <name>planstate</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>executor_done</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Fix up and serialize plan to be sent to workers. */</comment>
    <expr_stmt><expr><name>pstmt_data</name> <operator>=</operator> <call><name>ExecSerializePlan</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create a parallel context. */</comment>
    <expr_stmt><expr><name>pcxt</name> <operator>=</operator> <call><name>CreateParallelContext</name><argument_list>(<argument><expr><literal type="string">"postgres"</literal></expr></argument>, <argument><expr><literal type="string">"ParallelQueryMain"</literal></expr></argument>, <argument><expr><name>nworkers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>pcxt</name></name> <operator>=</operator> <name>pcxt</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Before telling the parallel context to create a dynamic shared memory
     * segment, we need to figure out how big it should be.  Estimate space
     * for the various things we need to store.
     */</comment>

    <comment type="block">/* Estimate space for query text. */</comment>
    <expr_stmt><expr><name>query_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sourceText</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>query_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Estimate space for serialized PlannedStmt. */</comment>
    <expr_stmt><expr><name>pstmt_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pstmt_data</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>pstmt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Estimate space for serialized ParamListInfo. */</comment>
    <expr_stmt><expr><name>param_len</name> <operator>=</operator> <call><name>EstimateParamListSpace</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>param_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* Estimate space for parallel workers' total number. */</comment>
    <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelWorkerStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>gather</name> <operator>&amp;&amp;</operator> <name><name>gather</name><operator>-&gt;</operator><name>parallelWorker_sendTuple</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsm_handle</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* send param to workers */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>nParamExec</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nParamExec</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>nParamExec</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>es_param_exec_vals</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>nParamExec</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParamExecData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nParamExec</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content> 
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ptype</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type>        <name>typOutput</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>    <name>typIsVarlena</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Datum</name></type>    <name>pval</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>pstring</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>        <name>len</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type> <name>ptype</name> <init>= <expr><name><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ptype</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Datum</name></type> <name>value</name> <init>= <expr><name><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* Get info needed to output the value */</comment>
                <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typOutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIsVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * If we have a toasted datum, forcibly detoast it here to avoid
                 * memory leakage inside the type's output routine.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>typIsVarlena</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>pval</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>pval</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <comment type="block">/* Convert Datum to string */</comment>
                <expr_stmt><expr><name>pstring</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typOutput</name></expr></argument>, <argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* copy data to the buffer */</comment>
                <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pstring</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Estimate space for BufferUsage.
     *
     * If EXPLAIN is not in use and there are no extensions loaded that care,
     * we could skip this.  But we have no way of knowing whether anyone's
     * looking at pgBufferUsage, so do it unconditionally.
     */</comment>
    <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>,
                           <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufferUsage</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>gather</name> <operator>||</operator> <operator>!</operator><name><name>gather</name><operator>-&gt;</operator><name>parallelWorker_sendTuple</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Estimate space for tuple queues. */</comment>
        <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>,
                               <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>PARALLEL_TUPLE_QUEUE_SIZE</name></expr></argument>, <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Give parallel-aware nodes a chance to add to the estimates, and get a
     * count of how many PlanState nodes there are.
     */</comment>
    <expr_stmt><expr><name><name>e</name><operator>.</operator><name>pcxt</name></name> <operator>=</operator> <name>pcxt</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>e</name><operator>.</operator><name>nnodes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecParallelEstimate</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Estimate space for instrumentation, if required. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>instrumentation_len</name> <operator>=</operator>
            <call><name>offsetof</name><argument_list>(<argument><expr><name>SharedExecutorInstrumentation</name></expr></argument>, <argument><expr><name>plan_node_id</name></expr></argument>)</argument_list></call> <operator>+</operator>
            <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>e</name><operator>.</operator><name>nnodes</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>instrumentation_len</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>instrumentation_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>instrument_offset</name> <operator>=</operator> <name>instrumentation_len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>instrumentation_len</name> <operator>+=</operator>
            <call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Instrumentation</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                     <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name><name>e</name><operator>.</operator><name>nnodes</name></name></expr></argument>, <argument><expr><name>nworkers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>instrumentation_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Estimate space for DSA area. */</comment>
    <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>dsa_minsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* Estimate space for DSA area for each parallel worker. */</comment>
    <if_stmt><if>if<condition>(<expr><name>nworkers</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nworkers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>dsa_minsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<comment type="block">/* set snapshot as needed */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_set_global_snapshot</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetSnapshot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


    <comment type="block">/* Everyone's had a chance to ask for space, so now create the DSM. */</comment>
    <expr_stmt><expr><call><name>InitializeParallelDSM</name><argument_list>(<argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * OK, now we have a dynamic shared memory segment, and it should be big
     * enough to store all of the data we estimated we would want to put into
     * it, plus whatever general stuff (not specifically executor-related) the
     * ParallelContext itself needs to store there.  None of the space we
     * asked for has been allocated or initialized yet, though, so do that.
     */</comment>

    <comment type="block">/* Store query string */</comment>
    <expr_stmt><expr><name>query_string</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>query_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sourceText</name></name></expr></argument>, <argument><expr><name>query_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_QUERY_TEXT</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Store serialized PlannedStmt. */</comment>
    <expr_stmt><expr><name>pstmt_space</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>pstmt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pstmt_space</name></expr></argument>, <argument><expr><name>pstmt_data</name></expr></argument>, <argument><expr><name>pstmt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_PLANNEDSTMT</name></expr></argument>, <argument><expr><name>pstmt_space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Store serialized ParamListInfo. */</comment>
    <expr_stmt><expr><name>param_space</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>param_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_PARAMS</name></expr></argument>, <argument><expr><name>param_space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SerializeParamList</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param_space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* Store parallel workers total number. */</comment>
    <expr_stmt><expr><name>num_parallel_workers</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelWorkerStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>num_parallel_workers</name><operator>-&gt;</operator><name>parallelWorkersSetupDone</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>num_parallel_workers</name><operator>-&gt;</operator><name>numLaunchedWorkers</name></name>       <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>num_parallel_workers</name><operator>-&gt;</operator><name>numExpectedWorkers</name></name>       <operator>=</operator> <name>nworkers</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_WORKERS_TOTAL_NUM</name></expr></argument>, <argument><expr><name>num_parallel_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>parallel_send</name>        <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>gather</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>parallel_send</name>   <operator>=</operator> <name><name>gather</name><operator>-&gt;</operator><name>parallelWorker_sendTuple</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>parallel_send</name>   <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* parallel executor done flag */</comment>
    <expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>executor_done</name></name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name><name>pei</name><operator>-&gt;</operator><name>executor_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_EXEC_DONE</name></expr></argument>, <argument><expr><name><name>pei</name><operator>-&gt;</operator><name>executor_done</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>parallelExecutionError</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>parallelExecutionError</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_WORKERS_SEND</name></expr></argument>, <argument><expr><name>parallel_send</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_EXEC_ERROR</name></expr></argument>, <argument><expr><name>parallelExecutionError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>gather</name> <operator>&amp;&amp;</operator> <name><name>gather</name><operator>-&gt;</operator><name>parallelWorker_sendTuple</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>handle</name>  <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsm_handle</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>handle</name> <operator>=</operator> <call><name>GetParallelSendSegHandle</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>handle</name> <operator>==</operator> <name>DSM_HANDLE_INVALID</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">" invalid parallel send segment handle."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_WORKERS_SEG_HANDLE</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* param */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>nParamExec</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nParamExec</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>nParamExec</name></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>es_param_exec_vals</name> <init>= <expr><call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>nParamExec</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParamExecData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>es_param_exec_vals</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name></name></expr></argument>, <argument><expr><name>nParamExec</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParamExecData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_EXEC_PARAM_LIST</name></expr></argument>, <argument><expr><name>es_param_exec_vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>paramsExec</name> <init>= <expr><call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>paramsExec</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_EXEC_PARAM_VALUE</name></expr></argument>, <argument><expr><name>paramsExec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Allocate space for each worker's BufferUsage; no need to initialize. */</comment>
    <expr_stmt><expr><name>bufusage_space</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>,
                                      <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufferUsage</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_BUFFER_USAGE</name></expr></argument>, <argument><expr><name>bufusage_space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>buffer_usage</name></name> <operator>=</operator> <name>bufusage_space</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>gather</name> <operator>&amp;&amp;</operator> <name><name>gather</name><operator>-&gt;</operator><name>parallelWorker_sendTuple</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>tqueue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Set up tuple queues. */</comment>
        <expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>tqueue</name></name> <operator>=</operator> <call><name>ExecParallelSetupTupleQueues</name><argument_list>(<argument><expr><name>pcxt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * If instrumentation options were supplied, allocate space for the data.
     * It only gets partially initialized here; the rest happens during
     * ExecParallelInitializeDSM.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Instrumentation</name> <modifier>*</modifier></type><name>instrument</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>instrumentation</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>instrumentation_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>instrumentation</name><operator>-&gt;</operator><name>instrument_options</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>instrumentation</name><operator>-&gt;</operator><name>instrument_offset</name></name> <operator>=</operator> <name>instrument_offset</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>instrumentation</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <name>nworkers</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>instrumentation</name><operator>-&gt;</operator><name>num_plan_nodes</name></name> <operator>=</operator> <name><name>e</name><operator>.</operator><name>nnodes</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>instrument</name> <operator>=</operator> <call><name>GetInstrumentationArray</name><argument_list>(<argument><expr><name>instrumentation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nworkers</name> <operator>*</operator> <name><name>e</name><operator>.</operator><name>nnodes</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>InstrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instrument</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_INSTRUMENTATION</name></expr></argument>,
                       <argument><expr><name>instrumentation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>instrumentation</name></name> <operator>=</operator> <name>instrumentation</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Create a DSA area that can be used by the leader and all workers.
     * (However, if we failed to create a DSM and are using private memory
     * instead, then skip this.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>seg</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>area_space</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>area_space</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>dsa_minsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_DSA</name></expr></argument>, <argument><expr><name>area_space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>area</name></name> <operator>=</operator> <call><name>dsa_create_in_place</name><argument_list>(<argument><expr><name>area_space</name></expr></argument>, <argument><expr><name>dsa_minsize</name></expr></argument>,
                                        <argument><expr><name>LWTRANCHE_PARALLEL_QUERY_DSA</name></expr></argument>,
                                        <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/* create dsa for each parallel worker. */</comment>
        <if_stmt><if>if<condition>(<expr><name>nworkers</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nworkers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name>area_space</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>dsa_minsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PARALLEL_KEY_FIRST_WORKER_DSA</name> <operator>+</operator> <name>i</name><operator>)</operator></expr></argument>,
                               <argument><expr><name>area_space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>dsa_create_in_place</name><argument_list>(<argument><expr><name>area_space</name></expr></argument>, <argument><expr><name>dsa_minsize</name></expr></argument>,
                                        <argument><expr><name>LWTRANCHE_PARALLEL_WORKER_DSA</name></expr></argument>,
                                        <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Make the area available to executor nodes running in the leader.  See
     * also ParallelQueryMain which makes it available to workers.
     */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_dsa</name></name> <operator>=</operator> <name><name>pei</name><operator>-&gt;</operator><name>area</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Give parallel-aware nodes a chance to initialize their shared data.
     * This also initializes the elements of instrumentation-&gt;ps_instrument,
     * if it exists.
     */</comment>
    <expr_stmt><expr><name><name>d</name><operator>.</operator><name>pcxt</name></name> <operator>=</operator> <name>pcxt</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d</name><operator>.</operator><name>instrumentation</name></name> <operator>=</operator> <name>instrumentation</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d</name><operator>.</operator><name>nnodes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecParallelInitializeDSM</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
	 * Make sure that the world hasn't shifted under our feet.  This could
     * probably just be an Assert(), but let's be conservative for now.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>.</operator><name>nnodes</name></name> <operator>!=</operator> <name><name>d</name><operator>.</operator><name>nnodes</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"inconsistent count of PlanState nodes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* OK, we're ready to rock and roll. */</comment>
    <return>return <expr><name>pei</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<comment type="block">/*
 * Re-initialize the parallel executor shared memory state before launching
 * a fresh batch of workers.
 */</comment>
<function><type><name>void</name></type>
<name>ExecParallelReinitialize</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
						 <parameter><decl><type><name>ParallelExecutorInfo</name> <modifier>*</modifier></type><name>pei</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Old workers must already be shut down */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>finished</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReinitializeParallelDSM</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>tqueue</name></name> <operator>=</operator> <call><name>ExecParallelSetupTupleQueues</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>finished</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Traverse plan tree and let each child node reset associated state. */</comment>
	<expr_stmt><expr><call><name>ExecParallelReInitializeDSM</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name><name>pei</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Traverse plan tree to reinitialize per-node dynamic shared memory state
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecParallelReInitializeDSM</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
							<parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>planstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Call reinitializers for DSM-using plan nodes.
	 */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_SeqScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecSeqScanReInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>SeqScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
										   <argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_IndexScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecIndexScanReInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>IndexScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
											 <argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_IndexOnlyScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecIndexOnlyScanReInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>IndexOnlyScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
												 <argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ForeignScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecForeignScanReInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>ForeignScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
											   <argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CustomScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecCustomScanReInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
											  <argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitmapHeapScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecBitmapHeapReInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapHeapScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
											  <argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashState</name></expr>:</case>
			<comment type="block">/* even when not parallel-aware, for EXPLAIN ANALYZE */</comment>
			<expr_stmt><expr><call><name>ExecHashReInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SortState</name></expr>:</case>
			<comment type="block">/* even when not parallel-aware, for EXPLAIN ANALYZE */</comment>
			<expr_stmt><expr><call><name>ExecSortReInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ExecParallelReInitializeDSM</name></expr></argument>, <argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy instrumentation information about this node and its descendants from
 * dynamic shared memory.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecParallelRetrieveInstrumentation</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
                                    <parameter><decl><type><name>SharedExecutorInstrumentation</name> <modifier>*</modifier></type><name>instrumentation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Instrumentation</name> <modifier>*</modifier></type><name>instrument</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ibytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>plan_node_id</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <comment type="block">/* Find the instrumentation for this node. */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>instrumentation</name><operator>-&gt;</operator><name>num_plan_nodes</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>instrumentation</name><operator>-&gt;</operator><name>plan_node_id</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>plan_node_id</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>instrumentation</name><operator>-&gt;</operator><name>num_plan_nodes</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"plan node %d not found"</literal></expr></argument>, <argument><expr><name>plan_node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Accumulate the statistics from all workers. */</comment>
    <expr_stmt><expr><name>instrument</name> <operator>=</operator> <call><name>GetInstrumentationArray</name><argument_list>(<argument><expr><name>instrumentation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>instrument</name> <operator>+=</operator> <name>i</name> <operator>*</operator> <name><name>instrumentation</name><operator>-&gt;</operator><name>num_workers</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>instrumentation</name><operator>-&gt;</operator><name>num_workers</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>InstrAggNode</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>instrument</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/*
     * Also store the per-worker detail.
     *
     * Worker instrumentation should be allocated in the same context as the
     * regular instrumentation information, which is the per-query context.
     * Switch into per-query memory context.
     */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ibytes</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><name><name>instrumentation</name><operator>-&gt;</operator><name>num_workers</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Instrumentation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>worker_instrument</name></name> <operator>=</operator>
        <call><name>palloc</name><argument_list>(<argument><expr><name>ibytes</name> <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>WorkerInstrumentation</name></expr></argument>, <argument><expr><name>instrument</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__TBASE__</name></cpp:ifndef>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>worker_instrument</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <name><name>instrumentation</name><operator>-&gt;</operator><name>num_workers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>planstate</name><operator>-&gt;</operator><name>worker_instrument</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>, <argument><expr><name>instrument</name></expr></argument>, <argument><expr><name>ibytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Perform any node-type-specific work that needs to be done. */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_SortState</name></expr>:</case>
		<expr_stmt><expr><call><name>ExecSortRetrieveInstrumentation</name><argument_list>(<argument><expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecHashRetrieveInstrumentation</name><argument_list>(<argument><expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<comment type="block">/* also retrieve instrumentation from remote */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>dn_instrument</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DatanodeInstrumentation</name> <modifier>*</modifier></type><name>tmp_instrument</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>dn_instrument</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>     <name>nnode</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>dn_instrument</name><operator>-&gt;</operator><name>nnode</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>    <name>size</name> <init>= <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>DatanodeInstrumentation</name></expr></argument>, <argument><expr><name>instrument</name></expr></argument>)</argument_list></call> <operator>+</operator>
		               <call><name>mul_size</name><argument_list>(<argument><expr><name>nnode</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RemoteInstrumentation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"retrieve downstream instrumentation, plan_node_id %d nnode %d"</literal></expr></argument>, <argument><expr><name>plan_node_id</name></expr></argument>, <argument><expr><name>nnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>dn_instrument</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>dn_instrument</name></name></expr></argument>, <argument><expr><name>tmp_instrument</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * TBase switch memory context later to keep retrieved instrumentation live until 
	 * sending them back to upstream.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ExecParallelRetrieveInstrumentation</name></expr></argument>,
                                 <argument><expr><name>instrumentation</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Finish parallel execution.  We wait for parallel workers to finish, and
 * accumulate their buffer usage and instrumentation.
 */</comment>
<function><type><name>void</name></type>
<name>ExecParallelFinish</name><parameter_list>(<parameter><decl><type><name>ParallelExecutorInfo</name> <modifier>*</modifier></type><name>pei</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pei</name><operator>-&gt;</operator><name>finished</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* First, wait for the workers to finish. */</comment>
    <expr_stmt><expr><call><name>WaitForParallelWorkersToFinish</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Next, accumulate buffer usage. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pei</name><operator>-&gt;</operator><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pei</name><operator>-&gt;</operator><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>InstrAccumParallelQuery</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pei</name><operator>-&gt;</operator><name>buffer_usage</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Finally, accumulate instrumentation, if any. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pei</name><operator>-&gt;</operator><name>instrumentation</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecParallelRetrieveInstrumentation</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>,
                                            <argument><expr><name><name>pei</name><operator>-&gt;</operator><name>instrumentation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>finished</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Clean up whatever ParallelExecutorInfo resources still exist after
 * ExecParallelFinish.  We separate these routines because someone might
 * want to examine the contents of the DSM after ExecParallelFinish and
 * before calling this routine.
 */</comment>
<function><type><name>void</name></type>
<name>ExecParallelCleanup</name><parameter_list>(<parameter><decl><type><name>ParallelExecutorInfo</name> <modifier>*</modifier></type><name>pei</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pei</name><operator>-&gt;</operator><name>area</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>dsa_detach</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>area</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>area</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pei</name><operator>-&gt;</operator><name>pcxt</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>DestroyParallelContext</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>pcxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pei</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a DestReceiver to write tuples we produce to the shm_mq designated
 * for that purpose.
 */</comment>
<function><type><specifier>static</specifier> <name>DestReceiver</name> <modifier>*</modifier></type>
<name>ExecParallelGetReceiver</name><parameter_list>(<parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>, <parameter><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>mqspace</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>shm_mq</name>       <modifier>*</modifier></type><name>mq</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>mqspace</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_TUPLE_QUEUE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mqspace</name> <operator>+=</operator> <name>ParallelWorkerNumber</name> <operator>*</operator> <name>PARALLEL_TUPLE_QUEUE_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mq</name> <operator>=</operator> <operator>(</operator><name>shm_mq</name> <operator>*</operator><operator>)</operator> <name>mqspace</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_mq_set_sender</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>CreateTupleQueueDestReceiver</name><argument_list>(<argument><expr><call><name>shm_mq_attach</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name>seg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a QueryDesc for the PlannedStmt we are to execute, and return it.
 */</comment>
<function><type><specifier>static</specifier> <name>QueryDesc</name> <modifier>*</modifier></type>
<name>ExecParallelGetQueryDesc</name><parameter_list>(<parameter><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>receiver</name></decl></parameter>,
                         <parameter><decl><type><name>int</name></type> <name>instrument_options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>pstmtspace</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>paramspace</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>queryString</name></decl>;</decl_stmt>

    <comment type="block">/* Get the query string from shared memory */</comment>
    <expr_stmt><expr><name>queryString</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_QUERY_TEXT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reconstruct leader-supplied PlannedStmt. */</comment>
    <expr_stmt><expr><name>pstmtspace</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_PLANNEDSTMT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pstmt</name> <operator>=</operator> <operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>pstmtspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reconstruct ParamListInfo. */</comment>
    <expr_stmt><expr><name>paramspace</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_PARAMS</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>RestoreParamList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create a QueryDesc for the query.
     *
     * It's not obvious how to obtain the query string from here; and even if
     * we could copying it would take more cycles than not copying it. But
     * it's a bit unsatisfying to just use a dummy string here, so consider
     * revising this someday.
     */</comment>
    <return>return <expr><call><name>CreateQueryDesc</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>,
                           <argument><expr><name>queryString</name></expr></argument>,
                           <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>,
                           <argument><expr><name>receiver</name></expr></argument>, <argument><expr><name>paramLI</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>instrument_options</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy instrumentation information from this node and its descendants into
 * dynamic shared memory, so that the parallel leader can retrieve it.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecParallelReportInstrumentation</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
                                  <parameter><decl><type><name>SharedExecutorInstrumentation</name> <modifier>*</modifier></type><name>instrumentation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>plan_node_id</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Instrumentation</name> <modifier>*</modifier></type><name>instrument</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>InstrEndLoop</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we shuffled the plan_node_id values in ps_instrument into sorted
     * order, we could use binary search here.  This might matter someday if
     * we're pushing down sufficiently large plan trees.  For now, do it the
     * slow, dumb way.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>instrumentation</name><operator>-&gt;</operator><name>num_plan_nodes</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>instrumentation</name><operator>-&gt;</operator><name>plan_node_id</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>plan_node_id</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>instrumentation</name><operator>-&gt;</operator><name>num_plan_nodes</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"plan node %d not found"</literal></expr></argument>, <argument><expr><name>plan_node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Add our statistics to the per-node, per-worker totals.  It's possible
     * that this could happen more than once if we relaunched workers.
     */</comment>
    <expr_stmt><expr><name>instrument</name> <operator>=</operator> <call><name>GetInstrumentationArray</name><argument_list>(<argument><expr><name>instrumentation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>instrument</name> <operator>+=</operator> <name>i</name> <operator>*</operator> <name><name>instrumentation</name><operator>-&gt;</operator><name>num_workers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ParallelWorkerNumber</name> <operator>&lt;</operator> <name><name>instrumentation</name><operator>-&gt;</operator><name>num_workers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>InstrAggNode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instrument</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ExecParallelReportInstrumentation</name></expr></argument>,
                                 <argument><expr><name>instrumentation</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the PlanState and its descendants with the information
 * retrieved from shared memory.  This has to be done once the PlanState
 * is allocated and initialized by executor; that is, after ExecutorStart().
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecParallelInitializeWorker</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>ParallelWorkerContext</name> <modifier>*</modifier></type><name>pwcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>planstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

        <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>T_SeqScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecSeqScanInitializeWorker</name><argument_list>(<argument><expr><operator>(</operator><name>SeqScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>T_IndexScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecIndexScanInitializeWorker</name><argument_list>(<argument><expr><operator>(</operator><name>IndexScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
											  <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>T_IndexOnlyScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecIndexOnlyScanInitializeWorker</name><argument_list>(<argument><expr><operator>(</operator><name>IndexOnlyScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
												  <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>T_ForeignScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecForeignScanInitializeWorker</name><argument_list>(<argument><expr><operator>(</operator><name>ForeignScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
												<argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>T_CustomScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecCustomScanInitializeWorker</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
				                               <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>T_BitmapHeapScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecBitmapHeapInitializeWorker</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapHeapScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
		<case>case <expr><name>T_HashState</name></expr>:</case>
			<comment type="block">/* even when not parallel-aware, for EXPLAIN ANALYZE */</comment>
			<expr_stmt><expr><call><name>ExecHashInitializeWorker</name><argument_list>(<argument><expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SortState</name></expr>:</case>
			<comment type="block">/* even when not parallel-aware, for EXPLAIN ANALYZE */</comment>
			<expr_stmt><expr><call><name>ExecSortInitializeWorker</name><argument_list>(<argument><expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ReDistributeInitializeWorker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
            <case>case <expr><name>T_RemoteQueryState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecRemoteQueryInitializeDSMWorker</name><argument_list>(<argument><expr><operator>(</operator><name>RemoteQueryState</name> <operator>*</operator><operator>)</operator><name>planstate</name></expr></argument>, <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>T_RemoteSubplanState</name></expr>:</case> 
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>==</operator> <name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* if instrument needed, init full plantree in worker */</comment>
				<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>,
				                                   <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>state</name></name></expr></argument>,
				                                   <argument><expr><name>EXEC_FLAG_EXPLAIN_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* attach share memory for it's child */</comment>
				<expr_stmt><expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ExecInitializeWorkerRemoteInstr</name></expr></argument>, <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>        
				<expr_stmt><expr><call><name>ExecRemoteSubPlanInitDSMWorker</name><argument_list>(<argument><expr><operator>(</operator><name>RemoteSubplanState</name> <operator>*</operator><operator>)</operator><name>planstate</name></expr></argument>, <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashJoinState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecParallelHashJoinInitWorker</name><argument_list>(<argument><expr><operator>(</operator><name>HashJoinState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>T_AggState</name></expr>:</case>
			    <if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name> <init>= <expr><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator><name>planstate</name></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ReDistributeInitializeWorker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <default>default:</default>
                <break>break;</break>
        </block_content>}</block></switch>

	<return>return <expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ExecParallelInitializeWorker</name></expr></argument>,
								 <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * Estimate share memory space for plan nodes executed by remote, they contain instruments
 * from all datanodes involved, and only leader worker receive these instruments.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecParallelEstimateRemoteInstr</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ExecParallelRemoteInstrContext</name> <modifier>*</modifier></type><name>ri</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name> <init>= <expr><name><name>ri</name><operator>-&gt;</operator><name>pcxt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type> <name>size</name> <init>= <expr><call><name>mul_size</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>ndatanode</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RemoteInstrumentation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>DatanodeInstrumentation</name></expr></argument>, <argument><expr><name>instrument</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	
	<comment type="block">/*
	 * only remote plan node could be here, we need disable parallel for these nodes
	 * to prevent them from initializing other share memory for execution, they don't
	 * need that, only init share memory for instrument collecting.
	 */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* for sub-plan */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RemoteSubplanState</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>,
		                              <argument><expr><name><name>node</name><operator>-&gt;</operator><name>state</name></name></expr></argument>,
		                              <argument><expr><name>EXEC_FLAG_EXPLAIN_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"parallel estimate shm remote instrument for plan node %d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<return>return <expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ExecParallelEstimateRemoteInstr</name></expr></argument>,
	                             <argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate share memory space for plan nodes executed by remote, they contain instruments
 * from all datanodes involved, and only leader worker receive these instruments. use
 * plan_node_id + offset as a unique key.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecParallelInitRemoteInstrDSM</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ExecParallelRemoteInstrContext</name> <modifier>*</modifier></type><name>ri</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name> <init>= <expr><name><name>ri</name><operator>-&gt;</operator><name>pcxt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type> <name>size</name> <init>= <expr><call><name>mul_size</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>ndatanode</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RemoteInstrumentation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>DatanodeInstrumentation</name></expr></argument>, <argument><expr><name>instrument</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>dn_instrument</name></name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>dn_instrument</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>dn_instrument</name><operator>-&gt;</operator><name>nnode</name></name> <operator>=</operator> <name><name>ri</name><operator>-&gt;</operator><name>ndatanode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name> <operator>+</operator> <name>PARALLEL_REMOTEINSTR_OFFSET</name></expr></argument>,
	               <argument><expr><name><name>node</name><operator>-&gt;</operator><name>dn_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"parallel allocate shm remote instrument for plan node %d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<return>return <expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ExecParallelInitRemoteInstrDSM</name></expr></argument>,
	                             <argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the share memory for plan nodes executed by remote, they will be fulfilled
 * with instruments during RemoteSubplan node's execution. use plan_node_id + offset
 * as the unique key.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecInitializeWorkerRemoteInstr</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>ParallelWorkerContext</name> <modifier>*</modifier></type><name>pwcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * only remote plan node could be here, we need disable parallel for these nodes
	 * to prevent them from initializing other share memory for execution, they don't
	 * need that, only init share memory for instrument collecting.
	 */</comment>
	<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>dn_instrument</name></name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name><name>pwcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>,
	                                          <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name> <operator>+</operator> <name>PARALLEL_REMOTEINSTR_OFFSET</name></expr></argument>,
	                                          <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* for sub-plan */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>RemoteSubplanState</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>,
		                                   <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>state</name></name></expr></argument>,
		                                   <argument><expr><name>EXEC_FLAG_EXPLAIN_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"parallel init worker remote instrument for plan node %d"</literal></expr></argument>, <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<return>return <expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ExecInitializeWorkerRemoteInstr</name></expr></argument>,
	                             <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Main entrypoint for parallel query worker processes.
 *
 * We reach this function from ParallelWorkerMain, so the setup necessary to
 * create a sensible parallel environment has already been done;
 * ParallelWorkerMain worries about stuff like the transaction state, combo
 * CID mappings, and GUC values, so we don't need to deal with any of that
 * here.
 *
 * Our job is to deal with concerns specific to the executor.  The parallel
 * group leader will have stored a serialized PlannedStmt, and it's our job
 * to execute that plan and write the resulting tuples to the appropriate
 * tuple queue.  Various bits of supporting information that we need in order
 * to do this are also stored in the dsm_segment and can be accessed through
 * the shm_toc.
 */</comment>
<function><type><name>void</name></type>
<name>ParallelQueryMain</name><parameter_list>(<parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>, <parameter><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>BufferUsage</name> <modifier>*</modifier></type><name>buffer_usage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>receiver</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>queryDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SharedExecutorInstrumentation</name> <modifier>*</modifier></type><name>instrumentation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>instrument_options</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>area_space</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_area</name>   <modifier>*</modifier></type><name>area</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParallelWorkerContext</name></type> <name>pwcxt</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>                               <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nWorkers</name>                        <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelWorkerStatus</name> <modifier>*</modifier></type><name>worker_status</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>parallel_send</name>                 <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsm_handle</name> <modifier>*</modifier></type><name>handle</name>                  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name>parallel_send</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_WORKERS_SEND</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>parallelExecutionError</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_EXEC_ERROR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>parallel_send</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>handle</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_WORKERS_SEG_HANDLE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>receiver</name> <operator>=</operator> <call><name>GetParallelSendReceiver</name><argument_list>(<argument><expr><operator>*</operator><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Set up DestReceiver, SharedExecutorInstrumentation, and QueryDesc. */</comment>
    <expr_stmt><expr><name>receiver</name> <operator>=</operator> <call><name>ExecParallelGetReceiver</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><name>toc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>execute_done</name> <init>= <expr><call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_EXEC_DONE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>ParallelReceiverSetExecuteDone</name><argument_list>(<argument><expr><name>receiver</name></expr></argument>, <argument><expr><name>execute_done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>instrumentation</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_INSTRUMENTATION</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>instrumentation</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>instrument_options</name> <operator>=</operator> <name><name>instrumentation</name><operator>-&gt;</operator><name>instrument_options</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>queryDesc</name> <operator>=</operator> <call><name>ExecParallelGetQueryDesc</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>receiver</name></expr></argument>, <argument><expr><name>instrument_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Setting debug_query_string for individual workers */</comment>
    <expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>sourceText</name></name></expr>;</expr_stmt>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>is_mls_user</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <call><name>mls_query_string_prune</name><argument_list>(<argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Report workers' query for monitoring purposes */</comment>
    <expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
    <comment type="block">/* Prepare to track buffer usage during query execution. */</comment>
    <expr_stmt><expr><call><name>InstrStartParallelQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Attach to the dynamic shared memory area. */</comment>
    <expr_stmt><expr><name>area_space</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_DSA</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>area</name> <operator>=</operator> <call><name>dsa_attach_in_place</name><argument_list>(<argument><expr><name>area_space</name></expr></argument>, <argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* Attach to each worker's dynamic shared memory area */</comment>
    <expr_stmt><expr><name>worker_status</name> <operator>=</operator> <call><name>GetParallelWorkerStatusInfo</name><argument_list>(<argument><expr><name>toc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nWorkers</name>      <operator>=</operator> <name><name>worker_status</name><operator>-&gt;</operator><name>numExpectedWorkers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>currentParallelWorkerArea</name> <operator>=</operator> <operator>(</operator><name>dsa_area</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_area</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nWorkers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nWorkers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>area_space</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><operator>(</operator><name>PARALLEL_KEY_FIRST_WORKER_DSA</name> <operator>+</operator> <name>i</name><operator>)</operator></expr></argument>,
                                    <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>currentParallelWorkerArea</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>dsa_attach_in_place</name><argument_list>(<argument><expr><name>area_space</name></expr></argument>, <argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>nParamExec</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>paramValue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        
        <decl_stmt><decl><type><name>int</name></type> <name>nParamExec</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>nParamExec</name></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>es_param_exec_vals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        
        <expr_stmt><expr><name>es_param_exec_vals</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_EXEC_PARAM_LIST</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>es_param_exec_vals</name></name> <operator>=</operator> <operator>(</operator><name>ParamExecData</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name>nParamExec</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParamExecData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>es_param_exec_vals</name></name></expr></argument>, <argument><expr><name>es_param_exec_vals</name></expr></argument>, <argument><expr><name>nParamExec</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParamExecData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nParamExec</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ptype</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>typinput</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>typioparam</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>pstring</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>         <name>ptype</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ptype</name></expr></init></decl>;</decl_stmt>
                
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>paramValue</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>paramValue</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_EXEC_PARAM_VALUE</name></expr></argument>,
                                                <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>paramValue</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>   <comment type="block">/* data len + '\0' */</comment>

                <expr_stmt><expr><name>pstring</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pstring</name></expr></argument>, <argument><expr><name>paramValue</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>pstring</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typinput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>OidInputFunctionCall</name><argument_list>(<argument><expr><name>typinput</name></expr></argument>, <argument><expr><name>pstring</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>execPlan</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>pwcxt</name><operator>.</operator><name>toc</name></name> <operator>=</operator> <name>toc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pwcxt</name><operator>.</operator><name>seg</name></name> <operator>=</operator> <name>seg</name></expr>;</expr_stmt>
    <comment type="block">/* Start up the executor */</comment>
    <expr_stmt><expr><call><name>ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Special executor initialization steps for parallel workers */</comment>
    <expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_query_dsa</name></name> <operator>=</operator> <name>area</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecParallelInitializeWorker</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Run the plan */</comment>
    <expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Shut down the executor */</comment>
    <expr_stmt><expr><call><name>ExecutorFinish</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Report buffer usage during parallel execution. */</comment>
    <expr_stmt><expr><name>buffer_usage</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_BUFFER_USAGE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>InstrEndParallelQuery</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buffer_usage</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Report instrumentation data if any instrumentation options are set. */</comment>
    <if_stmt><if>if <condition>(<expr><name>instrumentation</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecParallelReportInstrumentation</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>,
                                          <argument><expr><name>instrumentation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Must do this after capturing instrumentation. */</comment>
    <expr_stmt><expr><call><name>ExecutorEnd</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Cleanup. */</comment>
    <expr_stmt><expr><call><name>dsa_detach</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nWorkers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>dsa_detach</name><argument_list>(<argument><expr><name><name>currentParallelWorkerArea</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>currentParallelWorkerArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>FreeQueryDesc</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call>(<modifier>*</modifier><name><name>receiver</name><operator>-&gt;</operator><name>rDestroy</name></name>) <argument_list>(<argument><expr><name>receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>ParallelWorkerStatus</name> <modifier>*</modifier></type><name>GetParallelWorkerStatusInfo</name><parameter_list>(<parameter><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParallelWorkerStatus</name> <modifier>*</modifier></type><name>worker_status</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>worker_status</name> <operator>=</operator> <operator>(</operator><name>ParallelWorkerStatus</name><operator>*</operator><operator>)</operator><call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_WORKERS_TOTAL_NUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>worker_status</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32</name></type> <name>ExecGetForWorkerNumber</name><parameter_list>(<parameter><decl><type><name>ParallelWorkerStatus</name> <modifier>*</modifier></type><name>worker_status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>worker_status</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Get worker number, loop until we get the number. */</comment>
        <do>do
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>worker_status</name><operator>-&gt;</operator><name>parallelWorkersSetupDone</name></name></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name><name>worker_status</name><operator>-&gt;</operator><name>numLaunchedWorkers</name></name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>while<condition>(<expr><operator>!</operator><name><name>worker_status</name><operator>-&gt;</operator><name>parallelWorkersSetupDone</name></name></expr>)</condition>;</do>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* allocate share memory for parallel worker from dsa */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>ParallelWorkerShmAlloc</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>zero</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>dp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>shm_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>currentParallelWorkerArea</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"parallel worker dsa does not initialize."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>zero</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>dsa_allocate0</name><argument_list>(<argument><expr><name><name>currentParallelWorkerArea</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>dsa_allocate</name><argument_list>(<argument><expr><name><name>currentParallelWorkerArea</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>shm_ptr</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>currentParallelWorkerArea</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>shm_ptr</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>dsa_area</name> <modifier>*</modifier></type>
<name>GetNumWorkerDsa</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>workerNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>currentParallelWorkerArea</name><index>[<expr><name>workerNumber</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ParallelError</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>    
    <if_stmt><if>if <condition>(<expr><name>parallelExecutionError</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><operator>(</operator><operator>*</operator><name>parallelExecutionError</name><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> 
<name>HandleParallelExecutionError</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>parallelExecutionError</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>parallelExecutionError</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>SetParallelSendError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>parallelExecutionError</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
