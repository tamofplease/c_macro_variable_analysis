<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/executor/execUtils.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<comment type="block">/*-------------------------------------------------------------------------
 *
 * execUtils.c
 *      miscellaneous executor utility routines
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/executor/execUtils.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 * INTERFACE ROUTINES
 *        CreateExecutorState        Create/delete executor working state
 *        FreeExecutorState
 *        CreateExprContext
 *        CreateStandaloneExprContext
 *        FreeExprContext
 *        ReScanExprContext
 *
 *        ExecAssignExprContext    Common code for plan node init routines.
 *        ExecAssignResultType
 *        etc
 *
 *        ExecOpenScanRelation    Common code for scan node init routines.
 *        ExecCloseScanRelation
 *
 *        executor_errposition    Report syntactic position of an error.
 *
 *        RegisterExprContextCallback    Register function shutdown callback
 *        UnregisterExprContextCallback  Deregister function shutdown callback
 *
 *        GetAttributeByName        Runtime extraction of columns from tuples.
 *        GetAttributeByNum
 *
 *     NOTES
 *        This file has traditionally been the place to stick misc.
 *        executor support stuff that doesn't really go anyplace else.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ShutdownExprContext</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------------------------------------------------------------
 *                 Executor state and memory management functions
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------
 *        CreateExecutorState
 *
 *        Create and initialize an EState node, which is the root of
 *        working storage for an entire Executor invocation.
 *
 * Principally, this creates the per-query memory context that will be
 * used to hold all working data that lives till the end of the query.
 * Note that the per-query context will become a child of the caller's
 * CurrentMemoryContext.
 * ----------------
 */</comment>
<function><type><name>EState</name> <modifier>*</modifier></type>
<name>CreateExecutorState</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EState</name>       <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>qcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Create the per-query context for this Executor run.
     */</comment>
    <expr_stmt><expr><name>qcontext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                     <argument><expr><literal type="string">"ExecutorState"</literal></expr></argument>,
                                     <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Make the EState node within the per-query context.  This way, we don't
     * need a separate pfree() operation for it at shutdown.
     */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>qcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>EState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize all fields of the Executor State structure
     */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name> <operator>=</operator> <name>ForwardScanDirection</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name> <operator>=</operator> <name>InvalidSnapshot</name></expr>;</expr_stmt>    <comment type="block">/* caller must initialize this */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_crosscheck_snapshot</name></name> <operator>=</operator> <name>InvalidSnapshot</name></expr>;</expr_stmt>    <comment type="block">/* no crosscheck */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_junkFilter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name> <operator>=</operator> <operator>(</operator><name>CommandId</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_trig_target_relations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_trig_tuple_slot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_trig_oldtup_slot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_trig_newtup_slot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_queryEnv</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name> <operator>=</operator> <name>qcontext</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_rowMarks</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_lastoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_finished</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_exprcontexts</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_subplanstates</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_auxmodifytables</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_per_tuple_exprcontext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTupleSet</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqScanDone</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sourceText</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_remote_subplan_num</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Return the executor state structure
     */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>estate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        FreeExecutorState
 *
 *        Release an EState along with all remaining working storage.
 *
 * Note: this is not responsible for releasing non-memory resources,
 * such as open relations or buffer pins.  But it will shut down any
 * still-active ExprContexts within the EState.  That is sufficient
 * cleanup for situations where the EState has only been used for expression
 * evaluation, and not to run a complete Plan.
 *
 * This can be called in any memory context ... so long as it's not one
 * of the ones to be freed.
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>FreeExecutorState</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * Shut down and free any remaining ExprContexts.  We do this explicitly
     * to ensure that any remaining shutdown callbacks get called (since they
     * might need to release resources that aren't simply memory within the
     * per-query memory context).
     */</comment>
    <while>while <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_exprcontexts</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * XXX: seems there ought to be a faster way to implement this than
         * repeated list_delete(), no?
         */</comment>
        <expr_stmt><expr><call><name>FreeExprContext</name><argument_list>(<argument><expr><operator>(</operator><name>ExprContext</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_exprcontexts</name></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* FreeExprContext removed the list link for us */</comment>
    </block_content>}</block></while>

    <comment type="block">/*
     * Free the per-query memory context, thereby releasing all working
     * memory, including the EState node itself.
     */</comment>
    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        CreateExprContext
 *
 *        Create a context for expression evaluation within an EState.
 *
 * An executor run may require multiple ExprContexts (we usually make one
 * for each Plan node, and a separate one for per-output-tuple processing
 * such as constraint checking).  Each ExprContext has its own "per-tuple"
 * memory context.
 *
 * Note we make no assumption about the caller's memory context.
 * ----------------
 */</comment>
<function><type><name>ExprContext</name> <modifier>*</modifier></type>
<name>CreateExprContext</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <comment type="block">/* Create the ExprContext node within the per-query memory context */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExprContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Initialize fields of ExprContext */</comment>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Create working memory for expression evaluation in this context.
     */</comment>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name> <operator>=</operator>
        <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>,
                              <argument><expr><literal type="string">"ExprContext"</literal></expr></argument>,
                              <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_exec_vals</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_list_info</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggvalues</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggnulls</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>caseValue_datum</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>caseValue_isNull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>domainValue_datum</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>domainValue_isNull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_estate</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_callbacks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Link the ExprContext into the EState to ensure it is shut down when the
     * EState is freed.  Because we use lcons(), shutdowns will occur in
     * reverse order of creation, which may not be essential but can't hurt.
     */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_exprcontexts</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_exprcontexts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>econtext</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        CreateStandaloneExprContext
 *
 *        Create a context for standalone expression evaluation.
 *
 * An ExprContext made this way can be used for evaluation of expressions
 * that contain no Params, subplans, or Var references (it might work to
 * put tuple references into the scantuple field, but it seems unwise).
 *
 * The ExprContext struct is allocated in the caller's current memory
 * context, which also becomes its "per query" context.
 *
 * It is caller's responsibility to free the ExprContext when done,
 * or at least ensure that any shutdown callbacks have been called
 * (ReScanExprContext() is suitable).  Otherwise, non-memory resources
 * might be leaked.
 * ----------------
 */</comment>
<function><type><name>ExprContext</name> <modifier>*</modifier></type>
<name>CreateStandaloneExprContext</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>

    <comment type="block">/* Create the ExprContext node within the caller's memory context */</comment>
    <expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExprContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Initialize fields of ExprContext */</comment>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Create working memory for expression evaluation in this context.
     */</comment>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name> <operator>=</operator>
        <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                              <argument><expr><literal type="string">"ExprContext"</literal></expr></argument>,
                              <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_exec_vals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_list_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggvalues</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggnulls</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>caseValue_datum</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>caseValue_isNull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>domainValue_datum</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>domainValue_isNull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_estate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_callbacks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <return>return <expr><name>econtext</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        FreeExprContext
 *
 *        Free an expression context, including calling any remaining
 *        shutdown callbacks.
 *
 * Since we free the temporary context used for expression evaluation,
 * any previously computed pass-by-reference expression result will go away!
 *
 * If isCommit is false, we are being called in error cleanup, and should
 * not call callbacks but only release memory.  (It might be better to call
 * the callbacks and pass the isCommit flag to them, but that would require
 * more invasive code changes than currently seems justified.)
 *
 * Note we make no assumption about the caller's memory context.
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>FreeExprContext</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EState</name>       <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>

    <comment type="block">/* Call any registered callbacks */</comment>
    <expr_stmt><expr><call><name>ShutdownExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>isCommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* And clean up the memory used */</comment>
    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Unlink self from owning EState, if any */</comment>
    <expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_estate</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>estate</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_exprcontexts</name></name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_exprcontexts</name></name></expr></argument>,
                                                  <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* And delete the ExprContext node */</comment>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ReScanExprContext
 *
 *        Reset an expression context in preparation for a rescan of its
 *        plan node.  This requires calling any registered shutdown callbacks,
 *        since any partially complete set-returning-functions must be canceled.
 *
 * Note we make no assumption about the caller's memory context.
 */</comment>
<function><type><name>void</name></type>
<name>ReScanExprContext</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Call any registered callbacks */</comment>
    <expr_stmt><expr><call><name>ShutdownExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* And clean up the memory used */</comment>
    <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Build a per-output-tuple ExprContext for an EState.
 *
 * This is normally invoked via GetPerTupleExprContext() macro,
 * not directly.
 */</comment>
<function><type><name>ExprContext</name> <modifier>*</modifier></type>
<name>MakePerTupleExprContext</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_per_tuple_exprcontext</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_per_tuple_exprcontext</name></name> <operator>=</operator> <call><name>CreateExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name><name>estate</name><operator>-&gt;</operator><name>es_per_tuple_exprcontext</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *                 miscellaneous node-init support functions
 *
 * Note: all of these are expected to be called with CurrentMemoryContext
 * equal to the per-query memory context.
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------
 *        ExecAssignExprContext
 *
 *        This initializes the ps_ExprContext field.  It is only necessary
 *        to do this for nodes which use ExecQual or ExecProject
 *        because those routines require an econtext. Other nodes that
 *        don't have to evaluate expressions don't need to do this.
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecAssignExprContext</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ExprContext</name></name> <operator>=</operator> <call><name>CreateExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        ExecAssignResultType
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecAssignResultType</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ResultTupleSlot</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        ExecAssignResultTypeFromTL
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecAssignResultTypeFromTL</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>hasoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>		<modifier>*</modifier></type><name>targetList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>ExecContextForcesOids</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hasoid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* context forces OID choice; hasoid is now set correctly */</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* given free choice, don't leave space for OIDs in result tuples */</comment>
        <expr_stmt><expr><name>hasoid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
	 * If the command with returning syntax, the tupDesc's info should
	 * be maked up of returningList
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>RemoteQueryState</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>RemoteQueryState</name> <operator>*</operator><operator>)</operator><name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>eflags</name><operator>)</operator> <operator>&amp;</operator> <name>EXEC_FLAG_RETURNING</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;&amp;</operator> <name><name>planstate</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_plannedstmt</name></name> <operator>&amp;&amp;</operator>
			<name><name>planstate</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>parseTree</name></name> <operator>&amp;&amp;</operator>
			<name><name>planstate</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>parseTree</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>targetList</name> <operator>=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>parseTree</name><operator>-&gt;</operator><name>returningList</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>targetList</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>targetList</name> <operator>=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
     * ExecTypeFromTL needs the parse-time representation of the tlist, not a
     * list of ExprStates.  This is good because some plan nodes don't bother
     * to set up planstate-&gt;targetlist ...
     */</comment>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>ExecTypeFromTL</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>hasoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecAssignResultType</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        ExecGetResultType
 * ----------------
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>ExecGetResultType</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ResultTupleSlot</name></name></expr></init></decl>;</decl_stmt>

    <return>return <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------------
 *        ExecAssignProjectionInfo
 *
 * forms the projection information from the node's targetlist
 *
 * Notes for inputDesc are same as for ExecBuildProjectionInfo: supply it
 * for a relation-scan node, can pass NULL for upper-level nodes
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecAssignProjectionInfo</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
                         <parameter><decl><type><name>TupleDesc</name></type> <name>inputDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ProjInfo</name></name> <operator>=</operator>
        <call><name>ExecBuildProjectionInfo</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
                                <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ExprContext</name></name></expr></argument>,
                                <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ResultTupleSlot</name></name></expr></argument>,
                                <argument><expr><name>planstate</name></expr></argument>,
                                <argument><expr><name>inputDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------
 *        ExecFreeExprContext
 *
 * A plan node's ExprContext should be freed explicitly during executor
 * shutdown because there may be shutdown callbacks to call.  (Other resources
 * made by the above routines, such as projection info, don't need to be freed
 * explicitly because they're just memory in the per-query memory context.)
 *
 * However ... there is no particular need to do it during ExecEndNode,
 * because FreeExecutorState will free any remaining ExprContexts within
 * the EState.  Letting FreeExecutorState do it allows the ExprContexts to
 * be freed in reverse order of creation, rather than order of creation as
 * will happen if we delete them here, which saves O(N^2) work in the list
 * cleanup inside FreeExprContext.
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecFreeExprContext</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * Per above discussion, don't actually delete the ExprContext. We do
     * unlink it from the plan node, though.
     */</comment>
    <expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ExprContext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        the following scan type support functions are for
 *        those nodes which are stubborn and return tuples in
 *        their Scan tuple slot instead of their Result tuple
 *        slot..  luck fur us, these nodes do not do projections
 *        so we don't have to worry about getting the ProjectionInfo
 *        right for them...  -cim 6/3/91
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------
 *        ExecAssignScanType
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecAssignScanType</name><parameter_list>(<parameter><decl><type><name>ScanState</name> <modifier>*</modifier></type><name>scanstate</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss_ScanTupleSlot</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        ExecAssignScanTypeFromOuterPlan
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecAssignScanTypeFromOuterPlan</name><parameter_list>(<parameter><decl><type><name>ScanState</name> <modifier>*</modifier></type><name>scanstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupDesc</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>outerPlan</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>scanstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>ExecGetResultType</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ExecAssignScanType</name><argument_list>(<argument><expr><name>scanstate</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *                  Scan node support
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecRelationIsTargetRelation
 *
 *        Detect whether a relation (identified by rangetable index)
 *        is one of the target relations of the query.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>bool</name></type>
<name>ExecRelationIsTargetRelation</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>resultRelInfos</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>resultRelInfos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ri_RangeTableIndex</name> <operator>==</operator> <name>scanrelid</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecOpenScanRelation
 *
 *        Open the heap relation to be scanned by a base-level scan plan node.
 *        This should be called during the node's ExecInit routine.
 *
 * By default, this acquires AccessShareLock on the relation.  However,
 * if the relation was already locked by InitPlan, we don't need to acquire
 * any additional lock.  This saves trips to the shared lock manager.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>Relation</name></type>
<name>ExecOpenScanRelation</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>reloid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKMODE</name></type>    <name>lockmode</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Determine the lock type we need.  First, scan to see if target relation
     * is a result relation.  If not, check if it's a FOR UPDATE/FOR SHARE
     * relation.  In either of those cases, we got the lock already.
     */</comment>
    <expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>AccessShareLock</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ExecRelationIsTargetRelation</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>scanrelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>NoLock</name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Keep this check in sync with InitPlan! */</comment>
        <decl_stmt><decl><type><name>ExecRowMark</name> <modifier>*</modifier></type><name>erm</name> <init>= <expr><call><name>ExecFindRowMark</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>scanrelid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>erm</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>erm</name><operator>-&gt;</operator><name>relation</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>NoLock</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Open the relation and acquire lock as needed */</comment>
    <expr_stmt><expr><name>reloid</name> <operator>=</operator> <call><name>getrelid</name><argument_list>(<argument><expr><name>scanrelid</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Complain if we're attempting a scan of an unscannable relation, except
     * when the query won't actually be run.  This is a slightly klugy place
     * to do this, perhaps, but there is no better place.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_EXPLAIN_ONLY</name> <operator>|</operator> <name>EXEC_FLAG_WITH_NO_DATA</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>RelationIsScannable</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialized view \"%s\" has not been populated"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the REFRESH MATERIALIZED VIEW command."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>Relation</name></type>
<name>ExecOpenScanRelationPartition</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>partidx</name></decl></parameter>)</parameter_list>
<block>{<block_content>    
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>reloid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>     <name>partrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>partoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKMODE</name></type>    <name>lockmode</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Determine the lock type we need.  First, scan to see if target relation
     * is a result relation.  If not, check if it's a FOR UPDATE/FOR SHARE
     * relation.  In either of those cases, we got the lock already.
     */</comment>
    <expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>AccessShareLock</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ExecRelationIsTargetRelation</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>scanrelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>NoLock</name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>estate-&gt;es_rowMarks</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ExecRowMark</name> <modifier>*</modifier></type><name>erm</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name> <operator>==</operator> <name>scanrelid</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>NoLock</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Open the relation and acquire lock as needed */</comment>
    <expr_stmt><expr><name>reloid</name> <operator>=</operator> <call><name>getrelid</name><argument_list>(<argument><expr><name>scanrelid</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>partoid</name> <operator>=</operator> <call><name>RelationGetPartition</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>partidx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>partoid</name></expr>)</condition>
	<block>{<block_content>
	    <expr_stmt><expr><name>partrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>partoid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>partrel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * Complain if we're attempting a scan of an unscannable relation, except
     * when the query won't actually be run.  This is a slightly klugy place
     * to do this, perhaps, but there is no better place.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_EXPLAIN_ONLY</name> <operator>|</operator> <name>EXEC_FLAG_WITH_NO_DATA</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>RelationIsScannable</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialized view \"%s\" has not been populated"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the REFRESH MATERIALIZED VIEW command."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>partrel</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecCloseScanRelation
 *
 *        Close the heap relation scanned by a base-level scan plan node.
 *        This should be called during the node's ExecEnd routine.
 *
 * Currently, we do not release the lock acquired by ExecOpenScanRelation.
 * This lock should be held till end of transaction.  (There is a faction
 * that considers this too much locking, however.)
 *
 * If we did want to release the lock, we'd have to repeat the logic in
 * ExecOpenScanRelation in order to figure out what to release.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecCloseScanRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>scanrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>scanrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * UpdateChangedParamSet
 *        Add changed parameters to a plan node's chgParam set
 */</comment>
<function><type><name>void</name></type>
<name>UpdateChangedParamSet</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>newchg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>parmset</name></decl>;</decl_stmt>

    <comment type="block">/*
     * The plan node only depends on params listed in its allParam set. Don't
     * include anything else into its chgParam set.
     */</comment>
    <expr_stmt><expr><name>parmset</name> <operator>=</operator> <call><name>bms_intersect</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>allParam</name></name></expr></argument>, <argument><expr><name>newchg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Keep node-&gt;chgParam == NULL if there's not actually any members; this
     * allows the simplest possible tests in executor node files.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>parmset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>=</operator> <call><name>bms_join</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>, <argument><expr><name>parmset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>parmset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * executor_errposition
 *        Report an execution-time cursor position, if possible.
 *
 * This is expected to be used within an ereport() call.  The return value
 * is a dummy (always 0, in fact).
 *
 * The locations stored in parsetrees are byte offsets into the source string.
 * We have to convert them to 1-based character indexes for reporting to
 * clients.  (We do things this way to avoid unnecessary overhead in the
 * normal non-error case: computing character indexes would be much more
 * expensive than storing token offsets.)
 */</comment>
<function><type><name>int</name></type>
<name>executor_errposition</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>pos</name></decl>;</decl_stmt>

    <comment type="block">/* No-op if location was not provided */</comment>
    <if_stmt><if>if <condition>(<expr><name>location</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Can't do anything if source text is not available */</comment>
    <if_stmt><if>if <condition>(<expr><name>estate</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_sourceText</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Convert offset to character number */</comment>
    <expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>pg_mbstrlen_with_len</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sourceText</name></name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <comment type="block">/* And pass it to the ereport mechanism */</comment>
    <return>return <expr><call><name>errposition</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Register a shutdown callback in an ExprContext.
 *
 * Shutdown callbacks will be called (in reverse order of registration)
 * when the ExprContext is deleted or rescanned.  This provides a hook
 * for functions called in the context to do any cleanup needed --- it's
 * particularly useful for functions returning sets.  Note that the
 * callback will *not* be called in the event that execution is aborted
 * by an error.
 */</comment>
<function><type><name>void</name></type>
<name>RegisterExprContextCallback</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
                            <parameter><decl><type><name>ExprContextCallbackFunction</name></type> <name>function</name></decl></parameter>,
                            <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExprContext_CB</name> <modifier>*</modifier></type><name>ecxt_callback</name></decl>;</decl_stmt>

    <comment type="block">/* Save the info in appropriate memory context */</comment>
    <expr_stmt><expr><name>ecxt_callback</name> <operator>=</operator> <operator>(</operator><name>ExprContext_CB</name> <operator>*</operator><operator>)</operator>
        <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>,
                           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExprContext_CB</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ecxt_callback</name><operator>-&gt;</operator><name>function</name></name> <operator>=</operator> <name>function</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ecxt_callback</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

    <comment type="block">/* link to front of list for appropriate execution order */</comment>
    <expr_stmt><expr><name><name>ecxt_callback</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_callbacks</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_callbacks</name></name> <operator>=</operator> <name>ecxt_callback</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deregister a shutdown callback in an ExprContext.
 *
 * Any list entries matching the function and arg will be removed.
 * This can be used if it's no longer necessary to call the callback.
 */</comment>
<function><type><name>void</name></type>
<name>UnregisterExprContextCallback</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
                              <parameter><decl><type><name>ExprContextCallbackFunction</name></type> <name>function</name></decl></parameter>,
                              <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExprContext_CB</name> <modifier>*</modifier><modifier>*</modifier></type><name>prev_callback</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprContext_CB</name> <modifier>*</modifier></type><name>ecxt_callback</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>prev_callback</name> <operator>=</operator> <operator>&amp;</operator><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_callbacks</name></name></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>ecxt_callback</name> <operator>=</operator> <operator>*</operator><name>prev_callback</name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>ecxt_callback</name><operator>-&gt;</operator><name>function</name></name> <operator>==</operator> <name>function</name> <operator>&amp;&amp;</operator> <name><name>ecxt_callback</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>arg</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>prev_callback</name> <operator>=</operator> <name><name>ecxt_callback</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ecxt_callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>prev_callback</name> <operator>=</operator> <operator>&amp;</operator><name><name>ecxt_callback</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Call all the shutdown callbacks registered in an ExprContext.
 *
 * The callback list is emptied (important in case this is only a rescan
 * reset, and not deletion of the ExprContext).
 *
 * If isCommit is false, just clean the callback list but don't call 'em.
 * (See comment for FreeExprContext.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ShutdownExprContext</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExprContext_CB</name> <modifier>*</modifier></type><name>ecxt_callback</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <comment type="block">/* Fast path in normal case where there's nothing to do. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_callbacks</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Call the callbacks in econtext's per-tuple context.  This ensures that
     * any memory they might leak will get cleaned up.
     */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Call each callback function in reverse registration order.
     */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>ecxt_callback</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_callbacks</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_callbacks</name></name> <operator>=</operator> <name><name>ecxt_callback</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call>(<modifier>*</modifier><name><name>ecxt_callback</name><operator>-&gt;</operator><name>function</name></name>) <argument_list>(<argument><expr><name><name>ecxt_callback</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ecxt_callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecLockNonLeafAppendTables
 *
 * Locks, if necessary, the tables indicated by the RT indexes contained in
 * the partitioned_rels list.  These are the non-leaf tables in the partition
 * tree controlled by a given Append or MergeAppend node.
 */</comment>
<function><type><name>void</name></type>
<name>ExecLockNonLeafAppendTables</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitioned_rels</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>partitioned_rels</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Index</name></type>        <name>rti</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>is_result_rel</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name> <init>= <expr><call><name>getrelid</name><argument_list>(<argument><expr><name>rti</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* If this is a result relation, already locked in InitPlan */</comment>
        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>stmt-&gt;nonleafResultRelations</argument>)</argument_list></macro>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>rti</name> <operator>==</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>is_result_rel</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <comment type="block">/*
         * Not a result relation; check if there is a RowMark that requires
         * taking a RowShareLock on this rel.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_result_rel</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>stmt-&gt;rowMarks</argument>)</argument_list></macro>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>PlanRowMark</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>rti</name> <operator>==</operator> <name>rti</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>

            <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;&amp;</operator> <call><name>RowMarkRequiresRowShareLock</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>markType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 *        GetAttributeByName
 *        GetAttributeByNum
 *
 *        These functions return the value of the requested attribute
 *        out of the given tuple Datum.
 *        C functions which take a tuple as an argument are expected
 *        to use these.  Ex: overpaid(EMP) might call GetAttributeByNum().
 *        Note: these are actually rather slow because they do a typcache
 *        lookup on each call.
 */</comment>
<function><type><name>Datum</name></type>
<name>GetAttributeByName</name><parameter_list>(<parameter><decl><type><name>HeapTupleHeader</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attrno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>tupType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>tupTypmod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>attname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid attribute name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>isNull</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"a NULL isNull pointer was passed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Kinda bogus but compatible with old behavior... */</comment>
        <expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>tupType</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tupTypmod</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>tupType</name></expr></argument>, <argument><expr><name>tupTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>attrno</name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attname</name><operator>)</operator></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>attrno</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attnum</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>attrno</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * heap_getattr needs a HeapTuple not a bare HeapTupleHeader.  We set all
     * the fields in the struct just in case user tries to inspect system
     * columns.
     */</comment>
    <expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tmptup</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_xc_node_id</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>,
                          <argument><expr><name>attrno</name></expr></argument>,
                          <argument><expr><name>tupDesc</name></expr></argument>,
                          <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>GetAttributeByNum</name><parameter_list>(<parameter><decl><type><name>HeapTupleHeader</name></type> <name>tuple</name></decl></parameter>,
                  <parameter><decl><type><name>AttrNumber</name></type> <name>attrno</name></decl></parameter>,
                  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>tupType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>tupTypmod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name>attrno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid attribute number %d"</literal></expr></argument>, <argument><expr><name>attrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>isNull</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"a NULL isNull pointer was passed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Kinda bogus but compatible with old behavior... */</comment>
        <expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>tupType</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tupTypmod</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>tupType</name></expr></argument>, <argument><expr><name>tupTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * heap_getattr needs a HeapTuple not a bare HeapTupleHeader.  We set all
     * the fields in the struct just in case user tries to inspect system
     * columns.
     */</comment>
    <expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tmptup</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_xc_node_id</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>,
                          <argument><expr><name>attrno</name></expr></argument>,
                          <argument><expr><name>tupDesc</name></expr></argument>,
                          <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Number of items in a tlist (including any resjunk items!)
 */</comment>
<function><type><name>int</name></type>
<name>ExecTargetListLength</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* This used to be more complex, but fjoins are dead */</comment>
    <return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Number of items in a tlist, not including any resjunk items
 */</comment>
<function><type><name>int</name></type>
<name>ExecCleanTargetListLength</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tl</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>tl</argument>, <argument>targetlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>curTle</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>curTle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>
</unit>
