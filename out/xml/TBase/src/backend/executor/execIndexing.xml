<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/executor/execIndexing.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<comment type="block">/*-------------------------------------------------------------------------
 *
 * execIndexing.c
 *      routines for inserting index tuples and enforcing unique and
 *      exclusion constraints.
 *
 * ExecInsertIndexTuples() is the main entry point.  It's called after
 * inserting a tuple to the heap, and it inserts corresponding index tuples
 * into all indexes.  At the same time, it enforces any unique and
 * exclusion constraints:
 *
 * Unique Indexes
 * --------------
 *
 * Enforcing a unique constraint is straightforward.  When the index AM
 * inserts the tuple to the index, it also checks that there are no
 * conflicting tuples in the index already.  It does so atomically, so that
 * even if two backends try to insert the same key concurrently, only one
 * of them will succeed.  All the logic to ensure atomicity, and to wait
 * for in-progress transactions to finish, is handled by the index AM.
 *
 * If a unique constraint is deferred, we request the index AM to not
 * throw an error if a conflict is found.  Instead, we make note that there
 * was a conflict and return the list of indexes with conflicts to the
 * caller.  The caller must re-check them later, by calling index_insert()
 * with the UNIQUE_CHECK_EXISTING option.
 *
 * Exclusion Constraints
 * ---------------------
 *
 * Exclusion constraints are different from unique indexes in that when the
 * tuple is inserted to the index, the index AM does not check for
 * duplicate keys at the same time.  After the insertion, we perform a
 * separate scan on the index to check for conflicting tuples, and if one
 * is found, we throw an error and the transaction is aborted.  If the
 * conflicting tuple's inserter or deleter is in-progress, we wait for it
 * to finish first.
 *
 * There is a chance of deadlock, if two backends insert a tuple at the
 * same time, and then perform the scan to check for conflicts.  They will
 * find each other's tuple, and both try to wait for each other.  The
 * deadlock detector will detect that, and abort one of the transactions.
 * That's fairly harmless, as one of them was bound to abort with a
 * "duplicate key error" anyway, although you get a different error
 * message.
 *
 * If an exclusion constraint is deferred, we still perform the conflict
 * checking scan immediately after inserting the index tuple.  But instead
 * of throwing an error if a conflict is found, we return that information
 * to the caller.  The caller must re-check them later by calling
 * check_exclusion_constraint().
 *
 * Speculative insertion
 * ---------------------
 *
 * Speculative insertion is a two-phase mechanism used to implement
 * INSERT ... ON CONFLICT DO UPDATE/NOTHING.  The tuple is first inserted
 * to the heap and update the indexes as usual, but if a constraint is
 * violated, we can still back out the insertion without aborting the whole
 * transaction.  In an INSERT ... ON CONFLICT statement, if a conflict is
 * detected, the inserted tuple is backed out and the ON CONFLICT action is
 * executed instead.
 *
 * Insertion to a unique index works as usual: the index AM checks for
 * duplicate keys atomically with the insertion.  But instead of throwing
 * an error on a conflict, the speculatively inserted heap tuple is backed
 * out.
 *
 * Exclusion constraints are slightly more complicated.  As mentioned
 * earlier, there is a risk of deadlock when two backends insert the same
 * key concurrently.  That was not a problem for regular insertions, when
 * one of the transactions has to be aborted anyway, but with a speculative
 * insertion we cannot let a deadlock happen, because we only want to back
 * out the speculatively inserted tuple on conflict, not abort the whole
 * transaction.
 *
 * When a backend detects that the speculative insertion conflicts with
 * another in-progress tuple, it has two options:
 *
 * 1. back out the speculatively inserted tuple, then wait for the other
 *      transaction, and retry. Or,
 * 2. wait for the other transaction, with the speculatively inserted tuple
 *      still in place.
 *
 * If two backends insert at the same time, and both try to wait for each
 * other, they will deadlock.  So option 2 is not acceptable.  Option 1
 * avoids the deadlock, but it is prone to a livelock instead.  Both
 * transactions will wake up immediately as the other transaction backs
 * out.  Then they both retry, and conflict with each other again, lather,
 * rinse, repeat.
 *
 * To avoid the livelock, one of the backends must back out first, and then
 * wait, while the other one waits without backing out.  It doesn't matter
 * which one backs out, so we employ an arbitrary rule that the transaction
 * with the higher XID backs out.
 *
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/executor/execIndexing.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>

<comment type="block">/* waitMode argument to check_exclusion_or_unique_constraint() */</comment>
<typedef>typedef <type><enum>enum
<block>{
    <decl><name>CEOUC_WAIT</name></decl>,
    <decl><name>CEOUC_NOWAIT</name></decl>,
    <decl><name>CEOUC_LIVELOCK_PREVENTING_WAIT</name></decl>
}</block></enum></type> <name>CEOUC_WAIT_MODE</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_exclusion_or_unique_constraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>,
                                     <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
                                     <parameter><decl><type><name>ItemPointer</name></type> <name>tupleid</name></decl></parameter>,
                                     <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
                                     <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>newIndex</name></decl></parameter>,
                                     <parameter><decl><type><name>CEOUC_WAIT_MODE</name></type> <name>waitMode</name></decl></parameter>,
                                     <parameter><decl><type><name>bool</name></type> <name>errorOK</name></decl></parameter>,
                                     <parameter><decl><type><name>ItemPointer</name></type> <name>conflictTid</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>index_recheck_constraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>constr_procs</name></decl></parameter>,
                         <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>existing_values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>existing_isnull</name></decl></parameter>,
                         <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>new_values</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecOpenIndices
 *
 *        Find the indices associated with a result relation, open them,
 *        and save information about them in the result ResultRelInfo.
 *
 *        At entry, caller has already opened and locked
 *        resultRelInfo-&gt;ri_RelationDesc.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecOpenIndices</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>speculative</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>resultRelation</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>indexoidlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationPtr</name></type> <name>relationDescs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>indexInfoArray</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* fast path if no indexes */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>resultRelation</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relhasindex</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Get cached list of index OIDs
     */</comment>
    <expr_stmt><expr><name>indexoidlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>resultRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * allocate space for result arrays
     */</comment>
    <expr_stmt><expr><name>relationDescs</name> <operator>=</operator> <operator>(</operator><name>RelationPtr</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Relation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>indexInfoArray</name> <operator>=</operator> <operator>(</operator><name>IndexInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_IndexRelationDescs</name></name> <operator>=</operator> <name>relationDescs</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_IndexRelationInfo</name></name> <operator>=</operator> <name>indexInfoArray</name></expr>;</expr_stmt>

    <comment type="block">/*
     * For each index, open the index relation and save pg_index info. We
     * acquire RowExclusiveLock, signifying we will update the index.
     *
     * Note: we do this even if the index is not IndexIsReady; it's not worth
     * the trouble to optimize for the case where it isn't.
     */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>indexoidlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>indexOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>indexDesc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>ii</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>indexDesc</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* extract index key information from the index's pg_index info */</comment>
        <expr_stmt><expr><name>ii</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>indexDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If the indexes are to be used for speculative insertion, add extra
         * information required by unique index entries.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>speculative</name> <operator>&amp;&amp;</operator> <name><name>ii</name><operator>-&gt;</operator><name>ii_Unique</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>BuildSpeculativeIndexInfo</name><argument_list>(<argument><expr><name>indexDesc</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>relationDescs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>indexDesc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>indexInfoArray</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>ii</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* open index for interval partition child table */</comment>
    <if_stmt><if>if<condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ispartparent</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>arraymode</name></name> <operator>==</operator> <name>RESULT_RELINFO_MODE_COMPACT</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>partarraysize</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                 <expr_stmt><expr><call><name>ExecOpenIndices</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>part_relinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>speculative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if>
        <if type="elseif">else if<condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>arraymode</name></name> <operator>==</operator> <name>RESULT_RELINFO_MODE_EXPAND</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Bitmapset</name>    <modifier>*</modifier></type><name>temp_bms</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>partidx</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>temp_bms</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>partpruning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while<condition>(<expr><operator>(</operator><name>partidx</name> <operator>=</operator> <call><name>bms_first_member</name><argument_list>(<argument><expr><name>temp_bms</name></expr></argument>)</argument_list></call><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ExecOpenIndices</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>part_relinfo</name><index>[<expr><name>partidx</name></expr>]</index></name></expr></argument>, <argument><expr><name>speculative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>

            <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>temp_bms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecCloseIndices
 *
 *        Close the index relations stored in resultRelInfo
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecCloseIndices</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numIndices</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationPtr</name></type> <name>indexDescs</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>numIndices</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>indexDescs</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_IndexRelationDescs</name></name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numIndices</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>indexDescs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* shouldn't happen? */</comment>

        <comment type="block">/* Drop lock acquired by ExecOpenIndices */</comment>
        <expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name><name>indexDescs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * XXX should free indexInfo array here too?  Currently we assume that
     * such stuff will be cleaned up automatically in FreeExecutorState.
     */</comment>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecInsertIndexTuples
 *
 *        This routine takes care of inserting index tuples
 *        into all the relations indexing the result relation
 *        when a heap tuple is inserted into the result relation.
 *
 *        Unique and exclusion constraints are enforced at the same
 *        time.  This returns a list of index OIDs for any unique or
 *        exclusion constraints that are deferred and that had
 *        potential (unconfirmed) conflicts.  (if noDupErr == true,
 *        the same is done for non-deferred constraints, but report
 *        if conflict was speculative or deferred conflict to caller)
 *
 *        If 'arbiterIndexes' is nonempty, noDupErr applies only to
 *        those indexes.  NIL means noDupErr applies to all indexes.
 *
 *        CAUTION: this must not be called for a HOT update.
 *        We can't defend against that here for lack of info.
 *        Should we change the API to make it safer?
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ExecInsertIndexTuples</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
                      <parameter><decl><type><name>ItemPointer</name></type> <name>tupleid</name></decl></parameter>,
                      <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name></type> <name>noDupErr</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>specConflict</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>arbiterIndexes</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numIndices</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationPtr</name></type> <name>relationDescs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>heapRelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>indexInfoArray</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/*
     * Get information from the result relation info structure.
     */</comment>
    <expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>numIndices</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>relationDescs</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_IndexRelationDescs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>indexInfoArray</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_IndexRelationInfo</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>heapRelation</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * We will use the EState's per-tuple context for evaluating predicates
     * and index expressions (creating it if it's not already there).
     */</comment>
    <expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Arrange for econtext's scan tuple to be the tuple under test */</comment>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

    <comment type="block">/*
     * for each index, form and insert the index tuple
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numIndices</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>indexRelation</name> <init>= <expr><name><name>relationDescs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>applyNoDupErr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IndexUniqueCheck</name></type> <name>checkUnique</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>satisfiesConstraint</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>indexRelation</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>indexInfo</name> <operator>=</operator> <name><name>indexInfoArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

        <comment type="block">/* If the index is marked as read-only, ignore it */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ReadyForInserts</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Check for partial index */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>predicate</name></decl>;</decl_stmt>

            <comment type="block">/*
             * If predicate state not set up yet, create it (in the estate's
             * per-query context)
             */</comment>
            <expr_stmt><expr><name>predicate</name> <operator>=</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_PredicateState</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>predicate</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>predicate</name> <operator>=</operator> <call><name>ExecPrepareQual</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_PredicateState</name></name> <operator>=</operator> <name>predicate</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Skip this index-update if the predicate isn't satisfied */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * FormIndexDatum fills in its values and isnull parameters with the
         * appropriate values for the column(s) of the index.
         */</comment>
        <expr_stmt><expr><call><name>FormIndexDatum</name><argument_list>(<argument><expr><name>indexInfo</name></expr></argument>,
                       <argument><expr><name>slot</name></expr></argument>,
                       <argument><expr><name>estate</name></expr></argument>,
                       <argument><expr><name>values</name></expr></argument>,
                       <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Check whether to apply noDupErr to this index */</comment>
        <expr_stmt><expr><name>applyNoDupErr</name> <operator>=</operator> <name>noDupErr</name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name>arbiterIndexes</name> <operator>==</operator> <name>NIL</name> <operator>||</operator>
             <call><name>list_member_oid</name><argument_list>(<argument><expr><name>arbiterIndexes</name></expr></argument>,
                             <argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indexrelid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

        <comment type="block">/*
         * The index AM does the actual insertion, plus uniqueness checking.
         *
         * For an immediate-mode unique index, we just tell the index AM to
         * throw error if not unique.
         *
         * For a deferrable unique index, we tell the index AM to just detect
         * possible non-uniqueness, and we add the index OID to the result
         * list if further checking is needed.
         *
         * For a speculative insertion (used by INSERT ... ON CONFLICT), do
         * the same as for a deferrable unique index.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisunique</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>checkUnique</name> <operator>=</operator> <name>UNIQUE_CHECK_NO</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>applyNoDupErr</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>checkUnique</name> <operator>=</operator> <name>UNIQUE_CHECK_PARTIAL</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indimmediate</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>checkUnique</name> <operator>=</operator> <name>UNIQUE_CHECK_YES</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>checkUnique</name> <operator>=</operator> <name>UNIQUE_CHECK_PARTIAL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>satisfiesConstraint</name> <operator>=</operator>
            <call><name>index_insert</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <comment type="block">/* index relation */</comment>
                         <argument><expr><name>values</name></expr></argument>,    <comment type="block">/* array of index Datums */</comment>
                         <argument><expr><name>isnull</name></expr></argument>,    <comment type="block">/* null flags */</comment>
                         <argument><expr><name>tupleid</name></expr></argument>,    <comment type="block">/* tid of heap tuple */</comment>
                         <argument><expr><name>heapRelation</name></expr></argument>,    <comment type="block">/* heap relation */</comment>
                         <argument><expr><name>checkUnique</name></expr></argument>,    <comment type="block">/* type of uniqueness check to do */</comment>
                         <argument><expr><name>indexInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* index AM may need this */</comment>

        <comment type="block">/*
         * If the index has an associated exclusion constraint, check that.
         * This is simpler than the process for uniqueness checks since we
         * always insert first and then check.  If the constraint is deferred,
         * we check now anyway, but don't throw error on violation or wait for
         * a conclusive outcome from a concurrent insertion; instead we'll
         * queue a recheck event.  Similarly, noDupErr callers (speculative
         * inserters) will recheck later, and wait for a conclusive outcome
         * then.
         *
         * An index for an exclusion constraint can't also be UNIQUE (not an
         * essential property, we just don't allow it in the grammar), so no
         * need to preserve the prior state of satisfiesConstraint.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type>        <name>violationOK</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>CEOUC_WAIT_MODE</name></type> <name>waitMode</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>applyNoDupErr</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>violationOK</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>waitMode</name> <operator>=</operator> <name>CEOUC_LIVELOCK_PREVENTING_WAIT</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indimmediate</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>violationOK</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>waitMode</name> <operator>=</operator> <name>CEOUC_NOWAIT</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>violationOK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>waitMode</name> <operator>=</operator> <name>CEOUC_WAIT</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name>satisfiesConstraint</name> <operator>=</operator>
                <call><name>check_exclusion_or_unique_constraint</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>,
                                                     <argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>,
                                                     <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>,
                                                     <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                                     <argument><expr><name>waitMode</name></expr></argument>, <argument><expr><name>violationOK</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>checkUnique</name> <operator>==</operator> <name>UNIQUE_CHECK_PARTIAL</name> <operator>||</operator>
             <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator>
            <operator>!</operator><name>satisfiesConstraint</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * The tuple potentially violates the uniqueness or exclusion
             * constraint, so make a note of the index so that we can re-check
             * it later.  Speculative inserters are told if there was a
             * speculative conflict, since that always requires a restart.
             */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indimmediate</name></name> <operator>&amp;&amp;</operator> <name>specConflict</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>specConflict</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecCheckIndexConstraints
 *
 *        This routine checks if a tuple violates any unique or
 *        exclusion constraints.  Returns true if there is no conflict.
 *        Otherwise returns false, and the TID of the conflicting
 *        tuple is returned in *conflictTid.
 *
 *        If 'arbiterIndexes' is given, only those indexes are checked.
 *        NIL means all indexes.
 *
 *        Note that this doesn't lock the values in any way, so it's
 *        possible that a conflicting tuple is inserted immediately
 *        after this returns.  But this can be used for a pre-check
 *        before insertion.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>bool</name></type>
<name>ExecCheckIndexConstraints</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
                          <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>conflictTid</name></decl></parameter>,
                          <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>arbiterIndexes</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numIndices</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationPtr</name></type> <name>relationDescs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>heapRelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>indexInfoArray</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ItemPointerData</name></type> <name>invalidItemPtr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>checkedIndex</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><name>conflictTid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>invalidItemPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Get information from the result relation info structure.
     */</comment>
    <expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>numIndices</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>relationDescs</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_IndexRelationDescs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>indexInfoArray</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_IndexRelationInfo</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>heapRelation</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * We will use the EState's per-tuple context for evaluating predicates
     * and index expressions (creating it if it's not already there).
     */</comment>
    <expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Arrange for econtext's scan tuple to be the tuple under test */</comment>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

    <comment type="block">/*
     * For each index, form index tuple and check if it satisfies the
     * constraint.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numIndices</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>indexRelation</name> <init>= <expr><name><name>relationDescs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>satisfiesConstraint</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>indexRelation</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>indexInfo</name> <operator>=</operator> <name><name>indexInfoArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* If the index is marked as read-only, ignore it */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ReadyForInserts</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* When specific arbiter indexes requested, only examine them */</comment>
        <if_stmt><if>if <condition>(<expr><name>arbiterIndexes</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>arbiterIndexes</name></expr></argument>,
                             <argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indexrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indimmediate</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ON CONFLICT does not support deferrable unique constraints/exclusion constraints as arbiters"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>,
                                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>checkedIndex</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <comment type="block">/* Check for partial index */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>predicate</name></decl>;</decl_stmt>

            <comment type="block">/*
             * If predicate state not set up yet, create it (in the estate's
             * per-query context)
             */</comment>
            <expr_stmt><expr><name>predicate</name> <operator>=</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_PredicateState</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>predicate</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>predicate</name> <operator>=</operator> <call><name>ExecPrepareQual</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_PredicateState</name></name> <operator>=</operator> <name>predicate</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Skip this index-update if the predicate isn't satisfied */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * FormIndexDatum fills in its values and isnull parameters with the
         * appropriate values for the column(s) of the index.
         */</comment>
        <expr_stmt><expr><call><name>FormIndexDatum</name><argument_list>(<argument><expr><name>indexInfo</name></expr></argument>,
                       <argument><expr><name>slot</name></expr></argument>,
                       <argument><expr><name>estate</name></expr></argument>,
                       <argument><expr><name>values</name></expr></argument>,
                       <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>satisfiesConstraint</name> <operator>=</operator>
            <call><name>check_exclusion_or_unique_constraint</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>indexRelation</name></expr></argument>,
                                                 <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>invalidItemPtr</name></expr></argument>,
                                                 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                                 <argument><expr><name>CEOUC_WAIT</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                                 <argument><expr><name>conflictTid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>satisfiesConstraint</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>arbiterIndexes</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>checkedIndex</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected failure to find arbiter index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check for violation of an exclusion or unique constraint
 *
 * heap: the table containing the new tuple
 * index: the index supporting the constraint
 * indexInfo: info about the index, including the exclusion properties
 * tupleid: heap TID of the new tuple we have just inserted (invalid if we
 *        haven't inserted a new tuple yet)
 * values, isnull: the *index* column values computed for the new tuple
 * estate: an EState we can do evaluation in
 * newIndex: if true, we are trying to build a new index (this affects
 *        only the wording of error messages)
 * waitMode: whether to wait for concurrent inserters/deleters
 * violationOK: if true, don't throw error for violation
 * conflictTid: if not-NULL, the TID of the conflicting tuple is returned here
 *
 * Returns true if OK, false if actual or potential violation
 *
 * 'waitMode' determines what happens if a conflict is detected with a tuple
 * that was inserted or deleted by a transaction that's still running.
 * CEOUC_WAIT means that we wait for the transaction to commit, before
 * throwing an error or returning.  CEOUC_NOWAIT means that we report the
 * violation immediately; so the violation is only potential, and the caller
 * must recheck sometime later.  This behavior is convenient for deferred
 * exclusion checks; we need not bother queuing a deferred event if there is
 * definitely no conflict at insertion time.
 *
 * CEOUC_LIVELOCK_PREVENTING_WAIT is like CEOUC_NOWAIT, but we will sometimes
 * wait anyway, to prevent livelocking if two transactions try inserting at
 * the same time.  This is used with speculative insertions, for INSERT ON
 * CONFLICT statements. (See notes in file header)
 *
 * If violationOK is true, we just report the potential or actual violation to
 * the caller by returning 'false'.  Otherwise we throw a descriptive error
 * message here.  When violationOK is false, a false result is impossible.
 *
 * Note: The indexam is normally responsible for checking unique constraints,
 * so this normally only needs to be used for exclusion constraints.  But this
 * function is also called when doing a "pre-check" for conflicts on a unique
 * constraint, when doing speculative insertion.  Caller may use the returned
 * conflict TID to take further steps.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_exclusion_or_unique_constraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>,
                                     <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
                                     <parameter><decl><type><name>ItemPointer</name></type> <name>tupleid</name></decl></parameter>,
                                     <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
                                     <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>newIndex</name></decl></parameter>,
                                     <parameter><decl><type><name>CEOUC_WAIT_MODE</name></type> <name>waitMode</name></decl></parameter>,
                                     <parameter><decl><type><name>bool</name></type> <name>violationOK</name></decl></parameter>,
                                     <parameter><decl><type><name>ItemPointer</name></type> <name>conflictTid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>constr_procs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16</name>       <modifier>*</modifier></type><name>constr_strats</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>index_collations</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>rd_indcollation</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>index_natts</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnatts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>index_scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankeys</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SnapshotData</name></type> <name>DirtySnapshot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>conflict</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found_self</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>existing_slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>save_scantuple</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>constr_procs</name> <operator>=</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionProcs</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>constr_strats</name> <operator>=</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionStrats</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>constr_procs</name> <operator>=</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_UniqueProcs</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>constr_strats</name> <operator>=</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_UniqueStrats</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * If any of the input values are NULL, the constraint check is assumed to
     * pass (i.e., we assume the operators are strict).
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>index_natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Search the tuples that are in the index for any violations, including
     * tuples that aren't visible yet.
     */</comment>
    <expr_stmt><expr><call><name>InitDirtySnapshot</name><argument_list>(<argument><expr><name>DirtySnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>index_natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ScanKeyEntryInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankeys</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                               <argument><expr><literal type="number">0</literal></expr></argument>,
                               <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                               <argument><expr><name><name>constr_strats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                               <argument><expr><name>InvalidOid</name></expr></argument>,
                               <argument><expr><name><name>index_collations</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                               <argument><expr><name><name>constr_procs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                               <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Need a TupleTableSlot to put existing tuples in.
     *
     * To use FormIndexDatum, we have to make the econtext's scantuple point
     * to this slot.  Be sure to save and restore caller's value for
     * scantuple.
     */</comment>
    <expr_stmt><expr><name>existing_slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>save_scantuple</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>existing_slot</name></expr>;</expr_stmt>

    <comment type="block">/*
     * May have to restart scan from this point if a potential conflict is
     * found.
     */</comment>
<label><name>retry</name>:</label>
    <expr_stmt><expr><name>conflict</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>found_self</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>index_scan</name> <operator>=</operator> <call><name>index_beginscan</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>DirtySnapshot</name></expr></argument>, <argument><expr><name>index_natts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name>index_scan</name></expr></argument>, <argument><expr><name>scankeys</name></expr></argument>, <argument><expr><name>index_natts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>tup</name> <operator>=</operator> <call><name>index_getnext</name><argument_list>(<argument><expr><name>index_scan</name></expr></argument>,
                                <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>xwait</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ItemPointerData</name></type> <name>ctid_wait</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XLTW_Oper</name></type>    <name>reason_wait</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name><name>existing_values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>existing_isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>error_new</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>error_existing</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Ignore the entry for the tuple we're trying to check.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><name>tupleid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>ItemPointerEquals</name><argument_list>(<argument><expr><name>tupleid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>found_self</name></expr>)</condition><block type="pseudo"><block_content>        <comment type="block">/* should not happen */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"found self tuple multiple times in index \"%s\""</literal></expr></argument>,
                     <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>found_self</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Extract the index column values and isnull flags from the existing
         * tuple.
         */</comment>
        <expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>existing_slot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FormIndexDatum</name><argument_list>(<argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>existing_slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>,
                       <argument><expr><name>existing_values</name></expr></argument>, <argument><expr><name>existing_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If lossy indexscan, must recheck the condition */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>index_scan</name><operator>-&gt;</operator><name>xs_recheck</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>index_recheck_constraint</name><argument_list>(<argument><expr><name>index</name></expr></argument>,
                                          <argument><expr><name>constr_procs</name></expr></argument>,
                                          <argument><expr><name>existing_values</name></expr></argument>,
                                          <argument><expr><name>existing_isnull</name></expr></argument>,
                                          <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>        <comment type="block">/* tuple doesn't actually match, so no
                                 * conflict */</comment>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * At this point we have either a conflict or a potential conflict.
         *
         * If an in-progress transaction is affecting the visibility of this
         * tuple, we need to wait for it to complete and then recheck (unless
         * the caller requested not to).  For simplicity we do rechecking by
         * just restarting the whole scan --- this case probably doesn't
         * happen often enough to be worth trying harder, and anyway we don't
         * want to hold any index internal locks while waiting.
         */</comment>
        <expr_stmt><expr><name>xwait</name> <operator>=</operator> <ternary><condition><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>DirtySnapshot</name><operator>.</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then>
            <expr><name><name>DirtySnapshot</name><operator>.</operator><name>xmin</name></name></expr> </then><else>: <expr><name><name>DirtySnapshot</name><operator>.</operator><name>xmax</name></name></expr></else></ternary></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>(</operator><name>waitMode</name> <operator>==</operator> <name>CEOUC_WAIT</name> <operator>||</operator>
             <operator>(</operator><name>waitMode</name> <operator>==</operator> <name>CEOUC_LIVELOCK_PREVENTING_WAIT</name> <operator>&amp;&amp;</operator>
              <name><name>DirtySnapshot</name><operator>.</operator><name>speculativeToken</name></name> <operator>&amp;&amp;</operator>
              <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>xwait</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>ctid_wait</name> <operator>=</operator> <name><name>tup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>reason_wait</name> <operator>=</operator> <ternary><condition><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name></expr> ?</condition><then>
                <expr><name>XLTW_RecheckExclusionConstr</name></expr> </then><else>: <expr><name>XLTW_InsertIndex</name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>index_endscan</name><argument_list>(<argument><expr><name>index_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>DirtySnapshot</name><operator>.</operator><name>speculativeToken</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>SpeculativeInsertionWait</name><argument_list>(<argument><expr><name><name>DirtySnapshot</name><operator>.</operator><name>xmin</name></name></expr></argument>,
                                         <argument><expr><name><name>DirtySnapshot</name><operator>.</operator><name>speculativeToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>XactLockTableWait</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctid_wait</name></expr></argument>, <argument><expr><name>reason_wait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <goto>goto <name>retry</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * We have a definite conflict (or a potential one, but the caller
         * didn't want to wait).  Return it to caller, or report it.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>violationOK</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>conflict</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>conflictTid</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>conflictTid</name> <operator>=</operator> <name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>error_new</name> <operator>=</operator> <call><name>BuildIndexValueDescription</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>error_existing</name> <operator>=</operator> <call><name>BuildIndexValueDescription</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>existing_values</name></expr></argument>,
                                                    <argument><expr><name>existing_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>newIndex</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXCLUSION_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create exclusion constraint \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <ternary><condition><expr><name>error_new</name> <operator>&amp;&amp;</operator> <name>error_existing</name></expr> ?</condition><then>
                     <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Key %s conflicts with key %s."</literal></expr></argument>,
                               <argument><expr><name>error_new</name></expr></argument>, <argument><expr><name>error_existing</name></expr></argument>)</argument_list></call></expr> </then><else>:
                     <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Key conflicts exist."</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
                     <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>heap</name></expr></argument>,
                                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXCLUSION_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting key value violates exclusion constraint \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <ternary><condition><expr><name>error_new</name> <operator>&amp;&amp;</operator> <name>error_existing</name></expr> ?</condition><then>
                     <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Key %s conflicts with existing key %s."</literal></expr></argument>,
                               <argument><expr><name>error_new</name></expr></argument>, <argument><expr><name>error_existing</name></expr></argument>)</argument_list></call></expr> </then><else>:
                     <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Key conflicts with existing key."</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
                     <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>heap</name></expr></argument>,
                                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>index_endscan</name><argument_list>(<argument><expr><name>index_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Ordinarily, at this point the search should have found the originally
     * inserted tuple (if any), unless we exited the loop early because of
     * conflict.  However, it is possible to define exclusion constraints for
     * which that wouldn't be true --- for instance, if the operator is &lt;&gt;. So
     * we no longer complain if found_self is still false.
     */</comment>

    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>save_scantuple</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>existing_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>!</operator><name>conflict</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check for violation of an exclusion constraint
 *
 * This is a dumbed down version of check_exclusion_or_unique_constraint
 * for external callers. They don't need all the special modes.
 */</comment>
<function><type><name>void</name></type>
<name>check_exclusion_constraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>,
                           <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
                           <parameter><decl><type><name>ItemPointer</name></type> <name>tupleid</name></decl></parameter>,
                           <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
                           <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>newIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>check_exclusion_or_unique_constraint</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>,
                                                <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>,
                                                <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>newIndex</name></expr></argument>,
                                                <argument><expr><name>CEOUC_WAIT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check existing tuple's index values to see if it really matches the
 * exclusion condition against the new_values.  Returns true if conflict.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>index_recheck_constraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>constr_procs</name></decl></parameter>,
                         <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>existing_values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>existing_isnull</name></decl></parameter>,
                         <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>new_values</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>index_natts</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnatts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>index_natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* Assume the exclusion operators are strict */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>existing_isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>OidFunctionCall2Coll</name><argument_list>(<argument><expr><name><name>constr_procs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                               <argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                               <argument><expr><name><name>existing_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                               <argument><expr><name><name>new_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
