<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/executor/nodeAgg.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeAgg.c
 *      Routines to handle aggregate nodes.
 *
 *      ExecAgg normally evaluates each aggregate in the following steps:
 *
 *         transvalue = initcond
 *         foreach input_tuple do
 *            transvalue = transfunc(transvalue, input_value(s))
 *         result = finalfunc(transvalue, direct_argument(s))
 *
 *      If a finalfunc is not supplied then the result is just the ending
 *      value of transvalue.
 *
 *      Other behaviors can be selected by the "aggsplit" mode, which exists
 *      to support partial aggregation.  It is possible to:
 *      * Skip running the finalfunc, so that the output is always the
 *      final transvalue state.
 *      * Substitute the combinefunc for the transfunc, so that transvalue
 *      states (propagated up from a child partial-aggregation step) are merged
 *      rather than processing raw input rows.  (The statements below about
 *      the transfunc apply equally to the combinefunc, when it's selected.)
 *      * Apply the serializefunc to the output values (this only makes sense
 *      when skipping the finalfunc, since the serializefunc works on the
 *      transvalue data type).
 *      * Apply the deserializefunc to the input values (this only makes sense
 *      when using the combinefunc, for similar reasons).
 *      It is the planner's responsibility to connect up Agg nodes using these
 *      alternate behaviors in a way that makes sense, with partial aggregation
 *      results being fed to nodes that expect them.
 *
 *      If a normal aggregate call specifies DISTINCT or ORDER BY, we sort the
 *      input tuples and eliminate duplicates (if required) before performing
 *      the above-depicted process.  (However, we don't do that for ordered-set
 *      aggregates; their "ORDER BY" inputs are ordinary aggregate arguments
 *      so far as this module is concerned.)    Note that partial aggregation
 *      is not supported in these cases, since we couldn't ensure global
 *      ordering or distinctness of the inputs.
 *
 *      If transfunc is marked "strict" in pg_proc and initcond is NULL,
 *      then the first non-NULL input_value is assigned directly to transvalue,
 *      and transfunc isn't applied until the second non-NULL input_value.
 *      The agg's first input type and transtype must be the same in this case!
 *
 *      If transfunc is marked "strict" then NULL input_values are skipped,
 *      keeping the previous transvalue.  If transfunc is not strict then it
 *      is called for every input tuple and must deal with NULL initcond
 *      or NULL input_values for itself.
 *
 *      If finalfunc is marked "strict" then it is not called when the
 *      ending transvalue is NULL, instead a NULL result is created
 *      automatically (this is just the usual handling of strict functions,
 *      of course).  A non-strict finalfunc can make its own choice of
 *      what to return for a NULL ending transvalue.
 *
 *      Ordered-set aggregates are treated specially in one other way: we
 *      evaluate any "direct" arguments and pass them to the finalfunc along
 *      with the transition value.
 *
 *      A finalfunc can have additional arguments beyond the transvalue and
 *      any "direct" arguments, corresponding to the input arguments of the
 *      aggregate.  These are always just passed as NULL.  Such arguments may be
 *      needed to allow resolution of a polymorphic aggregate's result type.
 *
 *      We compute aggregate input expressions and run the transition functions
 *      in a temporary econtext (aggstate-&gt;tmpcontext).  This is reset at least
 *      once per input tuple, so when the transvalue datatype is
 *      pass-by-reference, we have to be careful to copy it into a longer-lived
 *      memory context, and free the prior value to avoid memory leakage.  We
 *      store transvalues in another set of econtexts, aggstate-&gt;aggcontexts
 *      (one per grouping set, see below), which are also used for the hashtable
 *      structures in AGG_HASHED mode.  These econtexts are rescanned, not just
 *      reset, at group boundaries so that aggregate transition functions can
 *      register shutdown callbacks via AggRegisterCallback.
 *
 *      The node's regular econtext (aggstate-&gt;ss.ps.ps_ExprContext) is used to
 *      run finalize functions and compute the output tuple; this context can be
 *      reset once per output tuple.
 *
 *      The executor's AggState node is passed as the fmgr "context" value in
 *      all transfunc and finalfunc calls.  It is not recommended that the
 *      transition functions look at the AggState node directly, but they can
 *      use AggCheckCallContext() to verify that they are being called by
 *      nodeAgg.c (and not as ordinary SQL functions).  The main reason a
 *      transition function might want to know this is so that it can avoid
 *      palloc'ing a fixed-size pass-by-ref transition value on every call:
 *      it can instead just scribble on and return its left input.  Ordinarily
 *      it is completely forbidden for functions to modify pass-by-ref inputs,
 *      but in the aggregate case we know the left input is either the initial
 *      transition value or a previous function result, and in either case its
 *      value need not be preserved.  See int8inc() for an example.  Notice that
 *      advance_transition_function() is coded to avoid a data copy step when
 *      the previous transition value pointer is returned.  It is also possible
 *      to avoid repeated data copying when the transition value is an expanded
 *      object: to do that, the transition function must take care to return
 *      an expanded object that is in a child context of the memory context
 *      returned by AggCheckCallContext().  Also, some transition functions want
 *      to store working state in addition to the nominal transition value; they
 *      can use the memory context returned by AggCheckCallContext() to do that.
 *
 *      Note: AggCheckCallContext() is available as of PostgreSQL 9.0.  The
 *      AggState is available as context in earlier releases (back to 8.1),
 *      but direct examination of the node is needed to use it before 9.0.
 *
 *      As of 9.4, aggregate transition functions can also use AggGetAggref()
 *      to get hold of the Aggref expression node for their aggregate call.
 *      This is mainly intended for ordered-set aggregates, which are not
 *      supported as window functions.  (A regular aggregate function would
 *      need some fallback logic to use this, since there's no Aggref node
 *      for a window function.)
 *
 *      Grouping sets:
 *
 *      A list of grouping sets which is structurally equivalent to a ROLLUP
 *      clause (e.g. (a,b,c), (a,b), (a)) can be processed in a single pass over
 *      ordered data.  We do this by keeping a separate set of transition values
 *      for each grouping set being concurrently processed; for each input tuple
 *      we update them all, and on group boundaries we reset those states
 *      (starting at the front of the list) whose grouping values have changed
 *      (the list of grouping sets is ordered from most specific to least
 *      specific).
 *
 *      Where more complex grouping sets are used, we break them down into
 *      "phases", where each phase has a different sort order (except phase 0
 *      which is reserved for hashing).  During each phase but the last, the
 *      input tuples are additionally stored in a tuplesort which is keyed to the
 *      next phase's sort order; during each phase but the first, the input
 *      tuples are drawn from the previously sorted data.  (The sorting of the
 *      data for the first phase is handled by the planner, as it might be
 *      satisfied by underlying nodes.)
 *
 *      Hashing can be mixed with sorted grouping.  To do this, we have an
 *      AGG_MIXED strategy that populates the hashtables during the first sorted
 *      phase, and switches to reading them out after completing all sort phases.
 *      We can also support AGG_HASHED with multiple hash tables and no sorting
 *      at all.
 *
 *      From the perspective of aggregate transition and final functions, the
 *      only issue regarding grouping sets is this: a single call site (flinfo)
 *      of an aggregate function may be used for updating several different
 *      transition values in turn. So the function must not cache in the flinfo
 *      anything which logically belongs as part of the transition value (most
 *      importantly, the memory context in which the transition value exists).
 *      The support API functions (AggCheckCallContext, AggRegisterCallback) are
 *      sensitive to the grouping set for which the aggregate function is
 *      currently being called.
 *
 *      Plan structure:
 *
 *      What we get from the planner is actually one "real" Agg node which is
 *      part of the plan tree proper, but which optionally has an additional list
 *      of Agg nodes hung off the side via the "chain" field.  This is because an
 *      Agg node happens to be a convenient representation of all the data we
 *      need for grouping sets.
 *
 *      For many purposes, we treat the "real" node as if it were just the first
 *      node in the chain.  The chain must be ordered such that hashed entries
 *      come before sorted/plain entries; the real node is marked AGG_MIXED if
 *      there are both types present (in which case the real node describes one
 *      of the hashed groupings, other AGG_HASHED nodes may optionally follow in
 *      the chain, followed in turn by AGG_SORTED or (one) AGG_PLAIN node).  If
 *      the real node is marked AGG_HASHED or AGG_SORTED, then all the chained
 *      nodes must be of the same type; if it is AGG_PLAIN, there can be no
 *      chained nodes.
 *
 *      We collect all hashed nodes into a single "phase", numbered 0, and create
 *      a sorted phase (numbered 1..n) for each AGG_SORTED or AGG_PLAIN node.
 *      Phase 0 is allocated even if there are no hashes, but remains unused in
 *      that case.
 *
 *      AGG_HASHED nodes actually refer to only a single grouping set each,
 *      because for each hashed grouping we need a separate grpColIdx and
 *      numGroups estimate.  AGG_SORTED nodes represent a "rollup", a list of
 *      grouping sets that share a sort order.  Each AGG_SORTED node other than
 *      the first one has an associated Sort node which describes the sort order
 *      to be used; the first sorted node takes its input from the outer subtree,
 *      which the planner has already arranged to provide ordered data.
 *
 *      Memory and ExprContext usage:
 *
 *      Because we're accumulating aggregate values across input rows, we need to
 *      use more memory contexts than just simple input/output tuple contexts.
 *      In fact, for a rollup, we need a separate context for each grouping set
 *      so that we can reset the inner (finer-grained) aggregates on their group
 *      boundaries while continuing to accumulate values for outer
 *      (coarser-grained) groupings.  On top of this, we might be simultaneously
 *      populating hashtables; however, we only need one context for all the
 *      hashtables.
 *
 *      So we create an array, aggcontexts, with an ExprContext for each grouping
 *      set in the largest rollup that we're going to process, and use the
 *      per-tuple memory context of those ExprContexts to store the aggregate
 *      transition values.  hashcontext is the single context created to support
 *      all hash tables.
 *
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *      src/backend/executor/nodeAgg.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAgg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tuplesort.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/locator.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>ReDistributeStatus</name> <modifier>*</modifier></type><name>workerStatus</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/* global GUC variables for hybrid hash agg */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>g_hybrid_hash_agg</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>g_hybrid_hash_agg_debug</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>  <name>g_default_hashagg_nbatches</name> <init>= <expr><literal type="number">32</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * AggStatePerTransData - per aggregate state value information
 *
 * Working state for updating the aggregate's state value, by calling the
 * transition function with an input row. This struct does not store the
 * information needed to produce the final aggregate result from the transition
 * state, that's stored in AggStatePerAggData instead. This separation allows
 * multiple aggregate results to be produced from a single state value.
 */</comment>
<typedef>typedef <type><struct>struct <name>AggStatePerTransData</name>
<block>{
    <comment type="block">/*
     * These values are set up during ExecInitAgg() and do not change
     * thereafter:
     */</comment>

    <comment type="block">/*
     * Link to an Aggref expr this state value is for.
     *
     * There can be multiple Aggref's sharing the same state value, as long as
     * the inputs and transition function are identical. This points to the
     * first one of them.
     */</comment>
    <decl_stmt><decl><type><name>Aggref</name>       <modifier>*</modifier></type><name>aggref</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Nominal number of arguments for aggregate function.  For plain aggs,
     * this excludes any ORDER BY expressions.  For ordered-set aggs, this
     * counts both the direct and aggregated (ORDER BY) arguments.
     */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>numArguments</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Number of aggregated input columns.  This includes ORDER BY expressions
     * in both the plain-agg and ordered-set cases.  Ordered-set direct args
     * are not counted, though.
     */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>numInputs</name></decl>;</decl_stmt>

    <comment type="block">/* offset of input columns in AggState-&gt;evalslot */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>inputoff</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Number of aggregated input columns to pass to the transfn.  This
     * includes the ORDER BY columns for ordered-set aggs, but not for plain
     * aggs.  (This doesn't count the transition state value!)
     */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>numTransInputs</name></decl>;</decl_stmt>

    <comment type="block">/* Oid of the state transition or combine function */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>transfn_oid</name></decl>;</decl_stmt>

    <comment type="block">/* Oid of the serialization function or InvalidOid */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>serialfn_oid</name></decl>;</decl_stmt>

    <comment type="block">/* Oid of the deserialization function or InvalidOid */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>deserialfn_oid</name></decl>;</decl_stmt>

    <comment type="block">/* Oid of state value's datatype */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>aggtranstype</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<decl_stmt><decl><type><name>Oid</name></type>         <name>serial_func_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>         <name>deserial_func_id</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* ExprStates of the FILTER and argument expressions. */</comment>
    <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>aggfilter</name></decl>;</decl_stmt>        <comment type="block">/* state of FILTER expression, if any */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>aggdirectargs</name></decl>;</decl_stmt>    <comment type="block">/* states of direct-argument expressions */</comment>

    <comment type="block">/*
     * fmgr lookup data for transition function or combine function.  Note in
     * particular that the fn_strict flag is kept here.
     */</comment>
    <decl_stmt><decl><type><name>FmgrInfo</name></type>    <name>transfn</name></decl>;</decl_stmt>

    <comment type="block">/* fmgr lookup data for serialization function */</comment>
    <decl_stmt><decl><type><name>FmgrInfo</name></type>    <name>serialfn</name></decl>;</decl_stmt>

    <comment type="block">/* fmgr lookup data for deserialization function */</comment>
    <decl_stmt><decl><type><name>FmgrInfo</name></type>    <name>deserialfn</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>combfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>serial_func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>deserial_func</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Input collation derived for aggregate */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>aggCollation</name></decl>;</decl_stmt>

    <comment type="block">/* number of sorting columns */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>numSortCols</name></decl>;</decl_stmt>

    <comment type="block">/* number of sorting columns to consider in DISTINCT comparisons */</comment>
    <comment type="block">/* (this is either zero or the same as numSortCols) */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>numDistinctCols</name></decl>;</decl_stmt>

    <comment type="block">/* deconstructed sorting information (arrays of length numSortCols) */</comment>
    <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>sortOperators</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>sortCollations</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>sortNullsFirst</name></decl>;</decl_stmt>

    <comment type="block">/*
     * fmgr lookup data for input columns' equality operators --- only
     * set/used when aggregate has DISTINCT flag.  Note that these are in
     * order of sort column index, not parameter index.
     */</comment>
    <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>equalfns</name></decl>;</decl_stmt>        <comment type="block">/* array of length numDistinctCols */</comment>

    <comment type="block">/*
     * initial value from pg_aggregate entry
     */</comment>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>initValue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>initValueIsNull</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We need the len and byval info for the agg's input and transition data
     * types in order to know how to copy/delete values.
     *
     * Note that the info for the input type is used only when handling
     * DISTINCT aggs with just one argument, so there is only one input type.
     */</comment>
    <decl_stmt><decl><type><name>int16</name></type>        <name>inputtypeLen</name></decl>,
                <name>transtypeLen</name>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>inputtypeByVal</name></decl>,
                <name>transtypeByVal</name>;</decl_stmt>

    <comment type="block">/*
     * Stuff for evaluation of aggregate inputs in cases where the aggregate
     * requires sorted input.  The arguments themselves will be evaluated via
     * AggState-&gt;evalslot/evalproj for all aggregates at once, but we only
     * want to sort the relevant columns for individual aggregates.
     */</comment>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>sortdesc</name></decl>;</decl_stmt>        <comment type="block">/* descriptor of input tuples */</comment>

    <comment type="block">/*
     * Slots for holding the evaluated input arguments.  These are set up
     * during ExecInitAgg() and then used for each input row requiring
     * processing besides what's done in AggState-&gt;evalproj.
     */</comment>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>sortslot</name></decl>;</decl_stmt>    <comment type="block">/* current input tuple */</comment>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>uniqslot</name></decl>;</decl_stmt>    <comment type="block">/* used for multi-column DISTINCT */</comment>

    <comment type="block">/*
     * These values are working state that is initialized at the start of an
     * input tuple group and updated for each input tuple.
     *
     * For a simple (non DISTINCT/ORDER BY) aggregate, we just feed the input
     * values straight to the transition function.  If it's DISTINCT or
     * requires ORDER BY, we pass the input values into a Tuplesort object;
     * then at completion of the input tuple group, we scan the sorted values,
     * eliminate duplicates if needed, and run the transition function on the
     * rest.
     *
     * We need a separate tuplesort for each grouping set.
     */</comment>

    <decl_stmt><decl><type><name>Tuplesortstate</name> <modifier>*</modifier><modifier>*</modifier></type><name>sortstates</name></decl>;</decl_stmt>    <comment type="block">/* sort objects, if DISTINCT or ORDER BY */</comment>

    <comment type="block">/*
     * This field is a pre-initialized FunctionCallInfo struct used for
     * calling this aggregate's transfn.  We save a few cycles per row by not
     * re-initializing the unchanging fields; which isn't much, but it seems
     * worth the extra space consumption.
     */</comment>
    <decl_stmt><decl><type><name>FunctionCallInfoData</name></type> <name>transfn_fcinfo</name></decl>;</decl_stmt>

    <comment type="block">/* Likewise for serialization and deserialization functions */</comment>
    <decl_stmt><decl><type><name>FunctionCallInfoData</name></type> <name>serialfn_fcinfo</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>FunctionCallInfoData</name></type> <name>deserialfn_fcinfo</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<decl_stmt><decl><type><name>FunctionCallInfoData</name></type> <name>combfn_fcinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfoData</name></type> <name>serial_func_fcinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfoData</name></type> <name>deserial_func_fcinfo</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type>            <name>AggStatePerTransData</name>;</typedef>

<comment type="block">/*
 * AggStatePerAggData - per-aggregate information
 *
 * This contains the information needed to call the final function, to produce
 * a final aggregate result from the state value. If there are multiple
 * identical Aggrefs in the query, they can all share the same per-agg data.
 *
 * These values are set up during ExecInitAgg() and do not change thereafter.
 */</comment>
<typedef>typedef <type><struct>struct <name>AggStatePerAggData</name>
<block>{
    <comment type="block">/*
     * Link to an Aggref expr this state value is for.
     *
     * There can be multiple identical Aggref's sharing the same per-agg. This
     * points to the first one of them.
     */</comment>
    <decl_stmt><decl><type><name>Aggref</name>       <modifier>*</modifier></type><name>aggref</name></decl>;</decl_stmt>

    <comment type="block">/* index to the state value which this agg should use */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>transno</name></decl>;</decl_stmt>

    <comment type="block">/* Optional Oid of final function (may be InvalidOid) */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>finalfn_oid</name></decl>;</decl_stmt>

    <comment type="block">/*
     * fmgr lookup data for final function --- only valid when finalfn_oid oid
     * is not InvalidOid.
     */</comment>
    <decl_stmt><decl><type><name>FmgrInfo</name></type>    <name>finalfn</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Number of arguments to pass to the finalfn.  This is always at least 1
     * (the transition state value) plus any ordered-set direct args. If the
     * finalfn wants extra args then we pass nulls corresponding to the
     * aggregated input columns.
     */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>numFinalArgs</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We need the len and byval info for the agg's result data type in order
     * to know how to copy/delete values.
     */</comment>
    <decl_stmt><decl><type><name>int16</name></type>        <name>resulttypeLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>resulttypeByVal</name></decl>;</decl_stmt>

}</block></struct></type>            <name>AggStatePerAggData</name>;</typedef>

<comment type="block">/*
 * AggStatePerGroupData - per-aggregate-per-group working state
 *
 * These values are working state that is initialized at the start of
 * an input tuple group and updated for each input tuple.
 *
 * In AGG_PLAIN and AGG_SORTED modes, we have a single array of these
 * structs (pointed to by aggstate-&gt;pergroup); we re-use the array for
 * each input group, if it's AGG_SORTED mode.  In AGG_HASHED mode, the
 * hash table contains an array of these structs for each tuple group.
 *
 * Logically, the sortstate field belongs in this struct, but we do not
 * keep it here for space reasons: we don't support DISTINCT aggregates
 * in AGG_HASHED mode, so there's no reason to use up a pointer field
 * in every entry of the hashtable.
 */</comment>
<typedef>typedef <type><struct>struct <name>AggStatePerGroupData</name>
<block>{
    <decl_stmt><decl><type><name>Datum</name></type>        <name>transValue</name></decl>;</decl_stmt>        <comment type="block">/* current transition value */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>transValueIsNull</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>bool</name></type>        <name>noTransValue</name></decl>;</decl_stmt>    <comment type="block">/* true if transValue not set yet */</comment>

    <comment type="block">/*
     * Note: noTransValue initially has the same value as transValueIsNull,
     * and if true both are cleared to false at the same time.  They are not
     * the same though: if transfn later returns a NULL, we want to keep that
     * NULL and not auto-replace it with a later input value. Only the first
     * non-NULL input will be auto-substituted.
     */</comment>
}</block></struct></type>            <name>AggStatePerGroupData</name>;</typedef>

<comment type="block">/*
 * AggStatePerPhaseData - per-grouping-set-phase state
 *
 * Grouping sets are divided into "phases", where a single phase can be
 * processed in one pass over the input. If there is more than one phase, then
 * at the end of input from the current phase, state is reset and another pass
 * taken over the data which has been re-sorted in the mean time.
 *
 * Accordingly, each phase specifies a list of grouping sets and group clause
 * information, plus each phase after the first also has a sort order.
 */</comment>
<typedef>typedef <type><struct>struct <name>AggStatePerPhaseData</name>
<block>{
    <decl_stmt><decl><type><name>AggStrategy</name></type> <name>aggstrategy</name></decl>;</decl_stmt>    <comment type="block">/* strategy for this phase */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>numsets</name></decl>;</decl_stmt>        <comment type="block">/* number of grouping sets (or 0) */</comment>
    <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>gset_lengths</name></decl>;</decl_stmt>    <comment type="block">/* lengths of grouping sets */</comment>
    <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>grouped_cols</name></decl>;</decl_stmt>    <comment type="block">/* column groupings for rollup */</comment>
    <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>eqfunctions</name></decl>;</decl_stmt>    <comment type="block">/* per-grouping-field equality fns */</comment>
    <decl_stmt><decl><type><name>Agg</name>           <modifier>*</modifier></type><name>aggnode</name></decl>;</decl_stmt>        <comment type="block">/* Agg node for phase data */</comment>
    <decl_stmt><decl><type><name>Sort</name>       <modifier>*</modifier></type><name>sortnode</name></decl>;</decl_stmt>        <comment type="block">/* Sort node for input ordering for phase */</comment>
}</block></struct></type>            <name>AggStatePerPhaseData</name>;</typedef>

<comment type="block">/*
 * AggStatePerHashData - per-hashtable state
 *
 * When doing grouping sets with hashing, we have one of these for each
 * grouping set. (When doing hashing without grouping sets, we have just one of
 * them.)
 */</comment>
<typedef>typedef <type><struct>struct <name>AggStatePerHashData</name>
<block>{
    <decl_stmt><decl><type><name>TupleHashTable</name></type> <name>hashtable</name></decl>;</decl_stmt>    <comment type="block">/* hash table with one entry per group */</comment>
    <decl_stmt><decl><type><name>TupleHashIterator</name></type> <name>hashiter</name></decl>;</decl_stmt> <comment type="block">/* for iterating through hash table */</comment>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>hashslot</name></decl>;</decl_stmt>    <comment type="block">/* slot for loading hash table */</comment>
    <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>hashfunctions</name></decl>;</decl_stmt>    <comment type="block">/* per-grouping-field hash fns */</comment>
    <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>eqfunctions</name></decl>;</decl_stmt>    <comment type="block">/* per-grouping-field equality fns */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>numCols</name></decl>;</decl_stmt>        <comment type="block">/* number of hash key columns */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>numhashGrpCols</name></decl>;</decl_stmt> <comment type="block">/* number of columns in hash table */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>largestGrpColIdx</name></decl>;</decl_stmt>    <comment type="block">/* largest col required for hashing */</comment>
    <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>hashGrpColIdxInput</name></decl>;</decl_stmt> <comment type="block">/* hash col indices in input slot */</comment>
    <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>hashGrpColIdxHash</name></decl>;</decl_stmt>    <comment type="block">/* indices in hashtbl tuples */</comment>
    <decl_stmt><decl><type><name>Agg</name>           <modifier>*</modifier></type><name>aggnode</name></decl>;</decl_stmt>        <comment type="block">/* original Agg node, for numGroups etc. */</comment>
}</block></struct></type>            <name>AggStatePerHashData</name>;</typedef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * used in ReDistributeInitializeDSM and ReDistributeInitializeWorker
 * to distinguish keys between shared memory for parallel and
 * shared memory for redistributed optimization, for parallel it's
 * plan_node_id the same as PG, for redistributed optimization, we
 * use plan_node_id + this macro
 *
 * Node: refer to execParallel.c, only the first 4 bits been occupied
 * for specific use, now we have to use an extra bit, but it's fine
 * since plan_node_id is only a 32bit integer.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_REDISTRIBUTE_OFFSET</name></cpp:macro> <cpp:value>UINT64CONST(0xE800000000000000)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>select_current_set</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>setno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_hash</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initialize_phase</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newphase</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>fetch_input_tuple</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initialize_aggregates</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
                      <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name></decl></parameter>,
                      <parameter><decl><type><name>int</name></type> <name>numReset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>advance_transition_function</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
                            <parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
                            <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>advance_aggregates</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name></decl></parameter>,
                   <parameter><decl><type><name>AggStatePerGroup</name> <modifier>*</modifier></type><name>pergroups</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>advance_combine_function</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
                         <parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
                         <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>combine_aggregates</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>process_ordered_aggregate_single</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
                                 <parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
                                 <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>process_ordered_aggregate_multi</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
                                <parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
                                <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>finalize_aggregate</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
                   <parameter><decl><type><name>AggStatePerAgg</name></type> <name>peragg</name></decl></parameter>,
                   <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>,
                   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resultVal</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resultIsNull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>finalize_partialaggregate</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
                          <parameter><decl><type><name>AggStatePerAgg</name></type> <name>peragg</name></decl></parameter>,
                          <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>,
                          <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resultVal</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resultIsNull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>prepare_projection_slot</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
                        <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
                        <parameter><decl><type><name>int</name></type> <name>currentSet</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>finalize_aggregates</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
                    <parameter><decl><type><name>AggStatePerAgg</name></type> <name>peragg</name></decl></parameter>,
                    <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>project_aggregates</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>find_unaggregated_cols</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>find_unaggregated_cols_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>colnos</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>build_hash_table</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleHashEntryData</name> <modifier>*</modifier></type><name>lookup_hash_entry</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AggStatePerGroup</name> <modifier>*</modifier></type><name>lookup_hash_entries</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>agg_retrieve_direct</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>agg_fill_hash_table</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>agg_retrieve_hash_table</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>GetAggInitVal</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>textInitVal</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>transtype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>build_pertrans_for_aggref</name><parameter_list>(<parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
                          <parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                          <parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>aggtransfn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>aggtranstype</name></decl></parameter>,
                          <parameter><decl><type><name>Oid</name></type> <name>aggserialfn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>aggdeserialfn</name></decl></parameter>,
                          <parameter><decl><type><name>Datum</name></type> <name>initValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>initValueIsNull</name></decl></parameter>,
                          <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>inputTypes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numArguments</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>find_compatible_peragg</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>newagg</name></decl></parameter>, <parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
                       <parameter><decl><type><name>int</name></type> <name>lastaggno</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>same_input_transnos</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>find_compatible_pertrans</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>newagg</name></decl></parameter>,
                         <parameter><decl><type><name>Oid</name></type> <name>aggtransfn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>aggtranstype</name></decl></parameter>,
                         <parameter><decl><type><name>Oid</name></type> <name>aggserialfn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>aggdeserialfn</name></decl></parameter>,
                         <parameter><decl><type><name>Datum</name></type> <name>initValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>initValueIsNull</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>transnos</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ReDistributeBufferFreeSize</name><parameter_list>(<parameter><decl><type><name>ReDistributeBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReDistributeBufferPutData</name><parameter_list>(<parameter><decl><type><name>ReDistributeBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dataLen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReDistributeBufferGetData</name><parameter_list>(<parameter><decl><type><name>ReDistributeBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dataLen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>RemoteDataRow</name> <modifier>*</modifier></type><name>datarow</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 * Select the current grouping set; affects current_set and
 * curaggcontext.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>select_current_set</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>setno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>is_hash</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name></name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>hashcontext</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name></name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>aggcontexts</name><index>[<expr><name>setno</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name> <operator>=</operator> <name>setno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Switch to phase "newphase", which must either be 0 or 1 (to reset) or
 * current_phase + 1. Juggle the tuplesorts accordingly.
 *
 * Phase 0 is for hashing, which we currently handle last in the AGG_MIXED
 * case, so when entering phase 0, all we need to do is drop open sorts.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initialize_phase</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newphase</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newphase</name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>||</operator> <name>newphase</name> <operator>==</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>current_phase</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Whatever the previous state, we're now done with whatever input
     * tuplesort was in use.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_in</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_in</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>newphase</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Discard any existing output tuplesort.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_out</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_out</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * The old output tuplesort becomes the new input one, and this is the
         * right time to actually sort it.
         */</comment>
        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_in</name></name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>sort_out</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_out</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * If this isn't the last phase, we need to sort appropriately for the
     * next phase in sequence.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>newphase</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>newphase</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numphases</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Sort</name>       <modifier>*</modifier></type><name>sortnode</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>phases</name><index>[<expr><name>newphase</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sortnode</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerNode</name> <init>= <expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupDesc</name> <init>= <expr><call><name>ExecGetResultType</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_out</name></name> <operator>=</operator> <call><name>tuplesort_begin_heap</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>,
                                                  <argument><expr><name><name>sortnode</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>,
                                                  <argument><expr><name><name>sortnode</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
                                                  <argument><expr><name><name>sortnode</name><operator>-&gt;</operator><name>sortOperators</name></name></expr></argument>,
                                                  <argument><expr><name><name>sortnode</name><operator>-&gt;</operator><name>collations</name></name></expr></argument>,
                                                  <argument><expr><name><name>sortnode</name><operator>-&gt;</operator><name>nullsFirst</name></name></expr></argument>,
                                                  <argument><expr><name>work_mem</name></expr></argument>,
                                                  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_phase</name></name> <operator>=</operator> <name>newphase</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>phases</name><index>[<expr><name>newphase</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch a tuple from either the outer plan (for phase 1) or from the sorter
 * populated by the previous phase.  Copy it to the sorter for the next phase
 * if any.
 *
 * Callers cannot rely on memory for tuple in returned slot remaining valid
 * past any subsequently fetched tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>fetch_input_tuple</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_in</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* make sure we check for interrupts in either path through here */</comment>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_gettupleslot</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_in</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                    <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_slot</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>sort_slot</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>sort_out</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>tuplesort_puttupleslot</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_out</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * (Re)Initialize an individual aggregate.
 *
 * This function handles only one grouping set, already set in
 * aggstate-&gt;current_set.
 *
 * When called, CurrentMemoryContext should be the per-query context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initialize_aggregate</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
                     <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * Start a fresh sort operation for each DISTINCT/ORDER BY aggregate.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>numSortCols</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * In case of rescan, maybe there could be an uncompleted sort
         * operation?  Clean it up if so.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


        <comment type="block">/*
         * We use a plain Datum sorter when there's a single input column;
         * otherwise sort the full tuple.  (See comments for
         * process_ordered_aggregate_single.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>numInputs</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name> <operator>=</operator>
                <call><name>tuplesort_begin_datum</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr></argument>,
                                      <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortOperators</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                                      <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortCollations</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                                      <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortNullsFirst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                                      <argument><expr><name>work_mem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name> <operator>=</operator>
                <call><name>tuplesort_begin_heap</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortdesc</name></name></expr></argument>,
                                     <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>numSortCols</name></name></expr></argument>,
                                     <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
                                     <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortOperators</name></name></expr></argument>,
                                     <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortCollations</name></name></expr></argument>,
                                     <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortNullsFirst</name></name></expr></argument>,
                                     <argument><expr><name>work_mem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * (Re)set transValue to the initial value.
     *
     * Note that when the initial value is pass-by-ref, we must copy it (into
     * the aggcontext) since we will pfree the transValue later.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>initValueIsNull</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>initValue</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(
                                           <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>initValue</name></name></expr></argument>,
                                              <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>,
                                              <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name> <operator>=</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>initValueIsNull</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * If the initial value for the transition state doesn't exist in the
     * pg_aggregate table then we will let the first non-NULL value returned
     * from the outer procNode become the initial value. (This is useful for
     * aggregates like max() and min().) The noTransValue flag signals that we
     * still need to do this.
     */</comment>
    <expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>noTransValue</name></name> <operator>=</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>initValueIsNull</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize all aggregate transition states for a new group of input values.
 *
 * If there are multiple grouping sets, we initialize only the first numReset
 * of them (the grouping sets are ordered so that the most specific one, which
 * is reset most often, is first). As a convenience, if numReset is 0, we
 * reinitialize all sets. numReset is -1 to initialize a hashtable entry, in
 * which case the caller must have used select_current_set appropriately.
 *
 * When called, CurrentMemoryContext should be the per-query context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initialize_aggregates</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
                      <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name></decl></parameter>,
                      <parameter><decl><type><name>int</name></type> <name>numReset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>transno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numGroupingSets</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>numsets</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>setno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numTrans</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>transstates</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>numReset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>numReset</name> <operator>=</operator> <name>numGroupingSets</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>transno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>transno</name> <operator>&lt;</operator> <name>numTrans</name></expr>;</condition> <incr><expr><name>transno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>transstates</name><index>[<expr><name>transno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>numReset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>pergroupstate</name> <operator>=</operator> <operator>&amp;</operator><name><name>pergroup</name><index>[<expr><name>transno</name></expr>]</index></name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>initialize_aggregate</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>pertrans</name></expr></argument>, <argument><expr><name>pergroupstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <for>for <control>(<init><expr><name>setno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>setno</name> <operator>&lt;</operator> <name>numReset</name></expr>;</condition> <incr><expr><name>setno</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>pergroupstate</name> <operator>=</operator> <operator>&amp;</operator><name><name>pergroup</name><index>[<expr><name>transno</name> <operator>+</operator> <operator>(</operator><name>setno</name> <operator>*</operator> <name>numTrans</name><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>select_current_set</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>setno</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>initialize_aggregate</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>pertrans</name></expr></argument>, <argument><expr><name>pergroupstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Given new input value(s), advance the transition function of one aggregate
 * state within one grouping set only (already set in aggstate-&gt;current_set)
 *
 * The new values (and null flags) have been preloaded into argument positions
 * 1 and up in pertrans-&gt;transfn_fcinfo, so that we needn't copy them again to
 * pass to the transition function.  We also expect that the static fields of
 * the fcinfo are already initialized; that was done by ExecInitAgg().
 *
 * It doesn't matter which memory context this is called in.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>advance_transition_function</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
                            <parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
                            <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn_fcinfo</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>newVal</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>transfn</name><operator>.</operator><name>fn_strict</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * For a strict transfn, nothing happens when there's a NULL input; we
         * just keep the prior transValue.
         */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>numTransInputs</name> <init>= <expr><name><name>pertrans</name><operator>-&gt;</operator><name>numTransInputs</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>numTransInputs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>noTransValue</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * transValue has not been initialized. This is the first non-NULL
             * input value. We use it as the initial value for transValue. (We
             * already checked that the agg's input type is binary-compatible
             * with its transtype, so straight copy here is OK.)
             *
             * We must copy the datum into aggcontext if it is pass-by-ref. We
             * do not need to pfree the old transValue, since it's NULL.
             */</comment>
            <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(
                                               <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                                  <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>,
                                                  <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>noTransValue</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Don't call a strict function with NULL inputs.  Note it is
             * possible to get here despite the above tests, if the transfn is
             * strict *and* returned a NULL on a prior cycle. If that happens
             * we will propagate the NULL all the way to the end.
             */</comment>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We run the transition functions in per-input-tuple memory context */</comment>
    <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* set up aggstate-&gt;curpertrans for AggGetAggref() */</comment>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curpertrans</name></name> <operator>=</operator> <name>pertrans</name></expr>;</expr_stmt>

    <comment type="block">/*
     * OK to call the transition function
     */</comment>
    <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>        <comment type="block">/* just in case transfn doesn't set it */</comment>

    <expr_stmt><expr><name>newVal</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curpertrans</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * If pass-by-ref datatype, must copy the new value into aggcontext and
     * free the prior transValue.  But if transfn returned a pointer to its
     * first input, we don't need to do anything.  Also, if transfn returned a
     * pointer to a R/W expanded object that is already a child of the
     * aggcontext, assume we can adopt that value without copying it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name> <operator>&amp;&amp;</operator>
        <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>DatumIsReadWriteExpandedObject</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>,
                                               <argument><expr><name>false</name></expr></argument>,
                                               <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                <call><name>MemoryContextGetParent</name><argument_list>(<argument><expr><call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>eoh_context</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CurrentMemoryContext</name></expr>)</condition><block type="pseudo"><block_content>
                 <comment type="block">/* do nothing */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>newVal</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>,
                                   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>,
                                   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>DatumIsReadWriteExpandedObject</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>,
                                               <argument><expr><name>false</name></expr></argument>,
                                               <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>DeleteExpandedObject</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <name>newVal</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Advance each aggregate transition state for one input tuple.  The input
 * tuple has been stored in tmpcontext-&gt;ecxt_outertuple, so that it is
 * accessible to ExecEvalExpr.
 *
 * We have two sets of transition states to handle: one for sorted aggregation
 * and one for hashed; we do them both here, to avoid multiple evaluation of
 * the inputs.
 *
 * When called, CurrentMemoryContext should be the per-query context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>advance_aggregates</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name></decl></parameter>, <parameter><decl><type><name>AggStatePerGroup</name> <modifier>*</modifier></type><name>pergroups</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>transno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>setno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numGroupingSets</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>numsets</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numHashes</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>num_hashes</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numTrans</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>evalslot</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* compute input for all aggregates */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>evalproj</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>evalslot</name></name> <operator>=</operator> <call><name>ExecProject</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>evalproj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>transno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>transno</name> <operator>&lt;</operator> <name>numTrans</name></expr>;</condition> <incr><expr><name>transno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name><index>[<expr><name>transno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>filter</name> <init>= <expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>numTransInputs</name> <init>= <expr><name><name>pertrans</name><operator>-&gt;</operator><name>numTransInputs</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>inputoff</name> <init>= <expr><name><name>pertrans</name><operator>-&gt;</operator><name>inputoff</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Skip anything FILTERed out */</comment>
        <if_stmt><if>if <condition>(<expr><name>filter</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Datum</name></type>        <name>res</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name></name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>isnull</name> <operator>||</operator> <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>numSortCols</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* DISTINCT and/or ORDER BY case */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>&gt;=</operator> <operator>(</operator><name><name>pertrans</name><operator>-&gt;</operator><name>numInputs</name></name> <operator>+</operator> <name>inputoff</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>pergroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If the transfn is strict, we want to check for nullity before
             * storing the row in the sorter, to save space if there are a lot
             * of nulls.  Note that we must only check numTransInputs columns,
             * not numInputs, since nullity in columns used only for sorting
             * is not relevant here.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>transfn</name><operator>.</operator><name>fn_strict</name></name></expr>)</condition>
            <block>{<block_content>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTransInputs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name> <operator>+</operator> <name>inputoff</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>numTransInputs</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <for>for <control>(<init><expr><name>setno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>setno</name> <operator>&lt;</operator> <name>numGroupingSets</name></expr>;</condition> <incr><expr><name>setno</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <comment type="block">/* OK, put the tuple into the tuplesort object */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>numInputs</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>tuplesort_putdatum</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name>setno</name></expr>]</index></name></expr></argument>,
                                       <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>inputoff</name></expr>]</index></name></expr></argument>,
                                       <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>inputoff</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/*
                     * Copy slot contents, starting from inputoff, into sort
                     * slot.
                     */</comment>
                    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortslot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortslot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>inputoff</name></expr>]</index></name></expr></argument>,
                           <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>numInputs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortslot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>inputoff</name></expr>]</index></name></expr></argument>,
                           <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>numInputs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortslot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>numInputs</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortslot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>tuplesort_puttupleslot</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name>setno</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortslot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* We can apply the transition function immediately */</comment>
            <decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn_fcinfo</name></name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Load values into fcinfo */</comment>
            <comment type="block">/* Start from 1, since the 0th arg will be the transition value */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>&gt;=</operator> <operator>(</operator><name>numTransInputs</name> <operator>+</operator> <name>inputoff</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTransInputs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name> <operator>+</operator> <name>inputoff</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name> <operator>+</operator> <name>inputoff</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></for>

            <if_stmt><if>if <condition>(<expr><name>pergroup</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* advance transition states for ordered grouping */</comment>

                <for>for <control>(<init><expr><name>setno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>setno</name> <operator>&lt;</operator> <name>numGroupingSets</name></expr>;</condition> <incr><expr><name>setno</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>select_current_set</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>setno</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>pergroupstate</name> <operator>=</operator> <operator>&amp;</operator><name><name>pergroup</name><index>[<expr><name>transno</name> <operator>+</operator> <operator>(</operator><name>setno</name> <operator>*</operator> <name>numTrans</name><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>advance_transition_function</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>pertrans</name></expr></argument>, <argument><expr><name>pergroupstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>pergroups</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* advance transition states for hashed grouping */</comment>

                <for>for <control>(<init><expr><name>setno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>setno</name> <operator>&lt;</operator> <name>numHashes</name></expr>;</condition> <incr><expr><name>setno</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>select_current_set</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>setno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<if_stmt><if>if <condition>(<expr><name>g_hybrid_hash_agg</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>AggStatePerHash</name></type> <name>perhash</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>hybrid</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name> <operator>=</operator> <name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>hybridcxt</name></name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><name>pergroupstate</name> <operator>=</operator> <operator>&amp;</operator><name><name>pergroups</name><index>[<expr><name>setno</name></expr>]</index><index>[<expr><name>transno</name></expr>]</index></name></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>advance_transition_function</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>pertrans</name></expr></argument>, <argument><expr><name>pergroupstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * combine_aggregates replaces advance_aggregates in DO_AGGSPLIT_COMBINE
 * mode.  The principal difference is that here we may need to apply the
 * deserialization function before running the transfn (which, in this mode,
 * is actually the aggregate's combinefn).  Also, we know we don't need to
 * handle FILTER, DISTINCT, ORDER BY, or grouping sets.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>combine_aggregates</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>transno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numTrans</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

    <comment type="block">/* combine not supported with grouping sets */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>numsets</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>g_hybrid_hash_agg</name></expr>)</condition>
	<block>{<block_content>	
		<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AggStatePerHash</name></type> <name>perhash</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>hybrid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name> <operator>=</operator> <name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>hybridcxt</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* compute input for all aggregates */</comment>
    <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProject</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>evalproj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>transno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>transno</name> <operator>&lt;</operator> <name>numTrans</name></expr>;</condition> <incr><expr><name>transno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name><index>[<expr><name>transno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name> <init>= <expr><operator>&amp;</operator><name><name>pergroup</name><index>[<expr><name>transno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn_fcinfo</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>inputoff</name> <init>= <expr><name><name>pertrans</name><operator>-&gt;</operator><name>inputoff</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>&gt;</operator> <name>inputoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * deserialfn_oid will be set if we must deserialize the input state
         * before calling the combine function
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>deserialfn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Don't call a strict deserialization function with NULL input */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>deserialfn</name><operator>.</operator><name>fn_strict</name></name> <operator>&amp;&amp;</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>inputoff</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>inputoff</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>inputoff</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>dsinfo</name> <init>= <expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>deserialfn_fcinfo</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>dsinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>inputoff</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dsinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>inputoff</name></expr>]</index></name></expr>;</expr_stmt>
                <comment type="block">/* Dummy second argument for type-safety reasons */</comment>
                <expr_stmt><expr><name><name>dsinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dsinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * We run the deserialization functions in per-input-tuple
                 * memory context.
                 */</comment>
                <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>dsinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>dsinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>inputoff</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>inputoff</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>advance_combine_function</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>pertrans</name></expr></argument>, <argument><expr><name>pergroupstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Perform combination of states between 2 aggregate states. Effectively this
 * 'adds' two states together by whichever logic is defined in the aggregate
 * function's combine function.
 *
 * Note that in this case transfn is set to the combination function. This
 * perhaps should be changed to avoid confusion, but one field is ok for now
 * as they'll never be needed at the same time.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>advance_combine_function</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
                         <parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
                         <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn_fcinfo</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>newVal</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>transfn</name><operator>.</operator><name>fn_strict</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* if we're asked to merge to a NULL state, then do nothing */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>noTransValue</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * transValue has not yet been initialized.  If pass-by-ref
             * datatype we must copy the combining state value into
             * aggcontext.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(
                                                   <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                                      <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>,
                                                      <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>noTransValue</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We run the combine functions in per-input-tuple memory context */</comment>
    <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* set up aggstate-&gt;curpertrans for AggGetAggref() */</comment>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curpertrans</name></name> <operator>=</operator> <name>pertrans</name></expr>;</expr_stmt>

    <comment type="block">/*
     * OK to call the combine function
     */</comment>
    <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>        <comment type="block">/* just in case combine func doesn't set it */</comment>

    <expr_stmt><expr><name>newVal</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curpertrans</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * If pass-by-ref datatype, must copy the new value into aggcontext and
     * free the prior transValue.  But if the combine function returned a
     * pointer to its first input, we don't need to do anything.  Also, if the
     * combine function returned a pointer to a R/W expanded object that is
     * already a child of the aggcontext, assume we can adopt that value
     * without copying it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name> <operator>&amp;&amp;</operator>
        <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>DatumIsReadWriteExpandedObject</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>,
                                               <argument><expr><name>false</name></expr></argument>,
                                               <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                <call><name>MemoryContextGetParent</name><argument_list>(<argument><expr><call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>eoh_context</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CurrentMemoryContext</name></expr>)</condition><block type="pseudo"><block_content>
                 <comment type="block">/* do nothing */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>newVal</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>,
                                   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>,
                                   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>DatumIsReadWriteExpandedObject</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>,
                                               <argument><expr><name>false</name></expr></argument>,
                                               <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>DeleteExpandedObject</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <name>newVal</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Run the transition function for a DISTINCT or ORDER BY aggregate
 * with only one input.  This is called after we have completed
 * entering all the input values into the sort object.  We complete the
 * sort, read out the values in sorted order, and run the transition
 * function on each value (applying DISTINCT if appropriate).
 *
 * Note that the strictness of the transition function was checked when
 * entering the values into the sort, so we don't check it again here;
 * we just apply standard SQL DISTINCT logic.
 *
 * The one-input case is handled separately from the multi-input case
 * for performance reasons: for single by-value inputs, such as the
 * common case of count(distinct id), the tuplesort_getdatum code path
 * is around 300% faster.  (The speedup for by-reference types is less
 * but still noticeable.)
 *
 * This function handles only one grouping set (already set in
 * aggstate-&gt;current_set).
 *
 * When called, CurrentMemoryContext should be the per-query context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_ordered_aggregate_single</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
                                 <parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
                                 <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>oldVal</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>oldIsNull</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>haveOldVal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>workcontext</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isDistinct</name> <init>= <expr><operator>(</operator><name><name>pertrans</name><operator>-&gt;</operator><name>numDistinctCols</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>newAbbrevVal</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>oldAbbrevVal</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn_fcinfo</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>newVal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>isNull</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>numDistinctCols</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Load the column into argument 1 (arg 0 will be transition value) */</comment>
    <expr_stmt><expr><name>newVal</name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>isNull</name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Note: if input type is pass-by-ref, the datums returned by the sort are
     * freshly palloc'd in the per-query context, so we must be careful to
     * pfree them when they are no longer needed.
     */</comment>

    <while>while <condition>(<expr><call><name>tuplesort_getdatum</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr></argument>,
                              <argument><expr><name>true</name></expr></argument>, <argument><expr><name>newVal</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newAbbrevVal</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Clear and select the working context for evaluation of the equality
         * function and transition function.
         */</comment>
        <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>workcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>workcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If DISTINCT mode, and not distinct from prior, skip it.
         *
         * Note: we assume equality functions don't care about collation.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>isDistinct</name> <operator>&amp;&amp;</operator>
            <name>haveOldVal</name> <operator>&amp;&amp;</operator>
            <operator>(</operator><operator>(</operator><name>oldIsNull</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>isNull</name><operator>)</operator> <operator>||</operator>
             <operator>(</operator><operator>!</operator><name>oldIsNull</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>isNull</name> <operator>&amp;&amp;</operator>
              <name>oldAbbrevVal</name> <operator>==</operator> <name>newAbbrevVal</name> <operator>&amp;&amp;</operator>
              <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>equalfns</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                                         <argument><expr><name>oldVal</name></expr></argument>, <argument><expr><operator>*</operator><name>newVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* equal to prior, so forget this one */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pertrans</name><operator>-&gt;</operator><name>inputtypeByVal</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><operator>*</operator><name>newVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>advance_transition_function</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>pertrans</name></expr></argument>, <argument><expr><name>pergroupstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* forget the old value, if any */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>oldIsNull</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pertrans</name><operator>-&gt;</operator><name>inputtypeByVal</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>oldVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* and remember the new one for subsequent equality checks */</comment>
            <expr_stmt><expr><name>oldVal</name> <operator>=</operator> <operator>*</operator><name>newVal</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>oldAbbrevVal</name> <operator>=</operator> <name>newAbbrevVal</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>oldIsNull</name> <operator>=</operator> <operator>*</operator><name>isNull</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>haveOldVal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>oldIsNull</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pertrans</name><operator>-&gt;</operator><name>inputtypeByVal</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>oldVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Run the transition function for a DISTINCT or ORDER BY aggregate
 * with more than one input.  This is called after we have completed
 * entering all the input values into the sort object.  We complete the
 * sort, read out the values in sorted order, and run the transition
 * function on each value (applying DISTINCT if appropriate).
 *
 * This function handles only one grouping set (already set in
 * aggstate-&gt;current_set).
 *
 * When called, CurrentMemoryContext should be the per-query context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_ordered_aggregate_multi</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
                                <parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
                                <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>workcontext</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn_fcinfo</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot1</name> <init>= <expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortslot</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot2</name> <init>= <expr><name><name>pertrans</name><operator>-&gt;</operator><name>uniqslot</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numTransInputs</name> <init>= <expr><name><name>pertrans</name><operator>-&gt;</operator><name>numTransInputs</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numDistinctCols</name> <init>= <expr><name><name>pertrans</name><operator>-&gt;</operator><name>numDistinctCols</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>newAbbrevVal</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>oldAbbrevVal</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>haveOldValue</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>slot2</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><call><name>tuplesort_gettupleslot</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr></argument>,
                                  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>slot1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newAbbrevVal</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Extract the first numTransInputs columns as datums to pass to the
         * transfn.  (This will help execTuplesMatch too, so we do it
         * immediately.)
         */</comment>
        <expr_stmt><expr><call><name>slot_getsomeattrs</name><argument_list>(<argument><expr><name>slot1</name></expr></argument>, <argument><expr><name>numTransInputs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>numDistinctCols</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
            <operator>!</operator><name>haveOldValue</name> <operator>||</operator>
            <name>newAbbrevVal</name> <operator>!=</operator> <name>oldAbbrevVal</name> <operator>||</operator>
            <operator>!</operator><call><name>execTuplesMatch</name><argument_list>(<argument><expr><name>slot1</name></expr></argument>, <argument><expr><name>slot2</name></expr></argument>,
                             <argument><expr><name>numDistinctCols</name></expr></argument>,
                             <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
                             <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>equalfns</name></name></expr></argument>,
                             <argument><expr><name>workcontext</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Load values into fcinfo */</comment>
            <comment type="block">/* Start from 1, since the 0th arg will be the transition value */</comment>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTransInputs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>slot1</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>slot1</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name>advance_transition_function</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>pertrans</name></expr></argument>, <argument><expr><name>pergroupstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>numDistinctCols</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* swap the slot pointers to retain the current tuple */</comment>
                <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tmpslot</name> <init>= <expr><name>slot2</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>slot2</name> <operator>=</operator> <name>slot1</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>slot1</name> <operator>=</operator> <name>tmpslot</name></expr>;</expr_stmt>
                <comment type="block">/* avoid execTuplesMatch() calls by reusing abbreviated keys */</comment>
                <expr_stmt><expr><name>oldAbbrevVal</name> <operator>=</operator> <name>newAbbrevVal</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>haveOldValue</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Reset context each time, unless execTuplesMatch did it for us */</comment>
        <if_stmt><if>if <condition>(<expr><name>numDistinctCols</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>workcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>slot2</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute the final value of one aggregate.
 *
 * This function handles only one grouping set (already set in
 * aggstate-&gt;current_set).
 *
 * The finalfunction will be run, and the result delivered, in the
 * output-tuple context; caller's CurrentMemoryContext does not matter.
 *
 * The finalfn uses the state as set in the transno. This also might be
 * being used by another aggregate function, so it's important that we do
 * nothing destructive here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>finalize_aggregate</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
                   <parameter><decl><type><name>AggStatePerAgg</name></type> <name>peragg</name></decl></parameter>,
                   <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>,
                   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resultVal</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resultIsNull</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>FunctionCallInfoData</name></type> <name>fcinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>anynull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name><index>[<expr><name><name>peragg</name><operator>-&gt;</operator><name>transno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Evaluate any direct arguments.  We do this even if there's no finalfn
     * (which is unlikely anyway), so that side-effects happen as expected.
     * The direct arguments go into arg positions 1 and up, leaving position 0
     * for the transition state value.
     */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pertrans-&gt;aggdirectargs</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>fcinfo</name><operator>.</operator><name>arg</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>,
                                     <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>anynull</name> <operator>|=</operator> <name><name>fcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Apply the agg's finalfn if one is provided, else return transValue.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>peragg</name><operator>-&gt;</operator><name>finalfn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>numFinalArgs</name> <init>= <expr><name><name>peragg</name><operator>-&gt;</operator><name>numFinalArgs</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* set up aggstate-&gt;curpertrans for AggGetAggref() */</comment>
        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curpertrans</name></name> <operator>=</operator> <name>pertrans</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>peragg</name><operator>-&gt;</operator><name>finalfn</name></name></expr></argument>,
                                 <argument><expr><name>numFinalArgs</name></expr></argument>,
                                 <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggCollation</name></name></expr></argument>,
                                 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>aggstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Fill in the transition state value */</comment>
        <expr_stmt><expr><name><name>fcinfo</name><operator>.</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>MakeExpandedObjectReadOnly</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>,
                                                   <argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr></argument>,
                                                   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>anynull</name> <operator>|=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>

        <comment type="block">/* Fill any remaining argument positions with nulls */</comment>
        <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numFinalArgs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>fcinfo</name><operator>.</operator><name>arg</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>anynull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>.</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_strict</name></name> <operator>&amp;&amp;</operator> <name>anynull</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* don't call a strict function with NULL inputs */</comment>
            <expr_stmt><expr><operator>*</operator><name>resultVal</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>resultIsNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>resultVal</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>resultIsNull</name> <operator>=</operator> <name><name>fcinfo</name><operator>.</operator><name>isnull</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curpertrans</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Don't need MakeExpandedObjectReadOnly; datumCopy will copy it */</comment>
        <expr_stmt><expr><operator>*</operator><name>resultVal</name> <operator>=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>resultIsNull</name> <operator>=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * If result is pass-by-ref, make sure it is in the right context.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>peragg</name><operator>-&gt;</operator><name>resulttypeByVal</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>resultIsNull</name> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>MemoryContextContains</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                               <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><operator>*</operator><name>resultVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>resultVal</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><operator>*</operator><name>resultVal</name></expr></argument>,
                               <argument><expr><name><name>peragg</name><operator>-&gt;</operator><name>resulttypeByVal</name></name></expr></argument>,
                               <argument><expr><name><name>peragg</name><operator>-&gt;</operator><name>resulttypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute the output value of one partial aggregate.
 *
 * The serialization function will be run, and the result delivered, in the
 * output-tuple context; caller's CurrentMemoryContext does not matter.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>finalize_partialaggregate</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
                          <parameter><decl><type><name>AggStatePerAgg</name></type> <name>peragg</name></decl></parameter>,
                          <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>,
                          <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resultVal</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resultIsNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name><index>[<expr><name><name>peragg</name><operator>-&gt;</operator><name>transno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * serialfn_oid will be set if we must serialize the transvalue before
     * returning it
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>serialfn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Don't call a strict serialization function with NULL input. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>serialfn</name><operator>.</operator><name>fn_strict</name></name> <operator>&amp;&amp;</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>resultVal</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>resultIsNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>serialfn_fcinfo</name></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>MakeExpandedObjectReadOnly</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>,
                                                        <argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr></argument>,
                                                        <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><operator>*</operator><name>resultVal</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>resultIsNull</name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Don't need MakeExpandedObjectReadOnly; datumCopy will copy it */</comment>
        <expr_stmt><expr><operator>*</operator><name>resultVal</name> <operator>=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>resultIsNull</name> <operator>=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* If result is pass-by-ref, make sure it is in the right context. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>peragg</name><operator>-&gt;</operator><name>resulttypeByVal</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>resultIsNull</name> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>MemoryContextContains</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                               <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><operator>*</operator><name>resultVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>resultVal</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><operator>*</operator><name>resultVal</name></expr></argument>,
                               <argument><expr><name><name>peragg</name><operator>-&gt;</operator><name>resulttypeByVal</name></name></expr></argument>,
                               <argument><expr><name><name>peragg</name><operator>-&gt;</operator><name>resulttypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare to finalize and project based on the specified representative tuple
 * slot and grouping set.
 *
 * In the specified tuple slot, force to null all attributes that should be
 * read as null in the context of the current grouping set.  Also stash the
 * current group bitmap where GroupingExpr can get at it.
 *
 * This relies on three conditions:
 *
 * 1) Nothing is ever going to try and extract the whole tuple from this slot,
 * only reference it in evaluations, which will only access individual
 * attributes.
 *
 * 2) No system columns are going to need to be nulled. (If a system column is
 * referenced in a group clause, it is actually projected in the outer plan
 * tlist.)
 *
 * 3) Within a given phase, we never need to recover the value of an attribute
 * once it has been set to null.
 *
 * Poking into the slot this way is a bit ugly, but the consensus is that the
 * alternative was worse.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>prepare_projection_slot</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>currentSet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>grouped_cols</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>grouped_cols</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>grouped_cols</name><index>[<expr><name>currentSet</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>grouped_cols</name></name> <operator>=</operator> <name>grouped_cols</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isempty</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Force all values to be NULL if working on an empty input tuple
             * (i.e. an empty grouping set for which no input rows were
             * supplied).
             */</comment>
            <expr_stmt><expr><call><name>ExecStoreAllNullTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>all_grouped_cols</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

            <comment type="block">/* all_grouped_cols is arranged in desc order */</comment>
            <expr_stmt><expr><call><name>slot_getsomeattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><call><name>linitial_int</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>all_grouped_cols</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>aggstate-&gt;all_grouped_cols</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>grouped_cols</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute the final value of all aggregates for one group.
 *
 * This function handles only one grouping set at a time, which the caller must
 * have selected.  It's also the caller's responsibility to adjust the supplied
 * pergroup parameter to point to the current set's transvalues.
 *
 * Results are stored in the output econtext aggvalues/aggnulls.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>finalize_aggregates</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
                    <parameter><decl><type><name>AggStatePerAgg</name></type> <name>peraggs</name></decl></parameter>,
                    <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>aggvalues</name> <init>= <expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggvalues</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>aggnulls</name> <init>= <expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggnulls</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>aggno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>transno</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If there were any DISTINCT and/or ORDER BY aggregates, sort their
     * inputs and run the transition functions.
     */</comment>
    <for>for <control>(<init><expr><name>transno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>transno</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name></expr>;</condition> <incr><expr><name>transno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name><index>[<expr><name>transno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>pergroupstate</name> <operator>=</operator> <operator>&amp;</operator><name><name>pergroup</name><index>[<expr><name>transno</name></expr>]</index></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>numSortCols</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_HASHED</name> <operator>&amp;&amp;</operator>
                   <name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_MIXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>numInputs</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>process_ordered_aggregate_single</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>,
                                                 <argument><expr><name>pertrans</name></expr></argument>,
                                                 <argument><expr><name>pergroupstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>process_ordered_aggregate_multi</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>,
                                                <argument><expr><name>pertrans</name></expr></argument>,
                                                <argument><expr><name>pergroupstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Run the final functions.
     */</comment>
    <for>for <control>(<init><expr><name>aggno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>aggno</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numaggs</name></name></expr>;</condition> <incr><expr><name>aggno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AggStatePerAgg</name></type> <name>peragg</name> <init>= <expr><operator>&amp;</operator><name><name>peraggs</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>transno</name> <init>= <expr><name><name>peragg</name><operator>-&gt;</operator><name>transno</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>pergroupstate</name> <operator>=</operator> <operator>&amp;</operator><name><name>pergroup</name><index>[<expr><name>transno</name></expr>]</index></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_SKIPFINAL</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>finalize_partialaggregate</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>peragg</name></expr></argument>, <argument><expr><name>pergroupstate</name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name><name>aggvalues</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aggnulls</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>finalize_aggregate</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>peragg</name></expr></argument>, <argument><expr><name>pergroupstate</name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name><name>aggvalues</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aggnulls</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Project the result of a group (whose aggs have already been calculated by
 * finalize_aggregates). Returns the result slot, or NULL if no row is
 * projected (suppressed by qual).
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>project_aggregates</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Check the qual (HAVING clause); if the group does not match, ignore it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ExecQual</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Form and return projection tuple using the aggregate results and
         * the representative input tuple.
         */</comment>
        <return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>InstrCountFiltered1</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_unaggregated_cols
 *      Construct a bitmapset of the column numbers of un-aggregated Vars
 *      appearing in our targetlist and qual (HAVING clause)
 */</comment>
<function><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type>
<name>find_unaggregated_cols</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Agg</name>           <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>colnos</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>colnos</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>find_unaggregated_cols_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>colnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>find_unaggregated_cols_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>colnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>colnos</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>find_unaggregated_cols_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>colnos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Var</name>           <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* setrefs.c should have set the varno to OUTER_VAR */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>OUTER_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>colnos</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><operator>*</operator><name>colnos</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call> <operator>||</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* do not descend into aggregate exprs */</comment>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>find_unaggregated_cols_walker</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>colnos</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the hash table(s) to empty.
 *
 * To implement hashed aggregation, we need a hashtable that stores a
 * representative tuple and an array of AggStatePerGroup structs for each
 * distinct set of GROUP BY column values.  We compute the hash key from the
 * GROUP BY columns.  The per-group data is allocated in lookup_hash_entry(),
 * for each entry.
 *
 * We have a separate hashtable and associated perhash data structure for each
 * grouping set for which we're doing hashing.
 *
 * The hash tables always live in the hashcontext's per-tuple memory context
 * (there is only one of these for all tables together, since they are all
 * reset at the same time).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>build_hash_table</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>tmpmem</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>additionalsize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name> <operator>||</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_MIXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>additionalsize</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerGroupData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>num_hashes</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AggStatePerHash</name></type> <name>perhash</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>aggnode</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>=</operator> <call><name>BuildTupleHashTable</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>,
                                                 <argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashGrpColIdxHash</name></name></expr></argument>,
                                                 <argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>eqfunctions</name></name></expr></argument>,
                                                 <argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashfunctions</name></name></expr></argument>,
                                                 <argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>aggnode</name><operator>-&gt;</operator><name>numGroups</name></name></expr></argument>,
                                                 <argument><expr><name>additionalsize</name></expr></argument>,
                                                 <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>hashcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>,
                                                 <argument><expr><name>tmpmem</name></expr></argument>,
                                                 <argument><expr><call><name>DO_AGGSPLIT_SKIPFINAL</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name><name>perhash</name><operator>-&gt;</operator><name>aggnode</name><operator>-&gt;</operator><name>hybrid</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* set entry size of each hashtable */</comment>
			<expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>actual_entrysize</name></name> <operator>=</operator> <name><name>perhash</name><operator>-&gt;</operator><name>aggnode</name><operator>-&gt;</operator><name>entrySize</name></name></expr>;</expr_stmt>

			<comment type="block">/* 
			 * recalculate the max buckets fit in memory and 
			 * number of batch files
			 */</comment>
			<expr_stmt><expr><call><name>OptimizeHybridHashtableSize</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>, <argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>aggnode</name><operator>-&gt;</operator><name>entrySize</name></name></expr></argument>, 
				                        <argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>aggnode</name><operator>-&gt;</operator><name>numGroups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Compute columns that actually need to be stored in hashtable entries.  The
 * incoming tuples from the child plan node will contain grouping columns,
 * other columns referenced in our targetlist and qual, columns used to
 * compute the aggregate functions, and perhaps just junk columns we don't use
 * at all.  Only columns of the first two types need to be stored in the
 * hashtable, and getting rid of the others can make the table entries
 * significantly smaller.  The hashtable only contains the relevant columns,
 * and is packed/unpacked in lookup_hash_entry() / agg_retrieve_hash_table()
 * into the format of the normal input descriptor.
 *
 * Additional columns, in addition to the columns grouped by, come from two
 * sources: Firstly functionally dependent columns that we don't need to group
 * by themselves, and secondly ctids for row-marks.
 *
 * To eliminate duplicates, we build a bitmapset of the needed columns, and
 * then build an array of the columns included in the hashtable.  Note that
 * the array is preserved over ExecReScanAgg, so we allocate it in the
 * per-query context (unlike the hash table itself).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>find_hash_columns</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>base_colnos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>outerTlist</name> <init>= <expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numHashes</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>num_hashes</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

    <comment type="block">/* Find Vars that will be needed in tlist and qual */</comment>
    <expr_stmt><expr><name>base_colnos</name> <operator>=</operator> <call><name>find_unaggregated_cols</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numHashes</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AggStatePerHash</name></type> <name>perhash</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>colnos</name> <init>= <expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>base_colnos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>grpColIdx</name> <init>= <expr><name><name>perhash</name><operator>-&gt;</operator><name>aggnode</name><operator>-&gt;</operator><name>grpColIdx</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>hashTlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>hashDesc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>largestGrpColIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/*
         * If we're doing grouping sets, then some Vars might be referenced in
         * tlist/qual for the benefit of other grouping sets, but not needed
         * when hashing; i.e. prepare_projection_slot will null them out, so
         * there'd be no point storing them.  Use prepare_projection_slot's
         * logic to determine which.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>phases</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>grouped_cols</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>grouped_cols</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>phases</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>grouped_cols</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>aggstate-&gt;all_grouped_cols</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>grouped_cols</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>colnos</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>colnos</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Add in all the grouping columns */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>perhash</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name>colnos</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>colnos</name></expr></argument>, <argument><expr><name><name>grpColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashGrpColIdxInput</name></name> <operator>=</operator>
            <call><name>palloc</name><argument_list>(<argument><expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>colnos</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashGrpColIdxHash</name></name> <operator>=</operator>
            <call><name>palloc</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>numCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * First build mapping for columns directly hashed. These are the
         * first, because they'll be accessed when computing hash values and
         * comparing tuples for exact matches. We also build simple mapping
         * for execGrouping, so it knows where to find the to-be-hashed /
         * compared columns in the input.
         */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>perhash</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashGrpColIdxInput</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>grpColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashGrpColIdxHash</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>numhashGrpCols</name></name><operator>++</operator></expr>;</expr_stmt>
            <comment type="block">/* delete already mapped columns */</comment>
            <expr_stmt><expr><call><name>bms_del_member</name><argument_list>(<argument><expr><name>colnos</name></expr></argument>, <argument><expr><name><name>grpColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/* and add the remaining columns */</comment>
        <while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_first_member</name><argument_list>(<argument><expr><name>colnos</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashGrpColIdxInput</name><index>[<expr><name><name>perhash</name><operator>-&gt;</operator><name>numhashGrpCols</name></name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>numhashGrpCols</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>

        <comment type="block">/* and build a tuple descriptor for the hashtable */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>perhash</name><operator>-&gt;</operator><name>numhashGrpCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>varNumber</name> <init>= <expr><name><name>perhash</name><operator>-&gt;</operator><name>hashGrpColIdxInput</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>hashTlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>hashTlist</name></expr></argument>, <argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>outerTlist</name></expr></argument>, <argument><expr><name>varNumber</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>largestGrpColIdx</name></name> <operator>=</operator>
                <call><name>Max</name><argument_list>(<argument><expr><name>varNumber</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>largestGrpColIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name>hashDesc</name> <operator>=</operator> <call><name>ExecTypeFromTL</name><argument_list>(<argument><expr><name>hashTlist</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashslot</name></name></expr></argument>, <argument><expr><name>hashDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>hashTlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>colnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>base_colnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate per-hash-table-entry overhead for the planner.
 *
 * Note that the estimate does not include space for pass-by-reference
 * transition data values, nor for the representative tuple of each group.
 * Nor does this account of the target fill-factor and growth policy of the
 * hash table.
 */</comment>
<function><type><name>Size</name></type>
<name>hash_agg_entry_size</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numAggs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type>        <name>entrysize</name></decl>;</decl_stmt>

    <comment type="block">/* This must match build_hash_table */</comment>
    <expr_stmt><expr><name>entrysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TupleHashEntryData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
        <name>numAggs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerGroupData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>entrysize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>entrysize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>entrysize</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find or create a hashtable entry for the tuple group containing the current
 * tuple (already set in tmpcontext's outertuple slot), in the current grouping
 * set (which the caller must have selected - note that initialize_aggregate
 * depends on this).
 *
 * When called, CurrentMemoryContext should be the per-query context.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleHashEntryData</name> <modifier>*</modifier></type>
<name>lookup_hash_entry</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>inputslot</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AggStatePerHash</name></type> <name>perhash</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>hashslot</name> <init>= <expr><name><name>perhash</name><operator>-&gt;</operator><name>hashslot</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleHashEntryData</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnew</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* transfer just the needed columns into hashslot */</comment>
    <expr_stmt><expr><call><name>slot_getsomeattrs</name><argument_list>(<argument><expr><name>inputslot</name></expr></argument>, <argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>largestGrpColIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>hashslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>perhash</name><operator>-&gt;</operator><name>numhashGrpCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>varNumber</name> <init>= <expr><name><name>perhash</name><operator>-&gt;</operator><name>hashGrpColIdxInput</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>hashslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>inputslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>varNumber</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>inputslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>varNumber</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>hashslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* find or create the hashtable entry using the filtered tuple */</comment>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>LookupTupleHashEntry</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>, <argument><expr><name>hashslot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>hybrid</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* use our own context */</comment>
		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name> <operator>=</operator> <name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>hybridcxt</name></name></expr>;</expr_stmt>
		
		<comment type="block">/*
		 * hashtable is full, dump the hashtable, then reuse
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* dump hashtable */</comment>
			<expr_stmt><expr><call><name>DumpHybridHashtable</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* find or create the hashtable entry using the filtered tuple */</comment>
			<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>LookupTupleHashEntry</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>, <argument><expr><name>hashslot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find entry in hybrid-hashtable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find entry in hashtable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>isnew</name></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>hybrid</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>additional</name></name> <operator>=</operator> <operator>(</operator><name>AggStatePerGroup</name><operator>)</operator>
				<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>hybridcxt</name></name></expr></argument>,
								   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerGroupData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>additional</name></name> <operator>=</operator> <operator>(</operator><name>AggStatePerGroup</name><operator>)</operator>
				<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>tablecxt</name></name></expr></argument>,
								   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerGroupData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>additional</name></name> <operator>=</operator> <operator>(</operator><name>AggStatePerGroup</name><operator>)</operator>
            <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>tablecxt</name></name></expr></argument>,
                               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerGroupData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* initialize aggregates for new tuple group */</comment>
        <expr_stmt><expr><call><name>initialize_aggregates</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><operator>(</operator><name>AggStatePerGroup</name><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>additional</name></name></expr></argument>,
                              <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Look up hash entries for the current tuple in all hashed grouping sets,
 * returning an array of pergroup pointers suitable for advance_aggregates.
 *
 * Be aware that lookup_hash_entry can reset the tmpcontext.
 */</comment>
<function><type><specifier>static</specifier> <name>AggStatePerGroup</name> <modifier>*</modifier></type>
<name>lookup_hash_entries</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>numHashes</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>num_hashes</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AggStatePerGroup</name> <modifier>*</modifier></type><name>pergroup</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>hash_pergroup</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>setno</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>setno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>setno</name> <operator>&lt;</operator> <name>numHashes</name></expr>;</condition> <incr><expr><name>setno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>select_current_set</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>setno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pergroup</name><index>[<expr><name>setno</name></expr>]</index></name> <operator>=</operator> <call><name>lookup_hash_entry</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>additional</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>pergroup</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_hashtable_if_spilled</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>setno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numHashes</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>num_hashes</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>setno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>setno</name> <operator>&lt;</operator> <name>numHashes</name></expr>;</condition> <incr><expr><name>setno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AggStatePerHash</name></type> <name>perhash</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><name>setno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>spilled</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>DumpHybridHashtable</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LoadHybridHashtable</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>perhash</name><operator>-&gt;</operator><name>hashiter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HybridHashtableLoadDone</name><parameter_list>(<parameter><decl><type><name>TupleHashTable</name></type> <name>hashtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	
	<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>spilled</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SpillSet</name> <modifier>*</modifier></type><name>spill_set</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>spill_set</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>spill_set</name> <operator>||</operator> <operator>(</operator><name><name>spill_set</name><operator>-&gt;</operator><name>current_file</name></name> <operator>&gt;=</operator> <name><name>spill_set</name><operator>-&gt;</operator><name>num_files</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>spill_set</name><operator>-&gt;</operator><name>parent_spill_set</name></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ResetHybridHashtable</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
 * get max number of buckets of hashtable in memory.
 * If not all fit in memory, get the batch file's number.
 */</comment>
<function><type><name>void</name></type>
<name>OptimizeHybridHashtableSize</name><parameter_list>(<parameter><decl><type><name>TupleHashTable</name></type> <name>hashtable</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>entrySize</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>numGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>nbatches</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>nentries</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>max_mem</name> <init>= <expr><name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* not all tuples fit in memory */</comment>
	<if_stmt><if>if <condition>(<expr><name>max_mem</name> <operator>&lt;=</operator> <name>entrySize</name> <operator>*</operator> <name>numGroups</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nentries</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>max_mem</name><operator>/</operator><name>entrySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbatches</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>numGroups</name><operator>/</operator><name>nentries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>nentries</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>max_mem</name><operator>/</operator><name>entrySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>nbatches</name> <operator>=</operator> <name>g_default_hashagg_nbatches</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatches</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>nbatches</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spilled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spill_set</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nentries</name></name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator><name>nentries</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tuplehash_set_hybrid</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashtab</name></name></expr></argument>, <argument><expr><name>nentries</name></expr></argument>, <argument><expr><name>nbatches</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hybridcxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>tablecxt</name></name></expr></argument>,
											     <argument><expr><literal type="string">"HybridContext"</literal></expr></argument>,
												 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hybrid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>g_hybrid_hash_agg_debug</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Hybrid-hashagg hashtable details: max_entries %u, nbatches %d, entry_size %u, max_mem %ld"</literal></expr></argument>,
			      <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nentries</name></name></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatches</name></name></expr></argument>, <argument><expr><name>entrySize</name></expr></argument>, <argument><expr><name>max_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * hashtable is full, write the hashtable into files, then reuse it
 */</comment>
<function><type><name>void</name></type>
<name>DumpHybridHashtable</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>TupleHashTable</name></type> <name>hashtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>spill_file_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleHashIterator</name></type> <name>hashiter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>temp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleHashEntryData</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpillSet</name> <modifier>*</modifier></type><name>spill_set</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* prepare the spillset for write first time */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>hashtable</name><operator>-&gt;</operator><name>spilled</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spilled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>old</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>tablecxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spill_set</name></name> <operator>=</operator> <operator>(</operator><name>SpillSet</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpillSet</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spill_set</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spill_set</name><operator>-&gt;</operator><name>num_files</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatches</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spill_set</name><operator>-&gt;</operator><name>parent_index</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spill_set</name><operator>-&gt;</operator><name>parent_spill_set</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spill_set</name><operator>-&gt;</operator><name>current_file</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spill_set</name><operator>-&gt;</operator><name>spill_file</name></name> <operator>=</operator> <operator>(</operator><name>SpillFile</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpillFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatches</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>g_hybrid_hash_agg_debug</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"hybrid hashtable spilled: level %d, num_files %d, parent_index %d"</literal></expr></argument>,
				       <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spill_set</name><operator>-&gt;</operator><name>level</name></name></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spill_set</name><operator>-&gt;</operator><name>num_files</name></name></expr></argument>,
				       <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spill_set</name><operator>-&gt;</operator><name>parent_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* write hashtable out */</comment>
	<expr_stmt><expr><name>spill_set</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spill_set</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hybridcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>InitTupleHashIterator</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hashiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>ScanTupleHashTable</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hashiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>entry</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type> <name>total_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type> <name>write_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SpillFile</name> <modifier>*</modifier></type><name>spill_file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>hash</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>hash</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>trans_values</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<comment type="block">/* 
		 * FIXME: we use mod to get the batch index, any other ways to 
		 * make tuples balance in batch files
		 */</comment>
		<expr_stmt><expr><name>spill_file_index</name> <operator>=</operator> <name>hash</name> <operator>%</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatches</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>spill_set</name><operator>-&gt;</operator><name>spill_file</name><index>[<expr><name>spill_file_index</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>old</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>tablecxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
			<expr_stmt><expr><name><name>spill_set</name><operator>-&gt;</operator><name>spill_file</name><index>[<expr><name>spill_file_index</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>SpillFile</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpillFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>spill_set</name><operator>-&gt;</operator><name>spill_file</name><index>[<expr><name>spill_file_index</name></expr>]</index></name><operator>-&gt;</operator><name>ntups_read</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>spill_set</name><operator>-&gt;</operator><name>spill_file</name><index>[<expr><name>spill_file_index</name></expr>]</index></name><operator>-&gt;</operator><name>ntups_write</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>spill_set</name><operator>-&gt;</operator><name>spill_file</name><index>[<expr><name>spill_file_index</name></expr>]</index></name><operator>-&gt;</operator><name>spilled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>spill_set</name><operator>-&gt;</operator><name>spill_file</name><index>[<expr><name>spill_file_index</name></expr>]</index></name><operator>-&gt;</operator><name>child_spill_set</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>spill_set</name><operator>-&gt;</operator><name>spill_file</name><index>[<expr><name>spill_file_index</name></expr>]</index></name><operator>-&gt;</operator><name>file</name> <operator>=</operator> <call><name>BufFileCreateTemp</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>spill_file</name> <operator>=</operator> <name><name>spill_set</name><operator>-&gt;</operator><name>spill_file</name><index>[<expr><name>spill_file_index</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BufFileWrite</name><argument_list>(<argument><expr><name><name>spill_file</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>hash</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DumpHybridHashtable:could not write hash key to bufFile temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>total_size</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>firstTuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>aggno</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type> <name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerGroupData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>groupstate</name> <init>= <expr><operator>(</operator><name>AggStatePerGroup</name><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>additional</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>transstates</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>total_size</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
			
			<for>for <control>(<init><expr><name>aggno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>aggno</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name></expr>;</condition> <incr><expr><name>aggno</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>transstates</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name> <init>= <expr><operator>&amp;</operator><name><name>groupstate</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Size</name></type> <name>datum_size</name> <init>= <expr><call><name>datumGetSize</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>,
													   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>,
													   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name>total_size</name> <operator>+=</operator> <name>datum_size</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<comment type="block">/* internal type or const */</comment>
					<else>else
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>==</operator> <name>INTERNALOID</name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>serial_func_fcinfo</name></name></expr></init></decl>;</decl_stmt>
							
							<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>serial_func_id</name></name></expr></argument>)</argument_list></call></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not serialize the transition value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>

							<if_stmt><if>if <condition>(<expr><operator>!</operator><name>trans_values</name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name>trans_values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>

							<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>MakeExpandedObjectReadOnly</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>,
																		<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr></argument>,
																		<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>

							<expr_stmt><expr><name><name>trans_values</name><index>[<expr><name>aggno</name></expr>]</index></name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><name>total_size</name> <operator>+=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>trans_values</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BufFileWrite</name><argument_list>(<argument><expr><name><name>spill_file</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>total_size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>total_size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>total_size</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DumpHybridHashtable:could not write total size to bufFile temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		
		<if_stmt><if>if <condition>(<expr><call><name>BufFileWrite</name><argument_list>(<argument><expr><name><name>spill_file</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>firstTuple</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>firstTuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>entry</name><operator>-&gt;</operator><name>firstTuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DumpHybridHashtable:could not write MinimalTuple to bufFile temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>write_len</name> <operator>+=</operator> <name><name>entry</name><operator>-&gt;</operator><name>firstTuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>aggno</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type> <name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerGroupData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>groupstate</name> <init>= <expr><operator>(</operator><name>AggStatePerGroup</name><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>additional</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>transstates</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>BufFileWrite</name><argument_list>(<argument><expr><name><name>spill_file</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>additional</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>size</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DumpHybridHashtable:could not write AggStatePerGroupData to bufFile temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>write_len</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>aggno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>aggno</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name></expr>;</condition> <incr><expr><name>aggno</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>transstates</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name> <init>= <expr><operator>&amp;</operator><name><name>groupstate</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Size</name></type> <name>datum_size</name> <init>= <expr><call><name>datumGetSize</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>,
													   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>,
													   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						
						<if_stmt><if>if <condition>(<expr><call><name>BufFileWrite</name><argument_list>(<argument><expr><name><name>spill_file</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>datum_size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>datum_size</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DumpHybridHashtable:could not write transValue to bufFile temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<expr_stmt><expr><name>write_len</name> <operator>+=</operator> <name>datum_size</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<comment type="block">/* internal type or const */</comment>
					<else>else
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>==</operator> <name>INTERNALOID</name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>Size</name></type> <name>datum_size</name> <init>= <expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>trans_values</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>BufFileWrite</name><argument_list>(<argument><expr><name><name>spill_file</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>trans_values</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>datum_size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>datum_size</name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
										<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
										 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DumpHybridHashtable:could not write transValue to bufFile temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>

							<expr_stmt><expr><name>write_len</name> <operator>+=</operator> <name>datum_size</name></expr>;</expr_stmt>

							<comment type="block">/* need to free memory allocated for internal type */</comment>
							<comment type="line">//pfree(trans_values[aggno]); /* assume that won't occupy much memory, reset will handle it */</comment>
							<expr_stmt><expr><name><name>trans_values</name><index>[<expr><name>aggno</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>write_len</name> <operator>!=</operator> <name>total_size</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"DumpHybridHashtable: write_len %lu does not match total_size %lu"</literal></expr></argument>,
				         <argument><expr><name>write_len</name></expr></argument>, <argument><expr><name>total_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>spill_file</name><operator>-&gt;</operator><name>ntups_write</name></name><operator>++</operator></expr>;</expr_stmt>
		
		<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>ScanTupleHashTable</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hashiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
	<comment type="block">/* reset hashtable */</comment>
	<expr_stmt><expr><call><name>tuplehash_reset</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* reset memorycontext for hashtable contents */</comment>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hybridcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>combine_transition</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
						 <parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
						 <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>combfn_fcinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>newVal</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>combfn</name><operator>.</operator><name>fn_strict</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if we're asked to merge to a NULL state, then do nothing */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
		<comment type="block">/* we always have value */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
		if (pergroupstate-&gt;noTransValue)
		{
			<comment type="block">/*
			 * transValue has not yet been initialized.  If pass-by-ref
			 * datatype we must copy the combining state value into
			 * aggcontext.
			 */</comment>
			if (!pertrans-&gt;transtypeByVal)
			{
				oldContext = MemoryContextSwitchTo(
												   aggstate-&gt;curaggcontext-&gt;ecxt_per_tuple_memory);
				pergroupstate-&gt;transValue = datumCopy(fcinfo-&gt;arg[1],
													  pertrans-&gt;transtypeByVal,
													  pertrans-&gt;transtypeLen);
				MemoryContextSwitchTo(oldContext);
			}
			else
				pergroupstate-&gt;transValue = fcinfo-&gt;arg[1];

			pergroupstate-&gt;transValueIsNull = false;
			pergroupstate-&gt;noTransValue = false;
			return;
		}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We run the combine functions in per-input-tuple memory context */</comment>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set up aggstate-&gt;curpertrans for AggGetAggref() */</comment>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curpertrans</name></name> <operator>=</operator> <name>pertrans</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * OK to call the combine function
	 */</comment>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>		<comment type="block">/* just in case combine func doesn't set it */</comment>

	<expr_stmt><expr><name>newVal</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curpertrans</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If pass-by-ref datatype, must copy the new value into aggcontext and
	 * free the prior transValue.  But if the combine function returned a
	 * pointer to its first input, we don't need to do anything.  Also, if the
	 * combine function returned a pointer to a R/W expanded object that is
	 * already a child of the aggcontext, assume we can adopt that value
	 * without copying it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name> <operator>&amp;&amp;</operator>
		<call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>DatumIsReadWriteExpandedObject</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>MemoryContextGetParent</name><argument_list>(<argument><expr><call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>eoh_context</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CurrentMemoryContext</name></expr>)</condition><block type="pseudo"><block_content>
				 <comment type="block">/* do nothing */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>newVal</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>,
								   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>,
								   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>DatumIsReadWriteExpandedObject</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>DeleteExpandedObject</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="line">//else</comment>
				<comment type="line">//pfree(DatumGetPointer(pergroupstate-&gt;transValue));</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <name>newVal</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>LoadHybridHashtable</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>TupleHashTable</name></type> <name>hashtable</name></decl></parameter>, <parameter><decl><type><name>TupleHashIterator</name> <modifier>*</modifier></type><name>hashiter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<label><name>RETRY</name>:</label>
	<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>spilled</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SpillSet</name> <modifier>*</modifier></type><name>spill_set</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>spill_set</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>spill_set</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>spill_set</name><operator>-&gt;</operator><name>current_file</name></name> <operator>&lt;</operator> <name><name>spill_set</name><operator>-&gt;</operator><name>num_files</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Size</name></type> <name>total_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>uint32</name></type> <name>hashkey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>size_t</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TupleHashEntryData</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>SpillFile</name> <modifier>*</modifier></type><name>spill_file</name> <init>= <expr><name><name>spill_set</name><operator>-&gt;</operator><name>spill_file</name><index>[<expr><name><name>spill_set</name><operator>-&gt;</operator><name>current_file</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>spill_set</name><operator>-&gt;</operator><name>current_file</name></name><operator>++</operator></expr>;</expr_stmt>

				<comment type="block">/* get readable file */</comment>
				<while>while <condition>(<expr><operator>!</operator><name>spill_file</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>spill_set</name><operator>-&gt;</operator><name>current_file</name></name> <operator>&gt;=</operator> <name><name>spill_set</name><operator>-&gt;</operator><name>num_files</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spill_set</name></name> <operator>=</operator> <operator>(</operator><name>SpillSet</name> <operator>*</operator><operator>)</operator><name><name>spill_set</name><operator>-&gt;</operator><name>parent_spill_set</name></name></expr>;</expr_stmt>
						<goto>goto <name>RETRY</name>;</goto>
					</block_content>}</block></if></if_stmt>
						
					<expr_stmt><expr><name>spill_file</name> <operator>=</operator> <name><name>spill_set</name><operator>-&gt;</operator><name>spill_file</name><index>[<expr><name><name>spill_set</name><operator>-&gt;</operator><name>current_file</name></name></expr>]</index></name></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>spill_set</name><operator>-&gt;</operator><name>current_file</name></name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></while>

				<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>hybridcxt</name></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>spill_file</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rewind hybrid-hashtable temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
					
				<comment type="block">/* read all */</comment>
				<while>while <condition>(<expr><name>true</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>BufFileRead</name><argument_list>(<argument><expr><name><name>spill_file</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>hashkey</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hashkey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* read done */</comment>
						<expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>spill_file</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* sanity check */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>spill_file</name><operator>-&gt;</operator><name>ntups_read</name></name> <operator>!=</operator> <name><name>spill_file</name><operator>-&gt;</operator><name>ntups_write</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"data corrupted in spill file, read tups %u, write tups %u"</literal></expr></argument>,
								         <argument><expr><name><name>spill_file</name><operator>-&gt;</operator><name>ntups_read</name></name></expr></argument>, <argument><expr><name><name>spill_file</name><operator>-&gt;</operator><name>ntups_write</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>spill_file</name><operator>-&gt;</operator><name>spilled</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spill_set</name></name> <operator>=</operator> <operator>(</operator><name>SpillSet</name> <operator>*</operator><operator>)</operator><name><name>spill_file</name><operator>-&gt;</operator><name>child_spill_set</name></name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<expr_stmt><expr><call><name>InitTupleHashIterator</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>hashiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>hashkey</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"LoadHybridHashtable:could not read hash key from bufFile temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
										
					<if_stmt><if>if <condition>(<expr><call><name>BufFileRead</name><argument_list>(<argument><expr><name><name>spill_file</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>total_size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>total_size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>total_size</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"LoadHybridHashtable:could not read total size from bufFile temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hybridcxt</name></name></expr></argument>, <argument><expr><name>total_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>BufFileRead</name><argument_list>(<argument><expr><name><name>spill_file</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>total_size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>total_size</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"LoadHybridHashtable:could not read PerGroupData from bufFile temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name><name>spill_file</name><operator>-&gt;</operator><name>ntups_read</name></name><operator>++</operator></expr>;</expr_stmt>

					<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>MinimalTuple</name><operator>)</operator><name>buffer</name></expr>;</expr_stmt>

					<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name>buffer</name> <operator>+</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>tempcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>old</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>tempcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>ExecStoreMinimalTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>inputslot</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>tuplehash_insert_with_key</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashtab</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>, <argument><expr><name>hashkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* merge */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>int</name></type> <name>aggno</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>Size</name></type> <name>datum_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

							<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name> <init>= <expr><operator>(</operator><name>AggStatePerGroup</name><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>additional</name></name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>merge_pergroup</name> <init>= <expr><operator>(</operator><name>AggStatePerGroup</name><operator>)</operator><name>buffer</name></expr></init></decl>;</decl_stmt>
							<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name>buffer</name> <operator>+</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerGroupData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name><operator>)</operator></expr>;</expr_stmt>
							
							<for>for <control>(<init><expr><name>aggno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>aggno</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name></expr>;</condition> <incr><expr><name>aggno</name><operator>++</operator></expr></incr>)</control>
							<block>{<block_content>
								<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
								<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name> <init>= <expr><operator>&amp;</operator><name><name>pergroup</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
								<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>merge_pergroupstate</name> <init>= <expr><operator>&amp;</operator><name><name>merge_pergroup</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
								<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>combfn_fcinfo</name></name></expr></init></decl>;</decl_stmt>

								<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>merge_pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>)</condition>
								<block>{<block_content>
									<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr>)</condition>
									<block>{<block_content>
										<expr_stmt><expr><name><name>merge_pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										
										<expr_stmt><expr><name>datum_size</name> <operator>=</operator> <call><name>datumGetSize</name><argument_list>(<argument><expr><name><name>merge_pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>,
																   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>,
																   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name>buffer</name> <operator>+</operator> <name>datum_size</name></expr>;</expr_stmt>
									</block_content>}</block></if>
									<else>else
									<block>{<block_content>
										<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>==</operator> <name>INTERNALOID</name></expr>)</condition>
										<block>{<block_content>
											<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>dsinfo</name> <init>= <expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>deserial_func_fcinfo</name></name></expr></init></decl>;</decl_stmt>
											
											<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>deserial_func_id</name></name></expr></argument>)</argument_list></call></expr>)</condition>
											<block>{<block_content>
												<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not deserial transition value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
											</block_content>}</block></if></if_stmt>

											<expr_stmt><expr><name><name>dsinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><empty_stmt>;</empty_stmt>
											<expr_stmt><expr><name><name>dsinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
											<comment type="block">/* Dummy second argument for type-safety reasons */</comment>
											<expr_stmt><expr><name><name>dsinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
											<expr_stmt><expr><name><name>dsinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

											<expr_stmt><expr><name>datum_size</name> <operator>=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>dsinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

											<expr_stmt><expr><name><name>merge_pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>dsinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

											<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name>buffer</name> <operator>+</operator> <name>datum_size</name></expr>;</expr_stmt>
										</block_content>}</block></if></if_stmt>
									</block_content>}</block></else></if_stmt>
								</block_content>}</block></if></if_stmt>

								<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>merge_pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>merge_pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>

								<expr_stmt><expr><call><name>combine_transition</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>pertrans</name></expr></argument>, <argument><expr><name>pergroupstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></for>
						</block_content>}</block></if></if_stmt>

						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* dump hashtable */</comment>
							<decl_stmt><decl><type><name>int</name></type> <name>file_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>SpillFile</name> <modifier>*</modifier></type><name>sfile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>SpillSet</name> <modifier>*</modifier></type><name>spillset</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>spill_file</name><operator>-&gt;</operator><name>spilled</name></name></expr>)</condition>
							<block>{<block_content>
								<decl_stmt><decl><type><name>MemoryContext</name></type> <name>temp</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>tablecxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
								
								<expr_stmt><expr><name>spillset</name> <operator>=</operator> <operator>(</operator><name>SpillSet</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpillSet</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								
								<expr_stmt><expr><name><name>spill_file</name><operator>-&gt;</operator><name>spilled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>spill_file</name><operator>-&gt;</operator><name>child_spill_set</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>spillset</name></expr>;</expr_stmt>

								<expr_stmt><expr><name><name>spillset</name><operator>-&gt;</operator><name>current_file</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>spillset</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <name><name>spill_set</name><operator>-&gt;</operator><name>level</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>spillset</name><operator>-&gt;</operator><name>num_files</name></name> <operator>=</operator> <name><name>spill_set</name><operator>-&gt;</operator><name>num_files</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>spillset</name><operator>-&gt;</operator><name>parent_index</name></name> <operator>=</operator> <name><name>spill_set</name><operator>-&gt;</operator><name>current_file</name></name></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>spillset</name><operator>-&gt;</operator><name>parent_spill_set</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>spill_set</name></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>spillset</name><operator>-&gt;</operator><name>spill_file</name></name> <operator>=</operator> <operator>(</operator><name>SpillFile</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpillFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>spillset</name><operator>-&gt;</operator><name>num_files</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

								<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

								<if_stmt><if>if <condition>(<expr><name>g_hybrid_hash_agg_debug</name></expr>)</condition>
								<block>{<block_content>
									<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"spill file into new set: level %d, num files %d"</literal></expr></argument>, <argument><expr><name><name>spillset</name><operator>-&gt;</operator><name>level</name></name></expr></argument>, <argument><expr><name><name>spillset</name><operator>-&gt;</operator><name>num_files</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								</block_content>}</block></if></if_stmt>
							</block_content>}</block></if></if_stmt>

							<expr_stmt><expr><name>spillset</name> <operator>=</operator> <operator>(</operator><name>SpillSet</name> <operator>*</operator><operator>)</operator><name><name>spill_file</name><operator>-&gt;</operator><name>child_spill_set</name></name></expr>;</expr_stmt>

							<expr_stmt><expr><name>file_index</name> <operator>=</operator> <name>hashkey</name> <operator>%</operator> <name><name>spillset</name><operator>-&gt;</operator><name>num_files</name></name></expr>;</expr_stmt>

							<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>spillset</name><operator>-&gt;</operator><name>spill_file</name><index>[<expr><name>file_index</name></expr>]</index></name></expr>)</condition>
							<block>{<block_content>
								<decl_stmt><decl><type><name>MemoryContext</name></type> <name>temp</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>tablecxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
								
								<expr_stmt><expr><name><name>spillset</name><operator>-&gt;</operator><name>spill_file</name><index>[<expr><name>file_index</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>SpillFile</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpillFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

								<expr_stmt><expr><name><name>spillset</name><operator>-&gt;</operator><name>spill_file</name><index>[<expr><name>file_index</name></expr>]</index></name><operator>-&gt;</operator><name>ntups_read</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>spillset</name><operator>-&gt;</operator><name>spill_file</name><index>[<expr><name>file_index</name></expr>]</index></name><operator>-&gt;</operator><name>ntups_write</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>spillset</name><operator>-&gt;</operator><name>spill_file</name><index>[<expr><name>file_index</name></expr>]</index></name><operator>-&gt;</operator><name>spilled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>spillset</name><operator>-&gt;</operator><name>spill_file</name><index>[<expr><name>file_index</name></expr>]</index></name><operator>-&gt;</operator><name>child_spill_set</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>spillset</name><operator>-&gt;</operator><name>spill_file</name><index>[<expr><name>file_index</name></expr>]</index></name><operator>-&gt;</operator><name>file</name> <operator>=</operator> <call><name>BufFileCreateTemp</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

								<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>

							<expr_stmt><expr><name>sfile</name> <operator>=</operator> <name><name>spillset</name><operator>-&gt;</operator><name>spill_file</name><index>[<expr><name>file_index</name></expr>]</index></name></expr>;</expr_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>BufFileWrite</name><argument_list>(<argument><expr><name><name>sfile</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>hashkey</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hashkey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>hashkey</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
										<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
										 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"LoadHybridHashtable:could not write hash key to bufFile temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>BufFileWrite</name><argument_list>(<argument><expr><name><name>sfile</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>total_size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>total_size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>total_size</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
										<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
										 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"LoadHybridHashtable:could not write total size to bufFile temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>BufFileWrite</name><argument_list>(<argument><expr><name><name>sfile</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>tuple</name></expr></argument>, <argument><expr><name>total_size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>total_size</name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
										<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
										 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"LoadHybridHashtable:could not write buffer to bufFile temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>

							<expr_stmt><expr><name><name>sfile</name><operator>-&gt;</operator><name>ntups_write</name></name><operator>++</operator></expr>;</expr_stmt>

							<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<comment type="block">/* new entry */</comment>
							<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>firstTuple</name></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>

							<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
							<block>{<block_content>
								<decl_stmt><decl><type><name>int</name></type> <name>aggno</name></decl>;</decl_stmt>
								<decl_stmt><decl><type><name>Size</name></type> <name>datum_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
								<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>groupstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
								<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>transstates</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name></name></expr></init></decl>;</decl_stmt>

								<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>additional</name></name> <operator>=</operator> <operator>(</operator><name>AggStatePerGroup</name><operator>)</operator><name>buffer</name></expr>;</expr_stmt>

								<expr_stmt><expr><name>groupstate</name> <operator>=</operator> <operator>(</operator><name>AggStatePerGroup</name><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>additional</name></name></expr>;</expr_stmt>

								<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name>buffer</name> <operator>+</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerGroupData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name><operator>)</operator></expr>;</expr_stmt>

								<for>for <control>(<init><expr><name>aggno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>aggno</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name></expr>;</condition> <incr><expr><name>aggno</name><operator>++</operator></expr></incr>)</control>
								<block>{<block_content>
									<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>transstates</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
									<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name> <init>= <expr><operator>&amp;</operator><name><name>groupstate</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

									<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>)</condition>
									<block>{<block_content>
										<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr>)</condition>
										<block>{<block_content>
											<expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
											
											<expr_stmt><expr><name>datum_size</name> <operator>=</operator> <call><name>datumGetSize</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>,
																	   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>,
																	   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
											<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name>buffer</name> <operator>+</operator> <name>datum_size</name></expr>;</expr_stmt>
										</block_content>}</block></if>
										<else>else <comment type="block">/* internal type or const */</comment>
										<block>{<block_content>
											<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>==</operator> <name>INTERNALOID</name></expr>)</condition>
											<block>{<block_content>
												<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
												<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>dsinfo</name> <init>= <expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>deserial_func_fcinfo</name></name></expr></init></decl>;</decl_stmt>
												
												<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>deserial_func_id</name></name></expr></argument>)</argument_list></call></expr>)</condition>
												<block>{<block_content>
													<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not deserial transition value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
												</block_content>}</block></if></if_stmt>

												<expr_stmt><expr><name><name>dsinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><empty_stmt>;</empty_stmt>
												<expr_stmt><expr><name><name>dsinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
												<comment type="block">/* Dummy second argument for type-safety reasons */</comment>
												<expr_stmt><expr><name><name>dsinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
												<expr_stmt><expr><name><name>dsinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

												<expr_stmt><expr><name>datum_size</name> <operator>=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>dsinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
													
												<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hybridcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

												<expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>dsinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

												<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

												<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name>buffer</name> <operator>+</operator> <name>datum_size</name></expr>;</expr_stmt>
											</block_content>}</block></if></if_stmt>
										</block_content>}</block></else></if_stmt>
									</block_content>}</block></if></if_stmt>
								</block_content>}</block></for>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></else></if_stmt>
					</block_content>}</block></else></if_stmt>

					<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></while>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spill_set</name></name> <operator>=</operator> <operator>(</operator><name>SpillSet</name> <operator>*</operator><operator>)</operator><name><name>spill_set</name><operator>-&gt;</operator><name>parent_spill_set</name></name></expr>;</expr_stmt>
				<goto>goto <name>RETRY</name>;</goto>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ResetHybridHashtable</name><parameter_list>(<parameter><decl><type><name>TupleHashTable</name></type> <name>hashtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* reset hashtable */</comment>
	<expr_stmt><expr><call><name>tuplehash_reset</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* reset memorycontext for hashtable contents */</comment>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hybridcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * ExecAgg -
 *
 *      ExecAgg receives tuples from its outer subplan and aggregates over
 *      the appropriate attribute for each aggregate function use (Aggref
 *      node) appearing in the targetlist or qual of the node.  The number
 *      of tuples to aggregate over depends on whether grouped or plain
 *      aggregation is selected.  In grouped aggregation, we produce a result
 *      row for each group; in plain aggregation there's a single result row
 *      for the whole query.  In either case, the value of each aggregate is
 *      stored in the expression context to be used when ExecProject evaluates
 *      the result tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecAgg</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>AggState</name>   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AggState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>agg_done</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Dispatch based on strategy */</comment>
        <switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>aggstrategy</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>AGG_HASHED</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>table_filled</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>agg_fill_hash_table</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <comment type="block">/* FALLTHROUGH */</comment>
            <case>case <expr><name>AGG_MIXED</name></expr>:</case>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>agg_retrieve_hash_table</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>AGG_PLAIN</name></expr>:</case>
            <case>case <expr><name>AGG_SORTED</name></expr>:</case>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>agg_retrieve_direct</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecAgg for non-hashed case
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>agg_retrieve_direct</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Agg</name>           <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>aggnode</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>tmpcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AggStatePerAgg</name></type> <name>peragg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AggStatePerGroup</name> <modifier>*</modifier></type><name>hash_pergroups</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerslot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>firstSlot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>hasGroupingSets</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>numsets</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numGroupingSets</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>numsets</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>currentSet</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nextSetSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numReset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * get state info from node
     *
     * econtext is the per-output-tuple expression context
     *
     * tmpcontext is the per-input-tuple expression context
     */</comment>
    <expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmpcontext</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>peragg</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>peragg</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pergroup</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>pergroup</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>firstSlot</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * We loop retrieving groups until we find one matching
     * aggstate-&gt;ss.ps.qual
     *
     * For grouping sets, we have the invariant that aggstate-&gt;projected_set
     * is either -1 (initial call) or the index (starting from 0) in
     * gset_lengths for the group we just completed (either by projecting a
     * row or by discarding it in the qual).
     */</comment>
    <while>while <condition>(<expr><operator>!</operator><name><name>aggstate</name><operator>-&gt;</operator><name>agg_done</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Clear the per-output-tuple context for each group, as well as
         * aggcontext (which contains any pass-by-ref transvalues of the old
         * group).  Some aggregate functions store working state in child
         * contexts; those now get reset automatically without us needing to
         * do anything special.
         *
         * We use ReScanExprContext not just ResetExprContext because we want
         * any registered shutdown callbacks to be called.  That allows
         * aggregate functions to ensure they've cleaned up any non-memory
         * resources.
         */</comment>
        <expr_stmt><expr><call><name>ReScanExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Determine how many grouping sets need to be reset at this boundary.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>&lt;</operator> <name>numGroupingSets</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>numReset</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>numReset</name> <operator>=</operator> <name>numGroupingSets</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * numReset can change on a phase boundary, but that's OK; we want to
         * reset the contexts used in _this_ phase, and later, after possibly
         * changing phase, initialize the right number of aggregates for the
         * _new_ phase.
         */</comment>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numReset</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ReScanExprContext</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggcontexts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/*
         * Check if input is complete and there are no more groups to project
         * in this phase; move to next phase or mark as done.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>input_done</name></name> <operator>==</operator> <name>true</name> <operator>&amp;&amp;</operator>
            <name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>&gt;=</operator> <operator>(</operator><name>numGroupingSets</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_phase</name></name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numphases</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>initialize_phase</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_phase</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>input_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>numGroupingSets</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>numsets</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>aggnode</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>numReset</name> <operator>=</operator> <name>numGroupingSets</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_MIXED</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Mixed mode; we've output all the grouped stuff and have
                 * full hashtables, so switch to outputting those.
                 */</comment>
                <expr_stmt><expr><call><name>initialize_phase</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>table_filled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ResetTupleHashIterator</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hashtable</name></expr></argument>,
                                       <argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hashiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>select_current_set</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><call><name>agg_retrieve_hash_table</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>agg_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Get the number of columns in the next grouping set after the last
         * projected one (if any). This is the number of columns to compare to
         * see if we reached the boundary of that set too.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>&lt;</operator> <operator>(</operator><name>numGroupingSets</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>nextSetSize</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>gset_lengths</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>nextSetSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*----------
         * If a subgroup for the current grouping set is present, project it.
         *
         * We have a new group if:
         *    - we're out of input but haven't projected all grouping sets
         *      (checked above)
         * OR
         *      - we already projected a row that wasn't from the last grouping
         *        set
         *      AND
         *      - the next grouping set has at least one grouping column (since
         *        empty grouping sets project only once input is exhausted)
         *      AND
         *      - the previous and pending rows differ on the grouping columns
         *        of the next grouping set
         *----------
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>input_done</name></name> <operator>||</operator>
            <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_PLAIN</name> <operator>&amp;&amp;</operator>
             <name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
             <name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>&lt;</operator> <operator>(</operator><name>numGroupingSets</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator>
             <name>nextSetSize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
             <operator>!</operator><call><name>execTuplesMatch</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name></expr></argument>,
                              <argument><expr><name><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name></expr></argument>,
                              <argument><expr><name>nextSetSize</name></expr></argument>,
                              <argument><expr><name><name>node</name><operator>-&gt;</operator><name>grpColIdx</name></name></expr></argument>,
                              <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>eqfunctions</name></name></expr></argument>,
                              <argument><expr><name><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>&lt;</operator> <name>numGroupingSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nextSetSize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>input_done</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * We no longer care what group we just projected, the next
             * projection will always be the first (or only) grouping set
             * (unless the input proves to be empty).
             */</comment>
            <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <comment type="block">/*
             * If we don't already have the first tuple of the new group,
             * fetch it from the outer plan.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>outerslot</name> <operator>=</operator> <call><name>fetch_input_tuple</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * Make a copy of the first input tuple; we will use this
                     * for comparisons (in group mode) and for projection.
                     */</comment>
                    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>=</operator> <call><name>ExecCopySlotTuple</name><argument_list>(<argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* outer plan produced no tuples at all */</comment>
                    <if_stmt><if>if <condition>(<expr><name>hasGroupingSets</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * If there was no input at all, we need to project
                         * rows only if there are grouping sets of size 0.
                         * Note that this implies that there can't be any
                         * references to ungrouped Vars, which would otherwise
                         * cause issues with the empty output slot.
                         *
                         * XXX: This is no longer true, we currently deal with
                         * this in finalize_aggregates().
                         */</comment>
                        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>input_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                        <while>while <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>gset_lengths</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>&gt;=</operator> <name>numGroupingSets</name></expr>)</condition>
                            <block>{<block_content>
                                <comment type="block">/*
                                 * We can't set agg_done here because we might
                                 * have more phases to do, even though the
                                 * input is empty. So we need to restart the
                                 * whole outer loop.
                                 */</comment>
                                <break>break;</break>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></while>

                        <if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>&gt;=</operator> <name>numGroupingSets</name></expr>)</condition><block type="pseudo"><block_content>
                            <continue>continue;</continue></block_content></block></if></if_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>agg_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <comment type="block">/* If we are grouping, we should produce no tuples too */</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_PLAIN</name></expr>)</condition><block type="pseudo"><block_content>
                            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Initialize working state for a new input tuple group.
             */</comment>
            <expr_stmt><expr><call><name>initialize_aggregates</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>pergroup</name></expr></argument>, <argument><expr><name>numReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Store the copied first input tuple in the tuple table slot
                 * reserved for it.  The tuple will be deleted when it is
                 * cleared from the slot.
                 */</comment>
                <expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>grp_firstTuple</name></name></expr></argument>,
                               <argument><expr><name>firstSlot</name></expr></argument>,
                               <argument><expr><name>InvalidBuffer</name></expr></argument>,
                               <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>    <comment type="block">/* don't keep two pointers */</comment>

                <comment type="block">/* set up for first advance_aggregates call */</comment>
                <expr_stmt><expr><name><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>firstSlot</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Process each outer-plan tuple, and then fetch the next one,
                 * until we exhaust the outer plan or cross a group boundary.
                 */</comment>
                <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
                <block>{<block_content>
                    <comment type="block">/*
                     * During phase 1 only of a mixed agg, we need to update
                     * hashtables as well in advance_aggregates.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_MIXED</name> <operator>&amp;&amp;</operator>
                        <name><name>aggstate</name><operator>-&gt;</operator><name>current_phase</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>hash_pergroups</name> <operator>=</operator> <call><name>lookup_hash_entries</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>hash_pergroups</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_COMBINE</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>combine_aggregates</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>pergroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>advance_aggregates</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>pergroup</name></expr></argument>, <argument><expr><name>hash_pergroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                    <comment type="block">/* Reset per-input-tuple context after each tuple */</comment>
                    <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>tmpcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>outerslot</name> <operator>=</operator> <call><name>fetch_input_tuple</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
						<if_stmt><if>if <condition>(<expr><name>g_hybrid_hash_agg</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>dump_hashtable_if_spilled</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <comment type="block">/* no more outer-plan tuples available */</comment>
                        <if_stmt><if>if <condition>(<expr><name>hasGroupingSets</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>input_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>agg_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                    <comment type="block">/* set up for next advance_aggregates call */</comment>
                    <expr_stmt><expr><name><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>outerslot</name></expr>;</expr_stmt>

                    <comment type="block">/*
                     * If we are grouping, check whether we've crossed a group
                     * boundary.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_PLAIN</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>execTuplesMatch</name><argument_list>(<argument><expr><name>firstSlot</name></expr></argument>,
                                             <argument><expr><name>outerslot</name></expr></argument>,
                                             <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>,
                                             <argument><expr><name><name>node</name><operator>-&gt;</operator><name>grpColIdx</name></name></expr></argument>,
                                             <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>eqfunctions</name></name></expr></argument>,
                                             <argument><expr><name><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>=</operator> <call><name>ExecCopySlotTuple</name><argument_list>(<argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Use the representative input tuple for any references to
             * non-aggregated input columns in aggregate direct args, the node
             * qual, and the tlist.  (If we are not grouping, and there are no
             * input rows at all, we will come here with an empty firstSlot
             * ... but if not grouping, there can't be any references to
             * non-aggregated input columns, so no problem.)
             */</comment>
            <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>firstSlot</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>currentSet</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>prepare_projection_slot</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name></expr></argument>, <argument><expr><name>currentSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>select_current_set</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>currentSet</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>finalize_aggregates</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>,
                            <argument><expr><name>peragg</name></expr></argument>,
                            <argument><expr><name>pergroup</name> <operator>+</operator> <operator>(</operator><name>currentSet</name> <operator>*</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If there's no row to project right now, we must continue rather
         * than returning a null since there might be more groups.
         */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>project_aggregates</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* No more groups */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecAgg for hashed case: read input and build hash table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>agg_fill_hash_table</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerslot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>tmpcontext</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>AttrNumber</name></type> <name>varattno</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>                <name>dataType</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* get the redistribution hashfunc for parallel execution */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AttrNumber</name></type> <name>group_col</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name>      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            
        <if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_HASHED</name> <operator>||</operator> 
            <call><name>list_length</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>all_grouped_cols</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"plan mismatched while redistributing data across "</literal>
                          <literal type="string">"parallel workers."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/*
        * all_grouped_cols was sorted by AttributeNum in descending order, get
        * first group-by column in targetlist .
        *
        * TODO: choose column with better distribution to avoid data skew
        * within parallel workers
        */</comment>
        <expr_stmt><expr><name>group_col</name> <operator>=</operator> <call><name>llast_int</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>all_grouped_cols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>group_col</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid group by AttrNumber %d found while "</literal>
                         <literal type="string">"redistributing data across parallel workers."</literal></expr></argument>, <argument><expr><name>group_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * get DataType and AttrNumber of the redistribution group-by column
		 * from outer plan
		 */</comment>
		<expr_stmt><expr><name>tle</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><call><name>list_nth_cell</name><argument_list>(
				   <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>group_col</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>dataType</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>varattno</name> <operator>=</operator> <name>group_col</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>hashfunc</name></name> <operator>=</operator> <call><name>hash_func_ptr</name><argument_list>(<argument><expr><name>dataType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>dataType</name></name> <operator>=</operator> <name>dataType</name></expr>;</expr_stmt>

		<comment type="block">/* could not find hash function for given data type */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>aggstate</name><operator>-&gt;</operator><name>hashfunc</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find hash function for given data type:%u"</literal></expr></argument>,
					<argument><expr><name>dataType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* initialize resources */</comment>
		<expr_stmt><expr><call><name>InitializeReDistribute</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
												 <argument><expr><literal type="string">"ExecAgg temp memoryContext"</literal></expr></argument>,
												 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"worker:%d redistributed in HashAgg."</literal></expr></argument>, <argument><expr><name>ParallelWorkerNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Process each outer-plan tuple, and then fetch the next one, until we
     * exhaust the outer plan.
     */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AggStatePerGroup</name> <modifier>*</modifier></type><name>pergroups</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>outerslot</name> <operator>=</operator> <call><name>fetch_input_tuple</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>)</condition>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>BufFile</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ReDistributeDataType</name></type> <name>dataType</name> <init>= <expr><name>DT_None</name></expr></init></decl>;</decl_stmt>
                
                <expr_stmt><expr><call><name>ReDistributeShareBufFile</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>GetReDistributeBufFile</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dataType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>dataslot</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><call><name>CreateTupleDescCopyConstr</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>dataslot</name></name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <while>while<condition>(<expr><call><name>GetReDistributeData</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>, 
                    <argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>dataslot</name></name></expr></argument>, <argument><expr><name>dataType</name></expr></argument>, <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* set up for lookup_hash_entries and advance_aggregates */</comment>
                    <expr_stmt><expr><name><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>dataslot</name></name></expr>;</expr_stmt>

                    <comment type="block">/* Find or build hashtable entries */</comment>
                    <expr_stmt><expr><name>pergroups</name> <operator>=</operator> <call><name>lookup_hash_entries</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* Advance the aggregates */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_COMBINE</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>combine_aggregates</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name><name>pergroups</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>advance_aggregates</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pergroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                    <comment type="block">/*
                     * Reset per-input-tuple context after each tuple, but note that the
                     * hash lookups do this too
                     */</comment>
                    <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></while>

                <comment type="block">/* sanity check */</comment>
                <expr_stmt><expr><call><name>ReDistributeBufferCheck</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <comment type="block">/* close buffile */</comment>
                <expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>dataslot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>dataslot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>g_hybrid_hash_agg</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>dump_hashtable_if_spilled</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>			
                <break>break;</break>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<if_stmt><if>if <condition>(<expr><name>g_hybrid_hash_agg</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>dump_hashtable_if_spilled</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>dataslot</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><call><name>CreateTupleDescCopyConstr</name><argument_list>(<argument><expr><name><name>outerslot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>dataslot</name></name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <if_stmt><if>if <condition>(<expr><call><name>ReDistributeData</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>, 
                                 <argument><expr><name>outerslot</name></expr></argument>, <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>hashfunc</name></name></expr></argument>, <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>dataType</name></name></expr></argument>, <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcxt</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* set up for lookup_hash_entries and advance_aggregates */</comment>
        <expr_stmt><expr><name><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>outerslot</name></expr>;</expr_stmt>

        <comment type="block">/* Find or build hashtable entries */</comment>
        <expr_stmt><expr><name>pergroups</name> <operator>=</operator> <call><name>lookup_hash_entries</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Advance the aggregates */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_COMBINE</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>combine_aggregates</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name><name>pergroups</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>advance_aggregates</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pergroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * Reset per-input-tuple context after each tuple, but note that the
         * hash lookups do this too
         */</comment>
        <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>table_filled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <comment type="block">/* Initialize to walk the first hash table */</comment>
    <expr_stmt><expr><call><name>select_current_set</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>hashtable</name><operator>-&gt;</operator><name>spilled</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ResetTupleHashIterator</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hashtable</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hashiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>ResetTupleHashIterator</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hashtable</name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hashiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * ExecAgg for hashed case: retrieving groups from hash table
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>agg_retrieve_hash_table</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AggStatePerAgg</name></type> <name>peragg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleHashEntryData</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>firstSlot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AggStatePerHash</name></type> <name>perhash</name></decl>;</decl_stmt>

    <comment type="block">/*
     * get state info from node.
     *
     * econtext is the per-output-tuple expression context.
     */</comment>
    <expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>peragg</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>peragg</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>firstSlot</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Note that perhash (and therefore anything accessed through it) can
     * change inside the loop, as we change between grouping sets.
     */</comment>
    <expr_stmt><expr><name>perhash</name> <operator>=</operator> <operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/*
     * We loop retrieving groups until we find one satisfying
     * aggstate-&gt;ss.ps.qual
     */</comment>
    <while>while <condition>(<expr><operator>!</operator><name><name>aggstate</name><operator>-&gt;</operator><name>agg_done</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>hashslot</name> <init>= <expr><name><name>perhash</name><operator>-&gt;</operator><name>hashslot</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Find the next entry in the hash table
         */</comment>
        <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>ScanTupleHashTable</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>perhash</name><operator>-&gt;</operator><name>hashiter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>nextset</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>hybrid</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HybridHashtableLoadDone</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>LoadHybridHashtable</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>perhash</name><operator>-&gt;</operator><name>hashiter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if_stmt><if>if <condition>(<expr><name>nextset</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>num_hashes</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Switch to next grouping set, reinitialize, and restart the
                 * loop.
                 */</comment>
                <expr_stmt><expr><call><name>select_current_set</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>nextset</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>perhash</name> <operator>=</operator> <operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ResetTupleHashIterator</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>perhash</name><operator>-&gt;</operator><name>hashiter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <continue>continue;</continue>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* No more hashtables, so done */</comment>
                <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>agg_done</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Clear the per-output-tuple context for each group
         *
         * We intentionally don't use ReScanExprContext here; if any aggs have
         * registered shutdown callbacks, they mustn't be called yet, since we
         * might not be done with that agg.
         */</comment>
        <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Transform representative tuple back into one with the right
         * columns.
         */</comment>
        <expr_stmt><expr><call><name>ExecStoreMinimalTuple</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>firstTuple</name></name></expr></argument>, <argument><expr><name>hashslot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>hashslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>firstSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>firstSlot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
               <argument><expr><name><name>firstSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>perhash</name><operator>-&gt;</operator><name>numhashGrpCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>varNumber</name> <init>= <expr><name><name>perhash</name><operator>-&gt;</operator><name>hashGrpColIdxInput</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>firstSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>varNumber</name></expr>]</index></name> <operator>=</operator> <name><name>hashslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>firstSlot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>varNumber</name></expr>]</index></name> <operator>=</operator> <name><name>hashslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>firstSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>pergroup</name> <operator>=</operator> <operator>(</operator><name>AggStatePerGroup</name><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>additional</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * Use the representative input tuple for any references to
         * non-aggregated input columns in the qual and tlist.
         */</comment>
        <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>firstSlot</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>prepare_projection_slot</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>,
                                <argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name></expr></argument>,
                                <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>finalize_aggregates</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>peragg</name></expr></argument>, <argument><expr><name>pergroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>project_aggregates</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* No more groups */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -----------------
 * ExecInitAgg
 *
 *    Creates the run-time information for the agg node produced by the
 *    planner and initializes its outer subtree.
 *
 * -----------------
 */</comment>
<function><type><name>AggState</name> <modifier>*</modifier></type>
<name>ExecInitAgg</name><parameter_list>(<parameter><decl><type><name>Agg</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>AggState</name>   <modifier>*</modifier></type><name>aggstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AggStatePerAgg</name></type> <name>peraggs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertransstates</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>outerPlan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numaggs</name></decl>,
                <decl><type ref="prev"/><name>transno</name></decl>,
                <decl><type ref="prev"/><name>aggno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>phase</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>phaseidx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>combined_inputeval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>all_grouped_cols</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numGroupingSets</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numPhases</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numHashes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>column_offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>use_hashing</name> <init>= <expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name> <operator>||</operator>
                               <name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_MIXED</name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <comment type="block">/* check for unsupported flags */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_BACKWARD</name> <operator>|</operator> <name>EXEC_FLAG_MARK</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * create state structure
     */</comment>
    <expr_stmt><expr><name>aggstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AggState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecAgg</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>numaggs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>aggsplit</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>maxsets</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>peragg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curpertrans</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>input_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>agg_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>pergroup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_in</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_out</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>state</name></name>    <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>file</name></name>     <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>    
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>dataslot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * phases[0] always exists, but is dummy in sorted/plain mode
     */</comment>
    <expr_stmt><expr><name>numPhases</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>use_hashing</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>numHashes</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>use_hashing</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/*
     * Calculate the maximum number of grouping sets in any phase; this
     * determines the size of some allocations.  Also calculate the number of
     * phases, since all hashed/mixed nodes contribute to only a single phase.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>numGroupingSets</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;chain</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Agg</name>           <modifier>*</modifier></type><name>agg</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>numGroupingSets</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>numGroupingSets</name></expr></argument>,
                                  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * additional AGG_HASHED aggs become part of phase 0, but all
             * others add an extra phase.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_HASHED</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>++</operator><name>numPhases</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><operator>++</operator><name>numHashes</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>maxsets</name></name> <operator>=</operator> <name>numGroupingSets</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>numphases</name></name> <operator>=</operator> <name>numPhases</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggcontexts</name></name> <operator>=</operator> <operator>(</operator><name>ExprContext</name> <operator>*</operator><operator>*</operator><operator>)</operator>
        <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExprContext</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numGroupingSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create expression contexts.  We need three or more, one for
     * per-input-tuple processing, one for per-output-tuple processing, one
     * for all the hashtables, and one for each grouping set.  The per-tuple
     * memory context of the per-grouping-set ExprContexts (aggcontexts)
     * replaces the standalone memory context formerly used to hold transition
     * values.  We cheat a little by using ExecAssignExprContext() to build
     * all of them.
     *
     * NOTE: the details of what is stored in aggcontexts and what is stored
     * in the regular per-query memory context are driven by a simple
     * decision: we want to reset the aggcontext at group boundaries (if not
     * hashing) and in ExecReScanAgg to recover no-longer-wanted space.
     */</comment>
    <expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name></name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numGroupingSets</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggcontexts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>use_hashing</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>hashcontext</name></name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * tuple table initialization.
     *
     * For hashtables, we create some additional slots below.
     */</comment>
    <expr_stmt><expr><call><name>ExecInitScanTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecInitResultTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_slot</name></name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * initialize child expressions
     *
     * We rely on the parser to have checked that no aggs contain other agg
     * calls in their arguments.  This would make no sense under SQL semantics
     * (and it's forbidden by the spec).  Because it is true, we don't need to
     * worry about evaluating the aggs in any particular order.
     *
     * Note: execExpr.c finds Aggrefs for us, and adds their AggrefExprState
     * nodes to aggstate-&gt;aggs.  Aggrefs in the qual are found here; Aggrefs
     * in the targetlist are found during ExecAssignProjectionInfo, below.
     */</comment>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
        <call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize child nodes.
     *
     * If we are doing a hashed aggregation then the child plan does not need
     * to handle REWIND efficiently; see ExecReScanAgg.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>eflags</name> <operator>&amp;=</operator> <operator>~</operator><name>EXEC_FLAG_REWIND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>outerPlan</name> <operator>=</operator> <call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * initialize source tuple type.
     */</comment>
    <expr_stmt><expr><call><name>ExecAssignScanTypeFromOuterPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>chain</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_slot</name></name></expr></argument>,
                              <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Initialize result tuple type and projection info.
     */</comment>
    <expr_stmt><expr><call><name>ExecAssignResultTypeFromTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecAssignProjectionInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We should now have found all Aggrefs in the targetlist and quals.
     */</comment>
    <expr_stmt><expr><name>numaggs</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numaggs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numaggs</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>numaggs</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * This is not an error condition: we might be using the Agg node just
         * to do hash-based grouping.  Even in the regular case,
         * constant-expression simplification could optimize away all of the
         * Aggrefs in the targetlist and qual.  So keep going, but force local
         * copy of numaggs positive so that palloc()s below don't choke.
         */</comment>
        <expr_stmt><expr><name>numaggs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * For each phase, prepare grouping set data and fmgr lookup data for
     * compare functions.  Accumulate all_grouped_cols in passing.
     */</comment>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phases</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>numPhases</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerPhaseData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>num_hashes</name></name> <operator>=</operator> <name>numHashes</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>numHashes</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerHashData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numHashes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phases</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>numsets</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phases</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>gset_lengths</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numHashes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phases</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>grouped_cols</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numHashes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Bitmapset</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>phase</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>phaseidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>phaseidx</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>phaseidx</name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Agg</name>           <modifier>*</modifier></type><name>aggnode</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Sort</name>       <modifier>*</modifier></type><name>sortnode</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>phaseidx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>aggnode</name> <operator>=</operator> <call><name>list_nth_node</name><argument_list>(<argument><expr><name>Agg</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>, <argument><expr><name>phaseidx</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>sortnode</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Sort</name></expr></argument>, <argument><expr><name><name>aggnode</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>aggnode</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>sortnode</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>phase</name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>||</operator> <name>sortnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>aggnode</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name>
            <operator>||</operator> <name><name>aggnode</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_MIXED</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>AggStatePerPhase</name></type> <name>phasedata</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>phases</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>AggStatePerHash</name></type> <name>perhash</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>cols</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>phase</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>phasedata</name><operator>-&gt;</operator><name>numsets</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>perhash</name> <operator>=</operator> <operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

            <comment type="block">/* phase 0 always points to the "real" Agg in the hash case */</comment>
            <expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>aggnode</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name></expr>;</expr_stmt>

            <comment type="block">/* but the actual Agg node representing this hash is saved here */</comment>
            <expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>aggnode</name></name> <operator>=</operator> <name>aggnode</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>gset_lengths</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>perhash</name><operator>-&gt;</operator><name>numCols</name></name> <operator>=</operator> <name><name>aggnode</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</expr_stmt>

            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>aggnode</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name>cols</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>cols</name></expr></argument>, <argument><expr><name><name>aggnode</name><operator>-&gt;</operator><name>grpColIdx</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

            <expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>grouped_cols</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>cols</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>all_grouped_cols</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>all_grouped_cols</name></expr></argument>, <argument><expr><name>cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>AggStatePerPhase</name></type> <name>phasedata</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>phases</name><index>[<expr><operator>++</operator><name>phase</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>num_sets</name></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>numsets</name></name> <operator>=</operator> <name>num_sets</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>aggnode</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>num_sets</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>gset_lengths</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_sets</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>grouped_cols</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_sets</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Bitmapset</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>aggnode-&gt;groupingSets</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type>            <name>current_length</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>cols</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                    <comment type="block">/* planner forces this to be correct */</comment>
                    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>current_length</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>cols</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>cols</name></expr></argument>, <argument><expr><name><name>aggnode</name><operator>-&gt;</operator><name>grpColIdx</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

                    <expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>grouped_cols</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>cols</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>gset_lengths</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>current_length</name></expr>;</expr_stmt>

                    <expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
                </block_content>}</block>

                <expr_stmt><expr><name>all_grouped_cols</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>all_grouped_cols</name></expr></argument>,
                                                   <argument><expr><name><name>phasedata</name><operator>-&gt;</operator><name>grouped_cols</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>phaseidx</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>gset_lengths</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>grouped_cols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/*
             * If we are grouping, precompute fmgr lookup data for inner loop.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>aggnode</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_SORTED</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggnode</name><operator>-&gt;</operator><name>numCols</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>eqfunctions</name></name> <operator>=</operator>
                    <call><name>execTuplesMatchPrepare</name><argument_list>(<argument><expr><name><name>aggnode</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>,
                                           <argument><expr><name><name>aggnode</name><operator>-&gt;</operator><name>grpOperators</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>aggnode</name></name> <operator>=</operator> <name>aggnode</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>=</operator> <name><name>aggnode</name><operator>-&gt;</operator><name>aggstrategy</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>sortnode</name></name> <operator>=</operator> <name>sortnode</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Convert all_grouped_cols to a descending-order list.
     */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>all_grouped_cols</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>all_grouped_cols</name></name> <operator>=</operator> <call><name>lcons_int</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>all_grouped_cols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

    <comment type="block">/*
     * Set up aggregate-result storage in the output expr context, and also
     * allocate my private per-agg working storage
     */</comment>
    <expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggvalues</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numaggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggnulls</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numaggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>peraggs</name> <operator>=</operator> <operator>(</operator><name>AggStatePerAgg</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerAggData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numaggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pertransstates</name> <operator>=</operator> <operator>(</operator><name>AggStatePerTrans</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerTransData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numaggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>peragg</name></name> <operator>=</operator> <name>peraggs</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name></name> <operator>=</operator> <name>pertransstates</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Hashing can only appear in the initial phase.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>use_hashing</name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numHashes</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hashslot</name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>execTuplesHashPrepare</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numCols</name></expr></argument>,
                                  <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggnode</name><operator>-&gt;</operator><name>grpOperators</name></name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eqfunctions</name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hashfunctions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/* this is an array of pointers, not structures */</comment>
        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>hash_pergroup</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerGroup</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numHashes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>find_hash_columns</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>build_hash_table</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>table_filled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_HASHED</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>pergroup</name> <operator>=</operator> <operator>(</operator><name>AggStatePerGroup</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerGroupData</name></expr></argument>)</argument_list></sizeof>
                                              <operator>*</operator> <name>numaggs</name>
                                              <operator>*</operator> <name>numGroupingSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>pergroup</name></name> <operator>=</operator> <name>pergroup</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Initialize current phase-dependent values to initial phase. The initial
     * phase is 1 (first sort pass) for all strategies that use sorting (if
     * hashing is being done too, then phase 0 is processed last); but if only
     * hashing is being done, then phase 0 is all there is.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_phase</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>initialize_phase</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>select_current_set</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_phase</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>initialize_phase</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>select_current_set</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* -----------------
     * Perform lookups of aggregate function info, and initialize the
     * unchanging fields of the per-agg and per-trans data.
     *
     * We try to optimize by detecting duplicate aggregate functions so that
     * their state and final values are re-used, rather than needlessly being
     * re-calculated independently. We also detect aggregates that are not
     * the same, but which can share the same transition state.
     *
     * Scenarios:
     *
     * 1. An aggregate function appears more than once in query:
     *
     *      SELECT SUM(x) FROM ... HAVING SUM(x) &gt; 0
     *
     *      Since the aggregates are the identical, we only need to calculate
     *      the calculate it once. Both aggregates will share the same 'aggno'
     *      value.
     *
     * 2. Two different aggregate functions appear in the query, but the
     *      aggregates have the same transition function and initial value, but
     *      different final function:
     *
     *      SELECT SUM(x), AVG(x) FROM ...
     *
     *      In this case we must create a new peragg for the varying aggregate,
     *      and need to call the final functions separately, but can share the
     *      same transition state.
     *
     * For either of these optimizations to be valid, the aggregate's
     * arguments must be the same, including any modifiers such as ORDER BY,
     * DISTINCT and FILTER, and they mustn't contain any volatile functions.
     * -----------------
     */</comment>
    <expr_stmt><expr><name>aggno</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>transno</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>aggstate-&gt;aggs</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AggrefExprState</name> <modifier>*</modifier></type><name>aggrefstate</name> <init>= <expr><operator>(</operator><name>AggrefExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Aggref</name>       <modifier>*</modifier></type><name>aggref</name> <init>= <expr><name><name>aggrefstate</name><operator>-&gt;</operator><name>aggref</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AggStatePerAgg</name></type> <name>peragg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>existing_aggno</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>existing_transno</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>same_input_transnos</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name><name>inputTypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>numArguments</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>numDirectArgs</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>aggTuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_aggregate</name></type> <name>aggform</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AclResult</name></type>    <name>aclresult</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>transfn_oid</name></decl>,
                    <decl><type ref="prev"/><name>finalfn_oid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>serialfn_oid</name></decl>,
                    <decl><type ref="prev"/><name>deserialfn_oid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>finalfnexpr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>aggtranstype</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>textInitVal</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>initValue</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>initValueIsNull</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<decl_stmt><decl><type><name>Oid</name></type>         <name>combfn_oid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>         <name>serial_func</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>         <name>deserial_func</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* Planner should have assigned aggregate to correct level */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* ... and the split mode should match */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>==</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* 1. Check for already processed aggs which can be re-used */</comment>
        <expr_stmt><expr><name>existing_aggno</name> <operator>=</operator> <call><name>find_compatible_peragg</name><argument_list>(<argument><expr><name>aggref</name></expr></argument>, <argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>aggno</name></expr></argument>,
                                                <argument><expr><operator>&amp;</operator><name>same_input_transnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>existing_aggno</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Existing compatible agg found. so just point the Aggref to the
             * same per-agg struct.
             */</comment>
            <expr_stmt><expr><name><name>aggrefstate</name><operator>-&gt;</operator><name>aggno</name></name> <operator>=</operator> <name>existing_aggno</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Mark Aggref state node with assigned index in the result array */</comment>
        <expr_stmt><expr><name>peragg</name> <operator>=</operator> <operator>&amp;</operator><name><name>peraggs</name><index>[<expr><operator>++</operator><name>aggno</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>peragg</name><operator>-&gt;</operator><name>aggref</name></name> <operator>=</operator> <name>aggref</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aggrefstate</name><operator>-&gt;</operator><name>aggno</name></name> <operator>=</operator> <name>aggno</name></expr>;</expr_stmt>

        <comment type="block">/* Fetch the pg_aggregate row */</comment>
        <expr_stmt><expr><name>aggTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>,
                                   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for aggregate %u"</literal></expr></argument>,
                 <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>aggform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_aggregate</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Check permission to call aggregate function */</comment>
        <expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
                                     <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ACL_KIND_PROC</name></expr></argument>,
                           <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* planner recorded transition state type in the Aggref itself */</comment>
        <expr_stmt><expr><name>aggtranstype</name> <operator>=</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggtranstype</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aggtranstype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If this aggregation is performing state combines, then instead of
         * using the transition function, we'll use the combine function
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_COMBINE</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>transfn_oid</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggcombinefn</name></name></expr>;</expr_stmt>

            <comment type="block">/* If not set then the planner messed up */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>transfn_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"combinefn not set for aggregate function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>transfn_oid</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggtransfn</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<expr_stmt><expr><name>combfn_oid</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggcombinefn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>serial_func</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggserialfn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>deserial_func</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggdeserialfn</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* Final function only required if we're finalizing the aggregates */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_SKIPFINAL</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>peragg</name><operator>-&gt;</operator><name>finalfn_oid</name></name> <operator>=</operator> <name>finalfn_oid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>peragg</name><operator>-&gt;</operator><name>finalfn_oid</name></name> <operator>=</operator> <name>finalfn_oid</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggfinalfn</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>serialfn_oid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>deserialfn_oid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Check if serialization/deserialization is required.  We only do it
         * for aggregates that have transtype INTERNAL.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>aggtranstype</name> <operator>==</operator> <name>INTERNALOID</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * The planner should only have generated a serialize agg node if
             * every aggregate with an INTERNAL state has a serialization
             * function.  Verify that.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_SERIALIZE</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* serialization only valid when not running finalfn */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>DO_AGGSPLIT_SKIPFINAL</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>aggform</name><operator>-&gt;</operator><name>aggserialfn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"serialfunc not provided for serialization aggregation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>serialfn_oid</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggserialfn</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Likewise for deserialization functions */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_DESERIALIZE</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* deserialization only valid when combining states */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>DO_AGGSPLIT_COMBINE</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>aggform</name><operator>-&gt;</operator><name>aggdeserialfn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"deserialfunc not provided for deserialization aggregation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>deserialfn_oid</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggdeserialfn</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Check that aggregate owner has permission to call component fns */</comment>
        <block>{<block_content>
            <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>procTuple</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>aggOwner</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>procTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>,
                                        <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>procTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>,
                     <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>aggOwner</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procTuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>proowner</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>transfn_oid</name></expr></argument>, <argument><expr><name>aggOwner</name></expr></argument>,
                                         <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ACL_KIND_PROC</name></expr></argument>,
                               <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>transfn_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name>transfn_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>finalfn_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>finalfn_oid</name></expr></argument>, <argument><expr><name>aggOwner</name></expr></argument>,
                                             <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ACL_KIND_PROC</name></expr></argument>,
                                   <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>finalfn_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name>finalfn_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>serialfn_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>serialfn_oid</name></expr></argument>, <argument><expr><name>aggOwner</name></expr></argument>,
                                             <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ACL_KIND_PROC</name></expr></argument>,
                                   <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>serialfn_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name>serialfn_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>deserialfn_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>deserialfn_oid</name></expr></argument>, <argument><expr><name>aggOwner</name></expr></argument>,
                                             <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ACL_KIND_PROC</name></expr></argument>,
                                   <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>deserialfn_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name>deserialfn_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <comment type="block">/*
         * Get actual datatypes of the (nominal) aggregate inputs.  These
         * could be different from the agg's declared input types, when the
         * agg accepts ANY or a polymorphic type.
         */</comment>
        <expr_stmt><expr><name>numArguments</name> <operator>=</operator> <call><name>get_aggregate_argtypes</name><argument_list>(<argument><expr><name>aggref</name></expr></argument>, <argument><expr><name>inputTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Count the "direct" arguments, if any */</comment>
        <expr_stmt><expr><name>numDirectArgs</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Detect how many arguments to pass to the finalfn */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>aggform</name><operator>-&gt;</operator><name>aggfinalextra</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>peragg</name><operator>-&gt;</operator><name>numFinalArgs</name></name> <operator>=</operator> <name>numArguments</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>peragg</name><operator>-&gt;</operator><name>numFinalArgs</name></name> <operator>=</operator> <name>numDirectArgs</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * build expression trees using actual argument &amp; result types for the
         * finalfn, if it exists and is required.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>finalfn_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>build_aggregate_finalfn_expr</name><argument_list>(<argument><expr><name>inputTypes</name></expr></argument>,
                                         <argument><expr><name><name>peragg</name><operator>-&gt;</operator><name>numFinalArgs</name></name></expr></argument>,
                                         <argument><expr><name>aggtranstype</name></expr></argument>,
                                         <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggtype</name></name></expr></argument>,
                                         <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
                                         <argument><expr><name>finalfn_oid</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>finalfnexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>finalfn_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>peragg</name><operator>-&gt;</operator><name>finalfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>finalfnexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>peragg</name><operator>-&gt;</operator><name>finalfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* get info about the output value's datatype */</comment>
        <expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggtype</name></name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name><name>peragg</name><operator>-&gt;</operator><name>resulttypeLen</name></name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name><name>peragg</name><operator>-&gt;</operator><name>resulttypeByVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * initval is potentially null, so don't try to access it as a struct
         * field. Must do it the hard way with SysCacheGetAttr.
         */</comment>
        <expr_stmt><expr><name>textInitVal</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>, <argument><expr><name>aggTuple</name></expr></argument>,
                                      <argument><expr><name>Anum_pg_aggregate_agginitval</name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name>initValueIsNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>initValueIsNull</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>initValue</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>initValue</name> <operator>=</operator> <call><name>GetAggInitVal</name><argument_list>(<argument><expr><name>textInitVal</name></expr></argument>, <argument><expr><name>aggtranstype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * 2. Build working state for invoking the transition function, or
         * look up previously initialized working state, if we can share it.
         *
         * find_compatible_peragg() already collected a list of per-Trans's
         * with the same inputs. Check if any of them have the same transition
         * function and initial value.
         */</comment>
        <expr_stmt><expr><name>existing_transno</name> <operator>=</operator> <call><name>find_compatible_pertrans</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>aggref</name></expr></argument>,
                                                    <argument><expr><name>transfn_oid</name></expr></argument>, <argument><expr><name>aggtranstype</name></expr></argument>,
                                                    <argument><expr><name>serialfn_oid</name></expr></argument>, <argument><expr><name>deserialfn_oid</name></expr></argument>,
                                                    <argument><expr><name>initValue</name></expr></argument>, <argument><expr><name>initValueIsNull</name></expr></argument>,
                                                    <argument><expr><name>same_input_transnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>existing_transno</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Existing compatible trans found, so just point the 'peragg' to
             * the same per-trans struct.
             */</comment>
            <expr_stmt><expr><name>pertrans</name> <operator>=</operator> <operator>&amp;</operator><name><name>pertransstates</name><index>[<expr><name>existing_transno</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>peragg</name><operator>-&gt;</operator><name>transno</name></name> <operator>=</operator> <name>existing_transno</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>pertrans</name> <operator>=</operator> <operator>&amp;</operator><name><name>pertransstates</name><index>[<expr><operator>++</operator><name>transno</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>build_pertrans_for_aggref</name><argument_list>(<argument><expr><name>pertrans</name></expr></argument>, <argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>,
                                      <argument><expr><name>aggref</name></expr></argument>, <argument><expr><name>transfn_oid</name></expr></argument>, <argument><expr><name>aggtranstype</name></expr></argument>,
                                      <argument><expr><name>serialfn_oid</name></expr></argument>, <argument><expr><name>deserialfn_oid</name></expr></argument>,
                                      <argument><expr><name>initValue</name></expr></argument>, <argument><expr><name>initValueIsNull</name></expr></argument>,
                                      <argument><expr><name>inputTypes</name></expr></argument>, <argument><expr><name>numArguments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>peragg</name><operator>-&gt;</operator><name>transno</name></name> <operator>=</operator> <name>transno</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>serial_func_id</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>deserial_func_id</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>g_hybrid_hash_agg</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>combfn_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>combinefnexpr</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>build_aggregate_combinefn_expr</name><argument_list>(<argument><expr><name>aggtranstype</name></expr></argument>,
												   <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
												   <argument><expr><name>combfn_oid</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>combinefnexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>combfn_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>combfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>combinefnexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>combfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>combfn_fcinfo</name></name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>combfn</name></name></expr></argument>,
											 <argument><expr><literal type="number">2</literal></expr></argument>,
											 <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggCollation</name></name></expr></argument>,
											 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>aggstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Ensure that a combine function to combine INTERNAL states is not
					 * strict. This should have been checked during CREATE AGGREGATE, but
					 * the strict property could have been changed since then.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>combfn</name><operator>.</operator><name>fn_strict</name></name> <operator>&amp;&amp;</operator> <name>aggtranstype</name> <operator>==</operator> <name>INTERNALOID</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"combine function for aggregate %u must be declared as STRICT"</literal></expr></argument>,
										<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>use_hashing</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
						
						<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>num_hashes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
						<block>{<block_content>
							<decl_stmt><decl><type><name>AggStatePerHash</name></type> <name>perhash</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

							<expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>hybrid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

							<expr_stmt><expr><call><name>tuplehash_set_hybrid</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>hashtab</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></for>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>aggtranstype</name> <operator>==</operator> <name>INTERNALOID</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>serial_func</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>deserial_func</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>use_hashing</name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
							
							<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>num_hashes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
							<block>{<block_content>
								<decl_stmt><decl><type><name>AggStatePerHash</name></type> <name>perhash</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

								<expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>hybrid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

								<expr_stmt><expr><call><name>tuplehash_set_hybrid</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>hashtab</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></for>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>serialfnexpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>deserialfnexpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>serial_func_id</name></name> <operator>=</operator> <name>serial_func</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>deserial_func_id</name></name> <operator>=</operator> <name>deserial_func</name></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>build_aggregate_serialfn_expr</name><argument_list>(<argument><expr><name>serial_func</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>serialfnexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>serial_func</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>serial_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>serialfnexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>serial_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>serial_func_fcinfo</name></name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>serial_func</name></name></expr></argument>,
												 <argument><expr><literal type="number">1</literal></expr></argument>,
												 <argument><expr><name>InvalidOid</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>aggstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>build_aggregate_deserialfn_expr</name><argument_list>(<argument><expr><name>deserial_func</name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>deserialfnexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>deserial_func</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>deserial_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>deserialfnexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>deserial_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>deserial_func_fcinfo</name></name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>deserial_func</name></name></expr></argument>,
												 <argument><expr><literal type="number">2</literal></expr></argument>,
												 <argument><expr><name>InvalidOid</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>aggstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Update numaggs to match the number of unique aggregates found. Also set
     * numstates to the number of unique aggregate states found.
     */</comment>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>numaggs</name></name> <operator>=</operator> <name>aggno</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name> <operator>=</operator> <name>transno</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Build a single projection computing the aggregate arguments for all
     * aggregates at once, that's considerably faster than doing it separately
     * for each.
     *
     * First create a targetlist combining the targetlist of all the
     * transitions.
     */</comment>
    <expr_stmt><expr><name>combined_inputeval</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>column_offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>transno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>transno</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name></expr>;</condition> <incr><expr><name>transno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>pertransstates</name><index>[<expr><name>transno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>inputoff</name></name> <operator>=</operator> <name>column_offset</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Adjust resno in a copied target entries, to point into the combined
         * slot.
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>pertrans-&gt;aggref-&gt;args</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>source_tle</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>flatCopyTargetEntry</name><argument_list>(<argument><expr><name>source_tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>+=</operator> <name>column_offset</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>combined_inputeval</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>combined_inputeval</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><name>column_offset</name> <operator>+=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* and then create a projection for that targetlist */</comment>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>evaldesc</name></name> <operator>=</operator> <call><name>ExecTypeFromTL</name><argument_list>(<argument><expr><name>combined_inputeval</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>evalslot</name></name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>evalproj</name></name> <operator>=</operator> <call><name>ExecBuildProjectionInfo</name><argument_list>(<argument><expr><name>combined_inputeval</name></expr></argument>,
                                                 <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name></name></expr></argument>,
                                                 <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>evalslot</name></name></expr></argument>,
                                                 <argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>,
                                                 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>evalslot</name></name></expr></argument>, <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>evaldesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>aggstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build the state needed to calculate a state value for an aggregate.
 *
 * This initializes all the fields in 'pertrans'. 'aggref' is the aggregate
 * to initialize the state for. 'aggtransfn', 'aggtranstype', and the rest
 * of the arguments could be calculated from 'aggref', but the caller has
 * calculated them already, so might as well pass them.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>build_pertrans_for_aggref</name><parameter_list>(<parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
                          <parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                          <parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name></decl></parameter>,
                          <parameter><decl><type><name>Oid</name></type> <name>aggtransfn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>aggtranstype</name></decl></parameter>,
                          <parameter><decl><type><name>Oid</name></type> <name>aggserialfn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>aggdeserialfn</name></decl></parameter>,
                          <parameter><decl><type><name>Datum</name></type> <name>initValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>initValueIsNull</name></decl></parameter>,
                          <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>inputTypes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numArguments</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>numGroupingSets</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>maxsets</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>serialfnexpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>deserialfnexpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numInputs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numDirectArgs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>sortlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numSortCols</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numDistinctCols</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>naggs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Agg</name>         <modifier>*</modifier></type><name>agg</name> <init>= <expr><operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Begin filling in the pertrans data */</comment>
    <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggref</name></name> <operator>=</operator> <name>aggref</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggCollation</name></name> <operator>=</operator> <name><name>aggref</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transfn_oid</name></name> <operator>=</operator> <name>aggtransfn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>serialfn_oid</name></name> <operator>=</operator> <name>aggserialfn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>deserialfn_oid</name></name> <operator>=</operator> <name>aggdeserialfn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>initValue</name></name> <operator>=</operator> <name>initValue</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>initValueIsNull</name></name> <operator>=</operator> <name>initValueIsNull</name></expr>;</expr_stmt>

    <comment type="block">/* Count the "direct" arguments, if any */</comment>
    <expr_stmt><expr><name>numDirectArgs</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Count the number of aggregated input columns */</comment>
    <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>numInputs</name></name> <operator>=</operator> <name>numInputs</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>aggtranstype</name></expr>;</expr_stmt>

    <comment type="block">/* Detect how many arguments to pass to the transfn */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>AGGKIND_IS_ORDERED_SET</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggkind</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>numTransInputs</name></name> <operator>=</operator> <name>numInputs</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>numTransInputs</name></name> <operator>=</operator> <name>numArguments</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * When combining states, we have no use at all for the aggregate
     * function's transfn. Instead we use the combinefn.  In this case, the
     * transfn and transfn_oid fields of pertrans refer to the combine
     * function rather than the transition function.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_COMBINE</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>combinefnexpr</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>build_aggregate_combinefn_expr</name><argument_list>(<argument><expr><name>aggtranstype</name></expr></argument>,
                                       <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
                                       <argument><expr><name>aggtransfn</name></expr></argument>,
                                       <argument><expr><operator>&amp;</operator><name>combinefnexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>aggtransfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>combinefnexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transfn_fcinfo</name></name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn</name></name></expr></argument>,
                                 <argument><expr><literal type="number">2</literal></expr></argument>,
                                 <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggCollation</name></name></expr></argument>,
                                 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>aggstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Ensure that a combine function to combine INTERNAL states is not
         * strict. This should have been checked during CREATE AGGREGATE, but
         * the strict property could have been changed since then.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>transfn</name><operator>.</operator><name>fn_strict</name></name> <operator>&amp;&amp;</operator> <name>aggtranstype</name> <operator>==</operator> <name>INTERNALOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"combine function for aggregate %u must be declared as STRICT"</literal></expr></argument>,
                            <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>transfnexpr</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Set up infrastructure for calling the transfn.  Note that invtrans
         * is not needed here.
         */</comment>
        <expr_stmt><expr><call><name>build_aggregate_transfn_expr</name><argument_list>(<argument><expr><name>inputTypes</name></expr></argument>,
                                     <argument><expr><name>numArguments</name></expr></argument>,
                                     <argument><expr><name>numDirectArgs</name></expr></argument>,
                                     <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggvariadic</name></name></expr></argument>,
                                     <argument><expr><name>aggtranstype</name></expr></argument>,
                                     <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
                                     <argument><expr><name>aggtransfn</name></expr></argument>,
                                     <argument><expr><name>InvalidOid</name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>transfnexpr</name></expr></argument>,
                                     <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>aggtransfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>transfnexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transfn_fcinfo</name></name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn</name></name></expr></argument>,
                                 <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>numTransInputs</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                                 <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggCollation</name></name></expr></argument>,
                                 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>aggstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If the transfn is strict and the initval is NULL, make sure input
         * type and transtype are the same (or at least binary-compatible), so
         * that it's OK to use the first aggregated input value as the initial
         * transValue.  This should have been checked at agg definition time,
         * but we must check again in case the transfn's strictness property
         * has been changed.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>transfn</name><operator>.</operator><name>fn_strict</name></name> <operator>&amp;&amp;</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>initValueIsNull</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>numArguments</name> <operator>&lt;=</operator> <name>numDirectArgs</name> <operator>||</operator>
                <operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name><name>inputTypes</name><index>[<expr><name>numDirectArgs</name></expr>]</index></name></expr></argument>,
                                   <argument><expr><name>aggtranstype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate %u needs to have compatible input type and transition type"</literal></expr></argument>,
                                <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* get info about the state value's datatype */</comment>
    <expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name>aggtranstype</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aggserialfn</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>build_aggregate_serialfn_expr</name><argument_list>(<argument><expr><name>aggserialfn</name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name>serialfnexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>aggserialfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>serialfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>serialfnexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>serialfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>serialfn_fcinfo</name></name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>serialfn</name></name></expr></argument>,
                                 <argument><expr><literal type="number">1</literal></expr></argument>,
                                 <argument><expr><name>InvalidOid</name></expr></argument>,
                                 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>aggstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aggdeserialfn</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>build_aggregate_deserialfn_expr</name><argument_list>(<argument><expr><name>aggdeserialfn</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>deserialfnexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>aggdeserialfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>deserialfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>deserialfnexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>deserialfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>deserialfn_fcinfo</name></name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>deserialfn</name></name></expr></argument>,
                                 <argument><expr><literal type="number">2</literal></expr></argument>,
                                 <argument><expr><name>InvalidOid</name></expr></argument>,
                                 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>aggstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Initialize the input and FILTER expressions */</comment>
    <expr_stmt><expr><name>naggs</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numaggs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggdirectargs</name></name> <operator>=</operator> <call><name>ExecInitExprList</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>,
                                               <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Complain if the aggregate's arguments contain any aggregates; nested
     * agg functions are semantically nonsensical.  (This should have been
     * caught earlier, but we defend against it here anyway.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>naggs</name> <operator>!=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numaggs</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GROUPING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate function calls cannot be nested"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If we're doing either DISTINCT or ORDER BY for a plain agg, then we
     * have a list of SortGroupClause nodes; fish out the data in them and
     * stick them into arrays.  We ignore ORDER BY for an ordered-set agg,
     * however; the agg's transfn and finalfn are responsible for that.
     * Distributed distinct agg does not need distinct in second phase.
     *
     * Note that by construction, if there is a DISTINCT clause then the ORDER
     * BY clause is a prefix of it (see transformDistinctClause).
     */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AGGKIND_IS_ORDERED_SET</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggkind</name></name></expr></argument>)</argument_list></call>
	    <operator>||</operator> <name><name>agg</name><operator>-&gt;</operator><name>noDistinct</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>sortlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>numSortCols</name> <operator>=</operator> <name>numDistinctCols</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>sortlist</name> <operator>=</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>numSortCols</name> <operator>=</operator> <name>numDistinctCols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>sortlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numSortCols</name> <operator>&gt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>sortlist</name> <operator>=</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>numSortCols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>sortlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>numDistinctCols</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>numSortCols</name></name> <operator>=</operator> <name>numSortCols</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>numDistinctCols</name></name> <operator>=</operator> <name>numDistinctCols</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>numSortCols</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Get a tupledesc and slot corresponding to the aggregated inputs
         * (including sort expressions) of the agg.
         */</comment>
        <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortdesc</name></name> <operator>=</operator> <call><name>ExecTypeFromTL</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortslot</name></name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortslot</name></name></expr></argument>, <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If we have only one input, we need its len/byval info. */</comment>
        <if_stmt><if>if <condition>(<expr><name>numInputs</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>inputTypes</name><index>[<expr><name>numDirectArgs</name></expr>]</index></name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>inputtypeLen</name></name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>inputtypeByVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>numDistinctCols</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* we will need an extra slot to store prior values */</comment>
            <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>uniqslot</name></name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>uniqslot</name></name></expr></argument>,
                                  <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Extract the sort information for use later */</comment>
        <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortColIdx</name></name> <operator>=</operator>
            <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numSortCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortOperators</name></name> <operator>=</operator>
            <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numSortCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortCollations</name></name> <operator>=</operator>
            <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numSortCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortNullsFirst</name></name> <operator>=</operator>
            <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numSortCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>sortlist</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sortcl</name></expr></argument>, <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* the parser should have made sure of this */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>sortcl</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortColIdx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>sortop</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortCollations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortNullsFirst</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>nulls_first</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>numSortCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

	<comment type="block">/* Distributed distinct agg does not need distinct in second phase. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>agg</name><operator>-&gt;</operator><name>noDistinct</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numArguments</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We need the equal function for each DISTINCT comparison we will
         * make.
         */</comment>
        <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>equalfns</name></name> <operator>=</operator>
            <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numDistinctCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>aggref-&gt;aggdistinct</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><call><name>get_opcode</name><argument_list>(<argument><expr><name><name>sortcl</name><operator>-&gt;</operator><name>eqop</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>equalfns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>numDistinctCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name></name> <operator>=</operator> <operator>(</operator><name>Tuplesortstate</name> <operator>*</operator><operator>*</operator><operator>)</operator>
        <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Tuplesortstate</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numGroupingSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>GetAggInitVal</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>textInitVal</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>transtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>typinput</name></decl>,
                <decl><type ref="prev"/><name>typioparam</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>strInitVal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>initVal</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name>transtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typinput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>strInitVal</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>textInitVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>initVal</name> <operator>=</operator> <call><name>OidInputFunctionCall</name><argument_list>(<argument><expr><name>typinput</name></expr></argument>, <argument><expr><name>strInitVal</name></expr></argument>,
                                   <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>strInitVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>initVal</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_compatible_peragg - search for a previously initialized per-Agg struct
 *
 * Searches the previously looked at aggregates to find one which is compatible
 * with this one, with the same input parameters. If no compatible aggregate
 * can be found, returns -1.
 *
 * As a side-effect, this also collects a list of existing per-Trans structs
 * with matching inputs. If no identical Aggref is found, the list is passed
 * later to find_compatible_perstate, to see if we can at least reuse the
 * state value of another aggregate.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>find_compatible_peragg</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>newagg</name></decl></parameter>, <parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
                       <parameter><decl><type><name>int</name></type> <name>lastaggno</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>same_input_transnos</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>aggno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AggStatePerAgg</name></type> <name>peraggs</name></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>same_input_transnos</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <comment type="block">/* we mustn't reuse the aggref if it contains volatile function calls */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newagg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>peraggs</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>peragg</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Search through the list of already seen aggregates. If we find an
     * existing aggregate with the same aggregate function and input
     * parameters as an existing one, then we can re-use that one. While
     * searching, we'll also collect a list of Aggrefs with the same input
     * parameters. If no matching Aggref is found, the caller can potentially
     * still re-use the transition state of one of them.
     */</comment>
    <for>for <control>(<init><expr><name>aggno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>aggno</name> <operator>&lt;=</operator> <name>lastaggno</name></expr>;</condition> <incr><expr><name>aggno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AggStatePerAgg</name></type> <name>peragg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Aggref</name>       <modifier>*</modifier></type><name>existingRef</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>peragg</name> <operator>=</operator> <operator>&amp;</operator><name><name>peraggs</name><index>[<expr><name>aggno</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>existingRef</name> <operator>=</operator> <name><name>peragg</name><operator>-&gt;</operator><name>aggref</name></name></expr>;</expr_stmt>

        <comment type="block">/* all of the following must be the same or it's no match */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>newagg</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>!=</operator> <name><name>existingRef</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>||</operator>
            <name><name>newagg</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>!=</operator> <name><name>existingRef</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>||</operator>
            <name><name>newagg</name><operator>-&gt;</operator><name>aggstar</name></name> <operator>!=</operator> <name><name>existingRef</name><operator>-&gt;</operator><name>aggstar</name></name> <operator>||</operator>
            <name><name>newagg</name><operator>-&gt;</operator><name>aggvariadic</name></name> <operator>!=</operator> <name><name>existingRef</name><operator>-&gt;</operator><name>aggvariadic</name></name> <operator>||</operator>
            <name><name>newagg</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>!=</operator> <name><name>existingRef</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>||</operator>
            <operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>newagg</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>, <argument><expr><name><name>existingRef</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
            <operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>newagg</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>existingRef</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
            <operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>newagg</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>, <argument><expr><name><name>existingRef</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
            <operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>newagg</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr></argument>, <argument><expr><name><name>existingRef</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
            <operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>newagg</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>, <argument><expr><name><name>existingRef</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* if it's the same aggregate function then report exact match */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>newagg</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>==</operator> <name><name>existingRef</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>&amp;&amp;</operator>
            <name><name>newagg</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>==</operator> <name><name>existingRef</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>&amp;&amp;</operator>
            <name><name>newagg</name><operator>-&gt;</operator><name>aggcollid</name></name> <operator>==</operator> <name><name>existingRef</name><operator>-&gt;</operator><name>aggcollid</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><operator>*</operator><name>same_input_transnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>same_input_transnos</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
            <return>return <expr><name>aggno</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Not identical, but it had the same inputs. Return it to the caller,
         * in case we can re-use its per-trans state.
         */</comment>
        <expr_stmt><expr><operator>*</operator><name>same_input_transnos</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><operator>*</operator><name>same_input_transnos</name></expr></argument>,
                                           <argument><expr><name><name>peragg</name><operator>-&gt;</operator><name>transno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_compatible_pertrans - search for a previously initialized per-Trans
 * struct
 *
 * Searches the list of transnos for a per-Trans struct with the same
 * transition state and initial condition. (The inputs have already been
 * verified to match.)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>find_compatible_pertrans</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>newagg</name></decl></parameter>,
                         <parameter><decl><type><name>Oid</name></type> <name>aggtransfn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>aggtranstype</name></decl></parameter>,
                         <parameter><decl><type><name>Oid</name></type> <name>aggserialfn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>aggdeserialfn</name></decl></parameter>,
                         <parameter><decl><type><name>Datum</name></type> <name>initValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>initValueIsNull</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>transnos</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>transnos</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>transno</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name><index>[<expr><name>transno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * if the transfns or transition state types are not the same then the
         * state can't be shared.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>aggtransfn</name> <operator>!=</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>transfn_oid</name></name> <operator>||</operator>
            <name>aggtranstype</name> <operator>!=</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>aggtranstype</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * The serialization and deserialization functions must match, if
         * present, as we're unable to share the trans state for aggregates
         * which will serialize or deserialize into different formats.
         * Remember that these will be InvalidOid if they're not required for
         * this agg node.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>aggserialfn</name> <operator>!=</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>serialfn_oid</name></name> <operator>||</operator>
            <name>aggdeserialfn</name> <operator>!=</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>deserialfn_oid</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Check that the initial condition matches, too. */</comment>
        <if_stmt><if>if <condition>(<expr><name>initValueIsNull</name> <operator>&amp;&amp;</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>initValueIsNull</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>transno</name></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>initValueIsNull</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pertrans</name><operator>-&gt;</operator><name>initValueIsNull</name></name> <operator>&amp;&amp;</operator>
            <call><name>datumIsEqual</name><argument_list>(<argument><expr><name>initValue</name></expr></argument>, <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>initValue</name></name></expr></argument>,
                         <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>, <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>transno</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecEndAgg</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>transno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numGroupingSets</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>maxsets</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>setno</name></decl>;</decl_stmt>

    <comment type="block">/* Make sure we have closed any open tuplesorts */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>sort_in</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sort_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>sort_out</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sort_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>transno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>transno</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numtrans</name></name></expr>;</condition> <incr><expr><name>transno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>pertrans</name><index>[<expr><name>transno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>setno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>setno</name> <operator>&lt;</operator> <name>numGroupingSets</name></expr>;</condition> <incr><expr><name>setno</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name>setno</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name>setno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <comment type="block">/* And ensure any agg shutdown callbacks have been called */</comment>
    <for>for <control>(<init><expr><name>setno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>setno</name> <operator>&lt;</operator> <name>numGroupingSets</name></expr>;</condition> <incr><expr><name>setno</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ReScanExprContext</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>aggcontexts</name><index>[<expr><name>setno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hashcontext</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ReScanExprContext</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We don't actually free any ExprContexts here (see comment in
     * ExecFreeExprContext), just unlinking the output one from the plan node
     * suffices.
     */</comment>
    <expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* clean up tuple table */</comment>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>outerPlan</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecReScanAgg</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name> <init>= <expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Agg</name>           <modifier>*</modifier></type><name>aggnode</name> <init>= <expr><operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>transno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numGroupingSets</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>maxsets</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>setno</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>agg_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * In the hashed case, if we haven't yet built the hash table then we
         * can just return; nothing done yet, so nothing to undo. If subnode's
         * chgParam is not NULL then it will be re-scanned by ExecProcNode,
         * else no reason to re-scan it at all.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>table_filled</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <comment type="block">/*
         * If we do have the hash table, and the subplan does not have any
         * parameter changes, and none of our own parameter changes affect
         * input expressions of the aggregated functions, then we can just
         * rescan the existing hash table; no need to build it again.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>outerPlan</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>chgParam</name></name></expr></argument>, <argument><expr><name><name>aggnode</name><operator>-&gt;</operator><name>aggParams</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ResetTupleHashIterator</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hashtable</name></expr></argument>,
                                   <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hashiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>select_current_set</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Make sure we have closed any open tuplesorts */</comment>
    <for>for <control>(<init><expr><name>transno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>transno</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numtrans</name></name></expr>;</condition> <incr><expr><name>transno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>setno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>setno</name> <operator>&lt;</operator> <name>numGroupingSets</name></expr>;</condition> <incr><expr><name>setno</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>pertrans</name><index>[<expr><name>transno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name>setno</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name>setno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name>setno</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <comment type="block">/*
     * We don't need to ReScanExprContext the output tuple context here;
     * ExecReScan already did it. But we do need to reset our per-grouping-set
     * contexts, which may have transvalues stored in them. (We use rescan
     * rather than just reset because transfns may have registered callbacks
     * that need to be run now.) For the AGG_HASHED case, see below.
     */</comment>

    <for>for <control>(<init><expr><name>setno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>setno</name> <operator>&lt;</operator> <name>numGroupingSets</name></expr>;</condition> <incr><expr><name>setno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ReScanExprContext</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>aggcontexts</name><index>[<expr><name>setno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Release first tuple of group, if we have made a copy */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>grp_firstTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Forget current agg values */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggvalues</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>node</name><operator>-&gt;</operator><name>numaggs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggnulls</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>node</name><operator>-&gt;</operator><name>numaggs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * With AGG_HASHED/MIXED, the hash table is allocated in a sub-context of
     * the hashcontext. This used to be an issue, but now, resetting a context
     * automatically deletes sub-contexts too.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_MIXED</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ReScanExprContext</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Rebuild an empty hash table */</comment>
        <expr_stmt><expr><call><name>build_hash_table</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>table_filled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <comment type="block">/* iterator will be reset when the table is filled */</comment>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_HASHED</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Reset the per-group state (in particular, mark transvalues null)
         */</comment>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pergroup</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerGroupData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>node</name><operator>-&gt;</operator><name>numaggs</name></name> <operator>*</operator> <name>numGroupingSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* reset to phase 1 */</comment>
        <expr_stmt><expr><call><name>initialize_phase</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>input_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>outerPlan</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***********************************************************************
 * API exposed to aggregate functions
 ***********************************************************************/</comment>


<comment type="block">/*
 * AggCheckCallContext - test if a SQL function is being called as an aggregate
 *
 * The transition and/or final functions of an aggregate may want to verify
 * that they are being called as aggregates, rather than as plain SQL
 * functions.  They should use this function to do so.  The return value
 * is nonzero if being called as an aggregate, or zero if not.  (Specific
 * nonzero values are AGG_CONTEXT_AGGREGATE or AGG_CONTEXT_WINDOW, but more
 * values could conceivably appear in future.)
 *
 * If aggcontext isn't NULL, the function also stores at *aggcontext the
 * identity of the memory context that aggregate transition values are being
 * stored in.  Note that the same aggregate call site (flinfo) may be called
 * interleaved on different transition values in different contexts, so it's
 * not kosher to cache aggcontext under fn_extra.  It is, however, kosher to
 * cache it in the transvalue itself (for internal-type transvalues).
 */</comment>
<function><type><name>int</name></type>
<name>AggCheckCallContext</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name> <modifier>*</modifier></type><name>aggcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>AggState</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>aggcontext</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>AggState</name>   <modifier>*</modifier></type><name>aggstate</name> <init>= <expr><operator>(</operator><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>cxt</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><operator>*</operator><name>aggcontext</name> <operator>=</operator> <name><name>cxt</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>AGG_CONTEXT_AGGREGATE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>WindowAggState</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>aggcontext</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>aggcontext</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>WindowAggState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name><operator>)</operator><operator>-&gt;</operator><name>curaggcontext</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>AGG_CONTEXT_WINDOW</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* this is just to prevent "uninitialized variable" warnings */</comment>
    <if_stmt><if>if <condition>(<expr><name>aggcontext</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>aggcontext</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AggGetAggref - allow an aggregate support function to get its Aggref
 *
 * If the function is being called as an aggregate support function,
 * return the Aggref node for the aggregate call.  Otherwise, return NULL.
 *
 * Note that if an aggregate is being used as a window function, this will
 * return NULL.  We could provide a similar function to return the relevant
 * WindowFunc node in such cases, but it's not needed yet.
 */</comment>
<function><type><name>Aggref</name> <modifier>*</modifier></type>
<name>AggGetAggref</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>AggState</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>curpertrans</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>curpertrans</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name><operator>)</operator><operator>-&gt;</operator><name>curpertrans</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>curpertrans</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name><name>curpertrans</name><operator>-&gt;</operator><name>aggref</name></name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AggGetTempMemoryContext - fetch short-term memory context for aggregates
 *
 * This is useful in agg final functions; the context returned is one that
 * the final function can safely reset as desired.  This isn't useful for
 * transition functions, since the context returned MAY (we don't promise)
 * be the same as the context those are called in.
 *
 * As above, this is currently not useful for aggs called as window functions.
 */</comment>
<function><type><name>MemoryContext</name></type>
<name>AggGetTempMemoryContext</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>AggState</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AggState</name>   <modifier>*</modifier></type><name>aggstate</name> <init>= <expr><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>

        <return>return <expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AggRegisterCallback - register a cleanup callback for an aggregate
 *
 * This is useful for aggs to register shutdown callbacks, which will ensure
 * that non-memory resources are freed.  The callback will occur just before
 * the associated aggcontext (as returned by AggCheckCallContext) is reset,
 * either between groups or as a result of rescanning the query.  The callback
 * will NOT be called on error paths.  The typical use-case is for freeing of
 * tuplestores or tuplesorts maintained in aggcontext, or pins held by slots
 * created by the agg functions.  (The callback will not be called until after
 * the result of the finalfn is no longer needed, so it's safe for the finalfn
 * to return data that will be freed by the callback.)
 *
 * As above, this is currently not useful for aggs called as window functions.
 */</comment>
<function><type><name>void</name></type>
<name>AggRegisterCallback</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
                    <parameter><decl><type><name>ExprContextCallbackFunction</name></type> <name>func</name></decl></parameter>,
                    <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>AggState</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AggState</name>   <modifier>*</modifier></type><name>aggstate</name> <init>= <expr><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>cxt</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>RegisterExprContextCallback</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate function cannot register a callback in this context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * aggregate_dummy - dummy execution routine for aggregate functions
 *
 * This function is listed as the implementation (prosrc field) of pg_proc
 * entries for aggregate functions.  Its only purpose is to throw an error
 * if someone mistakenly executes such a function in the normal way.
 *
 * Perhaps someday we could assign real meaning to the prosrc field of
 * an aggregate?
 */</comment>
<function><type><name>Datum</name></type>
<name>aggregate_dummy</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate function %u called as normal function"</literal></expr></argument>,
         <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>            <comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>ReDistributeEstimate</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type> <name>len</name> <init>= <expr><call><name>ReDistributeState_Size</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_SortState</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>SortState</name> <modifier>*</modifier></type><name>sort</name> <init>= <expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>sort</name><operator>-&gt;</operator><name>stateLen</name></name>  <operator>=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_AggState</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AggState</name> <modifier>*</modifier></type><name>agg</name>   <init>= <expr><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>stateLen</name></name>   <operator>=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unhandled ReDistribute PlanState %d in ReDistributeEstimate"</literal></expr></argument>, 
                         <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ReDistributeInitializeDSM</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type> <name>len</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReDistributeState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReDistributeState</name> <modifier>*</modifier><modifier>*</modifier></type><name>state_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_SortState</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>SortState</name> <modifier>*</modifier></type><name>sort</name> <init>= <expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>len</name>             <operator>=</operator> <name><name>sort</name><operator>-&gt;</operator><name>stateLen</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>state_ptr</name>       <operator>=</operator> <operator>&amp;</operator><name><name>sort</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_AggState</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AggState</name> <modifier>*</modifier></type><name>agg</name>   <init>= <expr><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>len</name>             <operator>=</operator> <name><name>agg</name><operator>-&gt;</operator><name>stateLen</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>state_ptr</name>       <operator>=</operator> <operator>&amp;</operator><name><name>agg</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unhandled ReDistribute PlanState %d in ReDistributeInitializeDSM"</literal></expr></argument>, 
                        <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* orginize memory allocated */</comment>
    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReDistributeState</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <operator>(</operator><name>ReDistributeStatus</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>state</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReDistributeStatus</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ReDistributeData</name></name> <operator>=</operator> <operator>(</operator><name>dsa_pointer</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>state</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dsa_pointer</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>*</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <operator>(</operator><name>ReDistributeBuffer</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>state</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
    
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>numExpectedParallelWorkers</name></name> <operator>=</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>status</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>ReDistribute_None</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReDistributeBuffer</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>*</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>*</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ReDistributeData</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>ReDistributeBuffer</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>state</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>ReDistributeBufferTotalSize</name></expr>;</expr_stmt>

        <comment type="block">/* initialize buffer */</comment>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>length</name>        <operator>=</operator> <name>ReDistributeBufferSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>head</name>          <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tail</name>          <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nTuples</name>       <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nTuplesBuffer</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nTuplesFile</name>   <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>dataType</name>      <operator>=</operator> <name>DT_None</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name> <operator>+</operator> <name>PARALLEL_REDISTRIBUTE_OFFSET</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>state_ptr</name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ReDistributeInitializeWorker</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParallelWorkerContext</name> <modifier>*</modifier></type><name>pwcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name> <init>= <expr><name><name>pwcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReDistributeState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReDistributeState</name> <modifier>*</modifier></type><name>rd_state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>ParallelWorkerStatus</name> <modifier>*</modifier></type><name>numParallelWorkers</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name> <operator>+</operator> <name>PARALLEL_REDISTRIBUTE_OFFSET</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>numParallelWorkers</name> <operator>=</operator> <call><name>GetParallelWorkerStatusInfo</name><argument_list>(<argument><expr><name>toc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rd_state</name> <operator>=</operator> <operator>(</operator><name>ReDistributeState</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReDistributeState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* orginize memory allocated */</comment>
    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReDistributeState</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rd_state</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <operator>(</operator><name>ReDistributeStatus</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>state</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReDistributeStatus</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>state</name><operator>-&gt;</operator><name>numExpectedParallelWorkers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rd_state</name><operator>-&gt;</operator><name>ReDistributeData</name></name> <operator>=</operator> <operator>(</operator><name>dsa_pointer</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>state</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dsa_pointer</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>state</name><operator>-&gt;</operator><name>numExpectedParallelWorkers</name></name> <operator>*</operator> <name><name>state</name><operator>-&gt;</operator><name>numExpectedParallelWorkers</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rd_state</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <operator>(</operator><name>ReDistributeBuffer</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReDistributeBuffer</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>state</name><operator>-&gt;</operator><name>numExpectedParallelWorkers</name></name> <operator>*</operator> <name><name>state</name><operator>-&gt;</operator><name>numExpectedParallelWorkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReDistributeBuffer</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>state</name><operator>-&gt;</operator><name>numExpectedParallelWorkers</name></name> <operator>*</operator> <name><name>state</name><operator>-&gt;</operator><name>numExpectedParallelWorkers</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>numExpectedParallelWorkers</name></name> <operator>*</operator> <name><name>state</name><operator>-&gt;</operator><name>numExpectedParallelWorkers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>rd_state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>ReDistributeBuffer</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>state</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>ReDistributeBufferTotalSize</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="block">/*
      * get total number of launched parallel workers.
      * this number is set by session after launching all parallel workers,
      * so we may need to wait for the setup
      */</comment>
    <while>while<condition>(<expr><operator>!</operator><name><name>numParallelWorkers</name><operator>-&gt;</operator><name>parallelWorkersSetupDone</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    </block_content>}</block></while>
    
    <expr_stmt><expr><name><name>rd_state</name><operator>-&gt;</operator><name>numExpectedParallelWorkers</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>numExpectedParallelWorkers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rd_state</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name> <operator>=</operator> <name><name>numParallelWorkers</name><operator>-&gt;</operator><name>numLaunchedWorkers</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>rd_state</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name> <operator>&gt;</operator> 
       <name><name>rd_state</name><operator>-&gt;</operator><name>numExpectedParallelWorkers</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"launched parallel workers' total number:%d"</literal>
                    <literal type="string">"is greater than the expected:%d"</literal></expr></argument>,
                    <argument><expr><name><name>rd_state</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr></argument>,
                    <argument><expr><name><name>rd_state</name><operator>-&gt;</operator><name>numExpectedParallelWorkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>ParallelWorkerNumber</name> <operator>&gt;=</operator> <name><name>rd_state</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"parallel worker's number:%d is greater than"</literal>
                    <literal type="string">"launched parallel workers' total number:%d"</literal></expr></argument>,
                    <argument><expr><name>ParallelWorkerNumber</name></expr></argument>, <argument><expr><name><name>rd_state</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name><name>rd_state</name><operator>-&gt;</operator><name>status</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <name>ReDistribute_Init</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>workerStatus</name> <operator>=</operator> <name><name>rd_state</name><operator>-&gt;</operator><name>status</name></name></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_SortState</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>SortState</name> <modifier>*</modifier></type><name>sort</name> <init>= <expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>sort</name><operator>-&gt;</operator><name>state</name></name>     <operator>=</operator> <name>rd_state</name></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_AggState</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AggState</name> <modifier>*</modifier></type><name>agg</name>   <init>= <expr><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>state</name></name>      <operator>=</operator> <name>rd_state</name></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unhandled ReDistribute PlanState %d in ReDistributeInitializeWorker"</literal></expr></argument>, 
                        <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* create bufFile to store data for other parallel workers */</comment>
<function><type><name>void</name></type>
<name>InitializeReDistribute</name><parameter_list>(<parameter><decl><type><name>ReDistributeState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BufFile</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>          <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numWorkers</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BufFile</name>  <modifier>*</modifier><modifier>*</modifier></type><name>bufFile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>bufFile</name> <operator>=</operator> <operator>(</operator><name>BufFile</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numWorkers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numWorkers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>bufFile</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BufFileCreateTemp</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><operator>*</operator><name>file</name> <operator>=</operator> <name>bufFile</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* 
  * re-distribute data between parallel workers 
  * calculate the hashvalue of input tupleslot by the hash function, and 
  * module the hashvalue with number of parallel workers, then decide
  * which worker the data need to send.
  * if the data is sent to worker self, do nothing, return false;
  * else return true.
  */</comment>
<function><type><name>bool</name></type>
<name>ReDistributeData</name><parameter_list>(<parameter><decl><type><name>ReDistributeState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BufFile</name> <modifier>*</modifier><modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>varattno</name></decl></parameter>, 
                 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>LocatorHashFunc</name></type>    <name>hashfunc</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>tmpcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>  <name>formDataRow</name>      <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>  <name>isnull</name>           <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>   <name>i</name>                <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numWorkers</name>         <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>value</name>            <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>indexSendWorker</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReDistributeDataType</name></type> <name>dataType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_area</name> <modifier>*</modifier></type> <name>dsa</name> <init>= <expr><call><name>GetNumWorkerDsa</name><argument_list>(<argument><expr><name>ParallelWorkerNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteDataRow</name></type> <name>dataRow</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>dataType</name> <operator>=</operator> <name>DT_DataRow</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mintuple</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>dataType</name> <operator>=</operator> <name>DT_MinimalTup</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>dataType</name> <operator>=</operator> <name>DT_HeapTup</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>formDataRow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dataType</name> <operator>=</operator> <name>DT_DataRow</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* get the attrNumber's value from given tupleslot */</comment>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"the re-distributed column is null."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>indexSendWorker</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* calculate the hashvalue */</comment>
        <expr_stmt><expr><name>indexSendWorker</name> <operator>=</operator> <call><name>ReDistributeHash</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>numWorkers</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>hashfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
    <comment type="block">/* data belongs to us */</comment>
    <if_stmt><if>if <condition>(<expr><name>indexSendWorker</name> <operator>==</operator> <name>ParallelWorkerNumber</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* send to others */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>dataLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>dp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ReDistributeBufFile</name> <modifier>*</modifier></type><name>bufFile</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><name>ParallelWorkerNumber</name> <operator>*</operator> <name>numWorkers</name> <operator>+</operator> <name>indexSendWorker</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* send data to other workers */</comment>
        <switch>switch<condition>(<expr><name>dataType</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>DT_DataRow</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>formDataRow</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>dataLen</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name><operator>-&gt;</operator><name>msglen</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>data</name>    <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name><operator>-&gt;</operator><name>msg</name></name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>dataRow</name> <operator>=</operator> <call><name>ExecCopySlotDatarow</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tmpcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>dataLen</name> <operator>=</operator> <name><name>dataRow</name><operator>-&gt;</operator><name>msglen</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>data</name>    <operator>=</operator> <name><name>dataRow</name><operator>-&gt;</operator><name>msg</name></name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <break>break;</break>
            <case>case <expr><name>DT_MinimalTup</name></expr>:</case>
                <block>{<block_content>
                    <expr_stmt><expr><name>dataLen</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_mintuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>data</name>    <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_mintuple</name></name></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>
            <case>case <expr><name>DT_HeapTup</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type> <name>offset</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>dataLen</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>+</operator> <name>HEAPTUPLESIZE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>data</name>    <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>dataLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></argument>, <argument><expr><name>HEAPTUPLESIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>HEAPTUPLESIZE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong data type while ReDistributing Data."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>

        <comment type="block">/* Mark extracted state invalid */</comment>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/* if we can send data to buffer instead of bufFile */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>ReDistributeBufferFreeSize</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <operator>(</operator><name>dataLen</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* enough space in buffer, put data into buffer */</comment>

            <comment type="block">/* datatype consistence check */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>index</name></expr>]</index></name><operator>-&gt;</operator><name>dataType</name> <operator>==</operator> <name>DT_None</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* first time we send data */</comment>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>index</name></expr>]</index></name><operator>-&gt;</operator><name>dataType</name> <operator>=</operator> <name>dataType</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>index</name></expr>]</index></name><operator>-&gt;</operator><name>dataType</name> <operator>!=</operator> <name>dataType</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"mismatch data type in same buffer. BufDataType:%d, InputDataType:%d,"</literal>
                                <literal type="string">"index %d, worker %d."</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>index</name></expr>]</index></name><operator>-&gt;</operator><name>dataType</name></expr></argument>, <argument><expr><name>dataType</name></expr></argument>,
                                <argument><expr><name>index</name></expr></argument>, <argument><expr><name>ParallelWorkerNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>index</name></expr>]</index></name><operator>-&gt;</operator><name>nTuples</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>index</name></expr>]</index></name><operator>-&gt;</operator><name>nTuplesBuffer</name><operator>++</operator></expr>;</expr_stmt>
            
            <comment type="block">/* put data */</comment>
            <expr_stmt><expr><call><name>ReDistributeBufferPutData</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><name>dataLen</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>ReDistributeData</name><index>[<expr><name>index</name></expr>]</index></name> <operator>==</operator> <name>InvalidDsaPointer</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>dsa_allocate0</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReDistributeBufFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>bufFile</name> <operator>=</operator> <operator>(</operator><name>ReDistributeBufFile</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ReDistributeData</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>dp</name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>bufFile</name><operator>-&gt;</operator><name>dataType</name></name> <operator>=</operator> <name>dataType</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"worker:%d, index:%d, dp:%lu."</literal></expr></argument>, <argument><expr><name>ParallelWorkerNumber</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>dp</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>ReDistributeData</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>bufFile</name> <operator>=</operator> <operator>(</operator><name>ReDistributeBufFile</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>bufFile</name><operator>-&gt;</operator><name>dataType</name></name> <operator>!=</operator> <name>dataType</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"mismatch data type in same bufFile. BufFileDataType:%d, InputDataType:%d,"</literal>
                                <literal type="string">"index %d, worker %d, dp %lu"</literal></expr></argument>, <argument><expr><name><name>bufFile</name><operator>-&gt;</operator><name>dataType</name></name></expr></argument>, <argument><expr><name>dataType</name></expr></argument>,
                                <argument><expr><name>index</name></expr></argument>, <argument><expr><name>ParallelWorkerNumber</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>index</name></expr>]</index></name><operator>-&gt;</operator><name>nTuples</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>index</name></expr>]</index></name><operator>-&gt;</operator><name>nTuplesFile</name><operator>++</operator></expr>;</expr_stmt>
            
            <if_stmt><if>if <condition>(<expr><call><name>BufFileWrite</name><argument_list>(<argument><expr><name><name>file</name><index>[<expr><name>indexSendWorker</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>dataLen</name></expr></argument>,
                             <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dataLen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dataLen</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ReDistributeData:could not write dataLen to bufFile temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>BufFileWrite</name><argument_list>(<argument><expr><name><name>file</name><index>[<expr><name>indexSendWorker</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></argument>,
                             <argument><expr><name>dataLen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>dataLen</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ReDistributeData:could not write data to bufFile temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>dataType</name> <operator>==</operator> <name>DT_HeapTup</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>dataType</name> <operator>==</operator> <name>DT_DataRow</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>formDataRow</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dataRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* we send data to others, and we also get data from others as possible. */</comment>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>numWorkers</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>dataLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>bufIndex</name> <init>= <expr><name>indexSendWorker</name> <operator>*</operator> <name>numWorkers</name> <operator>+</operator> <name>ParallelWorkerNumber</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RemoteDataRow</name></type> <name>datarow</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            
            <comment type="block">/* Have data in buffer */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>ReDistributeBufferFreeSize</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>bufIndex</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name>ReDistributeBufferSize</name> <operator>/</operator> <literal type="number">4</literal><operator>)</operator> <operator>*</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* read dataLen and data from buffer */</comment>
                <expr_stmt><expr><call><name>ReDistributeBufferGetData</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>bufIndex</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dataLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datarow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


                <switch>switch<condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>bufIndex</name></expr>]</index></name><operator>-&gt;</operator><name>dataType</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>DT_MinimalTup</name></expr>:</case>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>MinimalTuple</name></type> <name>mtup</name> <init>= <expr><operator>(</operator><name>MinimalTuple</name><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
                            
                            <if_stmt><if>if <condition>(<expr><name><name>mtup</name><operator>-&gt;</operator><name>t_len</name></name> <operator>!=</operator> <name>dataLen</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"data len mismatch between minimal tup and length read from bufFile."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                            
                            <expr_stmt><expr><call><name>ExecStoreMinimalTuple</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>
                        <break>break;</break>
                    <case>case <expr><name>DT_HeapTup</name></expr>:</case>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name> <init>= <expr><operator>(</operator><name>HeapTuple</name><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name>     <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator><operator>(</operator><name>data</name> <operator>+</operator> <name>HEAPTUPLESIZE</name><operator>)</operator></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>+</operator> <name>HEAPTUPLESIZE</name> <operator>!=</operator> <name>dataLen</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"data len mismatch between heap tup and length read from bufFile."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>

                            <expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>
                        <break>break;</break>
                    <case>case <expr><name>DT_DataRow</name></expr>:</case>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ExecStoreDataRowTuple</name><argument_list>(<argument><expr><name>datarow</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>
                        <break>break;</break>
                    <default>default:</default>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong data type while getting ReDistributeData."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></switch>

                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>indexSendWorker</name> <operator>=</operator> <operator>(</operator><name>indexSendWorker</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>numWorkers</name></expr>;</expr_stmt>
            
            <if_stmt><if>if <condition>(<expr><name>indexSendWorker</name> <operator>==</operator> <name>ParallelWorkerNumber</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>indexSendWorker</name> <operator>=</operator> <operator>(</operator><name>indexSendWorker</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>numWorkers</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>

        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* share bufFile's file name to other workers */</comment>
<function><type><name>void</name></type>
<name>ReDistributeShareBufFile</name><parameter_list>(<parameter><decl><type><name>ReDistributeState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BufFile</name> <modifier>*</modifier><modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>dp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_pointer</name> <modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numWorkers</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_area</name> <modifier>*</modifier></type> <name>dsa</name> <init>= <expr><call><name>GetNumWorkerDsa</name><argument_list>(<argument><expr><name>ParallelWorkerNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReDistributeBufFile</name> <modifier>*</modifier></type><name>bufFile</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numWorkers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>ParallelWorkerNumber</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* flush bufFile until flush successfully  */</comment>
            <do>do
            <block>{<block_content>
                <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>FlushBufFile</name><argument_list>(<argument><expr><name><name>file</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block> while<condition>(<expr><name>ret</name> <operator>==</operator> <name>EOF</name></expr>)</condition>;</do>
                
            <expr_stmt><expr><name>index</name> <operator>=</operator> <name>ParallelWorkerNumber</name> <operator>*</operator> <name>numWorkers</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>ReDistributeData</name><index>[<expr><name>index</name></expr>]</index></name> <operator>!=</operator> <name>InvalidDsaPointer</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>bufFile</name> <operator>=</operator> <operator>(</operator><name>ReDistributeBufFile</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>ReDistributeData</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>bufFile</name><operator>-&gt;</operator><name>numFiles</name></name> <operator>=</operator> <call><name>NumFilesBufFile</name><argument_list>(<argument><expr><name><name>file</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>dsa_allocate0</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_pointer</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>bufFile</name><operator>-&gt;</operator><name>numFiles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>bufFile</name><operator>-&gt;</operator><name>fileNames</name></name> <operator>=</operator> <name>dp</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>names</name> <operator>=</operator> <operator>(</operator><name>dsa_pointer</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>bufFile</name><operator>-&gt;</operator><name>numFiles</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fileName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>dsa_allocate0</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>names</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>dp</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>fileName</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>getBufFileName</name><argument_list>(<argument><expr><name><name>file</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>status</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <name>ReDistribute_ProduceDone</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>BufFile</name> <modifier>*</modifier></type>
<name>GetReDistributeBufFile</name><parameter_list>(<parameter><decl><type><name>ReDistributeState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ReDistributeDataType</name> <modifier>*</modifier></type><name>dataType</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numWorkers</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BufFile</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>dp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReDistributeBufFile</name> <modifier>*</modifier></type><name>bufFile</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_area</name> <modifier>*</modifier></type> <name>dsa</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_pointer</name> <modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nMerged</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>merged</name> <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numWorkers</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><name><name>merged</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>nMerged</name> <operator>&lt;</operator> <name>numWorkers</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>ParallelWorkerNumber</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name>ReDistribute_ProduceDone</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>merged</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>merged</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nMerged</name><operator>++</operator></expr>;</expr_stmt>
                
                <expr_stmt><expr><name>index</name> <operator>=</operator> <name>i</name> <operator>*</operator> <name>numWorkers</name> <operator>+</operator> <name>ParallelWorkerNumber</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>dsa</name> <operator>=</operator> <call><name>GetNumWorkerDsa</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>ReDistributeData</name><index>[<expr><name>index</name></expr>]</index></name> <operator>!=</operator> <name>InvalidDsaPointer</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>dp</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>ReDistributeData</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>

                    <expr_stmt><expr><name>bufFile</name> <operator>=</operator> <operator>(</operator><name>ReDistributeBufFile</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>dataType</name> <operator>==</operator> <name>DT_None</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><operator>*</operator><name>dataType</name> <operator>=</operator> <name><name>bufFile</name><operator>-&gt;</operator><name>dataType</name></name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>dataType</name> <operator>!=</operator> <name><name>bufFile</name><operator>-&gt;</operator><name>dataType</name></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"data type mismatch between workers."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></else></if_stmt>

                    <expr_stmt><expr><name>dp</name> <operator>=</operator> <name><name>bufFile</name><operator>-&gt;</operator><name>fileNames</name></name></expr>;</expr_stmt>

                    <expr_stmt><expr><name>names</name> <operator>=</operator> <operator>(</operator><name>dsa_pointer</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>CreateBufFile</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>bufFile</name><operator>-&gt;</operator><name>numFiles</name></name></expr></argument>, <argument><expr><name>names</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>ReDistribute_Error</name> <operator>||</operator> <call><name>ParallelError</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s:%d]some other workers exit with errors, and we need to exit because"</literal>
                            <literal type="string">" of data corrupted."</literal></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>numWorkers</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">100L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>file</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>GetReDistributeData</name><parameter_list>(<parameter><decl><type><name>ReDistributeState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BufFile</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>slot</name></decl></parameter>, 
                         <parameter><decl><type><name>ReDistributeDataType</name></type> <name>dataType</name></decl></parameter>, <parameter><decl><type><name>BufFile</name> <modifier>*</modifier><modifier>*</modifier></type><name>aggfile</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>   <name>readFromBuffer</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>nread</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>int</name></type>    <name>dataLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name>     <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteDataRow</name></type> <name>datarow</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numWorkers</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><operator>(</operator><operator>*</operator><name>index</name><operator>)</operator> <operator>&lt;</operator> <name>numWorkers</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>bufIndex</name> <init>= <expr><operator>(</operator><operator>*</operator><name>index</name><operator>)</operator> <operator>*</operator> <name>numWorkers</name> <operator>+</operator> <name>ParallelWorkerNumber</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>index</name><operator>)</operator> <operator>==</operator> <name>ParallelWorkerNumber</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>index</name><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name>index</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>bufIndex</name></expr>]</index></name><operator>-&gt;</operator><name>head</name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>bufIndex</name></expr>]</index></name><operator>-&gt;</operator><name>tail</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>dataType</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>bufIndex</name></expr>]</index></name><operator>-&gt;</operator><name>dataType</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>ReDistributeBufferGetData</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>bufIndex</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dataLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datarow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>readFromBuffer</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>index</name><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name>index</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>readFromBuffer</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* no data */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>file</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>nDone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>numWorkers</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>status</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <name>ReDistribute_ConsumeDone</name></expr>;</expr_stmt>

            <comment type="block">/* close file */</comment>
            <while>while <condition>(<expr><name>nDone</name> <operator>&lt;</operator> <name>numWorkers</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name><index>[<expr><name>nDone</name></expr>]</index></name> <operator>&lt;</operator> <name>ReDistribute_ConsumeDone</name> <operator>&amp;&amp;</operator>
                    <name><name>state</name><operator>-&gt;</operator><name>status</name><index>[<expr><name>nDone</name></expr>]</index></name> <operator>&gt;</operator> <name>ReDistribute_Error</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name><index>[<expr><name>nDone</name></expr>]</index></name> <operator>==</operator> <name>ReDistribute_Error</name> <operator>||</operator> <call><name>ParallelError</name><argument_list>()</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s:%d]some other workers exit with errors, and we need to exit because"</literal>
                                <literal type="string">" of data corrupted."</literal></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>nDone</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></while>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numWorkers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>aggfile</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    
<label><name>READ_LENGTH</name>:</label>
        <comment type="block">/* read data length */</comment>
        <expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>BufFileRead</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>dataLen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dataLen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* read all data */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>BufFileReadDone</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>nDone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>numWorkers</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr></init></decl>;</decl_stmt>
                <comment type="block">/* set status */</comment>
                <expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>status</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <name>ReDistribute_ConsumeDone</name></expr>;</expr_stmt>
                
                <comment type="block">/* close file */</comment>
                <while>while <condition>(<expr><name>nDone</name> <operator>&lt;</operator> <name>numWorkers</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name><index>[<expr><name>nDone</name></expr>]</index></name> <operator>&lt;</operator> <name>ReDistribute_ConsumeDone</name> <operator>&amp;&amp;</operator>
                        <name><name>state</name><operator>-&gt;</operator><name>status</name><index>[<expr><name>nDone</name></expr>]</index></name> <operator>&gt;</operator> <name>ReDistribute_Error</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name><index>[<expr><name>nDone</name></expr>]</index></name> <operator>==</operator> <name>ReDistribute_Error</name> <operator>||</operator> <call><name>ParallelError</name><argument_list>()</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s:%d]some other workers exit with errors, and we need to exit because"</literal>
                                    <literal type="string">" of data corrupted."</literal></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>nDone</name><operator>++</operator></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></while>

                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numWorkers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>aggfile</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                
                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <goto>goto <name>READ_LENGTH</name>;</goto>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>nread</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dataLen</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not read dataLen in ReDistribute bufFile."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>dataType</name> <operator>==</operator> <name>DT_DataRow</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>datarow</name> <operator>=</operator> <operator>(</operator><name>RemoteDataRow</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RemoteDataRowData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>dataLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>datarow</name><operator>-&gt;</operator><name>msgnode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>datarow</name><operator>-&gt;</operator><name>msglen</name></name> <operator>=</operator> <name>dataLen</name></expr>;</expr_stmt> 
            <expr_stmt><expr><name>data</name>    <operator>=</operator> <name><name>datarow</name><operator>-&gt;</operator><name>msg</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
			<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name>dataLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    
<label><name>READ_DATA</name>:</label>
        <comment type="block">/* read data length */</comment>
        <expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>BufFileRead</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>, <argument><expr><name>dataLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><call><name>BufFileReadDone</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no data in bufFile while reading data."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <goto>goto <name>READ_DATA</name>;</goto>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>nread</name> <operator>!=</operator> <name>dataLen</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not read data in ReDistribute bufFile."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <switch>switch<condition>(<expr><name>dataType</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>DT_MinimalTup</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>MinimalTuple</name></type> <name>mtup</name> <init>= <expr><operator>(</operator><name>MinimalTuple</name><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
                
                <if_stmt><if>if <condition>(<expr><name><name>mtup</name><operator>-&gt;</operator><name>t_len</name></name> <operator>!=</operator> <name>dataLen</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"data len mismatch between minimal tup and length read from bufFile."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                
                <expr_stmt><expr><call><name>ExecStoreMinimalTuple</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>, <argument><expr><operator>*</operator><name>slot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>DT_HeapTup</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name> <init>= <expr><operator>(</operator><name>HeapTuple</name><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name>     <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator><operator>(</operator><name>data</name> <operator>+</operator> <name>HEAPTUPLESIZE</name><operator>)</operator></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>+</operator> <name>HEAPTUPLESIZE</name> <operator>!=</operator> <name>dataLen</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"data len mismatch between heap tup and length read from bufFile."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><operator>*</operator><name>slot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>DT_DataRow</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ExecStoreDataRowTuple</name><argument_list>(<argument><expr><name>datarow</name></expr></argument>, <argument><expr><operator>*</operator><name>slot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong data type while getting ReDistributeData."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> 
<name>ReDistributeHash</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dataType</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numWorkers</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>LocatorHashFunc</name></type> <name>hashfunc</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>num</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>numWorkers</name></expr></init></decl>;</decl_stmt>
    
    <switch>switch<condition>(<expr><name>dataType</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>INT8OID</name></expr>:</case>
        <case>case <expr><name>CASHOID</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int64</name></type> <name>val</name> <init>= <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>%</operator> <name>num</name><operator>)</operator> <operator>%</operator> <name>numWorkers</name></expr>;</expr_stmt>
            </block_content>}</block>
			<break>break;</break>
        <case>case <expr><name>INT2OID</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int16</name></type> <name>val</name> <init>= <expr><call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>%</operator> <name>num</name><operator>)</operator> <operator>%</operator> <name>numWorkers</name></expr>;</expr_stmt>
            </block_content>}</block>
			<break>break;</break>
        <case>case <expr><name>OIDOID</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>uint32</name></type> <name>val</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>%</operator> <name>num</name><operator>)</operator> <operator>%</operator> <name>numWorkers</name></expr>;</expr_stmt>
            </block_content>}</block>
			<break>break;</break>
        <case>case <expr><name>INT4OID</name></expr>:</case>
        <case>case <expr><name>ABSTIMEOID</name></expr>:</case>
        <case>case <expr><name>RELTIMEOID</name></expr>:</case>
        <case>case <expr><name>DATEOID</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int32</name></type> <name>val</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>%</operator> <name>num</name><operator>)</operator> <operator>%</operator> <name>numWorkers</name></expr>;</expr_stmt>
            </block_content>}</block>
			<break>break;</break>
        <case>case <expr><name>BOOLOID</name></expr>:</case>
        <case>case <expr><name>CHAROID</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int32</name></type> <name>val</name> <init>= <expr><operator>(</operator><name>int32</name><operator>)</operator><call><name>DatumGetChar</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>%</operator> <name>num</name><operator>)</operator> <operator>%</operator> <name>numWorkers</name></expr>;</expr_stmt>
            </block_content>}</block>
			<break>break;</break>
        <case>case <expr><name>TIMEOID</name></expr>:</case>
        <case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
        <case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int64</name></type> <name>val</name> <init>= <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>%</operator> <name>num</name><operator>)</operator> <operator>%</operator> <name>numWorkers</name></expr>;</expr_stmt>
            </block_content>}</block>
			<break>break;</break>
        <default>default:</default>
            <block>{<block_content>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>hashvalue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>hashvalue</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>hashfunc</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>hashvalue</name> <operator>%</operator> <name>num</name><operator>)</operator> <operator>%</operator> <name>numWorkers</name></expr>;</expr_stmt>
            </block_content>}</block>
    </block_content>}</block></switch>

    <return>return <expr><call><name>abs</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ReDistributeBufferFreeSize</name><parameter_list>(<parameter><decl><type><name>ReDistributeBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>freeSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>head</name></name> <operator>&gt;=</operator> <name><name>buf</name><operator>-&gt;</operator><name>tail</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>freeSize</name> <operator>=</operator> <operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>head</name></name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>tail</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>freeSize</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>tail</name></name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>head</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>freeSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReDistributeBufferPutData</name><parameter_list>(<parameter><decl><type><name>ReDistributeBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dataLen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>posi</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* put data length */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>head</name></name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name>posi</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dataLen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>posi</name> <operator>=</operator> <operator>(</operator><name>posi</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>%</operator> <name><name>buf</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name>posi</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dataLen</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dataLen</name> <operator>+</operator> <name>len</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>posi</name> <operator>=</operator> <operator>(</operator><name>posi</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>%</operator> <name><name>buf</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* put data */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name>posi</name> <operator>&gt;=</operator> <name>dataLen</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name>posi</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>dataLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>    
        <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name>posi</name></expr>;</expr_stmt>
    
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name>posi</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>dataLen</name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>head</name></name> <operator>+</operator> <name>dataLen</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>%</operator> <name><name>buf</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReDistributeBufferGetData</name><parameter_list>(<parameter><decl><type><name>ReDistributeBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dataLen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>RemoteDataRow</name> <modifier>*</modifier></type><name>datarow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>tail</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* get data length */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name>offset</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>dataLen</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>dataLen</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>dataLen</name> <operator>+</operator> <name>len</name><operator>)</operator></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>offset</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>%</operator> <name><name>buf</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>dataType</name></name> <operator>==</operator> <name>DT_DataRow</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>datarow</name> <operator>=</operator> <operator>(</operator><name>RemoteDataRow</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RemoteDataRowData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>*</operator><name>dataLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>datarow</name><operator>)</operator><operator>-&gt;</operator><name>msgnode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>datarow</name><operator>)</operator><operator>-&gt;</operator><name>msglen</name></name> <operator>=</operator> <operator>*</operator><name>dataLen</name></expr>;</expr_stmt> 
        <expr_stmt><expr><name>msg</name>    <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>datarow</name><operator>)</operator><operator>-&gt;</operator><name>msg</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>msg</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><operator>*</operator><name>dataLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>data</name> <operator>=</operator> <name>msg</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* get data */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name>offset</name> <operator>&gt;=</operator> <operator>*</operator><name>dataLen</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><operator>*</operator><name>dataLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>msg</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><operator>*</operator><name>dataLen</name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>tail</name></name> <operator>+</operator> <operator>*</operator><name>dataLen</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>%</operator> <name><name>buf</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ReDistributeBufferCheck</name><parameter_list>(<parameter><decl><type><name>ReDistributeState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>int</name></type> <name>numWorkers</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>ParallelWorkerNumber</name> <operator>*</operator> <name>numWorkers</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ParallelWorkerNumber</name> <operator>*</operator> <name>numWorkers</name> <operator>+</operator> <name>numWorkers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>head</name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tail</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"data left in ReDistributeBuffer, worker %d, buffer %d."</literal></expr></argument>, <argument><expr><name>ParallelWorkerNumber</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Worker %d ReDistributeBuffer nTuples %zu, nTuples_buffer %zu, nTuples_file %zu"</literal></expr></argument>,
                      <argument><expr><name>ParallelWorkerNumber</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nTuples</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nTuplesBuffer</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nTuplesFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ReDistributeEreport</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>workerStatus</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>workerStatus</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <name>ReDistribute_Error</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>workerStatus</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
