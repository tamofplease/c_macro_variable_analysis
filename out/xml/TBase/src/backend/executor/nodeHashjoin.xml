<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/executor/nodeHashjoin.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeHashjoin.c
 *      Routines to handle hash join nodes
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/executor/nodeHashjoin.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/hashjoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHashjoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execParallel.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * States of the ExecHashJoin state machine
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HJ_BUILD_HASHTABLE</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HJ_NEED_NEW_OUTER</name></cpp:macro>        <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HJ_SCAN_BUCKET</name></cpp:macro>            <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HJ_FILL_OUTER_TUPLE</name></cpp:macro>        <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HJ_FILL_INNER_TUPLES</name></cpp:macro>    <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HJ_NEED_NEW_BATCH</name></cpp:macro>        <cpp:value>6</cpp:value></cpp:define>

<comment type="block">/* Returns true if doing null-fill on outer relation */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HJ_FILL_OUTER</name><parameter_list>(<parameter><type><name>hjstate</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>((hjstate)-&gt;hj_NullInnerTupleSlot != NULL)</cpp:value></cpp:define>
<comment type="block">/* Returns true if doing null-fill on inner relation */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HJ_FILL_INNER</name><parameter_list>(<parameter><type><name>hjstate</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>((hjstate)-&gt;hj_NullOuterTupleSlot != NULL)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>ParallelHashJoinStatus</name> <modifier>*</modifier></type><name>statusParallelWorker</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecHashJoinOuterGetTuple</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>outerNode</name></decl></parameter>,
                          <parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl></parameter>,
                          <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>hashvalue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecHashJoinGetSavedTuple</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl></parameter>,
                          <parameter><decl><type><name>BufFile</name> <modifier>*</modifier></type><name>file</name></decl></parameter>,
                          <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>hashvalue</name></decl></parameter>,
                          <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tupleSlot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecHashJoinNewBatch</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecShareBufFileName</name><parameter_list>(<parameter><decl><type><specifier>volatile</specifier> <name>ParallelHashJoinState</name> <modifier>*</modifier></type><name>parallelState</name></decl></parameter>, <parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inner</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HashJoinTable</name></type> <name>ExecMergeShmHashTable</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type> <name>hjstate</name></decl></parameter>, <parameter><decl><type><specifier>volatile</specifier> <name>ParallelHashJoinState</name> <modifier>*</modifier></type><name>parallelState</name></decl></parameter>, 
                                <parameter><decl><type><name>Hash</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashOperators</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>keepNulls</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecFormNewOuterBufFile</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type> <name>hjstate</name></decl></parameter>, <parameter><decl><type><specifier>volatile</specifier> <name>ParallelHashJoinState</name> <modifier>*</modifier></type><name>parallelState</name></decl></parameter>, 
                                 <parameter><decl><type><name>Hash</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* ----------------------------------------------------------------
 *        ExecHashJoin
 *
 *        This function implements the Hybrid Hashjoin algorithm.
 *
 *        Note: the relation we build hash table on is the "inner"
 *              the other one is "outer".
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>            <comment type="block">/* return: a tuple or NULL */</comment>
<name>ExecHashJoin</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>HashJoinState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerNode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashState</name>  <modifier>*</modifier></type><name>hashNode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashJoin</name>   <modifier>*</modifier></type><name>hashJoin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>joinqual</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>otherqual</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerTupleSlot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>hashvalue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>batchno</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>ParallelHashJoinState</name> <modifier>*</modifier></type><name>parallelState</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * get information from HashJoin node
     */</comment>
    <expr_stmt><expr><name>joinqual</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>joinqual</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>otherqual</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>hashNode</name> <operator>=</operator> <operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>outerNode</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hashtable</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name>parallelState</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>hj_parallelState</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Reset per-tuple memory context to free any expression evaluation
     * storage allocated in the previous tuple cycle.
     */</comment>
    <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * run the hash join state machine
     */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * It's possible to iterate this loop many times before returning a
         * tuple, in some pathological cases such as needing to move much of
         * the current batch to a later batch.  So let's check for interrupts
         * each time through.
         */</comment>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>HJ_BUILD_HASHTABLE</name></expr>:</case>

                <comment type="block">/*
                 * First time through: build hash table for inner relation.
                 */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>hashtable</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * If the outer relation is completely empty, and it's not
                 * right/full join, we can quit without building the hash
                 * table.  However, for an inner join it is only a win to
                 * check this when the outer relation's startup cost is less
                 * than the projected cost of building the hash table.
                 * Otherwise it's best to build the hash table first and see
                 * if the inner relation is empty.  (When it's a left join, we
                 * should always make this check, since we aren't going to be
                 * able to skip the join on the strength of an empty inner
                 * relation anyway.)
                 *
                 * If we are rescanning the join, we make use of information
                 * gained on the previous scan: don't bother to try the
                 * prefetch if the previous scan found the outer relation
                 * nonempty. This is not 100% reliable since with new
                 * parameters the outer relation might yield different
                 * results, but it's a good heuristic.
                 *
                 * The only way to make the check is to try to fetch a tuple
                 * from the outer plan node.  If we succeed, we have to stash
                 * it away for later consumption by ExecHashJoinOuterGetTuple.
                 */</comment>
                <expr_stmt><expr><name>hashJoin</name> <operator>=</operator> <operator>(</operator><name>HashJoin</name><operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>HJ_FILL_INNER</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* no chance to not build the hash table */</comment>
                    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_FirstOuterTupleSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><call><name>HJ_FILL_OUTER</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>||</operator>
                         <operator>(</operator><name><name>outerNode</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>&lt;</operator> <name><name>hashNode</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&amp;&amp;</operator>
                          <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>hj_OuterNotEmpty</name></name><operator>)</operator></expr>)</condition>
                <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <comment type="block">/* When we need to prefetch inner, we just assume there is at lease one row from outer plan */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>hashJoin</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_inner</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_OuterInited</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_FirstOuterTupleSlot</name></name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_FirstOuterTupleSlot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_OuterNotEmpty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><name>parallelState</name></expr>)</condition>
                            <block>{<block_content>
                                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>hj_InnerInited</name></name> <operator>&amp;&amp;</operator> <name>IS_PGXC_DATANODE</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>ExecDisconnectNode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hashNode</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                                <return>return <expr><name>NULL</name></expr>;</return>
                            </block_content>}</block></if>
                            <else>else<block type="pseudo"><block_content>
                                <expr_stmt><expr><name><name>parallelState</name><operator>-&gt;</operator><name>statusParallelWorker</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <name>ParallelHashJoin_EmptyOuter</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <return>return <expr><name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        </block_content>}</block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_OuterNotEmpty</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_FirstOuterTupleSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_FirstOuterTupleSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <if_stmt><if>if<condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>parallelState</name></expr>)</condition>
                <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>
                    <comment type="block">/* no tuples from outer, check other workers to see if we can stop here. */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>parallelState</name><operator>-&gt;</operator><name>statusParallelWorker</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>==</operator> <name>ParallelHashJoin_EmptyOuter</name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int</name></type>  <name>i</name>           <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>int</name></type>  <name>nEmptyOuter</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>int</name></type>  <name>nWorkers</name>    <init>= <expr><name><name>parallelState</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>checked</name>    <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nWorkers</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>bool</name></type>  <name>exit</name>       <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

                        <while>while <condition>(<expr><name>nEmptyOuter</name> <operator>&lt;</operator> <name>nWorkers</name></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>ParallelWorkerNumber</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>checked</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                            <block>{<block_content>
                                <if_stmt><if>if <condition>(<expr><name><name>parallelState</name><operator>-&gt;</operator><name>statusParallelWorker</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name>ParallelHashJoin_BuildShmHashTable</name> <operator>&amp;&amp;</operator>
                                    <name><name>parallelState</name><operator>-&gt;</operator><name>statusParallelWorker</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <name>ParallelHashJoin_MergeShmHashTableDone</name></expr>)</condition>
                                <block>{<block_content>
                                    <break>break;</break>
                                </block_content>}</block></if>
                                <if type="elseif">else if <condition>(<expr><name><name>parallelState</name><operator>-&gt;</operator><name>statusParallelWorker</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>ParallelHashJoin_EmptyOuter</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>nEmptyOuter</name><operator>++</operator></expr>;</expr_stmt>
                                    <expr_stmt><expr><name><name>checked</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                                </block_content>}</block></if>
                                <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>hashNode</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>exit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                                    <break>break;</break>
                                </block_content>}</block></if>
                                <if type="elseif">else if <condition>(<expr><name><name>parallelState</name><operator>-&gt;</operator><name>statusParallelWorker</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>ParallelHashJoin_Error</name> <operator>||</operator> <call><name>ParallelError</name><argument_list>()</argument_list></call></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s:%d]some other workers exit with errors, and we need to exit because"</literal>
                                                <literal type="string">" of data corrupted."</literal></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                                    
                            </block_content>}</block></if></if_stmt>

                            <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>nWorkers</name></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">10L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></while>

                        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>checked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><name>nEmptyOuter</name> <operator>==</operator> <name>nWorkers</name> <operator>||</operator> <name>exit</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"worker %d ExecHashJoin no tuples from outer!"</literal></expr></argument>, <argument><expr><name>ParallelWorkerNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>ExecDisconnectNode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hashNode</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <return>return <expr><name>NULL</name></expr>;</return>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>        
                    <if_stmt><if>if <condition>(<expr><name><name>hashNode</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_InnerInited</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <comment type="block">/* 
                          * create hashtable in share-memory
                          */</comment>
                        <expr_stmt><expr><name><name>parallelState</name><operator>-&gt;</operator><name>statusParallelWorker</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <name>ParallelHashJoin_BuildShmHashTable</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>hashtable</name> <operator>=</operator> <call><name>ExecShmHashTableCreate</name><argument_list>(<argument><expr><operator>(</operator><name>Hash</name> <operator>*</operator><operator>)</operator> <name><name>hashNode</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>,
                                                            <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashOperators</name></name></expr></argument>,
                                                            <argument><expr><call><name>HJ_FILL_INNER</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name><name>hashNode</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>=</operator> <name>hashtable</name></expr>;</expr_stmt>

                        <comment type="block">/* 
                          * build hashtable in share-memory, and set the worker status to tell other worker our hashtable
                          * has been finished.
                          */</comment>
                        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>MultiExecShmHash</name><argument_list>(<argument><expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>hashNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/*
                          * put hashtable bufile's file name into shm, so other workers can access
                          */</comment>
                        <expr_stmt><expr><name><name>parallelState</name><operator>-&gt;</operator><name>hashTableParallelWorker</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>dsa_pointer</name><operator>)</operator><name>hashtable</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>ExecShareBufFileName</name><argument_list>(<argument><expr><name>parallelState</name></expr></argument>, <argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>parallelState</name><operator>-&gt;</operator><name>statusParallelWorker</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <name>ParallelHashJoin_BuildShmHashTableDone</name></expr>;</expr_stmt>

                        <comment type="block">/* merge shared hashtable, copy into local hashtable */</comment>
                        <expr_stmt><expr><name>hashtable</name> <operator>=</operator> <call><name>ExecMergeShmHashTable</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>parallelState</name></expr></argument>, <argument><expr><operator>(</operator><name>Hash</name> <operator>*</operator><operator>)</operator> <name><name>hashNode</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>,
                                                            <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashOperators</name></name></expr></argument>,
                                                            <argument><expr><call><name>HJ_FILL_INNER</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name> <operator>=</operator> <name>hashtable</name></expr>;</expr_stmt>
						<comment type="block">/* copy into hashNode too, for instrumentation */</comment>
						<expr_stmt><expr><name><name>hashNode</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>=</operator> <name>hashtable</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>parallelState</name><operator>-&gt;</operator><name>statusParallelWorker</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <name>ParallelHashJoin_MergeShmHashTableDone</name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_InnerInited</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <comment type="block">/*
                         * create the hash table
                         */</comment>
                        <expr_stmt><expr><name>hashtable</name> <operator>=</operator> <call><name>ExecHashTableCreate</name><argument_list>(<argument><expr><operator>(</operator><name>Hash</name> <operator>*</operator><operator>)</operator> <name><name>hashNode</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>,
                                                        <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashOperators</name></name></expr></argument>,
                                                        <argument><expr><call><name>HJ_FILL_INNER</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name> <operator>=</operator> <name>hashtable</name></expr>;</expr_stmt>

                        <comment type="block">/*
                         * execute the Hash node, to build the hash table
                         */</comment>
                        <expr_stmt><expr><name><name>hashNode</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>=</operator> <name>hashtable</name></expr>;</expr_stmt>
                        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>MultiExecProcNode</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>hashNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_InnerInited</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <comment type="block">/*
                 * create the hash table
                 */</comment>
                <expr_stmt><expr><name>hashtable</name> <operator>=</operator> <call><name>ExecHashTableCreate</name><argument_list>(<argument><expr><operator>(</operator><name>Hash</name> <operator>*</operator><operator>)</operator> <name><name>hashNode</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>,
                                                <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashOperators</name></name></expr></argument>,
                                                <argument><expr><call><name>HJ_FILL_INNER</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name> <operator>=</operator> <name>hashtable</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * execute the Hash node, to build the hash table
                 */</comment>
                <expr_stmt><expr><name><name>hashNode</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>=</operator> <name>hashtable</name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>MultiExecProcNode</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>hashNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/*
                 * If the inner relation is completely empty, and we're not
                 * doing a left outer join, we can quit without scanning the
                 * outer relation.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>HJ_FILL_OUTER</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>hj_OuterInited</name></name> <operator>&amp;&amp;</operator> <name>IS_PGXC_DATANODE</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ExecDisconnectNode</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <return>return <expr><name>NULL</name></expr>;</return>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * need to remember whether nbatch has increased since we
                 * began scanning the outer relation
                 */</comment>
                <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch_outstart</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Reset OuterNotEmpty for scan.  (It's OK if we fetched a
                 * tuple above, because ExecHashJoinOuterGetTuple will
                 * immediately set it again.)
                 */</comment>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_OuterNotEmpty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_NEED_NEW_OUTER</name></expr>;</expr_stmt>

                <comment type="block">/* FALL THRU */</comment>

            <case>case <expr><name>HJ_NEED_NEW_OUTER</name></expr>:</case>

                <comment type="block">/*
                 * We don't have an outer tuple, try to get the next one
                 */</comment>
                <expr_stmt><expr><name>outerTupleSlot</name> <operator>=</operator> <call><name>ExecHashJoinOuterGetTuple</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>,
                                                           <argument><expr><name>node</name></expr></argument>,
                                                           <argument><expr><operator>&amp;</operator><name>hashvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerTupleSlot</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* end of batch, or maybe whole join */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>HJ_FILL_INNER</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                        <comment type="block">/*
                          * In parallel mode, we can also do right or full join
                          * since tuples are hashed into different corresponding
                          * batches. Each worker join some batches, and we can get
                          * the results.
                          * First, we should share each workers' outer batch buffiles to
                          * others.
                          * Second, form new outer batches.
                          * Third, join some batches.
                            */</comment>
                          <if_stmt><if>if <condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>parallelState</name> <operator>&amp;&amp;</operator> 
                            <name><name>hashNode</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
                          <block>{<block_content>
                              <comment type="block">/* only do it once */</comment>
                              <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>share_outerBufFile</name></name></expr>)</condition>
                              <block>{<block_content>
                                  <decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></init></decl>;</decl_stmt>
                                
                                  <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                                  <block>{<block_content>
                                      <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"only share outer bufFile at end of batch 0,"</literal>
                                        <literal type="string">"current batch %d, worker %d."</literal></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr></argument>, <argument><expr><name>ParallelWorkerNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
                                  </block_content>}</block></if></if_stmt>

                                <expr_stmt><expr><name><name>parallelState</name><operator>-&gt;</operator><name>statusParallelWorker</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <name>ParallelHashJoin_ShareOuterBufFile</name></expr>;</expr_stmt>
                                
                                <comment type="block">/* share outer buffiles to other workers */</comment>
                                <expr_stmt><expr><call><name>ExecShareBufFileName</name><argument_list>(<argument><expr><name>parallelState</name></expr></argument>, <argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                
                                <expr_stmt><expr><name><name>parallelState</name><operator>-&gt;</operator><name>statusParallelWorker</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <name>ParallelHashJoin_ShareOuterBufFileDone</name></expr>;</expr_stmt>

                                <comment type="block">/* form new outer buffiles */</comment>
                                <expr_stmt><expr><call><name>ExecFormNewOuterBufFile</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>parallelState</name></expr></argument>, <argument><expr><operator>(</operator><name>Hash</name> <operator>*</operator><operator>)</operator> <name><name>hashNode</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                
                                    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>share_outerBufFile</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                              </block_content>}</block></if></if_stmt>
                          </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
						<comment type="block">/* set up to scan for unmatched inner tuples */</comment>
						<expr_stmt><expr><call><name>ExecPrepHashTableForUnmatched</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_FILL_INNER_TUPLES</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_NEED_NEW_BATCH</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
				
				<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>outerTupleSlot</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_MatchedOuter</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Find the corresponding bucket for this tuple in the main
				 * hash table or skew hash table.
				 */</comment>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_CurHashValue</name></name> <operator>=</operator> <name>hashvalue</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExecHashGetBucketAndBatch</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>hj_CurBucketNo</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>batchno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_CurSkewBucketNo</name></name> <operator>=</operator> <call><name>ExecHashGetSkewBucket</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>,
																 <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_CurTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * The tuple might not belong to the current batch (where
				 * "current batch" includes the skew buckets if any).
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>batchno</name> <operator>!=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>&amp;&amp;</operator>
					<name><name>node</name><operator>-&gt;</operator><name>hj_CurSkewBucketNo</name></name> <operator>==</operator> <name>INVALID_SKEW_BUCKET_NO</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Need to postpone this outer tuple to a later batch.
					 * Save it in the corresponding outer-batch file.
					 */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>batchno</name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ExecHashJoinSaveTuple</name><argument_list>(<argument><expr><call><name>ExecFetchSlotMinimalTuple</name><argument_list>(<argument><expr><name>outerTupleSlot</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>hashvalue</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>batchno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Loop around, staying in HJ_NEED_NEW_OUTER state */</comment>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* OK, let's scan the bucket for matches */</comment>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_SCAN_BUCKET</name></expr>;</expr_stmt>

				<comment type="block">/* FALL THRU */</comment>

			<case>case <expr><name>HJ_SCAN_BUCKET</name></expr>:</case>

				<comment type="block">/*
				 * Scan the selected hash bucket for matches to current outer
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecScanHashBucket</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* out of matches; check for possible outer-join fill */</comment>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_FILL_OUTER_TUPLE</name></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * We've got a match, but still need to test non-hashed quals.
				 * ExecScanHashBucket already set up all the state needed to
				 * call ExecQual.
				 *
				 * If we pass the qual, then save state for next call and have
				 * ExecProject form the projection, store it in the tuple
				 * table, and return the slot.
				 *
				 * Only the joinquals determine tuple match status, but all
				 * quals must pass to actually return the tuple.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>joinqual</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>ExecQual</name><argument_list>(<argument><expr><name>joinqual</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_LEFT_SCALAR</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>hj_MatchedOuter</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CARDINALITY_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"more than one row returned by a subquery used as an expression"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_MatchedOuter</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>HeapTupleHeaderSetMatch</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_CurTuple</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* In an antijoin, we never return a matched tuple */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_ANTI</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_NEED_NEW_OUTER</name></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * If we only need to join to the first matching inner
					 * tuple, then consider returning this one, but after that
					 * continue with next outer tuple.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>single_match</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_NEED_NEW_OUTER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>otherqual</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>ExecQual</name><argument_list>(<argument><expr><name>otherqual</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>matched_tuples</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    </block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>InstrCountFiltered2</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>InstrCountFiltered1</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <break>break;</break>

            <case>case <expr><name>HJ_FILL_OUTER_TUPLE</name></expr>:</case>

                <comment type="block">/*
                 * The current outer tuple has run out of matches, so check
                 * whether to emit a dummy outer-join tuple.  Whether we emit
                 * one or not, the next state is NEED_NEW_OUTER.
                 */</comment>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_NEED_NEW_OUTER</name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>hj_MatchedOuter</name></name> <operator>&amp;&amp;</operator>
                    <call><name>HJ_FILL_OUTER</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * Generate a fake join tuple with nulls for the inner
                     * tuple, and return it if it passes the non-join quals.
                     */</comment>
                    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>hj_NullInnerTupleSlot</name></name></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>otherqual</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>ExecQual</name><argument_list>(<argument><expr><name>otherqual</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>InstrCountFiltered2</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>

            <case>case <expr><name>HJ_FILL_INNER_TUPLES</name></expr>:</case>

                <comment type="block">/*
                 * We have finished a batch, but we are doing right/full join,
                 * so any unmatched inner tuples in the hashtable have to be
                 * emitted before we continue to the next batch.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecScanHashTableForUnmatched</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* no more unmatched tuples */</comment>
                    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_NEED_NEW_BATCH</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * Generate a fake join tuple with nulls for the outer tuple,
                 * and return it if it passes the non-join quals.
                 */</comment>
                <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>hj_NullOuterTupleSlot</name></name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>otherqual</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>ExecQual</name><argument_list>(<argument><expr><name>otherqual</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>InstrCountFiltered2</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <break>break;</break>

            <case>case <expr><name>HJ_NEED_NEW_BATCH</name></expr>:</case>

                <comment type="block">/*
                 * Try to advance to next batch.  Done if there are no more.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecHashJoinNewBatch</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* end of join */</comment>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_NEED_NEW_OUTER</name></expr>;</expr_stmt>
                <break>break;</break>

            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized hashjoin state: %d"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecInitHashJoin
 *
 *        Init routine for HashJoin node.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>HashJoinState</name> <modifier>*</modifier></type>
<name>ExecInitHashJoin</name><parameter_list>(<parameter><decl><type><name>HashJoin</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>outerNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hash</name>	   <modifier>*</modifier></type><name>hashNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>lclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hoperators</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* check for unsupported flags */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_BACKWARD</name> <operator>|</operator> <name>EXEC_FLAG_MARK</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * create state structure
	 */</comment>
	<expr_stmt><expr><name>hjstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>HashJoinState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecHashJoin</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Miscellaneous initialization
	 *
	 * create expression context for node
	 */</comment>
	<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize child expressions
	 */</comment>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
		<call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>hjstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>jointype</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>jointype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>joinqual</name></name> <operator>=</operator>
		<call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>joinqual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>hjstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hashclauses</name></name> <operator>=</operator>
		<call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashclauses</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>hjstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize child nodes
	 *
	 * Note: we could suppress the REWIND flag for the inner input, which
	 * would amount to betting that the hash will be a single batch.  Not
	 * clear if this would be a win or not.
	 */</comment>
	<expr_stmt><expr><name>outerNode</name> <operator>=</operator> <call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hashNode</name> <operator>=</operator> <operator>(</operator><name>Hash</name> <operator>*</operator><operator>)</operator> <call><name>innerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>hashNode</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * tuple table initialization
	 */</comment>
	<expr_stmt><expr><call><name>ExecInitResultTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_OuterTupleSlot</name></name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * detect whether we need only consider the first matching inner tuple
	 */</comment>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>single_match</name></name> <operator>=</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>inner_unique</name></name> <operator>||</operator>
								<name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_SEMI</name> <operator>||</operator>
								<name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_LEFT_SEMI</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* set up null tuples for outer joins, if needed */</comment>
	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>jointype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JOIN_INNER</name></expr>:</case>
        <case>case <expr><name>JOIN_SEMI</name></expr>:</case>
		    <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<case>case <expr><name>JOIN_LEFT_SCALAR</name></expr>:</case>
		<case>case <expr><name>JOIN_LEFT_SEMI</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
		<case>case <expr><name>JOIN_ANTI</name></expr>:</case>
			<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_NullInnerTupleSlot</name></name> <operator>=</operator>
				<call><name>ExecInitNullTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
									  <argument><expr><call><name>ExecGetResultType</name><argument_list>(<argument><expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_RIGHT</name></expr>:</case>
			<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_NullOuterTupleSlot</name></name> <operator>=</operator>
				<call><name>ExecInitNullTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
									  <argument><expr><call><name>ExecGetResultType</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_FULL</name></expr>:</case>
			<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_NullOuterTupleSlot</name></name> <operator>=</operator>
				<call><name>ExecInitNullTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
									  <argument><expr><call><name>ExecGetResultType</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_NullInnerTupleSlot</name></name> <operator>=</operator>
				<call><name>ExecInitNullTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
									  <argument><expr><call><name>ExecGetResultType</name><argument_list>(<argument><expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized join type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * now for some voodoo.  our temporary tuple slot is actually the result
	 * tuple slot of the Hash node (which is our inner plan).  we can do this
	 * because Hash nodes don't return tuples via ExecProcNode() -- instead
	 * the hash join node uses ExecScanHashBucket() to get at the contents of
	 * the hash table.  -cim 6/9/91
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HashState</name>  <modifier>*</modifier></type><name>hashstate</name> <init>= <expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>hashstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTupleSlot</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * initialize tuple type and projection info
	 */</comment>
	<expr_stmt><expr><call><name>ExecAssignResultTypeFromTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecAssignProjectionInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_OuterTupleSlot</name></name></expr></argument>,
						  <argument><expr><call><name>ExecGetResultType</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize hash-specific info
	 */</comment>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_FirstOuterTupleSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurHashValue</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurBucketNo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurSkewBucketNo</name></name> <operator>=</operator> <name>INVALID_SKEW_BUCKET_NO</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Deconstruct the hash clauses into outer and inner argument values, so
	 * that we can evaluate those subexpressions separately.  Also make a list
	 * of the hash operator OIDs, in preparation for looking up the hash
	 * functions to use.
	 */</comment>
	<expr_stmt><expr><name>lclauses</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rclauses</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hoperators</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;hashclauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>hclause</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>lclauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>lclauses</name></expr></argument>, <argument><expr><call><name>ExecInitExpr</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>hclause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>hjstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rclauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rclauses</name></expr></argument>, <argument><expr><call><name>ExecInitExpr</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>hclause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>hjstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hoperators</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>hoperators</name></expr></argument>, <argument><expr><name><name>hclause</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_OuterHashKeys</name></name> <operator>=</operator> <name>lclauses</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_InnerHashKeys</name></name> <operator>=</operator> <name>rclauses</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashOperators</name></name> <operator>=</operator> <name>hoperators</name></expr>;</expr_stmt>
	<comment type="block">/* child Hash node needs to evaluate inner hash keys, too */</comment>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>hashkeys</name> <operator>=</operator> <name>rclauses</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_BUILD_HASHTABLE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_MatchedOuter</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_OuterNotEmpty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_OuterInited</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_InnerInited</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>hjstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecEndHashJoin
 *
 *        clean up routine for HashJoin node
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndHashJoin</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>HashState</name> <modifier>*</modifier></type><name>hashNode</name> <init>= <expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>hj_parallelState</name></name> <operator>&amp;&amp;</operator> <call><name>HJ_FILL_INNER</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <name><name>hashNode</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nWorkers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nDone</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ParallelHashJoinState</name> <modifier>*</modifier></type><name>parallelState</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>hj_parallelState</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>ParallelHashJoinStatus</name> <modifier>*</modifier></type><name>statusParallelWorker</name> <init>= <expr><name><name>parallelState</name><operator>-&gt;</operator><name>statusParallelWorker</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>statusParallelWorker</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>==</operator> <name>ParallelHashJoin_EmptyOuter</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"worker %d status abnormal %d in end of hash right/full join."</literal></expr></argument>,
                         <argument><expr><name>ParallelWorkerNumber</name></expr></argument>, <argument><expr><name><name>statusParallelWorker</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name><name>statusParallelWorker</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <name>ParallelHashJoin_ExecJoinDone</name></expr>;</expr_stmt>

        <comment type="block">/* wait for other workers to finish */</comment>
        <expr_stmt><expr><name>nWorkers</name> <operator>=</operator> <name><name>parallelState</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr>;</expr_stmt>
        <while>while<condition>(<expr><name>nDone</name> <operator>&lt;</operator> <name>nWorkers</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>statusParallelWorker</name><index>[<expr><name>nDone</name></expr>]</index></name> <operator>==</operator> <name>ParallelHashJoin_Error</name> <operator>||</operator> <call><name>ParallelError</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s:%d]some other workers exit with errors, and we need to exit because"</literal>
                            <literal type="string">" of data corrupted."</literal></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if<condition>(<expr><name><name>statusParallelWorker</name><index>[<expr><name>nDone</name></expr>]</index></name> <operator>&lt;</operator> <name>ParallelHashJoin_ExecJoinDone</name> <operator>&amp;&amp;</operator>
                       <name><name>statusParallelWorker</name><index>[<expr><name>nDone</name></expr>]</index></name> <operator>&gt;</operator> <name>ParallelHashJoin_None</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>nDone</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Free hash table
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ExecHashTableDestroy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>hj_parallelState</name></name> <operator>&amp;&amp;</operator> <name><name>hashNode</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nWorkers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nDone</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>dsa</name> <init>= <expr><call><name>GetNumWorkerDsa</name><argument_list>(<argument><expr><name>ParallelWorkerNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ParallelHashJoinState</name> <modifier>*</modifier></type><name>parallelState</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>hj_parallelState</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>ParallelHashJoinStatus</name> <modifier>*</modifier></type><name>statusParallelWorker</name> <init>= <expr><name><name>parallelState</name><operator>-&gt;</operator><name>statusParallelWorker</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name> <init>= <expr><operator>(</operator><name>HashJoinTable</name><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>parallelState</name><operator>-&gt;</operator><name>hashTableParallelWorker</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>statusParallelWorker</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>!=</operator> <name>ParallelHashJoin_EmptyOuter</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>statusParallelWorker</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <name>ParallelHashJoin_ExecJoinDone</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* wait for other workers to finish */</comment>
        <expr_stmt><expr><name>nWorkers</name> <operator>=</operator> <name><name>parallelState</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr>;</expr_stmt>
        <while>while<condition>(<expr><name>nDone</name> <operator>&lt;</operator> <name>nWorkers</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>statusParallelWorker</name><index>[<expr><name>nDone</name></expr>]</index></name> <operator>==</operator> <name>ParallelHashJoin_Error</name> <operator>||</operator> <call><name>ParallelError</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s:%d]some other workers exit with errors, and we need to exit because"</literal>
                            <literal type="string">" of data corrupted."</literal></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if<condition>(<expr><name><name>statusParallelWorker</name><index>[<expr><name>nDone</name></expr>]</index></name> <operator>&lt;</operator> <name>ParallelHashJoin_ExecJoinDone</name> <operator>&amp;&amp;</operator>
                       <name><name>statusParallelWorker</name><index>[<expr><name>nDone</name></expr>]</index></name> <operator>&gt;</operator> <name>ParallelHashJoin_None</name> <operator>&amp;&amp;</operator>
                       <name><name>statusParallelWorker</name><index>[<expr><name>nDone</name></expr>]</index></name> <operator>!=</operator> <name>ParallelHashJoin_EmptyOuter</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>nDone</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>

        <comment type="block">/* remove bufFile in share hashtable */</comment>
        <if_stmt><if>if<condition>(<expr><name>hashtable</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
            
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"worker %d ExecHashjoin matched tuples %zu"</literal></expr></argument>, <argument><expr><name>ParallelWorkerNumber</name></expr></argument>,
                                                               <argument><expr><name><name>node</name><operator>-&gt;</operator><name>matched_tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"ExecHashjoin matched tuples %zu"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>matched_tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Free the exprcontext
     */</comment>
    <expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * clean out the tuple table
     */</comment>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_OuterTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * clean up subtrees
     */</comment>
    <expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHashJoinOuterGetTuple
 *
 *        get the next outer tuple for hashjoin: either by
 *        executing the outer plan node in the first pass, or from
 *        the temp files for the hashjoin batches.
 *
 * Returns a null slot if no more outer tuples (within the current batch).
 *
 * On success, the tuple's hash value is stored at *hashvalue --- this is
 * either originally computed, or re-read from the temp file.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecHashJoinOuterGetTuple</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>outerNode</name></decl></parameter>,
                          <parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl></parameter>,
                          <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>hashvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name> <init>= <expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>curbatch</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>curbatch</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>            <comment type="block">/* if it is the first pass */</comment>
    <block>{<block_content>
        <comment type="block">/*
         * Check to see if first outer tuple was already fetched by
         * ExecHashJoin() and not used yet.
         */</comment>
        <expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>hjstate</name><operator>-&gt;</operator><name>hj_FirstOuterTupleSlot</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_FirstOuterTupleSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <while>while <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We have to compute the tuple's hash value.
             */</comment>
            <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>hjstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>ExecHashGetHashValue</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>,
                                     <argument><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_OuterHashKeys</name></name></expr></argument>,
                                     <argument><expr><name>true</name></expr></argument>,    <comment type="block">/* outer tuple */</comment>
                                     <argument><expr><call><name>HJ_FILL_OUTER</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* remember outer relation is not empty for possible rescan */</comment>
                <expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_OuterNotEmpty</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                <return>return <expr><name>slot</name></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * That tuple couldn't match because of a NULL, so discard it and
             * continue with the next one.
             */</comment>
            <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>curbatch</name> <operator>&lt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BufFile</name>    <modifier>*</modifier></type><name>file</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * In outer-join cases, we could get here even though the batch file
         * is empty.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecHashJoinGetSavedTuple</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>,
                                         <argument><expr><name>file</name></expr></argument>,
                                         <argument><expr><name>hashvalue</name></expr></argument>,
                                         <argument><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_OuterTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>slot</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* End of this batch */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHashJoinNewBatch
 *        switch to a new hashjoin batch
 *
 * Returns true if successful, false if there are no more batches.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecHashJoinNewBatch</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name> <init>= <expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nbatch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>curbatch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BufFile</name>    <modifier>*</modifier></type><name>innerFile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>hashvalue</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>HashState</name>  <modifier>*</modifier></type><name>hashNode</name> <init>= <expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>nbatch</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>curbatch</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>curbatch</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We no longer need the previous outer batch file; close it right
         * away to free disk space.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else                        <comment type="block">/* we just finished the first batch */</comment>
    <block>{<block_content>
        <comment type="block">/*
         * Reset some of the skew optimization state variables, since we no
         * longer need to consider skew tuples after the first batch. The
         * memory context reset we are about to do will release the skew
         * hashtable itself.
         */</comment>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewEnabled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucketNums</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nSkewBuckets</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsedSkew</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * We can always skip over any batches that are completely empty on both
     * sides.  We can sometimes skip over batches that are empty on only one
     * side, but there are exceptions:
     *
     * 1. In a left/full outer join, we have to process outer batches even if
     * the inner batch is empty.  Similarly, in a right/full outer join, we
     * have to process inner batches even if the outer batch is empty.
     *
     * 2. If we have increased nbatch since the initial estimate, we have to
     * scan inner batches since they might contain tuples that need to be
     * reassigned to later inner batches.
     *
     * 3. Similarly, if we have increased nbatch since starting the outer
     * scan, we have to rescan outer batches in case they contain tuples that
     * need to be reassigned.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>hjstate</name><operator>-&gt;</operator><name>hj_parallelState</name></name> <operator>&amp;&amp;</operator> <call><name>HJ_FILL_INNER</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <name><name>hashNode</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>curbatch</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>ParallelWorkerNumber</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>curbatch</name> <operator>=</operator> <name>curbatch</name> <operator>+</operator> <name><name>hjstate</name><operator>-&gt;</operator><name>hj_parallelState</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>curbatch</name> <operator>=</operator> <name>curbatch</name> <operator>+</operator> <name>ParallelWorkerNumber</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>curbatch</name> <operator>=</operator> <name>curbatch</name> <operator>+</operator> <name><name>hjstate</name><operator>-&gt;</operator><name>hj_parallelState</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>curbatch</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>curbatch</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <while>while <condition>(<expr><name>curbatch</name> <operator>&lt;</operator> <name>nbatch</name> <operator>&amp;&amp;</operator>
           <operator>(</operator><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
            <name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>&amp;&amp;</operator>
            <call><name>HJ_FILL_OUTER</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>                <comment type="block">/* must process due to rule 1 */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>&amp;&amp;</operator>
            <call><name>HJ_FILL_INNER</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>                <comment type="block">/* must process due to rule 1 */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>&amp;&amp;</operator>
            <name>nbatch</name> <operator>!=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch_original</name></name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>                <comment type="block">/* must process due to rule 2 */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>&amp;&amp;</operator>
            <name>nbatch</name> <operator>!=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch_outstart</name></name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>                <comment type="block">/* must process due to rule 3 */</comment>
        <comment type="block">/* We can ignore this batch. */</comment>
        <comment type="block">/* Release associated temp files right away. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>hjstate</name><operator>-&gt;</operator><name>hj_parallelState</name></name> <operator>&amp;&amp;</operator> <call><name>HJ_FILL_INNER</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <name><name>hashNode</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>curbatch</name> <operator>=</operator> <name>curbatch</name> <operator>+</operator> <name><name>hjstate</name><operator>-&gt;</operator><name>hj_parallelState</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>curbatch</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>curbatch</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>curbatch</name> <operator>&gt;=</operator> <name>nbatch</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* no more batches */</comment>

    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>=</operator> <name>curbatch</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Reload the hash table with the new inner batch (which could be empty)
     */</comment>
    <expr_stmt><expr><call><name>ExecHashTableReset</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>innerFile</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>innerFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name>innerFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rewind hash-join temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <while>while <condition>(<expr><operator>(</operator><name>slot</name> <operator>=</operator> <call><name>ExecHashJoinGetSavedTuple</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>,
                                                 <argument><expr><name>innerFile</name></expr></argument>,
                                                 <argument><expr><operator>&amp;</operator><name>hashvalue</name></expr></argument>,
                                                 <argument><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTupleSlot</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * NOTE: some tuples may be sent to future batches.  Also, it is
             * possible for hashtable-&gt;nbatch to be increased here!
             */</comment>
            <expr_stmt><expr><call><name>ExecHashTableInsert</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <comment type="block">/*
         * after we build the hash table, the inner batch file is no longer
         * needed
         */</comment>
        <expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name>innerFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Rewind outer batch file (if present), so that we can start reading it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>curbatch</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rewind hash-join temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHashJoinSaveTuple
 *        save a tuple to a batch file.
 *
 * The data recorded in the file for each tuple is its hash value,
 * then the tuple in MinimalTuple format.
 *
 * Note: it is important always to call this in the regular executor
 * context, not in a shorter-lived context; else the temp file buffers
 * will get messed up.
 */</comment>
<function><type><name>void</name></type>
<name>ExecHashJoinSaveTuple</name><parameter_list>(<parameter><decl><type><name>MinimalTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>,
                      <parameter><decl><type><name>BufFile</name> <modifier>*</modifier><modifier>*</modifier></type><name>fileptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BufFile</name>    <modifier>*</modifier></type><name>file</name> <init>= <expr><operator>*</operator><name>fileptr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>written</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* First write to this batch file, so open it. */</comment>
        <expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>BufFileCreateTemp</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>fileptr</name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>written</name> <operator>=</operator> <call><name>BufFileWrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>hashvalue</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>written</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to hash-join temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>written</name> <operator>=</operator> <call><name>BufFileWrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tuple</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>written</name> <operator>!=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to hash-join temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHashJoinGetSavedTuple
 *        read the next tuple from a batch file.  Return NULL if no more.
 *
 * On success, *hashvalue is set to the tuple's hash value, and the tuple
 * itself is stored in the given slot.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecHashJoinGetSavedTuple</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl></parameter>,
                          <parameter><decl><type><name>BufFile</name> <modifier>*</modifier></type><name>file</name></decl></parameter>,
                          <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>hashvalue</name></decl></parameter>,
                          <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tupleSlot</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>uint32</name></type>        <name><name>header</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>nread</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We check for interrupts here because this is typically taken as an
     * alternative code path to an ExecProcNode() call, which would include
     * such a check.
     */</comment>
    <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<label><name>RETRY</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Since both the hash value and the MinimalTuple length word are uint32,
     * we can read them both in one BufFileRead() call without any type
     * cheating.
     */</comment>
    <expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>BufFileRead</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/*
      * each bufFile of worker may have more than one file, and some of
      * those files do not exceed the MAX_PHYSICAL_FILESIZE, those files
      * should also be read.
         */</comment>
    <if_stmt><if>if<condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name>nread</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><call><name>BufFileReadDone</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>tupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <goto>goto <name>RETRY</name>;</goto>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>                <comment type="block">/* end of file */</comment>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>tupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from hash-join temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>hashvalue</name> <operator>=</operator> <name><name>header</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>MinimalTuple</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>header</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name><name>header</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>BufFileRead</name><argument_list>(<argument><expr><name>file</name></expr></argument>,
                        <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuple</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>,
                        <argument><expr><name><name>header</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>!=</operator> <name><name>header</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from hash-join temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><call><name>ExecStoreMinimalTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupleSlot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>ExecReScanHashJoin</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * In a multi-batch join, we currently have to do rescans the hard way,
     * primarily because batch temp files may have already been released. But
     * if it's a single-batch join, and there is no parameter change for the
     * inner subnode, then we can just re-use the existing hash table without
     * rebuilding it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
            <name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>righttree</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Okay to reuse the hash table; needn't rescan inner, either.
             *
             * However, if it's a right/full join, we'd better reset the
             * inner-tuple match flags contained in the table.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>HJ_FILL_INNER</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecHashTableResetMatchFlags</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Also, we need to reset our state about the emptiness of the
             * outer relation, so that the new scan of the outer will update
             * it correctly if it turns out to be empty this time. (There's no
             * harm in clearing it now because ExecHashJoin won't need the
             * info.  In the other cases, where the hash table doesn't exist
             * or we are destroying it, we leave this state alone because
             * ExecHashJoin will need it the first time through.)
             */</comment>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_OuterNotEmpty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

            <comment type="block">/* ExecHashJoin can skip the BUILD_HASHTABLE step */</comment>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_NEED_NEW_OUTER</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* must destroy and rebuild hash table */</comment>
            <expr_stmt><expr><call><name>ExecHashTableDestroy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_HashTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_JoinState</name></name> <operator>=</operator> <name>HJ_BUILD_HASHTABLE</name></expr>;</expr_stmt>

            <comment type="block">/*
             * if chgParam of subnode is not null then plan will be re-scanned
             * by first ExecProcNode.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>righttree</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Always reset intra-tuple state */</comment>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_CurHashValue</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_CurBucketNo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_CurSkewBucketNo</name></name> <operator>=</operator> <name>INVALID_SKEW_BUCKET_NO</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_CurTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_MatchedOuter</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_FirstOuterTupleSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * if chgParam of subnode is not null then plan will be re-scanned by
     * first ExecProcNode.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>lefttree</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/* ----------------------------------------------------------------
 *        ExecParallelHashJoinEstimate
 *
 *        estimates the space required to serialize hashjoin parallel state.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecParallelHashJoinEstimate</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_parallelStateLen</name></name> <operator>=</operator> <call><name>ParallelHashJoinState_Size</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_parallelStateLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *        ExecParallelHashJoinInitializeDSM
 *
 *        Set up a parallel hashjoin state for parallel workers
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecParallelHashJoinInitializeDSM</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                                          <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelHashJoinState</name> <modifier>*</modifier></type><name>parallelState</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>parallelState</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_parallelStateLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* orginize memory allocated */</comment>
    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParallelHashJoinState</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>parallelState</name><operator>-&gt;</operator><name>statusParallelWorker</name></name> <operator>=</operator> <operator>(</operator><name>ParallelHashJoinStatus</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>parallelState</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParallelHashJoinStatus</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>parallelState</name><operator>-&gt;</operator><name>hashTableParallelWorker</name></name> <operator>=</operator> <operator>(</operator><name>dsa_pointer</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>parallelState</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dsa_pointer</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>parallelState</name><operator>-&gt;</operator><name>bufFileNames</name></name> <operator>=</operator> <operator>(</operator><name>dsa_pointer</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>parallelState</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dsa_pointer</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>parallelState</name><operator>-&gt;</operator><name>outerBufFileNames</name></name> <operator>=</operator> <operator>(</operator><name>dsa_pointer</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>parallelState</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
    
    <expr_stmt><expr><name><name>parallelState</name><operator>-&gt;</operator><name>numExpectedParallelWorkers</name></name> <operator>=</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>parallelState</name><operator>-&gt;</operator><name>statusParallelWorker</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>ParallelHashJoin_None</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    
    <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>, <argument><expr><name>parallelState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_parallelState</name></name> <operator>=</operator> <name>parallelState</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecParallelHashJoinInitializeWorker
 *
 *        Copy relevant information from TOC into planstate.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecParallelHashJoinInitWorker</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParallelWorkerContext</name> <modifier>*</modifier></type><name>pwcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelHashJoinState</name> <modifier>*</modifier></type><name>parallelState</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>ParallelWorkerStatus</name> <modifier>*</modifier></type><name>numParallelWorkers</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>parallelState</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name><name>pwcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numParallelWorkers</name> <operator>=</operator> <call><name>GetParallelWorkerStatusInfo</name><argument_list>(<argument><expr><name><name>pwcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_parallelState</name></name> <operator>=</operator> <operator>(</operator><name>ParallelHashJoinState</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelHashJoinState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_parallelState</name><operator>-&gt;</operator><name>numExpectedParallelWorkers</name></name> <operator>=</operator> <name><name>parallelState</name><operator>-&gt;</operator><name>numExpectedParallelWorkers</name></name></expr>;</expr_stmt>
    
    <comment type="block">/* orginize memory allocated */</comment>
    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParallelHashJoinState</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_parallelState</name><operator>-&gt;</operator><name>statusParallelWorker</name></name> <operator>=</operator> <operator>(</operator><name>ParallelHashJoinStatus</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>parallelState</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParallelHashJoinStatus</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>numParallelWorkers</name><operator>-&gt;</operator><name>numExpectedWorkers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_parallelState</name><operator>-&gt;</operator><name>hashTableParallelWorker</name></name> <operator>=</operator> <operator>(</operator><name>dsa_pointer</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>parallelState</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dsa_pointer</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>numParallelWorkers</name><operator>-&gt;</operator><name>numExpectedWorkers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_parallelState</name><operator>-&gt;</operator><name>bufFileNames</name></name> <operator>=</operator> <operator>(</operator><name>dsa_pointer</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>parallelState</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dsa_pointer</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>numParallelWorkers</name><operator>-&gt;</operator><name>numExpectedWorkers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_parallelState</name><operator>-&gt;</operator><name>outerBufFileNames</name></name> <operator>=</operator> <operator>(</operator><name>dsa_pointer</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>parallelState</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
    
    <comment type="block">/*
      * get total number of launched parallel workers.
      * this number is set by session after launching all parallel workers,
      * so we may need to wait for the setup
      */</comment>
    <while>while<condition>(<expr><operator>!</operator><name><name>numParallelWorkers</name><operator>-&gt;</operator><name>parallelWorkersSetupDone</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_parallelState</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name> <operator>=</operator> <name><name>numParallelWorkers</name><operator>-&gt;</operator><name>numLaunchedWorkers</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hj_parallelState</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name> <operator>&gt;</operator> 
       <name><name>node</name><operator>-&gt;</operator><name>hj_parallelState</name><operator>-&gt;</operator><name>numExpectedParallelWorkers</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"launched parallel workers' total number:%d"</literal>
                    <literal type="string">"is greater than the expected:%d"</literal></expr></argument>,
                    <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_parallelState</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr></argument>,
                    <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_parallelState</name><operator>-&gt;</operator><name>numExpectedParallelWorkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>ParallelWorkerNumber</name> <operator>&gt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>hj_parallelState</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"parallel worker's number:%d is greater than"</literal>
                    <literal type="string">"launched parallel workers' total number:%d"</literal></expr></argument>,
                    <argument><expr><name>ParallelWorkerNumber</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hj_parallelState</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hj_parallelState</name><operator>-&gt;</operator><name>statusParallelWorker</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <name>ParallelHashJoin_Init</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>statusParallelWorker</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>hj_parallelState</name><operator>-&gt;</operator><name>statusParallelWorker</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* 
  * share bufFiles with other parallel workers
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecShareBufFileName</name><parameter_list>(<parameter><decl><type><specifier>volatile</specifier> <name>ParallelHashJoinState</name> <modifier>*</modifier></type><name>parallelState</name></decl></parameter>, <parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inner</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numFiles</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>dp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashJoinTable</name></type> <name>ht</name></decl>;</decl_stmt>
    
    <comment type="block">/* get hashtable */</comment>
    <decl_stmt><decl><type><name>dsa_area</name> <modifier>*</modifier></type> <name>dsa</name> <init>= <expr><call><name>GetNumWorkerDsa</name><argument_list>(<argument><expr><name>ParallelWorkerNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>inner</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ht</name> <operator>=</operator> <operator>(</operator><name>HashJoinTable</name><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><operator>(</operator><name>dsa_pointer</name><operator>)</operator><name>hashtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>ht</name> <operator>=</operator> <name>hashtable</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
    <comment type="block">/*
      * allocate space for bufFile's file name in shm.
      * store num_batch in hashtable, num_files in each batch,
      * then file names
      */</comment>
    <if_stmt><if>if<condition>(<expr><name><name>ht</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HashTableBufFileName</name> <modifier>*</modifier></type><name>htbufFileName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name>                  <modifier>*</modifier></type><name>nFiles</name>        <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dsa_pointer</name>          <modifier>*</modifier></type><name>names</name>         <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            
        <expr_stmt><expr><name>dp</name>            <operator>=</operator> <call><name>dsa_allocate0</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HashTableBufFileName</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>inner</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>parallelState</name><operator>-&gt;</operator><name>bufFileNames</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <name>dp</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>parallelState</name><operator>-&gt;</operator><name>outerBufFileNames</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <name>dp</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        
        <expr_stmt><expr><name>htbufFileName</name> <operator>=</operator> <operator>(</operator><name>HashTableBufFileName</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>htbufFileName</name><operator>-&gt;</operator><name>nBatch</name></name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>dp</name>            <operator>=</operator> <call><name>dsa_allocate0</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>ht</name><operator>-&gt;</operator><name>nbatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>htbufFileName</name><operator>-&gt;</operator><name>nFiles</name></name> <operator>=</operator> <name>dp</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nFiles</name>        <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>dp</name>            <operator>=</operator> <call><name>dsa_allocate0</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_pointer</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>ht</name><operator>-&gt;</operator><name>nbatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>htbufFileName</name><operator>-&gt;</operator><name>name</name></name>   <operator>=</operator> <name>dp</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>names</name>         <operator>=</operator> <operator>(</operator><name>dsa_pointer</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ht</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>BufFile</name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
            
            <if_stmt><if>if <condition>(<expr><name>inner</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>file</name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>ht</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* flush outer bufFile until flush successfully  */</comment>
                    <do>do
                    <block>{<block_content>
                        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>FlushBufFile</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block> while<condition>(<expr><name>ret</name> <operator>==</operator> <name>EOF</name></expr>)</condition>;</do>
                </block_content>}</block></if></if_stmt>
                
                <expr_stmt><expr><name>file</name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name>numFiles</name>  <operator>=</operator> <call><name>NumFilesBufFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>nFiles</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>numFiles</name></expr>;</expr_stmt>
            
            <if_stmt><if>if<condition>(<expr><name>numFiles</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>dsa_pointer</name> <modifier>*</modifier></type><name>bufFileName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>dp</name>                       <operator>=</operator> <call><name>dsa_allocate0</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_pointer</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numFiles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>names</name><index>[<expr><name>i</name></expr>]</index></name>                 <operator>=</operator> <name>dp</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>bufFileName</name>              <operator>=</operator> <operator>(</operator><name>dsa_pointer</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <for>for<control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numFiles</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fileName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>dp</name>             <operator>=</operator> <call><name>dsa_allocate0</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>bufFileName</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>dp</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>fileName</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>getBufFileName</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
  * merge all parallel workers' shared hashtables into local hashtable
  */</comment>
<function><type><specifier>static</specifier> <name>HashJoinTable</name></type>
<name>ExecMergeShmHashTable</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type> <name>hjstate</name></decl></parameter>, <parameter><decl><type><specifier>volatile</specifier> <name>ParallelHashJoinState</name> <modifier>*</modifier></type><name>parallelState</name></decl></parameter>, 
                                <parameter><decl><type><name>Hash</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashOperators</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>keepNulls</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>            <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nMerged</name>      <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>workerLeader</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>indexbucket</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>indexbatch</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nWorkers</name>     <init>= <expr><name><name>parallelState</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>merged</name>     <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nWorkers</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_area</name> <modifier>*</modifier></type> <name>leaderDsa</name> <init>= <expr><call><name>GetNumWorkerDsa</name><argument_list>(<argument><expr><name>workerLeader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>ParallelHashJoinStatus</name> <modifier>*</modifier></type><name>statusParallelWorker</name>    <init>= <expr><name><name>parallelState</name><operator>-&gt;</operator><name>statusParallelWorker</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>dsa_pointer</name>            <modifier>*</modifier></type><name>hashTableParallelWorker</name> <init>= <expr><name><name>parallelState</name><operator>-&gt;</operator><name>hashTableParallelWorker</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashJoinTable</name></type> <name>ht</name> <init>= <expr><operator>(</operator><name>HashJoinTable</name><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>leaderDsa</name></expr></argument>, <argument><expr><name><name>hashTableParallelWorker</name><index>[<expr><name>workerLeader</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    
    <comment type="block">/* build local hashtable */</comment>
    <decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name> <init>= <expr><call><name>ExecHashTableCreate</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
                                                  <argument><expr><name>hashOperators</name></expr></argument>,
                                                  <argument><expr><name>keepNulls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nMerged</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>nMerged</name> <operator>&lt;</operator> <name>nWorkers</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>merged</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>statusParallelWorker</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name>ParallelHashJoin_BuildShmHashTableDone</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>dsa</name> <init>= <expr><call><name>GetNumWorkerDsa</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>HashJoinTable</name></type> <name>mergeHashtable</name> <init>= <expr><operator>(</operator><name>HashJoinTable</name><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>hashTableParallelWorker</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            
            <expr_stmt><expr><name><name>merged</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>nMerged</name><operator>++</operator></expr>;</expr_stmt>

            <comment type="block">/* 
              *   merge hashtable buckets 
              *   worker leader do the merging, other workers just copy the merged hashtable
              *   into local memory
              * 
              *   the main work of merging is just linking the hashtable's buckets from different workers.
              */</comment>
            <if_stmt><if>if<condition>(<expr><name>workerLeader</name> <operator>==</operator> <name>ParallelWorkerNumber</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if<condition>(<expr><name>i</name> <operator>!=</operator> <name>workerLeader</name></expr>)</condition>
                <block>{<block_content>            
                    <decl_stmt><decl><type><name>HashJoinTupleData</name> <modifier>*</modifier><modifier>*</modifier></type><name>ht_buckets</name>          <init>= <expr><operator>(</operator><name>HashJoinTuple</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>leaderDsa</name></expr></argument>, 
                                                                          <argument><expr><operator>(</operator><name>dsa_pointer</name><operator>)</operator><name><name>ht</name><operator>-&gt;</operator><name>buckets</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>HashJoinTupleData</name> <modifier>*</modifier><modifier>*</modifier></type><name>ht_buckets_tail</name>     <init>= <expr><operator>(</operator><name>HashJoinTuple</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>leaderDsa</name></expr></argument>, 
                                                                          <argument><expr><operator>(</operator><name>dsa_pointer</name><operator>)</operator><name><name>ht</name><operator>-&gt;</operator><name>buckets_tail</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>HashJoinTupleData</name> <modifier>*</modifier><modifier>*</modifier></type><name>merged_buckets</name>      <init>= <expr><operator>(</operator><name>HashJoinTuple</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, 
                                                                          <argument><expr><operator>(</operator><name>dsa_pointer</name><operator>)</operator><name><name>mergeHashtable</name><operator>-&gt;</operator><name>buckets</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>HashJoinTupleData</name> <modifier>*</modifier><modifier>*</modifier></type><name>merged_buckets_tail</name> <init>= <expr><operator>(</operator><name>HashJoinTuple</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, 
                                                                          <argument><expr><operator>(</operator><name>dsa_pointer</name><operator>)</operator><name><name>mergeHashtable</name><operator>-&gt;</operator><name>buckets_tail</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>head_workNum</name>                       <init>= <expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>leaderDsa</name></expr></argument>, 
                                                                          <argument><expr><operator>(</operator><name>dsa_pointer</name><operator>)</operator><name><name>ht</name><operator>-&gt;</operator><name>bucket_wNum</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>tail_workNum</name>                       <init>= <expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>leaderDsa</name></expr></argument>, 
                                                                          <argument><expr><operator>(</operator><name>dsa_pointer</name><operator>)</operator><name><name>ht</name><operator>-&gt;</operator><name>bucket_tail_wNum</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    
                    <if_stmt><if>if<condition>(<expr><name><name>ht</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>!=</operator> <name><name>mergeHashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"number of buckets is different in parallel workers' hashtables."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><name><name>ht</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>+</operator> <name><name>mergeHashtable</name><operator>-&gt;</operator><name>totalTuples</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>ht</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>spacePeak</name></name></expr></argument>, <argument><expr><name><name>mergeHashtable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    
                    <comment type="block">/* merge hashtable */</comment>
                    <for>for<control>(<init><expr><name>indexbucket</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>indexbucket</name> <operator>&lt;</operator> <name><name>ht</name><operator>-&gt;</operator><name>nbuckets</name></name></expr>;</condition> <incr><expr><name>indexbucket</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <if_stmt><if>if<condition>(<expr><name><name>ht_buckets</name><index>[<expr><name>indexbucket</name></expr>]</index></name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>int</name></type> <name>workerNumber</name> <init>= <expr><name><name>tail_workNum</name><index>[<expr><name>indexbucket</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>HashJoinTupleData</name> <modifier>*</modifier></type><name>tail</name> <init>= <expr><operator>(</operator><name>HashJoinTupleData</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><call><name>GetNumWorkerDsa</name><argument_list>(<argument><expr><name>workerNumber</name></expr></argument>)</argument_list></call></expr></argument>, 
                                                                                       <argument><expr><operator>(</operator><name>dsa_pointer</name><operator>)</operator><name><name>ht_buckets_tail</name><index>[<expr><name>indexbucket</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><name><name>tail</name><operator>-&gt;</operator><name>next</name></name>              <operator>=</operator> <name><name>merged_buckets</name><index>[<expr><name>indexbucket</name></expr>]</index></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>tail</name><operator>-&gt;</operator><name>workerNumber</name></name>      <operator>=</operator> <name>i</name></expr>;</expr_stmt>

                            <if_stmt><if>if<condition>(<expr><name><name>merged_buckets</name><index>[<expr><name>indexbucket</name></expr>]</index></name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>ht_buckets_tail</name><index>[<expr><name>indexbucket</name></expr>]</index></name> <operator>=</operator> <name><name>merged_buckets_tail</name><index>[<expr><name>indexbucket</name></expr>]</index></name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>tail_workNum</name><index>[<expr><name>indexbucket</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <if_stmt><if>if<condition>(<expr><name><name>merged_buckets</name><index>[<expr><name>indexbucket</name></expr>]</index></name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>ht_buckets</name><index>[<expr><name>indexbucket</name></expr>]</index></name> <operator>=</operator> <name><name>merged_buckets</name><index>[<expr><name>indexbucket</name></expr>]</index></name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>ht_buckets_tail</name><index>[<expr><name>indexbucket</name></expr>]</index></name> <operator>=</operator> <name><name>merged_buckets_tail</name><index>[<expr><name>indexbucket</name></expr>]</index></name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>tail_workNum</name><index>[<expr><name>indexbucket</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>head_workNum</name><index>[<expr><name>indexbucket</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* merge hashtable inner batch file */</comment>
            <if_stmt><if>if<condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>HashTableBufFileName</name> <modifier>*</modifier></type><name>bufFileNames</name> <init>= <expr><operator>(</operator><name>HashTableBufFileName</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, 
                                                                         <argument><expr><name><name>parallelState</name><operator>-&gt;</operator><name>bufFileNames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>nFiles</name>                        <init>= <expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>bufFileNames</name><operator>-&gt;</operator><name>nFiles</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                
                <decl_stmt><decl><type><name>dsa_pointer</name> <modifier>*</modifier></type><name>names</name>                 <init>= <expr><operator>(</operator><name>dsa_pointer</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>bufFileNames</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                
                <if_stmt><if>if<condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>!=</operator> <name><name>mergeHashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"number of batch is different in parallel workers' hashtables."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                
                <for>for<control>(<init><expr><name>indexbatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>indexbatch</name> <operator>&lt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</condition> <incr><expr><name>indexbatch</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type> <name>fileNum</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>dsa_pointer</name> <modifier>*</modifier></type><name>fileName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name>fileNum</name>     <operator>=</operator> <name><name>nFiles</name><index>[<expr><name>indexbatch</name></expr>]</index></name></expr>;</expr_stmt>

                    <if_stmt><if>if<condition>(<expr><name>fileNum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>fileName</name> <operator>=</operator> <operator>(</operator><name>dsa_pointer</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>names</name><index>[<expr><name>indexbatch</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>CreateBufFile</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>fileNum</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>indexbatch</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>statusParallelWorker</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>ParallelHashJoin_Error</name> <operator>||</operator> <call><name>ParallelError</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s:%d]some other workers exit with errors, and we need to exit because"</literal>
                        <literal type="string">" of data corrupted."</literal></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
        else if (!merged[i] &amp;&amp; statusParallelWorker[i] == ParallelHashJoin_None)
        {
            elog(LOG, "worker %d not launched while worker %d ExecMergeShmHashTable.", i, ParallelWorkerNumber);
            merged[i] = true;
            nMerged++;
        }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>nWorkers</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if<condition>(<expr><name>workerLeader</name> <operator>==</operator> <name>ParallelWorkerNumber</name></expr>)</condition>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
        <comment type="block">/* debug */</comment>
        int i = 0;
        size_t tuple_num = 0;
        HashJoinTuple hashTuple;
        dsa_area *dsa = NULL;
        int work_num = 0;

        HashJoinTupleData **ht_buckets  = (HashJoinTuple *)dsa_get_address(leaderDsa, 
                                              (dsa_pointer)ht-&gt;buckets);
        int *head_wnum = (int *)dsa_get_address(leaderDsa, 
                                              (dsa_pointer)ht-&gt;bucket_wNum);
        for(i = 0; i &lt; ht-&gt;nbuckets; i++)
        {
            HashJoinTupleData *temp = NULL;
            
            if(ht_buckets[i])
            {
                tuple_num++;

                dsa = GetNumWorkerDsa(head_wnum[i]);
                hashTuple = (HashJoinTuple)dsa_get_address(dsa, (dsa_pointer)ht_buckets[i]);

                temp = hashTuple-&gt;next;
                work_num = hashTuple-&gt;workerNumber;
            }

            while(temp)
            {
                tuple_num++;

                dsa = GetNumWorkerDsa(work_num);
                hashTuple = (HashJoinTuple)dsa_get_address(dsa, (dsa_pointer)temp);

                temp = hashTuple-&gt;next;
                work_num = hashTuple-&gt;workerNumber;
            }
        }

        if(tuple_num != ht-&gt;totalTuples)
        {
            elog(PANIC, "merged hashtable's totaltuple is mismatch, tuple_num %zu, totalTuples %lf.",
                         tuple_num, ht-&gt;totalTuples);
        }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name><name>statusParallelWorker</name><index>[<expr><name>workerLeader</name></expr>]</index></name> <operator>=</operator> <name>ParallelHashJoin_MergeShmHashTableDone</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* 
      * copy merged hashtable into local hashtable 
      * should wait for the leader finish merging hashtable
      */</comment>
    <while>while<condition>(<expr><name><name>statusParallelWorker</name><index>[<expr><name>workerLeader</name></expr>]</index></name> <operator>&lt;</operator> <name>ParallelHashJoin_MergeShmHashTableDone</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>statusParallelWorker</name><index>[<expr><name>workerLeader</name></expr>]</index></name> <operator>==</operator> <name>ParallelHashJoin_Error</name> <operator>||</operator> <call><name>ParallelError</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s:%d]some other workers exit with errors, and we need to exit because"</literal>
                        <literal type="string">" of data corrupted."</literal></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <block>{<block_content>
        <decl_stmt><decl><type><name>HashJoinTable</name></type> <name>ht</name> <init>= <expr><operator>(</operator><name>HashJoinTable</name><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>leaderDsa</name></expr></argument>, <argument><expr><name><name>hashTableParallelWorker</name><index>[<expr><name>workerLeader</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HashJoinTupleData</name> <modifier>*</modifier><modifier>*</modifier></type><name>ht_buckets</name>  <init>= <expr><operator>(</operator><name>HashJoinTuple</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>leaderDsa</name></expr></argument>, 
                                                      <argument><expr><operator>(</operator><name>dsa_pointer</name><operator>)</operator><name><name>ht</name><operator>-&gt;</operator><name>buckets</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>bucket_wNum</name> <init>= <expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>leaderDsa</name></expr></argument>, <argument><expr><operator>(</operator><name>dsa_pointer</name><operator>)</operator><name><name>ht</name><operator>-&gt;</operator><name>bucket_wNum</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name></name></expr></argument>, <argument><expr><name>ht_buckets</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTupleData</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>bucket_wNum</name></name></expr></argument>, <argument><expr><name>bucket_wNum</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>totalTuples</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewEnabled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>growEnabled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<comment type="block">/* copy instrumentation too */</comment>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>nbuckets</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_original</name></name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>nbuckets_original</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch_original</name></name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>nbatch_original</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>;</expr_stmt>
    </block_content>}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    <comment type="block">/* debug */</comment>
    {
        int i = 0;
        size_t tuple_num = 0;
        HashJoinTuple hashTuple;
        dsa_area *dsa = NULL;
        int work_num = 0;

        HashJoinTupleData **ht_buckets  = hashtable-&gt;buckets;
        for(i = 0; i &lt; hashtable-&gt;nbuckets; i++)
        {
            HashJoinTupleData *temp = NULL;
            
            if(ht_buckets[i])
            {
                tuple_num++;

                dsa = GetNumWorkerDsa(hashtable-&gt;bucket_wNum[i]);
                hashTuple = (HashJoinTuple)dsa_get_address(dsa, (dsa_pointer)ht_buckets[i]);

                temp = hashTuple-&gt;next;
                work_num = hashTuple-&gt;workerNumber;
            }

            while(temp)
            {
                tuple_num++;

                dsa = GetNumWorkerDsa(work_num);
                hashTuple = (HashJoinTuple)dsa_get_address(dsa, (dsa_pointer)temp);

                temp = hashTuple-&gt;next;
                work_num = hashTuple-&gt;workerNumber;
            }
        }

        if (hashtable-&gt;nbatch &gt; 1)
        {
            uint32 hashvalue = 0;
            
            for(i = 1; i &lt; hashtable-&gt;nbatch; i++)
            {
                while (ExecHashJoinGetSavedTuple(hjstate, hashtable-&gt;innerBatchFile[i], &amp;hashvalue, hjstate-&gt;hj_HashTupleSlot))
                {
                    tuple_num++;
                    ExecClearTuple(hjstate-&gt;hj_HashTupleSlot);
                }

                ReSetBufFile(hashtable-&gt;innerBatchFile[i]);
            }
        }

        elog(LOG, "worker_num:%d, tuple_num:%zu, totaltuple:%lf", ParallelWorkerNumber, tuple_num, hashtable-&gt;totalTuples);
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>hashtable</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecFormNewOuterBufFile</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type> <name>hjstate</name></decl></parameter>, <parameter><decl><type><specifier>volatile</specifier> <name>ParallelHashJoinState</name> <modifier>*</modifier></type><name>parallelState</name></decl></parameter>, 
                                 <parameter><decl><type><name>Hash</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nMerged</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>indexbatch</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nWorkers</name>     <init>= <expr><name><name>parallelState</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>merged</name>     <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nWorkers</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name> <init>= <expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>ParallelHashJoinStatus</name> <modifier>*</modifier></type><name>statusParallelWorker</name>     <init>= <expr><name><name>parallelState</name><operator>-&gt;</operator><name>statusParallelWorker</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nMerged</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>nMerged</name> <operator>&lt;</operator> <name>nWorkers</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>ParallelWorkerNumber</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>merged</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>statusParallelWorker</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name>ParallelHashJoin_ShareOuterBufFileDone</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>dsa</name> <init>= <expr><call><name>GetNumWorkerDsa</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            
            <expr_stmt><expr><name><name>merged</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>nMerged</name><operator>++</operator></expr>;</expr_stmt>

            <comment type="block">/* merge hashtable outer batch files */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>HashTableBufFileName</name> <modifier>*</modifier></type><name>bufFileNames</name> <init>= <expr><operator>(</operator><name>HashTableBufFileName</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, 
                                                                         <argument><expr><name><name>parallelState</name><operator>-&gt;</operator><name>outerBufFileNames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                
                <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>nFiles</name>                        <init>= <expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>bufFileNames</name><operator>-&gt;</operator><name>nFiles</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                
                <decl_stmt><decl><type><name>dsa_pointer</name> <modifier>*</modifier></type><name>names</name>                 <init>= <expr><operator>(</operator><name>dsa_pointer</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>bufFileNames</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                
                <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>!=</operator> <name><name>bufFileNames</name><operator>-&gt;</operator><name>nBatch</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"number of outer batch is different in parallel workers' hashtables."</literal>
                                <literal type="string">"worker %d nbatch %d, worker %d nbatch %d."</literal></expr></argument>, <argument><expr><name>ParallelWorkerNumber</name></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr></argument>,
                                <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>bufFileNames</name><operator>-&gt;</operator><name>nBatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                
                <for>for <control>(<init><expr><name>indexbatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>indexbatch</name> <operator>&lt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</condition> <incr><expr><name>indexbatch</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type> <name>fileNum</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>dsa_pointer</name> <modifier>*</modifier></type><name>fileName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name>fileNum</name>     <operator>=</operator> <name><name>nFiles</name><index>[<expr><name>indexbatch</name></expr>]</index></name></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>fileNum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>fileName</name> <operator>=</operator> <operator>(</operator><name>dsa_pointer</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>names</name><index>[<expr><name>indexbatch</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>CreateBufFile</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>fileNum</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>indexbatch</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
            
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>statusParallelWorker</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>ParallelHashJoin_Error</name> <operator>||</operator> <call><name>ParallelError</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s:%d]some other workers exit with errors, and we need to exit because"</literal>
                        <literal type="string">" of data corrupted."</literal></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>nWorkers</name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ParallelHashJoinEreport</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>statusParallelWorker</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>statusParallelWorker</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <name>ParallelHashJoin_Error</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>statusParallelWorker</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
