<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/executor/execPartition.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execPartition.c
 *	  Support routines for partitioning.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/executor/execPartition.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execPartition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>


<comment type="block">/*-----------------------
 * PartitionDispatch - information about one partitioned table in a partition
 * hierarchy required to route a tuple to one of its partitions
 *
 * reldesc     Relation descriptor of the table
 * key         Partition key information of the table
 * keystate    Execution state required for expressions in the partition key
 * partdesc    Partition descriptor of the table
 * tupslot     A standalone TupleTableSlot initialized with this table's tuple
 *             descriptor
 * tupmap      TupleConversionMap to convert from the parent's rowtype to
 *             this table's rowtype (when extracting the partition key of a
 *             tuple just before routing it through this table)
 * indexes     Array with partdesc-&gt;nparts members (for details on what
 *             individual members represent, see how they are set in
 *             get_partition_dispatch_recurse())
 *-----------------------
 */</comment>
<typedef>typedef <type><struct>struct <name>PartitionDispatchData</name>
<block>{
   <decl_stmt><decl><type><name>Relation</name></type>    <name>reldesc</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>keystate</name></decl>;</decl_stmt>       <comment type="block">/* list of ExprState */</comment>
   <decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tupslot</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>tupmap</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>int</name>        <modifier>*</modifier></type><name>indexes</name></decl>;</decl_stmt>
}</block></struct></type> <name>PartitionDispatchData</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>PartitionDispatch</name> <modifier>*</modifier></type><name>RelationGetPartitionDispatchInfo</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
								 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_parted</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>leaf_part_oids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_partition_dispatch_recurse</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>pds</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>leaf_part_oids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FormPartitionKeyDatum</name><parameter_list>(<parameter><decl><type><name>PartitionDispatch</name></type> <name>pd</name></decl></parameter>,
					  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
					  <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>ExecBuildSlotPartitionKeyDescription</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
									 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
									 <parameter><decl><type><name>int</name></type> <name>maxfieldlen</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * ExecSetupPartitionTupleRouting - sets up information needed during
 * tuple routing for partitioned tables, encapsulates it in
 * PartitionTupleRouting, and returns it.
 *
 * While we allocate the arrays of pointers of ResultRelInfo and
 * TupleConversionMap for all partitions here, actual objects themselves are
 * lazily allocated for a given partition if a tuple is actually routed to it;
 * see ExecInitPartitionInfo.  However, if the function is invoked for update
 * tuple routing, caller would already have initialized ResultRelInfo's for
 * some of the partitions, which are reused and assigned to their respective
 * slot in the aforementioned array.
 */</comment>
<function><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type>
<name>ExecSetupPartitionTupleRouting</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>leaf_parts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>update_rri</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_update_rri</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>update_rri_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get the information about the partition tree after locking all the
	 * partitions.
	 */</comment>
	<expr_stmt><expr><name>proute</name> <operator>=</operator> <operator>(</operator><name>PartitionTupleRouting</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionTupleRouting</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>partition_dispatch_info</name></name> <operator>=</operator>
		<call><name>RelationGetPartitionDispatchInfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>proute</name><operator>-&gt;</operator><name>num_dispatch</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>leaf_parts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>num_partitions</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>leaf_parts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>partitions</name></name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>num_partitions</name></name> <operator>*</operator>
												   <sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>parent_child_tupconv_maps</name></name> <operator>=</operator>
		<operator>(</operator><name>TupleConversionMap</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>num_partitions</name></name> <operator>*</operator>
										<sizeof>sizeof<argument_list>(<argument><expr><name>TupleConversionMap</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>partition_oids</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>num_partitions</name></name> <operator>*</operator>
											<sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up details specific to the type of tuple routing we are doing. */</comment>
	<if_stmt><if>if <condition>(<expr><name>mtstate</name> <operator>&amp;&amp;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>update_rri</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_update_rri</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>subplan_partition_offsets</name></name> <operator>=</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><name>num_update_rri</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>num_subplan_partition_offsets</name></name> <operator>=</operator> <name>num_update_rri</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We need an additional tuple slot for storing transient tuples that
		 * are converted to the root table descriptor.
		 */</comment>
		<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>root_tuple_slot</name></name> <operator>=</operator> <call><name>MakeTupleTableSlot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Initialize an empty slot that will be used to manipulate tuples of any
	 * given partition's rowtype.  It is attached to the caller-specified node
	 * (such as ModifyTableState) and released when the node finishes
	 * processing.
	 */</comment>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>partition_tuple_slot</name></name> <operator>=</operator> <call><name>MakeTupleTableSlot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>leaf_parts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>leaf_part_rri</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>leaf_oid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>partition_oids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>leaf_oid</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the leaf partition is already present in the per-subplan result
         * rels, we re-use that rather than initialize a new result rel. The
         * per-subplan resultrels and the resultrels of the leaf partitions
         * are both in the same canonical order. So while going through the
         * leaf partition oids, we need to keep track of the next per-subplan
         * result rel to be looked for in the leaf partition resultrels.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>update_rri_index</name> <operator>&lt;</operator> <name>num_update_rri</name> <operator>&amp;&amp;</operator>
            <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>update_rri</name><index>[<expr><name>update_rri_index</name></expr>]</index></name><operator>.</operator><name>ri_RelationDesc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>leaf_oid</name></expr>)</condition>
		<block>{<block_content>
			 <decl_stmt><decl><type><name>Relation</name></type>    <name>partrel</name></decl>;</decl_stmt>
             <decl_stmt><decl><type><name>TupleDesc</name></type>   <name>part_tupdesc</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>leaf_part_rri</name> <operator>=</operator> <operator>&amp;</operator><name><name>update_rri</name><index>[<expr><name>update_rri_index</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>partrel</name> <operator>=</operator> <name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>

            <comment type="block">/*
             * This is required in order to convert the partition's tuple to
             * be compatible with the root partitioned table's tuple
             * descriptor.  When generating the per-subplan result rels, this
             * was not set.
             */</comment>
            <expr_stmt><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_PartitionRoot</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>

            <comment type="block">/* Remember the subplan offset for this ResultRelInfo */</comment>
            <expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>subplan_partition_offsets</name><index>[<expr><name>update_rri_index</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>update_rri_index</name><operator>++</operator></expr>;</expr_stmt>

            <expr_stmt><expr><name>part_tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Save a tuple conversion map to convert a tuple routed to this
             * partition from the parent's type to the partition's.
             */</comment>
            <expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>parent_child_tupconv_maps</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
                <call><name>convert_tuples_by_name</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>part_tupdesc</name></expr></argument>,
                                       <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Verify result relation is a valid target for an INSERT.  An
             * UPDATE of a partition-key becomes a DELETE+INSERT operation, so
             * this check is required even when the operation is CMD_UPDATE.
             */</comment>
            <expr_stmt><expr><call><name>CheckValidResultRel</name><argument_list>(<argument><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         </block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>leaf_part_rri</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * For UPDATE, we should have found all the per-subplan resultrels in the
	 * leaf partitions.  (If this is an INSERT, both values will be zero.)
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>update_rri_index</name> <operator>==</operator> <name>num_update_rri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>proute</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecFindPartition -- Find a leaf partition in the partition tree rooted
 * at parent, for the heap tuple contained in *slot
 *
 * estate must be non-NULL; we'll need it to compute any expressions in the
 * partition key(s)
 *
 * If no leaf partition is found, this routine errors out with the appropriate
 * error message, else it returns the leaf partition sequence number
 * as an index into the array of (ResultRelInfos of) all leaf partitions in
 * the partition tree.
 */</comment>
<function><type><name>int</name></type>
<name>ExecFindPartition</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>, <parameter><decl><type><name>PartitionDispatch</name> <modifier>*</modifier></type><name>pd</name></decl></parameter>,
				  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionDispatch</name></type> <name>parent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>ecxt</name> <init>= <expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>ecxt_scantuple_old</name> <init>= <expr><name><name>ecxt</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * First check the root table's partition constraint, if any.  No point in
	 * routing the tuple if it doesn't belong in the root table itself.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionCheck</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecPartitionCheck</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* start with the root partitioned table */</comment>
	<expr_stmt><expr><name>parent</name> <operator>=</operator> <name><name>pd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionDesc</name></type>	<name>partdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>myslot</name> <init>= <expr><name><name>parent</name><operator>-&gt;</operator><name>tupslot</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><name><name>parent</name><operator>-&gt;</operator><name>tupmap</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>		<name>cur_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>reldesc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>partdesc</name> <operator>=</operator> <call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Convert the tuple to this parent's layout so that we can do certain
		 * things we do below.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>myslot</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><call><name>ExecFetchSlotTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>myslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>do_convert_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <name>myslot</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Extract partition key from tuple. Expression evaluation machinery
		 * that FormPartitionKeyDatum() invokes expects ecxt_scantuple to
		 * point to the correct tuple slot.  The slot might have changed from
		 * what was used for the parent table if the table of the current
		 * partitioning level has different tuple descriptor from the parent.
		 * So update ecxt_scantuple accordingly.
		 */</comment>
		<expr_stmt><expr><name><name>ecxt</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FormPartitionKeyDatum</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Nothing for get_partition_for_tuple() to do if there are no
		 * partitions to begin with.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>cur_index</name> <operator>=</operator> <call><name>get_partition_for_tuple</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * cur_index &lt; 0 means we failed to find a partition of this parent.
		 * cur_index &gt;= 0 means we either found the leaf partition, or the
		 * next parent to find a partition of.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>cur_index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>cur_index</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>cur_index</name></expr>]</index></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>parent</name> <operator>=</operator> <name><name>pd</name><index>[<expr><operator>-</operator><name><name>parent</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>cur_index</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* A partition was not found. */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val_desc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>val_desc</name> <operator>=</operator> <call><name>ExecBuildSlotPartitionKeyDescription</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
														<argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no partition of relation \"%s\" found for row"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>val_desc</name></expr> ?</condition><then> <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Partition key of the failing row contains %s."</literal></expr></argument>, <argument><expr><name>val_desc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>ecxt</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>ecxt_scantuple_old</name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecInitPartitionInfo
 *     Lock the partition and initialize ResultRelInfo.  Also setup other
 *     information for the partition and store it in the next empty slot in
 *     the proute-&gt;partitions array.
 *
 * Returns the ResultRelInfo
 */</comment>
<function><type><name>ResultRelInfo</name> <modifier>*</modifier></type>
<name>ExecInitPartitionInfo</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
					  <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
					  <parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>,
					  <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>partidx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rootrel</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>,
				<decl><type ref="prev"/><name>partrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>leaf_part_rri</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><ternary><condition><expr><name>mtstate</name></expr> ?</condition><then> <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>partrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>partition_oids</name><index>[<expr><name>partidx</name></expr>]</index></name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Keep ResultRelInfo and other information for this partition in the
	 * per-query memory context so they'll survive throughout the query.
	 */</comment>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>leaf_part_rri</name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitResultRelInfo</name><argument_list>(<argument><expr><name>leaf_part_rri</name></expr></argument>,
					  <argument><expr><name>partrel</name></expr></argument>,
					  <argument><expr><ternary><condition><expr><name>node</name></expr> ?</condition><then> <expr><name><name>node</name><operator>-&gt;</operator><name>nominalRelation</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>,
					  <argument><expr><name>rootrel</name></expr></argument>,
					  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Verify result relation is a valid target for an INSERT.  An UPDATE of a
	 * partition-key becomes a DELETE+INSERT operation, so this check is still
	 * required when the operation is CMD_UPDATE.
	 */</comment>
	<expr_stmt><expr><call><name>CheckValidResultRel</name><argument_list>(<argument><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open partition indices.  The user may have asked to check for conflicts
	 * within this leaf partition and do "nothing" instead of throwing an
	 * error.  Be prepared in that case by initializing the index information
	 * needed by ExecInsert() to perform speculative insertions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>partrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name> <operator>&amp;&amp;</operator>
		<name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_IndexRelationDescs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecOpenIndices</name><argument_list>(<argument><expr><name>leaf_part_rri</name></expr></argument>,
						<argument><expr><operator>(</operator><name>mtstate</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
						 <name><name>mtstate</name><operator>-&gt;</operator><name>mt_onconflict</name></name> <operator>!=</operator> <name>ONCONFLICT_NONE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Build WITH CHECK OPTION constraints for the partition.  Note that we
	 * didn't build the withCheckOptionList for partitions within the planner,
	 * but simple translation of varattnos will suffice.  This only occurs for
	 * the INSERT case or in the case of UPDATE tuple routing where we didn't
	 * find a result rel to reuse in ExecSetupPartitionTupleRouting().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>wcoList</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>wcoExprs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ll</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>firstVarno</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ri_RangeTableIndex</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>firstResultRel</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ri_RelationDesc</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * In the case of INSERT on a partitioned table, there is only one
		 * plan.  Likewise, there is only one WCO list, not one per partition.
		 * For UPDATE, there are as many WCO lists as there are plans.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>&amp;&amp;</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator>
			   <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name></expr></argument>)</argument_list></call> <operator>==</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Use the WCO list of the first plan as a reference to calculate
		 * attno's for the WCO list of this partition.  In the INSERT case,
		 * that refers to the root partitioned table, whereas in the UPDATE
		 * tuple routing case, that refers to the first partition in the
		 * mtstate-&gt;resultRelInfo array.  In any case, both that relation and
		 * this partition should have the same columns, so we should be able
		 * to map attributes successfully.
		 */</comment>
		<expr_stmt><expr><name>wcoList</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Convert Vars in it to contain this partition's attribute numbers.
		 */</comment>
		<expr_stmt><expr><name>wcoList</name> <operator>=</operator> <call><name>map_partition_varattnos</name><argument_list>(<argument><expr><name>wcoList</name></expr></argument>, <argument><expr><name>firstVarno</name></expr></argument>,
										  <argument><expr><name>partrel</name></expr></argument>, <argument><expr><name>firstResultRel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>ll</argument>, <argument>wcoList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WithCheckOption</name> <modifier>*</modifier></type><name>wco</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>WithCheckOption</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>ll</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>wcoExpr</name> <init>= <expr><call><name>ExecInitQual</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>wco</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>wcoExprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>wcoExprs</name></expr></argument>, <argument><expr><name>wcoExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>=</operator> <name>wcoList</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_WithCheckOptionExprs</name></name> <operator>=</operator> <name>wcoExprs</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Build the RETURNING projection for the partition.  Note that we didn't
	 * build the returningList for partitions within the planner, but simple
	 * translation of varattnos will suffice.  This only occurs for the INSERT
	 * case or in the case of UPDATE tuple routing where we didn't find a
	 * result rel to reuse in ExecSetupPartitionTupleRouting().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>returningLists</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>returningList</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>firstVarno</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ri_RangeTableIndex</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>firstResultRel</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ri_RelationDesc</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* See the comment above for WCO lists. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>&amp;&amp;</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator>
			   <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>)</argument_list></call> <operator>==</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Use the RETURNING list of the first plan as a reference to
		 * calculate attno's for the RETURNING list of this partition.  See
		 * the comment above for WCO lists for more details on why this is
		 * okay.
		 */</comment>
		<expr_stmt><expr><name>returningList</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Convert Vars in it to contain this partition's attribute numbers.
		 */</comment>
		<expr_stmt><expr><name>returningList</name> <operator>=</operator> <call><name>map_partition_varattnos</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>, <argument><expr><name>firstVarno</name></expr></argument>,
												<argument><expr><name>partrel</name></expr></argument>, <argument><expr><name>firstResultRel</name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Initialize the projection itself.
		 *
		 * Use the slot and the expression context that would have been set up
		 * in ExecInitModifyTable() for projection's output.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_projectReturning</name></name> <operator>=</operator>
			<call><name>ExecBuildProjectionInfo</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>partidx</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>partidx</name></expr>]</index></name> <operator>=</operator> <name>leaf_part_rri</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Save a tuple conversion map to convert a tuple routed to this partition
	 * from the parent's type to the partition's.
	 */</comment>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>parent_child_tupconv_maps</name><index>[<expr><name>partidx</name></expr>]</index></name> <operator>=</operator>
		<call><name>convert_tuples_by_name</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rootrel</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>leaf_part_rri</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecSetupChildParentMapForLeaf -- Initialize the per-leaf-partition
 * child-to-root tuple conversion map array.
 *
 * This map is required for capturing transition tuples when the target table
 * is a partitioned table. For a tuple that is routed by an INSERT or UPDATE,
 * we need to convert it from the leaf partition to the target table
 * descriptor.
 */</comment>
<function><type><name>void</name></type>
<name>ExecSetupChildParentMapForLeaf</name><parameter_list>(<parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>proute</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * These array elements gets filled up with maps on an on-demand basis.
	 * Initially just set all of them to NULL.
	 */</comment>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>child_parent_tupconv_maps</name></name> <operator>=</operator>
		<operator>(</operator><name>TupleConversionMap</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleConversionMap</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator>
										<name><name>proute</name><operator>-&gt;</operator><name>num_partitions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Same is the case for this array. All the values are set to false */</comment>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>child_parent_map_not_required</name></name> <operator>=</operator>
		<operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>proute</name><operator>-&gt;</operator><name>num_partitions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * TupConvMapForLeaf -- Get the tuple conversion map for a given leaf partition
 * index.
 */</comment>
<function><type><name>TupleConversionMap</name> <modifier>*</modifier></type>
<name>TupConvMapForLeaf</name><parameter_list>(<parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>,
				  <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rootRelInfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>leaf_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>resultRelInfos</name> <init>= <expr><name><name>proute</name><operator>-&gt;</operator><name>partitions</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier><modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>

	<comment type="block">/* Don't call this if we're not supposed to be using this type of map. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>child_parent_tupconv_maps</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If it's already known that we don't need a map, return NULL. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proute</name><operator>-&gt;</operator><name>child_parent_map_not_required</name><index>[<expr><name>leaf_index</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If we've already got a map, return it. */</comment>
	<expr_stmt><expr><name>map</name> <operator>=</operator> <operator>&amp;</operator><name><name>proute</name><operator>-&gt;</operator><name>child_parent_tupconv_maps</name><index>[<expr><name>leaf_index</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>*</operator><name>map</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* No map yet; try to create one. */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>resultRelInfos</name><index>[<expr><name>leaf_index</name></expr>]</index></name><operator>-&gt;</operator><name>ri_RelationDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>map</name> <operator>=</operator>
		<call><name>convert_tuples_by_name</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>,
							   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>rootRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If it turns out no map is needed, remember for next time. */</comment>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>child_parent_map_not_required</name><index>[<expr><name>leaf_index</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>map</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><operator>*</operator><name>map</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ConvertPartitionTupleSlot -- convenience function for tuple conversion.
 * The tuple, if converted, is stored in new_slot, and *p_my_slot is
 * updated to point to it.  new_slot typically should be one of the
 * dedicated partition tuple slots. If map is NULL, *p_my_slot is not changed.
 *
 * Returns the converted tuple, unless map is NULL, in which case original
 * tuple is returned unmodified.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>ConvertPartitionTupleSlot</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>partrel</name></decl></parameter>, <parameter><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>,
						  <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
						  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>new_slot</name></decl></parameter>,
						  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_my_slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>map</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>tuple</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>do_convert_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Change the partition tuple slot descriptor, as per converted tuple.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>p_my_slot</name> <operator>=</operator> <name>new_slot</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name>new_slot</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>outdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>new_slot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecCleanupTupleRouting -- Clean up objects allocated for partition tuple
 * routing.
 *
 * Close all the partitioned tables, leaf partitions, and their indices.
 */</comment>
<function><type><name>void</name></type>
<name>ExecCleanupTupleRouting</name><parameter_list>(<parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>subplan_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Remember, proute-&gt;partition_dispatch_info[0] corresponds to the root
	 * partitioned table, which we must not try to close, because it is the
	 * main target table of the query that will be closed by callers such as
	 * ExecEndPlan() or DoCopy(). Also, tupslot is NULL for the root
	 * partitioned table.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>proute</name><operator>-&gt;</operator><name>num_dispatch</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionDispatch</name></type> <name>pd</name> <init>= <expr><name><name>proute</name><operator>-&gt;</operator><name>partition_dispatch_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name><name>pd</name><operator>-&gt;</operator><name>reldesc</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>pd</name><operator>-&gt;</operator><name>tupslot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>proute</name><operator>-&gt;</operator><name>num_partitions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><name><name>proute</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* skip further processsing for uninitialized partitions */</comment>
		<if_stmt><if>if <condition>(<expr><name>resultRelInfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If this result rel is one of the UPDATE subplan result rels, let
		 * ExecEndPlan() close it. For INSERT or COPY,
		 * proute-&gt;subplan_partition_offsets will always be NULL. Note that
		 * the subplan_partition_offsets array and the partitions array have
		 * the partitions in the same order. So, while we iterate over
		 * partitions array, we also iterate over the
		 * subplan_partition_offsets array in order to figure out which of the
		 * result rels are present in the UPDATE subplans.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>proute</name><operator>-&gt;</operator><name>subplan_partition_offsets</name></name> <operator>&amp;&amp;</operator>
			<name>subplan_index</name> <operator>&lt;</operator> <name><name>proute</name><operator>-&gt;</operator><name>num_subplan_partition_offsets</name></name> <operator>&amp;&amp;</operator>
			<name><name>proute</name><operator>-&gt;</operator><name>subplan_partition_offsets</name><index>[<expr><name>subplan_index</name></expr>]</index></name> <operator>==</operator> <name>i</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>subplan_index</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ExecCloseIndices</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Release the standalone partition tuple descriptors, if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proute</name><operator>-&gt;</operator><name>root_tuple_slot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>root_tuple_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>proute</name><operator>-&gt;</operator><name>partition_tuple_slot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>partition_tuple_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RelationGetPartitionDispatchInfo
 *		Returns information necessary to route tuples down a partition tree
 *
 * The number of elements in the returned array (that is, the number of
 * PartitionDispatch objects for the partitioned tables in the partition tree)
 * is returned in *num_parted and a list of the OIDs of all the leaf
 * partitions of rel is returned in *leaf_part_oids.
 *
 * All the relations in the partition tree (including 'rel') must have been
 * locked (using at least the AccessShareLock) by the caller.
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionDispatch</name> <modifier>*</modifier></type>
<name>RelationGetPartitionDispatchInfo</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
								 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_parted</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>leaf_part_oids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pdlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionDispatchData</name> <modifier>*</modifier><modifier>*</modifier></type><name>pd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>num_parted</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>leaf_part_oids</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>get_partition_dispatch_recurse</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pdlist</name></expr></argument>, <argument><expr><name>leaf_part_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>num_parted</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>pdlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pd</name> <operator>=</operator> <operator>(</operator><name>PartitionDispatchData</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>*</operator><name>num_parted</name> <operator>*</operator>
										   <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionDispatchData</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pdlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pd</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>pd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_partition_dispatch_recurse
 *		Recursively expand partition tree rooted at rel
 *
 * As the partition tree is expanded in a depth-first manner, we maintain two
 * global lists: of PartitionDispatch objects corresponding to partitioned
 * tables in *pds and of the leaf partition OIDs in *leaf_part_oids.
 *
 * Note that the order of OIDs of leaf partitions in leaf_part_oids matches
 * the order in which the planner's expand_partitioned_rtentry() processes
 * them.  It's not necessarily the case that the offsets match up exactly,
 * because constraint exclusion might prune away some partitions on the
 * planner side, whereas we'll always have the complete list; but unpruned
 * partitions will appear in the same order in the plan as they are returned
 * here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_partition_dispatch_recurse</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>pds</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>leaf_part_oids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>partkey</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionDispatch</name></type> <name>pd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build a PartitionDispatch for this table and add it to *pds. */</comment>
	<expr_stmt><expr><name>pd</name> <operator>=</operator> <operator>(</operator><name>PartitionDispatch</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionDispatchData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>pds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>pds</name></expr></argument>, <argument><expr><name>pd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>reldesc</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>partkey</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>keystate</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>partdesc</name></name> <operator>=</operator> <name>partdesc</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>parent</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For every partitioned table other than the root, we must store a
		 * tuple table slot initialized with its tuple descriptor and a tuple
		 * conversion map to convert a tuple from its parent's rowtype to its
		 * own. That is to make sure that we are looking at the correct row
		 * using the correct tuple descriptor when computing its partition key
		 * for tuple routing.
		 */</comment>
		<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>tupslot</name></name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>tupmap</name></name> <operator>=</operator> <call><name>convert_tuples_by_name</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>tupdesc</name></expr></argument>,
											<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Not required for the root partitioned table */</comment>
		<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>tupslot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>tupmap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Go look at each partition of this table.  If it's a leaf partition,
	 * simply add its OID to *leaf_part_oids.  If it's a partitioned table,
	 * recursively call get_partition_dispatch_recurse(), so that its
	 * partitions are processed as well and a corresponding PartitionDispatch
	 * object gets added to *pds.
	 *
	 * About the values in pd-&gt;indexes: for a leaf partition, it contains the
	 * leaf partition's position in the global list *leaf_part_oids minus 1,
	 * whereas for a partitioned table partition, it contains the partition's
	 * position in the global list *pds multiplied by -1.  The latter is
	 * multiplied by -1 to distinguish partitioned tables from leaf partitions
	 * when going through the values in pd-&gt;indexes.  So, for example, when
	 * using it during tuple-routing, encountering a value &gt;= 0 means we found
	 * a leaf partition.  It is immediately returned as the index in the array
	 * of ResultRelInfos of all the leaf partitions, using which we insert the
	 * tuple into that leaf partition.  A negative value means we found a
	 * partitioned table.  The value multiplied by -1 is returned as the index
	 * in the array of PartitionDispatch objects of all partitioned tables in
	 * the tree.  This value is used to continue the search in the next level
	 * of the partition tree.
	 */</comment>
	<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>indexes</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>partrelid</name> <init>= <expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>partrelid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>leaf_part_oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><operator>*</operator><name>leaf_part_oids</name></expr></argument>, <argument><expr><name>partrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><operator>*</operator><name>leaf_part_oids</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We assume all tables in the partition tree were already locked
			 * by the caller.
			 */</comment>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>partrel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>partrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><call><name>list_length</name><argument_list>(<argument><expr><operator>*</operator><name>pds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_partition_dispatch_recurse</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pds</name></expr></argument>, <argument><expr><name>leaf_part_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		FormPartitionKeyDatum
 *			Construct values[] and isnull[] arrays for the partition key
 *			of a tuple.
 *
 *	pd				Partition dispatch object of the partitioned table
 *	slot			Heap tuple from which to extract partition key
 *	estate			executor state for evaluating any partition key
 *					expressions (must be non-NULL)
 *	values			Array of partition key Datums (output area)
 *	isnull			Array of is-null indicators (output area)
 *
 * the ecxt_scantuple slot of estate's per-tuple expr context must point to
 * the heap tuple passed in.
 * ----------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FormPartitionKeyDatum</name><parameter_list>(<parameter><decl><type><name>PartitionDispatch</name></type> <name>pd</name></decl></parameter>,
					  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
					  <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>partexpr_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pd</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>partexprs</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name><name>pd</name><operator>-&gt;</operator><name>keystate</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Check caller has set up context correctly */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>estate</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			   <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ecxt_scantuple</name> <operator>==</operator> <name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* First time through, set up expression evaluation state */</comment>
		<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>keystate</name></name> <operator>=</operator> <call><name>ExecPrepareExprList</name><argument_list>(<argument><expr><name><name>pd</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>partexpr_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>pd</name><operator>-&gt;</operator><name>keystate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pd</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>keycol</name> <init>= <expr><name><name>pd</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>keycol</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Plain column; get the value directly from the heap tuple */</comment>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>keycol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Expression; need to evaluate it */</comment>
			<if_stmt><if>if <condition>(<expr><name>partexpr_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of partition key expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>partexpr_item</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partexpr_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>partexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>datum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>isNull</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>partexpr_item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of partition key expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * BuildSlotPartitionKeyDescription
 *
 * This works very much like BuildIndexValueDescription() and is currently
 * used for building error messages when ExecFindPartition() fails to find
 * partition for a row.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ExecBuildSlotPartitionKeyDescription</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
									 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
									 <parameter><decl><type><name>int</name></type> <name>maxfieldlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>partnatts</name> <init>= <expr><call><name>get_partition_natts</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>check_enable_rls</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RLS_ENABLED</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If the user has table-level access, just go build the description. */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Step through the columns of the partition key and make sure the
		 * user has SELECT rights on all of them.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name> <init>= <expr><call><name>get_partition_col_attnum</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If this partition key column is an expression, we return no
			 * detail rather than try to figure out what column(s) the
			 * expression includes and if the user has SELECT rights on them.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name> <operator>||</operator>
				<call><name>pg_attribute_aclcheck</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
									  <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(%s) = ("</literal></expr></argument>,
					 <argument><expr><call><name>pg_get_partkeydef_columns</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>vallen</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="string">"null"</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>foutoid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>typisvarlena</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><call><name>get_partition_col_typid</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>foutoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>foutoid</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* truncate if needed */</comment>
		<expr_stmt><expr><name>vallen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>vallen</name> <operator>&lt;=</operator> <name>maxfieldlen</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>vallen</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>vallen</name></expr></argument>, <argument><expr><name>maxfieldlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>vallen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
