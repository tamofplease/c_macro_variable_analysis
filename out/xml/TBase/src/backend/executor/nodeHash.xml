<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/executor/nodeHash.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeHash.c
 *      Routines to hash relations for hashjoin
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/executor/nodeHash.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 * INTERFACE ROUTINES
 *        MultiExecHash    - generate an in-memory hash table of the relation
 *        ExecInitHash    - initialize node and subnodes
 *        ExecEndHash        - shutdown node and subnodes
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/hashjoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHashjoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/dynahash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execParallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/nodemgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_BUCKET_THRESHOLD</name></cpp:macro>  <cpp:value>1048576</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_BATCH_THRESHOLD</name></cpp:macro>   <cpp:value>32</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecHashIncreaseNumBatches</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecHashIncreaseNumBuckets</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecHashBuildSkewHash</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>, <parameter><decl><type><name>Hash</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                      <parameter><decl><type><name>int</name></type> <name>mcvsToUse</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecHashSkewTableInsert</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>,
                        <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
                        <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>,
                        <parameter><decl><type><name>int</name></type> <name>bucketNumber</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecHashRemoveNextSkewBucket</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>dense_alloc</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecHash
 *
 *        stub for pro forma compliance
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecHash</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Hash node does not support ExecProcNode call convention"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        MultiExecHash
 *
 *        build hash table for hashjoin, doing partitioning if more
 *        than one batch is required.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>MultiExecHash</name><parameter_list>(<parameter><decl><type><name>HashState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerNode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>hashkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>hashvalue</name></decl>;</decl_stmt>

    <comment type="block">/* must provide our own instrumentation support */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>InstrStartNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * get state info from node
     */</comment>
    <expr_stmt><expr><name>outerNode</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hashtable</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>hashtable</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * set expression context
     */</comment>
    <expr_stmt><expr><name>hashkeys</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>hashkeys</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * get all inner tuples and insert into the hash table (or temp files)
     */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <comment type="block">/* We have to compute the hash value */</comment>
        <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ExecHashGetHashValue</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>hashkeys</name></expr></argument>,
                                 <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>keepNulls</name></name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>hashvalue</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>bucketNumber</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>bucketNumber</name> <operator>=</operator> <call><name>ExecHashGetSkewBucket</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>bucketNumber</name> <operator>!=</operator> <name>INVALID_SKEW_BUCKET_NO</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* It's a skew tuple, so put it into that hash table */</comment>
                <expr_stmt><expr><call><name>ExecHashSkewTableInsert</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>,
                                        <argument><expr><name>bucketNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewTuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Not subject to skew optimization, so insert normally */</comment>
                <expr_stmt><expr><call><name>ExecHashTableInsert</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* resize the hash table if needed (NTUP_PER_BUCKET exceeded) */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>!=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecHashIncreaseNumBuckets</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Account for the buckets in spaceUsed (reported in EXPLAIN ANALYZE) */</comment>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>+=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* must provide our own instrumentation support */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>InstrStopNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>instrument</name></name></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We do not return the hash table directly because it's not a subtype of
     * Node, and so would violate the MultiExecProcNode API.  Instead, our
     * parent Hashjoin node is expected to know how to fish it out of our node
     * state.  Ugly but not really worth cleaning up, since Hashjoin knows
     * quite a bit more about Hash besides that.
     */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecInitHash
 *
 *        Init routine for Hash node
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>HashState</name> <modifier>*</modifier></type>
<name>ExecInitHash</name><parameter_list>(<parameter><decl><type><name>Hash</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HashState</name>  <modifier>*</modifier></type><name>hashstate</name></decl>;</decl_stmt>

    <comment type="block">/* check for unsupported flags */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_BACKWARD</name> <operator>|</operator> <name>EXEC_FLAG_MARK</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * create state structure
     */</comment>
    <expr_stmt><expr><name>hashstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>HashState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecHash</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashstate</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashstate</name><operator>-&gt;</operator><name>hashkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>    <comment type="block">/* will be set by parent HashJoin */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<expr_stmt><expr><name><name>hashstate</name><operator>-&gt;</operator><name>shared_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Miscellaneous initialization
     *
     * create expression context for node
     */</comment>
    <expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hashstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * initialize our result slot
     */</comment>
    <expr_stmt><expr><call><name>ExecInitResultTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hashstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * initialize child expressions
     */</comment>
    <expr_stmt><expr><name><name>hashstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
        <call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>hashstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * initialize child nodes
     */</comment>
    <expr_stmt><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>hashstate</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * initialize tuple type. no need to initialize projection info because
     * this node doesn't do projections
     */</comment>
    <expr_stmt><expr><call><name>ExecAssignResultTypeFromTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hashstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <return>return <expr><name>hashstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ---------------------------------------------------------------
 *        ExecEndHash
 *
 *        clean up routine for Hash node
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndHash</name><parameter_list>(<parameter><decl><type><name>HashState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name></decl>;</decl_stmt>

    <comment type="block">/*
     * free exprcontext
     */</comment>
    <expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * shut down the subplan
     */</comment>
    <expr_stmt><expr><name>outerPlan</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *        ExecHashTableCreate
 *
 *        create an empty hashtable data structure for hashjoin.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>HashJoinTable</name></type>
<name>ExecHashTableCreate</name><parameter_list>(<parameter><decl><type><name>Hash</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashOperators</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>keepNulls</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>outerNode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nbuckets</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nbatch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_skew_mcvs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>log2_nbuckets</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ho</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Get information about the size of the relation to be hashed (it's the
     * "outer" subtree of this node, but the inner relation of the hashjoin).
     * Compute the appropriate size of the hash table.
     */</comment>
    <expr_stmt><expr><name>outerNode</name> <operator>=</operator> <call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_aware</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>double</name></type> <name>plan_rows</name> <init>= <expr><name><name>outerNode</name><operator>-&gt;</operator><name>plan_rows</name></name></expr></init></decl>;</decl_stmt><comment type="line">// * max_parallel_workers_per_gather;</comment>
        <decl_stmt><decl><type><name>double</name></type> <name>mynbatch</name>  <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
        
        <expr_stmt><expr><call><name>ExecChooseHashTableSize</name><argument_list>(<argument><expr><name>plan_rows</name></expr></argument>, <argument><expr><name><name>outerNode</name><operator>-&gt;</operator><name>plan_width</name></name></expr></argument>,
                        <argument><expr><name>false</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>nbuckets</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbatch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_skew_mcvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>nbuckets</name> <operator>&lt;</operator> <name>HASH_BUCKET_THRESHOLD</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <name>HASH_BUCKET_THRESHOLD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* 
          * In parallel mode, nbuckets and nbatch can not be changed.
          * Need to estimate both appropriate value.
          */</comment>
        <expr_stmt><expr><name>mynbatch</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>plan_rows</name> <operator>/</operator> <name>nbuckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* ... and force it to be a power of 2. */</comment>
        <expr_stmt><expr><name>mynbatch</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <call><name>my_log2</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>mynbatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>nbatch</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>nbatch</name></expr></argument>, <argument><expr><name>mynbatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        
        <comment type="line">//if (nbatch &lt; HASH_BATCH_THRESHOLD)</comment>
        <comment type="line">//    nbatch   = nbatch   * max_parallel_workers_per_gather;</comment>

        <comment type="line">//nbuckets = nbuckets * NumDataNodes * max_parallel_workers_per_gather;</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>ExecChooseHashTableSize</name><argument_list>(<argument><expr><name><name>outerNode</name><operator>-&gt;</operator><name>plan_rows</name></name></expr></argument>, <argument><expr><name><name>outerNode</name><operator>-&gt;</operator><name>plan_width</name></name></expr></argument>,
                            <argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>skewTable</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>nbuckets</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbatch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_skew_mcvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* nbuckets must be a power of 2 */</comment>
    <expr_stmt><expr><name>log2_nbuckets</name> <operator>=</operator> <call><name>my_log2</name><argument_list>(<argument><expr><name>nbuckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nbuckets</name> <operator>==</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>log2_nbuckets</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize the hash table control block.
     *
     * The hashtable control block is just palloc'd from the executor's
     * per-query memory context.
     */</comment>
    <expr_stmt><expr><name>hashtable</name> <operator>=</operator> <operator>(</operator><name>HashJoinTable</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTableData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>=</operator> <name>nbuckets</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_original</name></name> <operator>=</operator> <name>nbuckets</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>=</operator> <name>nbuckets</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets</name></name> <operator>=</operator> <name>log2_nbuckets</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets_optimal</name></name> <operator>=</operator> <name>log2_nbuckets</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>keepNulls</name></name> <operator>=</operator> <name>keepNulls</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewEnabled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucketLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nSkewBuckets</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucketNums</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>=</operator> <name>nbatch</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch_original</name></name> <operator>=</operator> <name>nbatch</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch_outstart</name></name> <operator>=</operator> <name>nbatch</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>growEnabled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewTuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceAllowed</name></name> <operator>=</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsedSkew</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceAllowedSkew</name></name> <operator>=</operator>
        <name><name>hashtable</name><operator>-&gt;</operator><name>spaceAllowed</name></name> <operator>*</operator> <name>SKEW_WORK_MEM_PERCENT</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HJDEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Hashjoin %p: initial nbatch = %d, nbuckets = %d\n"</literal></expr></argument>,
           <argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>nbatch</name></expr></argument>, <argument><expr><name>nbuckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Get info about the hash functions to be used for each hash key. Also
     * remember whether the join operators are strict.
     */</comment>
    <expr_stmt><expr><name>nkeys</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>hashOperators</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outer_hashfunctions</name></name> <operator>=</operator>
        <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>inner_hashfunctions</name></name> <operator>=</operator>
        <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashStrict</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>ho</argument>, <argument>hashOperators</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>hashop</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>ho</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>left_hashfn</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>right_hashfn</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_op_hash_functions</name><argument_list>(<argument><expr><name>hashop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left_hashfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right_hashfn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find hash function for hash operator %u"</literal></expr></argument>,
                 <argument><expr><name>hashop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>left_hashfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>outer_hashfunctions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>right_hashfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>inner_hashfunctions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashStrict</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>op_strict</name><argument_list>(<argument><expr><name>hashop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Create temporary memory contexts in which to keep the hashtable working
     * storage.  See notes in executor/hashjoin.h.
     */</comment>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashCxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                               <argument><expr><literal type="string">"HashTableContext"</literal></expr></argument>,
                                               <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batchCxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashCxt</name></name></expr></argument>,
                                                <argument><expr><literal type="string">"HashBatchContext"</literal></expr></argument>,
                                                <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Allocate data that will live for the life of the hashjoin */</comment>

    <expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>nbatch</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * allocate and initialize the file arrays in hashCxt
         */</comment>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name></name> <operator>=</operator> <operator>(</operator><name>BufFile</name> <operator>*</operator><operator>*</operator><operator>)</operator>
            <call><name>palloc0</name><argument_list>(<argument><expr><name>nbatch</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BufFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name></name> <operator>=</operator> <operator>(</operator><name>BufFile</name> <operator>*</operator><operator>*</operator><operator>)</operator>
            <call><name>palloc0</name><argument_list>(<argument><expr><name>nbatch</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BufFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* The files will not be opened until needed... */</comment>
        <comment type="block">/* ... but make sure we have temp tablespaces established for them */</comment>
        <expr_stmt><expr><call><name>PrepareTempTablespaces</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Prepare context for the first-scan space allocations; allocate the
     * hashbucket array therein, and set each bucket "empty".
     */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batchCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name></name> <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name> <operator>*</operator><operator>)</operator>
        <call><name>palloc0</name><argument_list>(<argument><expr><name>nbuckets</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>bucket_wNum</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name>nbuckets</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Set up for skew optimization, if possible and there's a need for more
     * than one batch.  (In a one-batch join, there's no point in it.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>nbatch</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecHashBuildSkewHash</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>num_skew_mcvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>hashtable</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Compute appropriate size for hashtable given the estimated size of the
 * relation to be hashed (number of rows and average row width).
 *
 * This is exported so that the planner's costsize.c can use it.
 */</comment>

<comment type="block">/* Target bucket loading (tuples per bucket) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTUP_PER_BUCKET</name></cpp:macro>            <cpp:value>1</cpp:value></cpp:define>

<function><type><name>void</name></type>
<name>ExecChooseHashTableSize</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>ntuples</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tupwidth</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useskew</name></decl></parameter>,
                        <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numbuckets</name></decl></parameter>,
                        <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numbatches</name></decl></parameter>,
                        <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_skew_mcvs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>tupsize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>inner_rel_bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>bucket_bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>hash_table_bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>skew_table_bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>max_pointers</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>mppow2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nbatch</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nbuckets</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>dbuckets</name></decl>;</decl_stmt>

    <comment type="block">/* Force a plausible relation size if no info */</comment>
    <if_stmt><if>if <condition>(<expr><name>ntuples</name> <operator>&lt;=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ntuples</name> <operator>=</operator> <literal type="number">1000.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Estimate tupsize based on footprint of tuple in hashtable... note this
     * does not allow for any palloc overhead.  The manipulations of spaceUsed
     * don't count palloc overhead either.
     */</comment>
    <expr_stmt><expr><name>tupsize</name> <operator>=</operator> <name>HJTUPLE_OVERHEAD</name> <operator>+</operator>
        <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofMinimalTupleHeader</name></expr></argument>)</argument_list></call> <operator>+</operator>
        <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>tupwidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>inner_rel_bytes</name> <operator>=</operator> <name>ntuples</name> <operator>*</operator> <name>tupsize</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Target in-memory hashtable size is work_mem kilobytes.
     */</comment>
    <expr_stmt><expr><name>hash_table_bytes</name> <operator>=</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * If skew optimization is possible, estimate the number of skew buckets
     * that will fit in the memory allowed, and decrement the assumed space
     * available for the main hash table accordingly.
     *
     * We make the optimistic assumption that each skew bucket will contain
     * one inner-relation tuple.  If that turns out to be low, we will recover
     * at runtime by reducing the number of skew buckets.
     *
     * hashtable-&gt;skewBucket will have up to 8 times as many HashSkewBucket
     * pointers as the number of MCVs we allow, since ExecHashBuildSkewHash
     * will round up to the next power of 2 and then multiply by 4 to reduce
     * collisions.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>useskew</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>skew_table_bytes</name> <operator>=</operator> <name>hash_table_bytes</name> <operator>*</operator> <name>SKEW_WORK_MEM_PERCENT</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>

        <comment type="block">/*----------
         * Divisor is:
         * size of a hash tuple +
         * worst-case size of skewBucket[] per MCV +
         * size of skewBucketNums[] entry +
         * size of skew bucket struct itself
         *----------
         */</comment>
        <expr_stmt><expr><operator>*</operator><name>num_skew_mcvs</name> <operator>=</operator> <name>skew_table_bytes</name> <operator>/</operator> <operator>(</operator><name>tupsize</name> <operator>+</operator>
                                             <operator>(</operator><literal type="number">8</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashSkewBucket</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>+</operator>
                                             <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
                                             <name>SKEW_BUCKET_OVERHEAD</name><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>num_skew_mcvs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>hash_table_bytes</name> <operator>-=</operator> <name>skew_table_bytes</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>num_skew_mcvs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Set nbuckets to achieve an average bucket load of NTUP_PER_BUCKET when
     * memory is filled, assuming a single batch; but limit the value so that
     * the pointer arrays we'll try to allocate do not exceed work_mem nor
     * MaxAllocSize.
     *
     * Note that both nbuckets and nbatch must be powers of 2 to make
     * ExecHashGetBucketAndBatch fast.
     */</comment>
    <expr_stmt><expr><name>max_pointers</name> <operator>=</operator> <operator>(</operator><name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal><operator>)</operator> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>max_pointers</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>max_pointers</name></expr></argument>, <argument><expr><name>MaxAllocSize</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* If max_pointers isn't a power of 2, must round it down to one */</comment>
    <expr_stmt><expr><name>mppow2</name> <operator>=</operator> <literal type="number">1L</literal> <operator>&lt;&lt;</operator> <call><name>my_log2</name><argument_list>(<argument><expr><name>max_pointers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>max_pointers</name> <operator>!=</operator> <name>mppow2</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>max_pointers</name> <operator>=</operator> <name>mppow2</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Also ensure we avoid integer overflow in nbatch and nbuckets */</comment>
    <comment type="block">/* (this step is redundant given the current value of MaxAllocSize) */</comment>
    <expr_stmt><expr><name>max_pointers</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>max_pointers</name></expr></argument>, <argument><expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>dbuckets</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>ntuples</name> <operator>/</operator> <name>NTUP_PER_BUCKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dbuckets</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>dbuckets</name></expr></argument>, <argument><expr><name>max_pointers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>dbuckets</name></expr>;</expr_stmt>
    <comment type="block">/* don't let nbuckets be really small, though ... */</comment>
    <expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>nbuckets</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* ... and force it to be a power of 2. */</comment>
    <expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <call><name>my_log2</name><argument_list>(<argument><expr><name>nbuckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If there's not enough space to store the projected number of tuples and
     * the required bucket headers, we will need multiple batches.
     */</comment>
    <expr_stmt><expr><name>bucket_bytes</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nbuckets</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>inner_rel_bytes</name> <operator>+</operator> <name>bucket_bytes</name> <operator>&gt;</operator> <name>hash_table_bytes</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We'll need multiple batches */</comment>
        <decl_stmt><decl><type><name>long</name></type>        <name>lbuckets</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type>        <name>dbatch</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>minbatch</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type>        <name>bucket_size</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Estimate the number of buckets we'll want to have when work_mem is
         * entirely full.  Each bucket will contain a bucket pointer plus
         * NTUP_PER_BUCKET tuples, whose projected size already includes
         * overhead for the hash code, pointer to the next tuple, etc.
         */</comment>
        <expr_stmt><expr><name>bucket_size</name> <operator>=</operator> <operator>(</operator><name>tupsize</name> <operator>*</operator> <name>NTUP_PER_BUCKET</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>lbuckets</name> <operator>=</operator> <literal type="number">1L</literal> <operator>&lt;&lt;</operator> <call><name>my_log2</name><argument_list>(<argument><expr><name>hash_table_bytes</name> <operator>/</operator> <name>bucket_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lbuckets</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>lbuckets</name></expr></argument>, <argument><expr><name>max_pointers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>lbuckets</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <call><name>my_log2</name><argument_list>(<argument><expr><name>nbuckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bucket_bytes</name> <operator>=</operator> <name>nbuckets</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

        <comment type="block">/*
         * Buckets are simple pointers to hashjoin tuples, while tupsize
         * includes the pointer, hash code, and MinimalTupleData.  So buckets
         * should never really exceed 25% of work_mem (even for
         * NTUP_PER_BUCKET=1); except maybe for work_mem values that are not
         * 2^N bytes, where we might get more because of doubling. So let's
         * look for 50% here.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bucket_bytes</name> <operator>&lt;=</operator> <name>hash_table_bytes</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Calculate required number of batches. */</comment>
        <expr_stmt><expr><name>dbatch</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>inner_rel_bytes</name> <operator>/</operator> <operator>(</operator><name>hash_table_bytes</name> <operator>-</operator> <name>bucket_bytes</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dbatch</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>dbatch</name></expr></argument>, <argument><expr><name>max_pointers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>minbatch</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>dbatch</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nbatch</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>nbatch</name> <operator>&lt;</operator> <name>minbatch</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>nbatch</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nbuckets</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nbatch</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>numbuckets</name> <operator>=</operator> <name>nbuckets</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>numbatches</name> <operator>=</operator> <name>nbatch</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *        ExecHashTableDestroy
 *
 *        destroy a hash table
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecHashTableDestroy</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Make sure all the temp files are closed.  We skip batch 0, since it
     * can't have any temp files (and the arrays might not even exist if
     * nbatch is only 1).
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Release working memory (batchCxt is a child, so it goes away too) */</comment>
    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* And drop the control block */</comment>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHashIncreaseNumBatches
 *        increase the original number of batches in order to reduce
 *        current memory consumption
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecHashIncreaseNumBatches</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>oldnbatch</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>curbatch</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nbatch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>ninmemory</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>nfreed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashMemoryChunk</name></type> <name>oldchunks</name></decl>;</decl_stmt>

    <comment type="block">/* do nothing if we've decided to shut off growth */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>hashtable</name><operator>-&gt;</operator><name>growEnabled</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* safety check to avoid overflow */</comment>
    <if_stmt><if>if <condition>(<expr><name>oldnbatch</name> <operator>&gt;</operator> <call><name>Min</name><argument_list>(<argument><expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>MaxAllocSize</name> <operator>/</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>nbatch</name> <operator>=</operator> <name>oldnbatch</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nbatch</name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HJDEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Hashjoin %p: increasing nbatch to %d because space = %zu\n"</literal></expr></argument>,
           <argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>nbatch</name></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* we had no file arrays before */</comment>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name></name> <operator>=</operator> <operator>(</operator><name>BufFile</name> <operator>*</operator><operator>*</operator><operator>)</operator>
            <call><name>palloc0</name><argument_list>(<argument><expr><name>nbatch</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BufFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name></name> <operator>=</operator> <operator>(</operator><name>BufFile</name> <operator>*</operator><operator>*</operator><operator>)</operator>
            <call><name>palloc0</name><argument_list>(<argument><expr><name>nbatch</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BufFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* time to establish the temp tablespaces, too */</comment>
        <expr_stmt><expr><call><name>PrepareTempTablespaces</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* enlarge arrays and zero out added entries */</comment>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name></name> <operator>=</operator> <operator>(</operator><name>BufFile</name> <operator>*</operator><operator>*</operator><operator>)</operator>
            <call><name>repalloc</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name></name></expr></argument>, <argument><expr><name>nbatch</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BufFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name></name> <operator>=</operator> <operator>(</operator><name>BufFile</name> <operator>*</operator><operator>*</operator><operator>)</operator>
            <call><name>repalloc</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name></name></expr></argument>, <argument><expr><name>nbatch</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BufFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name></name> <operator>+</operator> <name>oldnbatch</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
               <argument><expr><operator>(</operator><name>nbatch</name> <operator>-</operator> <name>oldnbatch</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BufFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name></name> <operator>+</operator> <name>oldnbatch</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
               <argument><expr><operator>(</operator><name>nbatch</name> <operator>-</operator> <name>oldnbatch</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BufFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>=</operator> <name>nbatch</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Scan through the existing hash table entries and dump out any that are
     * no longer of the current batch.
     */</comment>
    <expr_stmt><expr><name>ninmemory</name> <operator>=</operator> <name>nfreed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* If know we need to resize nbuckets, we can do it while rebatching. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>!=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* we never decrease the number of buckets */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets_optimal</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name></name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name></name></expr></argument>,
                                      <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We will scan through the chunks directly, so that we can reset the
     * buckets now and not have to keep track which tuples in the buckets have
     * already been processed. We will free the old chunks as we go.
     */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldchunks</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* so, let's scan through the old chunks, and all tuples in each chunk */</comment>
    <while>while <condition>(<expr><name>oldchunks</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HashMemoryChunk</name></type> <name>nextchunk</name> <init>= <expr><name><name>oldchunks</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* position within the buffer (up to oldchunks-&gt;used) */</comment>
        <decl_stmt><decl><type><name>size_t</name></type>        <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* process all tuples stored in this chunk (and then free it) */</comment>
        <while>while <condition>(<expr><name>idx</name> <operator>&lt;</operator> <name><name>oldchunks</name><operator>-&gt;</operator><name>used</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>hashTuple</name> <init>= <expr><operator>(</operator><name>HashJoinTuple</name><operator>)</operator> <operator>(</operator><name><name>oldchunks</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>idx</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name> <init>= <expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>hashTupleSize</name> <init>= <expr><operator>(</operator><name>HJTUPLE_OVERHEAD</name> <operator>+</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>bucketno</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>batchno</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>ninmemory</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExecHashGetBucketAndBatch</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>hashvalue</name></name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name>bucketno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>batchno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>batchno</name> <operator>==</operator> <name>curbatch</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* keep tuple in memory - copy it into the new chunk */</comment>
                <decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>copyTuple</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>copyTuple</name> <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name><operator>)</operator> <call><name>dense_alloc</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>hashTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>, <argument><expr><name>hashTuple</name></expr></argument>, <argument><expr><name>hashTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* and add it back to the appropriate bucket */</comment>
                <expr_stmt><expr><name><name>copyTuple</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><index>[<expr><name>bucketno</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><index>[<expr><name>bucketno</name></expr>]</index></name> <operator>=</operator> <name>copyTuple</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* dump it out */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>batchno</name> <operator>&gt;</operator> <name>curbatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExecHashJoinSaveTuple</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>hashvalue</name></name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>batchno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>-=</operator> <name>hashTupleSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nfreed</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* next tuple in this chunk */</comment>
            <expr_stmt><expr><name>idx</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>hashTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* allow this loop to be cancellable */</comment>
            <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <comment type="block">/* we're done with this chunk - free it and proceed to the next one */</comment>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oldchunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>oldchunks</name> <operator>=</operator> <name>nextchunk</name></expr>;</expr_stmt>
    </block_content>}</block></while>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HJDEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Hashjoin %p: freed %ld of %ld tuples, space now %zu\n"</literal></expr></argument>,
           <argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>nfreed</name></expr></argument>, <argument><expr><name>ninmemory</name></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If we dumped out either all or none of the tuples in the table, disable
     * further expansion of nbatch.  This situation implies that we have
     * enough tuples of identical hashvalues to overflow spaceAllowed.
     * Increasing nbatch will not fix it since there's no way to subdivide the
     * group any more finely. We have to just gut it out and hope the server
     * has enough RAM.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>nfreed</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>nfreed</name> <operator>==</operator> <name>ninmemory</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>growEnabled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HJDEBUG</name></cpp:ifdef>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Hashjoin %p: disabling further increase of nbatch\n"</literal></expr></argument>,
               <argument><expr><name>hashtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHashIncreaseNumBuckets
 *        increase the original number of buckets in order to reduce
 *        number of tuples per bucket
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecHashIncreaseNumBuckets</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HashMemoryChunk</name></type> <name>chunk</name></decl>;</decl_stmt>

    <comment type="block">/* do nothing if not an increase (it's called increase for a reason) */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>&gt;=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HJDEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Hashjoin %p: increasing nbuckets %d =&gt; %d\n"</literal></expr></argument>,
           <argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets_optimal</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>&lt;=</operator> <operator>(</operator><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>==</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Just reallocate the proper number of buckets - we don't need to walk
     * through them - we can walk the dense-allocated chunks (just like in
     * ExecHashIncreaseNumBatches, but without all the copying into new
     * chunks)
     */</comment>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name></name> <operator>=</operator>
        <operator>(</operator><name>HashJoinTuple</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name></name></expr></argument>,
                                   <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* scan through all tuples in all chunks to rebuild the hash table */</comment>
    <for>for <control>(<init><expr><name>chunk</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name></expr>;</init> <condition><expr><name>chunk</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>chunk</name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* process all tuples stored in this chunk */</comment>
        <decl_stmt><decl><type><name>size_t</name></type>        <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><name>idx</name> <operator>&lt;</operator> <name><name>chunk</name><operator>-&gt;</operator><name>used</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>hashTuple</name> <init>= <expr><operator>(</operator><name>HashJoinTuple</name><operator>)</operator> <operator>(</operator><name><name>chunk</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>idx</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>bucketno</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>batchno</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>ExecHashGetBucketAndBatch</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>hashvalue</name></name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name>bucketno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>batchno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* add the tuple to the proper bucket */</comment>
            <expr_stmt><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><index>[<expr><name>bucketno</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><index>[<expr><name>bucketno</name></expr>]</index></name> <operator>=</operator> <name>hashTuple</name></expr>;</expr_stmt>

            <comment type="block">/* advance index past the tuple */</comment>
            <expr_stmt><expr><name>idx</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>HJTUPLE_OVERHEAD</name> <operator>+</operator>
                            <call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <comment type="block">/* allow this loop to be cancellable */</comment>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * ExecHashTableInsert
 *        insert a tuple into the hash table depending on the hash value
 *        it may just go to a temp file for later batches
 *
 * Note: the passed TupleTableSlot may contain a regular, minimal, or virtual
 * tuple; the minimal case in particular is certain to happen while reloading
 * tuples from batch files.  We could save some cycles in the regular-tuple
 * case by not forcing the slot contents into minimal form; not clear if it's
 * worth the messiness required.
 */</comment>
<function><type><name>void</name></type>
<name>ExecHashTableInsert</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>,
                    <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
                    <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ExecFetchSlotMinimalTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>bucketno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>batchno</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ExecHashGetBucketAndBatch</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>bucketno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>batchno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * decide whether to put the tuple in the hash table or a temp file
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>batchno</name> <operator>==</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * put the tuple in hash table
         */</comment>
        <decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>hashTuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>hashTupleSize</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type>        <name>ntuples</name> <init>= <expr><operator>(</operator><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>-</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>skewTuples</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Create the HashJoinTuple */</comment>
        <expr_stmt><expr><name>hashTupleSize</name> <operator>=</operator> <name>HJTUPLE_OVERHEAD</name> <operator>+</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name><operator>)</operator> <call><name>dense_alloc</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>hashTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>hashvalue</name></name> <operator>=</operator> <name>hashvalue</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We always reset the tuple-matched flag on insertion.  This is okay
         * even when reloading a tuple from a batch file, since the tuple
         * could not possibly have been matched to an outer tuple before it
         * went into the batch file.
         */</comment>
        <expr_stmt><expr><call><name>HeapTupleHeaderClearMatch</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Push it onto the front of the bucket's list */</comment>
        <expr_stmt><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><index>[<expr><name>bucketno</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><index>[<expr><name>bucketno</name></expr>]</index></name> <operator>=</operator> <name>hashTuple</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Increase the (optimal) number of buckets if we just exceeded the
         * NTUP_PER_BUCKET threshold, but only when there's still a single
         * batch.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
            <name>ntuples</name> <operator>&gt;</operator> <operator>(</operator><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>*</operator> <name>NTUP_PER_BUCKET</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Guard against integer overflow and alloc size overflow */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>&lt;=</operator> <name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
                <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>&lt;=</operator> <name>MaxAllocSize</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets_optimal</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Account for space used, and back off if we've used too much */</comment>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>+=</operator> <name>hashTupleSize</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>+</operator>
            <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof>
            <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spaceAllowed</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ExecHashIncreaseNumBatches</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * put the tuple into a temp file for later batches
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>batchno</name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExecHashJoinSaveTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
                              <argument><expr><name>hashvalue</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>batchno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHashGetHashValue
 *        Compute the hash value for a tuple
 *
 * The tuple to be tested must be in either econtext-&gt;ecxt_outertuple or
 * econtext-&gt;ecxt_innertuple.  Vars in the hashkeys expressions should have
 * varno either OUTER_VAR or INNER_VAR.
 *
 * A TRUE result means the tuple's hash value has been successfully computed
 * and stored at *hashvalue.  A FALSE result means the tuple cannot match
 * because it contains a null attribute, and hence it should be discarded
 * immediately.  (If keep_nulls is true then FALSE is never returned.)
 */</comment>
<function><type><name>bool</name></type>
<name>ExecHashGetHashValue</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>,
                     <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
                     <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashkeys</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name></type> <name>outer_tuple</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name></type> <name>keep_nulls</name></decl></parameter>,
                     <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>hashvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>hashkey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>hashfunctions</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>hk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We reset the eval context each time to reclaim any memory leaked in the
     * hashkey expressions.
     */</comment>
    <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>outer_tuple</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>hashfunctions</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>outer_hashfunctions</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>hashfunctions</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>inner_hashfunctions</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>hk</argument>, <argument>hashkeys</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>keyexpr</name> <init>= <expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>keyval</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isNull</name></decl>;</decl_stmt>

        <comment type="block">/* rotate hashkey left 1 bit at each step */</comment>
        <expr_stmt><expr><name>hashkey</name> <operator>=</operator> <operator>(</operator><name>hashkey</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>hashkey</name> <operator>&amp;</operator> <literal type="number">0x80000000</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

        <comment type="block">/*
         * Get the join attribute value of the tuple
         */</comment>
        <expr_stmt><expr><name>keyval</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name>keyexpr</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If the attribute is NULL, and the join operator is strict, then
         * this tuple cannot pass the join qual so we can reject it
         * immediately (unless we're scanning the outside of an outer join, in
         * which case we must not reject it).  Otherwise we act like the
         * hashcode of NULL is zero (this will support operators that act like
         * IS NOT DISTINCT, though not any more-random behavior).  We treat
         * the hash support function as strict even if the operator is not.
         *
         * Note: currently, all hashjoinable operators must be strict since
         * the hash index AM assumes that.  However, it takes so little extra
         * code here to allow non-strict that we may as well do it.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashStrict</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>keep_nulls</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>false</name></expr>;</return>    <comment type="block">/* cannot match */</comment>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* else, leave hashkey unmodified, equivalent to hashcode 0 */</comment>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Compute the hash function */</comment>
            <decl_stmt><decl><type><name>uint32</name></type>        <name>hkey</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>hkey</name> <operator>=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>FunctionCall1</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hashfunctions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>keyval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>hashkey</name> <operator>^=</operator> <name>hkey</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>hashvalue</name> <operator>=</operator> <name>hashkey</name></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHashGetBucketAndBatch
 *        Determine the bucket number and batch number for a hash value
 *
 * Note: on-the-fly increases of nbatch must not change the bucket number
 * for a given hash code (since we don't move tuples to different hash
 * chains), and must only cause the batch number to remain the same or
 * increase.  Our algorithm is
 *        bucketno = hashvalue MOD nbuckets
 *        batchno = (hashvalue DIV nbuckets) MOD nbatch
 * where nbuckets and nbatch are both expected to be powers of 2, so we can
 * do the computations by shifting and masking.  (This assumes that all hash
 * functions are good about randomizing all their output bits, else we are
 * likely to have very skewed bucket or batch occupancy.)
 *
 * nbuckets and log2_nbuckets may change while nbatch == 1 because of dynamic
 * bucket count growth.  Once we start batching, the value is fixed and does
 * not change over the course of the join (making it possible to compute batch
 * number the way we do here).
 *
 * nbatch is always a power of 2; we increase it only by doubling it.  This
 * effectively adds one more bit to the top of the batchno.
 */</comment>
<function><type><name>void</name></type>
<name>ExecHashGetBucketAndBatch</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>,
                          <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>,
                          <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>bucketno</name></decl></parameter>,
                          <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>batchno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>nbuckets</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>nbatch</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>nbatch</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* we can do MOD by masking, DIV by shifting */</comment>
        <expr_stmt><expr><operator>*</operator><name>bucketno</name> <operator>=</operator> <name>hashvalue</name> <operator>&amp;</operator> <operator>(</operator><name>nbuckets</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>batchno</name> <operator>=</operator> <operator>(</operator><name>hashvalue</name> <operator>&gt;&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets</name></name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>nbatch</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>bucketno</name> <operator>=</operator> <name>hashvalue</name> <operator>&amp;</operator> <operator>(</operator><name>nbuckets</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>batchno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecScanHashBucket
 *        scan a hash bucket for matches to the current outer tuple
 *
 * The current outer tuple must be stored in econtext-&gt;ecxt_outertuple.
 *
 * On success, the inner tuple is stored into hjstate-&gt;hj_CurTuple and
 * econtext-&gt;ecxt_innertuple, using hjstate-&gt;hj_HashTupleSlot as the slot
 * for the latter.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecScanHashBucket</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl></parameter>,
                   <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>hjclauses</name> <init>= <expr><name><name>hjstate</name><operator>-&gt;</operator><name>hashclauses</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name> <init>= <expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>hashTuple</name> <init>= <expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurTuple</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>hashvalue</name> <init>= <expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurHashValue</name></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>HashState</name>  <modifier>*</modifier></type><name>hashNode</name> <init>= <expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * hj_CurTuple is the address of the tuple last returned from the current
     * bucket, or NULL if it's time to start scanning a new bucket.
     *
     * If the tuple hashed to a skew bucket then scan the skew bucket
     * otherwise scan the standard hashtable bucket.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>hashNode</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>dsa</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        
        <if_stmt><if>if <condition>(<expr><name>hashTuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>dsa</name> <operator>=</operator> <call><name>GetNumWorkerDsa</name><argument_list>(<argument><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>workerNumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><operator>(</operator><name>dsa_pointer</name><operator>)</operator><name><name>hashTuple</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurSkewBucketNo</name></name> <operator>!=</operator> <name>INVALID_SKEW_BUCKET_NO</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name><index>[<expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurSkewBucketNo</name></name></expr>]</index></name><operator>-&gt;</operator><name>tuples</name></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>dsa</name> <operator>=</operator> <call><name>GetNumWorkerDsa</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>bucket_wNum</name><index>[<expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurBucketNo</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><operator>(</operator><name>dsa_pointer</name><operator>)</operator><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><index>[<expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurBucketNo</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <while>while <condition>(<expr><name>hashTuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>hashTuple</name><operator>-&gt;</operator><name>hashvalue</name></name> <operator>==</operator> <name>hashvalue</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>inntuple</name></decl>;</decl_stmt>

                <comment type="block">/* insert hashtable's tuple into exec slot so ExecQual sees it */</comment>
                <expr_stmt><expr><name>inntuple</name> <operator>=</operator> <call><name>ExecStoreMinimalTuple</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></argument>,
                                                 <argument><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTupleSlot</name></name></expr></argument>,
                                                 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* do not pfree */</comment>
                <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>inntuple</name></expr>;</expr_stmt>

                <comment type="block">/* reset temp memory each time to avoid leaks from qual expr */</comment>
                <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>ExecQual</name><argument_list>(<argument><expr><name>hjclauses</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurTuple</name></name> <operator>=</operator> <name>hashTuple</name></expr>;</expr_stmt>
                    <return>return <expr><name>true</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if<condition>(<expr><name><name>hashTuple</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>dsa</name> <operator>=</operator> <call><name>GetNumWorkerDsa</name><argument_list>(<argument><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>workerNumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><operator>(</operator><name>dsa_pointer</name><operator>)</operator><name><name>hashTuple</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>hashTuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <name><name>hashTuple</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurSkewBucketNo</name></name> <operator>!=</operator> <name>INVALID_SKEW_BUCKET_NO</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name><index>[<expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurSkewBucketNo</name></name></expr>]</index></name><operator>-&gt;</operator><name>tuples</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><index>[<expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurBucketNo</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <while>while <condition>(<expr><name>hashTuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>hashTuple</name><operator>-&gt;</operator><name>hashvalue</name></name> <operator>==</operator> <name>hashvalue</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>inntuple</name></decl>;</decl_stmt>

            <comment type="block">/* insert hashtable's tuple into exec slot so ExecQual sees it */</comment>
            <expr_stmt><expr><name>inntuple</name> <operator>=</operator> <call><name>ExecStoreMinimalTuple</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTupleSlot</name></name></expr></argument>,
                                             <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* do not pfree */</comment>
            <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>inntuple</name></expr>;</expr_stmt>

            <comment type="block">/* reset temp memory each time to avoid leaks from qual expr */</comment>
            <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>ExecQual</name><argument_list>(<argument><expr><name>hjclauses</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurTuple</name></name> <operator>=</operator> <name>hashTuple</name></expr>;</expr_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <name><name>hashTuple</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * no match
     */</comment>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecPrepHashTableForUnmatched
 *        set up for a series of ExecScanHashTableForUnmatched calls
 */</comment>
<function><type><name>void</name></type>
<name>ExecPrepHashTableForUnmatched</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*----------
     * During this scan we use the HashJoinState fields as follows:
     *
     * hj_CurBucketNo: next regular bucket to scan
     * hj_CurSkewBucketNo: next skew bucket (an index into skewBucketNums)
     * hj_CurTuple: last tuple returned, or NULL to start next bucket
     *----------
     */</comment>
    <expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurBucketNo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurSkewBucketNo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecScanHashTableForUnmatched
 *        scan the hash table for unmatched inner tuples
 *
 * On success, the inner tuple is stored into hjstate-&gt;hj_CurTuple and
 * econtext-&gt;ecxt_innertuple, using hjstate-&gt;hj_HashTupleSlot as the slot
 * for the latter.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecScanHashTableForUnmatched</name><parameter_list>(<parameter><decl><type><name>HashJoinState</name> <modifier>*</modifier></type><name>hjstate</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name> <init>= <expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTable</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>hashTuple</name> <init>= <expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurTuple</name></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>HashState</name>  <modifier>*</modifier></type><name>hashNode</name> <init>= <expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>hjstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
     <comment type="block">/* 
      * parallel right/full join 
      */</comment>
    <if_stmt><if>if<condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>hjstate</name><operator>-&gt;</operator><name>hj_parallelState</name></name> <operator>&amp;&amp;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <name><name>hashNode</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>ParallelWorkerNumber</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>dsa</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        
            <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>hashTuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>dsa</name> <operator>=</operator> <call><name>GetNumWorkerDsa</name><argument_list>(<argument><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>workerNumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><operator>(</operator><name>dsa_pointer</name><operator>)</operator><name><name>hashTuple</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurBucketNo</name></name> <operator>&lt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>dsa</name> <operator>=</operator> <call><name>GetNumWorkerDsa</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>bucket_wNum</name><index>[<expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurBucketNo</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><operator>(</operator><name>dsa_pointer</name><operator>)</operator><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><index>[<expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurBucketNo</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                    <expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurBucketNo</name></name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="block">/* no skewbuckets */</comment>
                <if type="elseif">else if <condition>(<expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurSkewBucketNo</name></name> <operator>&lt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nSkewBuckets</name></name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type>            <name>j</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucketNums</name><index>[<expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurSkewBucketNo</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>tuples</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurSkewBucketNo</name></name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></else></if_stmt>                <comment type="block">/* finished all buckets */</comment>

                <while>while <condition>(<expr><name>hashTuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleHeaderHasMatch</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>inntuple</name></decl>;</decl_stmt>

                        <comment type="block">/* insert hashtable's tuple into exec slot */</comment>
                        <expr_stmt><expr><name>inntuple</name> <operator>=</operator> <call><name>ExecStoreMinimalTuple</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></argument>,
                                                         <argument><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTupleSlot</name></name></expr></argument>,
                                                         <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* do not pfree */</comment>
                        <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>inntuple</name></expr>;</expr_stmt>

                        <comment type="block">/*
                         * Reset temp memory each time; although this function doesn't
                         * do any qual eval, the caller will, so let's keep it
                         * parallel to ExecScanHashBucket.
                         */</comment>
                        <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurTuple</name></name> <operator>=</operator> <name>hashTuple</name></expr>;</expr_stmt>
                        <return>return <expr><name>true</name></expr>;</return>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if<condition>(<expr><name><name>hashTuple</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>dsa</name> <operator>=</operator> <call><name>GetNumWorkerDsa</name><argument_list>(<argument><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>workerNumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><operator>(</operator><name>dsa_pointer</name><operator>)</operator><name><name>hashTuple</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></while>
            </block_content>}</block></for>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * hj_CurTuple is the address of the tuple last returned from the
         * current bucket, or NULL if it's time to start scanning a new
         * bucket.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>hashTuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <name><name>hashTuple</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurBucketNo</name></name> <operator>&lt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><index>[<expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurBucketNo</name></name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurBucketNo</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurSkewBucketNo</name></name> <operator>&lt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nSkewBuckets</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>j</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucketNums</name><index>[<expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurSkewBucketNo</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>tuples</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurSkewBucketNo</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <break>break;</break></block_content></block></else></if_stmt>                <comment type="block">/* finished all buckets */</comment>

        <while>while <condition>(<expr><name>hashTuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleHeaderHasMatch</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>inntuple</name></decl>;</decl_stmt>

                <comment type="block">/* insert hashtable's tuple into exec slot */</comment>
                <expr_stmt><expr><name>inntuple</name> <operator>=</operator> <call><name>ExecStoreMinimalTuple</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></argument>,
                                                 <argument><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_HashTupleSlot</name></name></expr></argument>,
                                                 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* do not pfree */</comment>
                <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>inntuple</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Reset temp memory each time; although this function doesn't
                 * do any qual eval, the caller will, so let's keep it
                 * parallel to ExecScanHashBucket.
                 */</comment>
                <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>hjstate</name><operator>-&gt;</operator><name>hj_CurTuple</name></name> <operator>=</operator> <name>hashTuple</name></expr>;</expr_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <name><name>hashTuple</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></for>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * no more unmatched tuples
     */</comment>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHashTableReset
 *
 *        reset hash table header for new batch
 */</comment>
<function><type><name>void</name></type>
<name>ExecHashTableReset</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nbuckets</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Release all the hash buckets and tuples acquired in the prior pass, and
     * reinitialize the context for a new pass.
     */</comment>
    <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batchCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batchCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reallocate and reinitialize the hash bucket headers. */</comment>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name></name> <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name> <operator>*</operator><operator>)</operator>
        <call><name>palloc0</name><argument_list>(<argument><expr><name>nbuckets</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Forget the chunks (the memory was freed by the context reset above). */</comment>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHashTableResetMatchFlags
 *        Clear all the HeapTupleHeaderHasMatch flags in the table
 */</comment>
<function><type><name>void</name></type>
<name>ExecHashTableResetMatchFlags</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Reset all flags in the main table ... */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>tuple</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>tuple</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>tuple</name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>HeapTupleHeaderClearMatch</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></for>

    <comment type="block">/* ... and the same for the skew buckets, if any */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nSkewBuckets</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>j</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucketNums</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HashSkewBucket</name> <modifier>*</modifier></type><name>skewBucket</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>tuple</name> <operator>=</operator> <name><name>skewBucket</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</init> <condition><expr><name>tuple</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>tuple</name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>HeapTupleHeaderClearMatch</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></for>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>ExecReScanHash</name><parameter_list>(<parameter><decl><type><name>HashState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * if chgParam of subnode is not null then plan will be re-scanned by
     * first ExecProcNode.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>lefttree</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExecHashBuildSkewHash
 *
 *        Set up for skew optimization if we can identify the most common values
 *        (MCVs) of the outer relation's join key.  We make a skew hash bucket
 *        for the hash value of each MCV, up to the number of slots allowed
 *        based on available memory.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecHashBuildSkewHash</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>, <parameter><decl><type><name>Hash</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mcvsToUse</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HeapTupleData</name> <modifier>*</modifier></type><name>statsTuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>sslot</name></decl>;</decl_stmt>

    <comment type="block">/* Do nothing if planner didn't identify the outer relation's join key */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>skewTable</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Also, do nothing if we don't have room for at least one skew bucket */</comment>
    <if_stmt><if>if <condition>(<expr><name>mcvsToUse</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Try to find the MCV statistics for the outer relation's join key.
     */</comment>
    <expr_stmt><expr><name>statsTuple</name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>STATRELATTINH</name></expr></argument>,
                                 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>skewTable</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>skewColumn</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>skewInherit</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>statsTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>, <argument><expr><name>statsTuple</name></expr></argument>,
                         <argument><expr><name>STATISTIC_KIND_MCV</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                         <argument><expr><name>ATTSTATSSLOT_VALUES</name> <operator>|</operator> <name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>double</name></type>        <name>frac</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>nbuckets</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>hashfunctions</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>mcvsToUse</name> <operator>&gt;</operator> <name><name>sslot</name><operator>.</operator><name>nvalues</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>mcvsToUse</name> <operator>=</operator> <name><name>sslot</name><operator>.</operator><name>nvalues</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Calculate the expected fraction of outer relation that will
         * participate in the skew optimization.  If this isn't at least
         * SKEW_MIN_OUTER_FRACTION, don't use skew optimization.
         */</comment>
        <expr_stmt><expr><name>frac</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>mcvsToUse</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name>frac</name> <operator>+=</operator> <name><name>sslot</name><operator>.</operator><name>numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
        <if_stmt><if>if <condition>(<expr><name>frac</name> <operator>&lt;</operator> <name>SKEW_MIN_OUTER_FRACTION</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>statsTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Okay, set up the skew hashtable.
         *
         * skewBucket[] is an open addressing hashtable with a power of 2 size
         * that is greater than the number of MCV values.  (This ensures there
         * will be at least one null entry, so searches will always
         * terminate.)
         *
         * Note: this code could fail if mcvsToUse exceeds INT_MAX/8 or
         * MaxAllocSize/sizeof(void *)/8, but that is not currently possible
         * since we limit pg_statistic entries to much less than that.
         */</comment>
        <expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>nbuckets</name> <operator>&lt;=</operator> <name>mcvsToUse</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>nbuckets</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>
        <comment type="block">/* use two more bits just to help avoid collisions */</comment>
        <expr_stmt><expr><name>nbuckets</name> <operator>&lt;&lt;=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewEnabled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucketLen</name></name> <operator>=</operator> <name>nbuckets</name></expr>;</expr_stmt>

        <comment type="block">/*
         * We allocate the bucket memory in the hashtable's batch context. It
         * is only needed during the first batch, and this ensures it will be
         * automatically removed once the first batch is done.
         */</comment>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name></name> <operator>=</operator> <operator>(</operator><name>HashSkewBucket</name> <operator>*</operator><operator>*</operator><operator>)</operator>
            <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batchCxt</name></name></expr></argument>,
                                   <argument><expr><name>nbuckets</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashSkewBucket</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucketNums</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator>
            <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batchCxt</name></name></expr></argument>,
                                   <argument><expr><name>mcvsToUse</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>+=</operator> <name>nbuckets</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashSkewBucket</name> <operator>*</operator></expr></argument>)</argument_list></sizeof>
            <operator>+</operator> <name>mcvsToUse</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsedSkew</name></name> <operator>+=</operator> <name>nbuckets</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashSkewBucket</name> <operator>*</operator></expr></argument>)</argument_list></sizeof>
            <operator>+</operator> <name>mcvsToUse</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Create a skew bucket for each MCV hash value.
         *
         * Note: it is very important that we create the buckets in order of
         * decreasing MCV frequency.  If we have to remove some buckets, they
         * must be removed in reverse order of creation (see notes in
         * ExecHashRemoveNextSkewBucket) and we want the least common MCVs to
         * be removed first.
         */</comment>
        <expr_stmt><expr><name>hashfunctions</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>outer_hashfunctions</name></name></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>mcvsToUse</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>uint32</name></type>        <name>hashvalue</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>bucket</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>hashvalue</name> <operator>=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>FunctionCall1</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hashfunctions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                                                     <argument><expr><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * While we have not hit a hole in the hashtable and have not hit
             * the desired bucket, we have collided with some previous hash
             * value, so try the next bucket location.  NB: this code must
             * match ExecHashGetSkewBucket.
             */</comment>
            <expr_stmt><expr><name>bucket</name> <operator>=</operator> <name>hashvalue</name> <operator>&amp;</operator> <operator>(</operator><name>nbuckets</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
            <while>while <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name><index>[<expr><name>bucket</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                   <name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name><index>[<expr><name>bucket</name></expr>]</index></name><operator>-&gt;</operator><name>hashvalue</name> <operator>!=</operator> <name>hashvalue</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>bucket</name> <operator>=</operator> <operator>(</operator><name>bucket</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>nbuckets</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></while>

            <comment type="block">/*
             * If we found an existing bucket with the same hashvalue, leave
             * it alone.  It's okay for two MCVs to share a hashvalue.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name><index>[<expr><name>bucket</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/* Okay, create a new skew bucket for this hashvalue. */</comment>
            <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name><index>[<expr><name>bucket</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>HashSkewBucket</name> <operator>*</operator><operator>)</operator>
                <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batchCxt</name></name></expr></argument>,
                                   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HashSkewBucket</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name><index>[<expr><name>bucket</name></expr>]</index></name><operator>-&gt;</operator><name>hashvalue</name> <operator>=</operator> <name>hashvalue</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name><index>[<expr><name>bucket</name></expr>]</index></name><operator>-&gt;</operator><name>tuples</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucketNums</name><index>[<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nSkewBuckets</name></name></expr>]</index></name> <operator>=</operator> <name>bucket</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nSkewBuckets</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>+=</operator> <name>SKEW_BUCKET_OVERHEAD</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsedSkew</name></name> <operator>+=</operator> <name>SKEW_BUCKET_OVERHEAD</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>statsTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHashGetSkewBucket
 *
 *        Returns the index of the skew bucket for this hashvalue,
 *        or INVALID_SKEW_BUCKET_NO if the hashvalue is not
 *        associated with any active skew bucket.
 */</comment>
<function><type><name>int</name></type>
<name>ExecHashGetSkewBucket</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>bucket</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Always return INVALID_SKEW_BUCKET_NO if not doing skew optimization (in
     * particular, this happens after the initial batch is done).
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>hashtable</name><operator>-&gt;</operator><name>skewEnabled</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>INVALID_SKEW_BUCKET_NO</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Since skewBucketLen is a power of 2, we can do a modulo by ANDing.
     */</comment>
    <expr_stmt><expr><name>bucket</name> <operator>=</operator> <name>hashvalue</name> <operator>&amp;</operator> <operator>(</operator><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucketLen</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/*
     * While we have not hit a hole in the hashtable and have not hit the
     * desired bucket, we have collided with some other hash value, so try the
     * next bucket location.
     */</comment>
    <while>while <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name><index>[<expr><name>bucket</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
           <name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name><index>[<expr><name>bucket</name></expr>]</index></name><operator>-&gt;</operator><name>hashvalue</name> <operator>!=</operator> <name>hashvalue</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>bucket</name> <operator>=</operator> <operator>(</operator><name>bucket</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucketLen</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></while>

    <comment type="block">/*
     * Found the desired bucket?
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name><index>[<expr><name>bucket</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>bucket</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * There must not be any hashtable entry for this hash value.
     */</comment>
    <return>return <expr><name>INVALID_SKEW_BUCKET_NO</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHashSkewTableInsert
 *
 *        Insert a tuple into the skew hashtable.
 *
 * This should generally match up with the current-batch case in
 * ExecHashTableInsert.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecHashSkewTableInsert</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>,
                        <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
                        <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>,
                        <parameter><decl><type><name>int</name></type> <name>bucketNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ExecFetchSlotMinimalTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>hashTuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>hashTupleSize</name></decl>;</decl_stmt>

    <comment type="block">/* Create the HashJoinTuple */</comment>
    <expr_stmt><expr><name>hashTupleSize</name> <operator>=</operator> <name>HJTUPLE_OVERHEAD</name> <operator>+</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batchCxt</name></name></expr></argument>,
                                                   <argument><expr><name>hashTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>hashvalue</name></name> <operator>=</operator> <name>hashvalue</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HeapTupleHeaderClearMatch</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Push it onto the front of the skew bucket's list */</comment>
    <expr_stmt><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name><index>[<expr><name>bucketNumber</name></expr>]</index></name><operator>-&gt;</operator><name>tuples</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name><index>[<expr><name>bucketNumber</name></expr>]</index></name><operator>-&gt;</operator><name>tuples</name> <operator>=</operator> <name>hashTuple</name></expr>;</expr_stmt>

    <comment type="block">/* Account for space used, and back off if we've used too much */</comment>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>+=</operator> <name>hashTupleSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsedSkew</name></name> <operator>+=</operator> <name>hashTupleSize</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <while>while <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsedSkew</name></name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spaceAllowedSkew</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecHashRemoveNextSkewBucket</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

    <comment type="block">/* Check we are not over the total spaceAllowed, either */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spaceAllowed</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecHashIncreaseNumBatches</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        ExecHashRemoveNextSkewBucket
 *
 *        Remove the least valuable skew bucket by pushing its tuples into
 *        the main hash table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecHashRemoveNextSkewBucket</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>bucketToRemove</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashSkewBucket</name> <modifier>*</modifier></type><name>bucket</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>hashvalue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>bucketno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>batchno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>hashTuple</name></decl>;</decl_stmt>

    <comment type="block">/* Locate the bucket to remove */</comment>
    <expr_stmt><expr><name>bucketToRemove</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>skewBucketNums</name><index>[<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nSkewBuckets</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bucket</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name><index>[<expr><name>bucketToRemove</name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Calculate which bucket and batch the tuples belong to in the main
     * hashtable.  They all have the same hash value, so it's the same for all
     * of them.  Also note that it's not possible for nbatch to increase while
     * we are processing the tuples.
     */</comment>
    <expr_stmt><expr><name>hashvalue</name> <operator>=</operator> <name><name>bucket</name><operator>-&gt;</operator><name>hashvalue</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecHashGetBucketAndBatch</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bucketno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>batchno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Process all tuples in the bucket */</comment>
    <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <name><name>bucket</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>hashTuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>nextHashTuple</name> <init>= <expr><name><name>hashTuple</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Size</name></type>        <name>tupleSize</name></decl>;</decl_stmt>

        <comment type="block">/*
         * This code must agree with ExecHashTableInsert.  We do not use
         * ExecHashTableInsert directly as ExecHashTableInsert expects a
         * TupleTableSlot while we already have HashJoinTuples.
         */</comment>
        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tupleSize</name> <operator>=</operator> <name>HJTUPLE_OVERHEAD</name> <operator>+</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>

        <comment type="block">/* Decide whether to put the tuple in the hash table or a temp file */</comment>
        <if_stmt><if>if <condition>(<expr><name>batchno</name> <operator>==</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Move the tuple to the main hash table */</comment>
            <decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>copyTuple</name></decl>;</decl_stmt>

            <comment type="block">/*
             * We must copy the tuple into the dense storage, else it will not
             * be found by, eg, ExecHashIncreaseNumBatches.
             */</comment>
            <expr_stmt><expr><name>copyTuple</name> <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name><operator>)</operator> <call><name>dense_alloc</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>tupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>, <argument><expr><name>hashTuple</name></expr></argument>, <argument><expr><name>tupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>copyTuple</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><index>[<expr><name>bucketno</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><index>[<expr><name>bucketno</name></expr>]</index></name> <operator>=</operator> <name>copyTuple</name></expr>;</expr_stmt>

            <comment type="block">/* We have reduced skew space, but overall space doesn't change */</comment>
            <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsedSkew</name></name> <operator>-=</operator> <name>tupleSize</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Put the tuple into a temp file for later batches */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>batchno</name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExecHashJoinSaveTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>batchno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>-=</operator> <name>tupleSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsedSkew</name></name> <operator>-=</operator> <name>tupleSize</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <name>nextHashTuple</name></expr>;</expr_stmt>

        <comment type="block">/* allow this loop to be cancellable */</comment>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * Free the bucket struct itself and reset the hashtable entry to NULL.
     *
     * NOTE: this is not nearly as simple as it looks on the surface, because
     * of the possibility of collisions in the hashtable.  Suppose that hash
     * values A and B collide at a particular hashtable entry, and that A was
     * entered first so B gets shifted to a different table entry.  If we were
     * to remove A first then ExecHashGetSkewBucket would mistakenly start
     * reporting that B is not in the hashtable, because it would hit the NULL
     * before finding B.  However, we always remove entries in the reverse
     * order of creation, so this failure cannot happen.
     */</comment>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name><index>[<expr><name>bucketToRemove</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nSkewBuckets</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>-=</operator> <name>SKEW_BUCKET_OVERHEAD</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsedSkew</name></name> <operator>-=</operator> <name>SKEW_BUCKET_OVERHEAD</name></expr>;</expr_stmt>

    <comment type="block">/*
     * If we have removed all skew buckets then give up on skew optimization.
     * Release the arrays since they aren't useful any more.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nSkewBuckets</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewEnabled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucketNums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucketNums</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>-=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsedSkew</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsedSkew</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reserve space in the DSM segment for instrumentation data.
 */</comment>
<function><type><name>void</name></type>
<name>ExecHashEstimate</name><parameter_list>(<parameter><decl><type><name>HashState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>size</name></decl>;</decl_stmt>

	<comment type="block">/* don't need this if not instrumenting or no workers */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>instrument</name></name> <operator>||</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HashInstrumentation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>SharedHashInfo</name></expr></argument>, <argument><expr><name>hinstrument</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set up a space in the DSM for all workers to record instrumentation data
 * about their hash table.
 */</comment>
<function><type><name>void</name></type>
<name>ExecHashInitializeDSM</name><parameter_list>(<parameter><decl><type><name>HashState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>size</name></decl>;</decl_stmt>

	<comment type="block">/* don't need this if not instrumenting or no workers */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>instrument</name></name> <operator>||</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>SharedHashInfo</name></expr></argument>, <argument><expr><name>hinstrument</name></expr></argument>)</argument_list></call> <operator>+</operator>
		<name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashInstrumentation</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>shared_info</name></name> <operator>=</operator> <operator>(</operator><name>SharedHashInfo</name> <operator>*</operator><operator>)</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>shared_info</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>shared_info</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>,
				   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>shared_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reset shared state before beginning a fresh scan.
 */</comment>
<function><type><name>void</name></type>
<name>ExecHashReInitializeDSM</name><parameter_list>(<parameter><decl><type><name>HashState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>shared_info</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>shared_info</name><operator>-&gt;</operator><name>hinstrument</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>shared_info</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashInstrumentation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Locate the DSM space for hash table instrumentation data that we'll write
 * to at shutdown time.
 */</comment>
<function><type><name>void</name></type>
<name>ExecHashInitializeWorker</name><parameter_list>(<parameter><decl><type><name>HashState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParallelWorkerContext</name> <modifier>*</modifier></type><name>pwcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SharedHashInfo</name> <modifier>*</modifier></type><name>shared_info</name></decl>;</decl_stmt>

	<comment type="block">/* don't need this if not instrumenting */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	
	<expr_stmt><expr><name>shared_info</name> <operator>=</operator> <operator>(</operator><name>SharedHashInfo</name> <operator>*</operator><operator>)</operator>
		<call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name><name>pwcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hinstrument</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>shared_info</name><operator>-&gt;</operator><name>hinstrument</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<comment type="block">/* set node-&gt;shared_info for distributed instrument */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>shared_info</name></name> <operator>=</operator> <name>shared_info</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Copy instrumentation data from this worker's hash table (if it built one)
 * to DSM memory so the leader can retrieve it.  This must be done in an
 * ExecShutdownHash() rather than ExecEndHash() because the latter runs after
 * we've detached from the DSM segment.
 */</comment>
<function><type><name>void</name></type>
<name>ExecShutdownHash</name><parameter_list>(<parameter><decl><type><name>HashState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Now accumulate data for the current (final) hash table */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hinstrument</name></name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>hashtable</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecHashGetInstrumentation</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hinstrument</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Retrieve instrumentation data from workers before the DSM segment is
 * detached, so that EXPLAIN can access it.
 */</comment>
<function><type><name>void</name></type>
<name>ExecHashRetrieveInstrumentation</name><parameter_list>(<parameter><decl><type><name>HashState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SharedHashInfo</name> <modifier>*</modifier></type><name>shared_info</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>shared_info</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>size</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>shared_info</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	
	<comment type="block">/* Replace node-&gt;shared_info with a copy in backend-local memory. */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>SharedHashInfo</name></expr></argument>, <argument><expr><name>hinstrument</name></expr></argument>)</argument_list></call> <operator>+</operator>
		<name><name>shared_info</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashInstrumentation</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>shared_info</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>shared_info</name></name></expr></argument>, <argument><expr><name>shared_info</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Copy the instrumentation data from 'hashtable' into a HashInstrumentation
 * struct.
 */</comment>
<function><type><name>void</name></type>
<name>ExecHashGetInstrumentation</name><parameter_list>(<parameter><decl><type><name>HashInstrumentation</name> <modifier>*</modifier></type><name>instrument</name></decl></parameter>,
						   <parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>instrument</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>instrument</name><operator>-&gt;</operator><name>nbuckets_original</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_original</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>instrument</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>instrument</name><operator>-&gt;</operator><name>nbatch_original</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch_original</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>instrument</name><operator>-&gt;</operator><name>space_peak</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate 'size' bytes from the currently active HashMemoryChunk
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>dense_alloc</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HashMemoryChunk</name></type> <name>newChunk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

    <comment type="block">/* just in case the size is not already aligned properly */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If tuple size is larger than of 1/4 of chunk size, allocate a separate
     * chunk.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <name>HASH_CHUNK_THRESHOLD</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* allocate new chunk and put it at the beginning of the list */</comment>
        <expr_stmt><expr><name>newChunk</name> <operator>=</operator> <operator>(</operator><name>HashMemoryChunk</name><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batchCxt</name></name></expr></argument>,
                                                        <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>HashMemoryChunkData</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newChunk</name><operator>-&gt;</operator><name>maxlen</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newChunk</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newChunk</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/*
         * Add this chunk to the list after the first existing chunk, so that
         * we don't lose the remaining space in the "current" chunk.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>newChunk</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>newChunk</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>newChunk</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>=</operator> <name>newChunk</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name><name>newChunk</name><operator>-&gt;</operator><name>used</name></name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newChunk</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <return>return <expr><name><name>newChunk</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * See if we have enough space for it in the current chunk (if any). If
     * not, allocate a fresh chunk.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name><operator>-&gt;</operator><name>maxlen</name></name> <operator>-</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name><operator>-&gt;</operator><name>used</name></name><operator>)</operator> <operator>&lt;</operator> <name>size</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* allocate new chunk and put it at the beginning of the list */</comment>
        <expr_stmt><expr><name>newChunk</name> <operator>=</operator> <operator>(</operator><name>HashMemoryChunk</name><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batchCxt</name></name></expr></argument>,
                                                        <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>HashMemoryChunkData</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>HASH_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>newChunk</name><operator>-&gt;</operator><name>maxlen</name></name> <operator>=</operator> <name>HASH_CHUNK_SIZE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newChunk</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newChunk</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>newChunk</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>=</operator> <name>newChunk</name></expr>;</expr_stmt>

        <return>return <expr><name><name>newChunk</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* There is enough space in the current chunk, let's add the tuple */</comment>
    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name><operator>-&gt;</operator><name>used</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name><operator>-&gt;</operator><name>used</name></name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* return pointer to the start of the tuple memory */</comment>
    <return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecShmHashSkewTableInsert</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>,
                        <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
                        <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>,
                        <parameter><decl><type><name>int</name></type> <name>bucketNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ExecFetchSlotMinimalTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>hashTuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>hashTupleSize</name></decl>;</decl_stmt>

    <comment type="block">/* Create the HashJoinTuple */</comment>
    <expr_stmt><expr><name>hashTupleSize</name> <operator>=</operator> <name>HJTUPLE_OVERHEAD</name> <operator>+</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name><operator>)</operator> <call><name>ParallelWorkerShmAlloc</name><argument_list>(<argument><expr><name>hashTupleSize</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>hashvalue</name></name> <operator>=</operator> <name>hashvalue</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HeapTupleHeaderClearMatch</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Push it onto the front of the skew bucket's list */</comment>
    <expr_stmt><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name><index>[<expr><name>bucketNumber</name></expr>]</index></name><operator>-&gt;</operator><name>tuples</name></expr>;</expr_stmt>

    <comment type="block">/* put the tail into the skew bucket tail's list */</comment>
    <if_stmt><if>if<condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name><index>[<expr><name>bucketNumber</name></expr>]</index></name><operator>-&gt;</operator><name>tuples</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket_tail</name><index>[<expr><name>bucketNumber</name></expr>]</index></name><operator>-&gt;</operator><name>tuples</name> <operator>=</operator> <name>hashTuple</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name><index>[<expr><name>bucketNumber</name></expr>]</index></name><operator>-&gt;</operator><name>tuples</name> <operator>=</operator> <name>hashTuple</name></expr>;</expr_stmt>

    <comment type="block">/* Account for space used, and back off if we've used too much */</comment>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>+=</operator> <name>hashTupleSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsedSkew</name></name> <operator>+=</operator> <name>hashTupleSize</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsedSkew</name></name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spaceAllowedSkew</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecHashRemoveNextSkewBucket</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecShmHashTableInsert</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>,
                    <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
                    <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ExecFetchSlotMinimalTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>bucketno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>batchno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>dp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_area</name> <modifier>*</modifier></type> <name>dsa</name> <init>= <expr><call><name>GetNumWorkerDsa</name><argument_list>(<argument><expr><name>ParallelWorkerNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ExecHashGetBucketAndBatch</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>bucketno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>batchno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * decide whether to put the tuple in the hash table or a temp file
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>batchno</name> <operator>==</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * put the tuple in hash table
         */</comment>
        <decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>hashTuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>hashTupleSize</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type>        <name>ntuples</name> <init>= <expr><operator>(</operator><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>-</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>skewTuples</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HashJoinTupleData</name> <modifier>*</modifier><modifier>*</modifier></type><name>buckets</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HashJoinTupleData</name> <modifier>*</modifier><modifier>*</modifier></type><name>buckets_tail</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>tail_wnum</name></decl>;</decl_stmt>
        <comment type="block">/*
          * TODO:we can compress the minimaltup here, so more data
          * can be stored in memory, this may make join more efficient
          */</comment>
        
        <comment type="block">/* Create the HashJoinTuple */</comment>
        <expr_stmt><expr><name>hashTupleSize</name> <operator>=</operator> <name>HJTUPLE_OVERHEAD</name> <operator>+</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dp</name>            <operator>=</operator> <call><name>dsa_allocate</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>hashTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hashTuple</name>     <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name><operator>)</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>hashvalue</name></name>    <operator>=</operator> <name>hashvalue</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>workerNumber</name></name> <operator>=</operator> <name>ParallelWorkerNumber</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We always reset the tuple-matched flag on insertion.  This is okay
         * even when reloading a tuple from a batch file, since the tuple
         * could not possibly have been matched to an outer tuple before it
         * went into the batch file.
         */</comment>
        <expr_stmt><expr><call><name>HeapTupleHeaderClearMatch</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>buckets</name>      <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><operator>(</operator><name>dsa_pointer</name><operator>)</operator><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>buckets_tail</name> <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><operator>(</operator><name>dsa_pointer</name><operator>)</operator><name><name>hashtable</name><operator>-&gt;</operator><name>buckets_tail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tail_wnum</name>    <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><operator>(</operator><name>dsa_pointer</name><operator>)</operator><name><name>hashtable</name><operator>-&gt;</operator><name>bucket_tail_wNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Push it onto the front of the bucket's list */</comment>
        <expr_stmt><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>buckets</name><index>[<expr><name>bucketno</name></expr>]</index></name></expr>;</expr_stmt>

        <comment type="block">/* put it to the tail of the bucket's list */</comment>
        <if_stmt><if>if<condition>(<expr><name><name>buckets</name><index>[<expr><name>bucketno</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>buckets_tail</name><index>[<expr><name>bucketno</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>HashJoinTupleData</name> <operator>*</operator><operator>)</operator><name>dp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tail_wnum</name><index>[<expr><name>bucketno</name></expr>]</index></name> <operator>=</operator> <name>ParallelWorkerNumber</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>buckets</name><index>[<expr><name>bucketno</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>HashJoinTupleData</name> <operator>*</operator><operator>)</operator><name>dp</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>+=</operator> <name>hashTupleSize</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spaceAllowed</name></name></expr>)</condition><block type="pseudo"><block_content>
            
        <comment type="block">/*
         * Increase the (optimal) number of buckets if we just exceeded the
         * NTUP_PER_BUCKET threshold, but only when there's still a single
         * batch.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
            <name>ntuples</name> <operator>&gt;</operator> <operator>(</operator><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>*</operator> <name>NTUP_PER_BUCKET</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Guard against integer overflow and alloc size overflow */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>&lt;=</operator> <name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
                <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>&lt;=</operator> <name>MaxAllocSize</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets_optimal</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Account for space used, and back off if we've used too much */</comment>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>+=</operator> <name>hashTupleSize</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>+</operator>
            <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof>
            <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spaceAllowed</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ExecHashIncreaseNumBatches</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * put the tuple into a temp file for later batches
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>batchno</name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExecHashJoinSaveTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
                              <argument><expr><name>hashvalue</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>batchno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static void
ExecShmHashBuildSkewHash(HashJoinTable hashtable, Hash *node, int mcvsToUse)
{<comment type="line">// #lizard forgives</comment>
    HeapTupleData *statsTuple;
    AttStatsSlot sslot;

    <comment type="block">/* Do nothing if planner didn't identify the outer relation's join key */</comment>
    if (!OidIsValid(node-&gt;skewTable))
        return;
    <comment type="block">/* Also, do nothing if we don't have room for at least one skew bucket */</comment>
    if (mcvsToUse &lt;= 0)
        return;

    <comment type="block">/*
     * Try to find the MCV statistics for the outer relation's join key.
     */</comment>
    statsTuple = SearchSysCache3(STATRELATTINH,
                                 ObjectIdGetDatum(node-&gt;skewTable),
                                 Int16GetDatum(node-&gt;skewColumn),
                                 BoolGetDatum(node-&gt;skewInherit));
    if (!HeapTupleIsValid(statsTuple))
        return;

    if (get_attstatsslot(&amp;sslot, statsTuple,
                         STATISTIC_KIND_MCV, InvalidOid,
                         ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))
    {
        double        frac;
        int            nbuckets;
        FmgrInfo   *hashfunctions;
        int            i;

        if (mcvsToUse &gt; sslot.nvalues)
            mcvsToUse = sslot.nvalues;

        <comment type="block">/*
         * Calculate the expected fraction of outer relation that will
         * participate in the skew optimization.  If this isn't at least
         * SKEW_MIN_OUTER_FRACTION, don't use skew optimization.
         */</comment>
        frac = 0;
        for (i = 0; i &lt; mcvsToUse; i++)
            frac += sslot.numbers[i];
        if (frac &lt; SKEW_MIN_OUTER_FRACTION)
        {
            free_attstatsslot(&amp;sslot);
            ReleaseSysCache(statsTuple);
            return;
        }

        <comment type="block">/*
         * Okay, set up the skew hashtable.
         *
         * skewBucket[] is an open addressing hashtable with a power of 2 size
         * that is greater than the number of MCV values.  (This ensures there
         * will be at least one null entry, so searches will always
         * terminate.)
         *
         * Note: this code could fail if mcvsToUse exceeds INT_MAX/8 or
         * MaxAllocSize/sizeof(void *)/8, but that is not currently possible
         * since we limit pg_statistic entries to much less than that.
         */</comment>
        nbuckets = 2;
        while (nbuckets &lt;= mcvsToUse)
            nbuckets &lt;&lt;= 1;
        <comment type="block">/* use two more bits just to help avoid collisions */</comment>
        nbuckets &lt;&lt;= 2;

        hashtable-&gt;skewEnabled = true;
        hashtable-&gt;skewBucketLen = nbuckets;

        <comment type="block">/*
         * We allocate the bucket memory in the hashtable's batch context. It
         * is only needed during the first batch, and this ensures it will be
         * automatically removed once the first batch is done.
         */</comment>
        hashtable-&gt;skewBucket      = (HashSkewBucket **)
            ParallelWorkerShmAlloc(nbuckets * sizeof(HashSkewBucket *), true);
        hashtable-&gt;skewBucket_tail = (HashSkewBucket **)
            ParallelWorkerShmAlloc(nbuckets * sizeof(HashSkewBucket *), true);
        hashtable-&gt;skewBucketNums  = (int *)
            ParallelWorkerShmAlloc(mcvsToUse * sizeof(int), true);

        hashtable-&gt;spaceUsed += nbuckets * sizeof(HashSkewBucket *)
            + mcvsToUse * sizeof(int);
        hashtable-&gt;spaceUsedSkew += nbuckets * sizeof(HashSkewBucket *)
            + mcvsToUse * sizeof(int);
        if (hashtable-&gt;spaceUsed &gt; hashtable-&gt;spacePeak)
            hashtable-&gt;spacePeak = hashtable-&gt;spaceUsed;

        <comment type="block">/*
         * Create a skew bucket for each MCV hash value.
         *
         * Note: it is very important that we create the buckets in order of
         * decreasing MCV frequency.  If we have to remove some buckets, they
         * must be removed in reverse order of creation (see notes in
         * ExecHashRemoveNextSkewBucket) and we want the least common MCVs to
         * be removed first.
         */</comment>
        hashfunctions = hashtable-&gt;outer_hashfunctions;

        for (i = 0; i &lt; mcvsToUse; i++)
        {
            uint32        hashvalue;
            int            bucket;

            hashvalue = DatumGetUInt32(FunctionCall1(&amp;hashfunctions[0],
                                                     sslot.values[i]));

            <comment type="block">/*
             * While we have not hit a hole in the hashtable and have not hit
             * the desired bucket, we have collided with some previous hash
             * value, so try the next bucket location.  NB: this code must
             * match ExecHashGetSkewBucket.
             */</comment>
            bucket = hashvalue &amp; (nbuckets - 1);
            while (hashtable-&gt;skewBucket[bucket] != NULL &amp;&amp;
                   hashtable-&gt;skewBucket[bucket]-&gt;hashvalue != hashvalue)
                bucket = (bucket + 1) &amp; (nbuckets - 1);

            <comment type="block">/*
             * If we found an existing bucket with the same hashvalue, leave
             * it alone.  It's okay for two MCVs to share a hashvalue.
             */</comment>
            if (hashtable-&gt;skewBucket[bucket] != NULL)
                continue;

            <comment type="block">/* Okay, create a new skew bucket for this hashvalue. */</comment>
            hashtable-&gt;skewBucket[bucket]      = (HashSkewBucket *)
                ParallelWorkerShmAlloc(sizeof(HashSkewBucket), false);
            hashtable-&gt;skewBucket_tail[bucket] = (HashSkewBucket *)
                ParallelWorkerShmAlloc(sizeof(HashSkewBucket), false);
            hashtable-&gt;skewBucket[bucket]-&gt;hashvalue      = hashvalue;
            hashtable-&gt;skewBucket_tail[bucket]-&gt;hashvalue = hashvalue;
            hashtable-&gt;skewBucket[bucket]-&gt;tuples      = NULL;
            hashtable-&gt;skewBucket_tail[bucket]-&gt;tuples = NULL;
            hashtable-&gt;skewBucketNums[hashtable-&gt;nSkewBuckets] = bucket;
            hashtable-&gt;nSkewBuckets++;
            hashtable-&gt;spaceUsed += SKEW_BUCKET_OVERHEAD;
            hashtable-&gt;spaceUsedSkew += SKEW_BUCKET_OVERHEAD;
            if (hashtable-&gt;spaceUsed &gt; hashtable-&gt;spacePeak)
                hashtable-&gt;spacePeak = hashtable-&gt;spaceUsed;
        }

        free_attstatsslot(&amp;sslot);
    }

    ReleaseSysCache(statsTuple);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecShmHashTableCreate
 *
 *        create an empty share-hashtable data structure for hashjoin.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>HashJoinTable</name></type>
<name>ExecShmHashTableCreate</name><parameter_list>(<parameter><decl><type><name>Hash</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashOperators</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>keepNulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>outerNode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nbuckets</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nbatch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_skew_mcvs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>log2_nbuckets</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>      <name>plan_rows</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ho</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>dp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>dp_buckets</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>dp_wnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_area</name> <modifier>*</modifier></type> <name>dsa</name> <init>= <expr><call><name>GetNumWorkerDsa</name><argument_list>(<argument><expr><name>ParallelWorkerNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>mynbatch</name>  <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Get information about the size of the relation to be hashed (it's the
     * "outer" subtree of this node, but the inner relation of the hashjoin).
     * Compute the appropriate size of the hash table.
     */</comment>
    <expr_stmt><expr><name>outerNode</name> <operator>=</operator> <call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>plan_rows</name> <operator>=</operator> <name><name>outerNode</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt><comment type="line">// * max_parallel_workers_per_gather;</comment>
        
    <expr_stmt><expr><call><name>ExecChooseHashTableSize</name><argument_list>(<argument><expr><name>plan_rows</name></expr></argument>, <argument><expr><name><name>outerNode</name><operator>-&gt;</operator><name>plan_width</name></name></expr></argument>,
                            <argument><expr><name>false</name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>nbuckets</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbatch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_skew_mcvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>nbuckets</name> <operator>&lt;</operator> <name>HASH_BUCKET_THRESHOLD</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <name>HASH_BUCKET_THRESHOLD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* 
      * In parallel mode, nbuckets and nbatch can not be changed.
      * Need to estimate both appropriate value.
      */</comment>
    <expr_stmt><expr><name>mynbatch</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>plan_rows</name> <operator>/</operator> <name>nbuckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* ... and force it to be a power of 2. */</comment>
    <expr_stmt><expr><name>mynbatch</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <call><name>my_log2</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>mynbatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>nbatch</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>nbatch</name></expr></argument>, <argument><expr><name>mynbatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="line">//if (nbatch &lt; HASH_BATCH_THRESHOLD)</comment>
    <comment type="line">//    nbatch     = nbatch    * max_parallel_workers_per_gather;</comment>

    <comment type="block">/* nbuckets must be a power of 2 */</comment>
    <expr_stmt><expr><name>log2_nbuckets</name> <operator>=</operator> <call><name>my_log2</name><argument_list>(<argument><expr><name>nbuckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nbuckets</name> <operator>==</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>log2_nbuckets</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize the hash table control block.
     *
     * The hashtable control block is just palloc'd from the executor's
     * per-query memory context.
     */</comment>
    <expr_stmt><expr><name>dp</name>        <operator>=</operator> <call><name>dsa_allocate</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTableData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hashtable</name> <operator>=</operator> <operator>(</operator><name>HashJoinTable</name><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>=</operator> <name>nbuckets</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_original</name></name> <operator>=</operator> <name>nbuckets</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>=</operator> <name>nbuckets</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets</name></name> <operator>=</operator> <name>log2_nbuckets</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets_optimal</name></name> <operator>=</operator> <name>log2_nbuckets</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>keepNulls</name></name> <operator>=</operator> <name>keepNulls</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewEnabled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucketLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nSkewBuckets</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucketNums</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>=</operator> <name>nbatch</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch_original</name></name> <operator>=</operator> <name>nbatch</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch_outstart</name></name> <operator>=</operator> <name>nbatch</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>growEnabled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewTuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceAllowed</name></name> <operator>=</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsedSkew</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceAllowedSkew</name></name> <operator>=</operator>
        <name><name>hashtable</name><operator>-&gt;</operator><name>spaceAllowed</name></name> <operator>*</operator> <name>SKEW_WORK_MEM_PERCENT</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HJDEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Hashjoin %p: initial nbatch = %d, nbuckets = %d\n"</literal></expr></argument>,
           <argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>nbatch</name></expr></argument>, <argument><expr><name>nbuckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Get info about the hash functions to be used for each hash key. Also
     * remember whether the join operators are strict.
     */</comment>
    <expr_stmt><expr><name>nkeys</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>hashOperators</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outer_hashfunctions</name></name> <operator>=</operator>
        <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>inner_hashfunctions</name></name> <operator>=</operator>
        <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashStrict</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>ho</argument>, <argument>hashOperators</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>hashop</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>ho</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>left_hashfn</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>right_hashfn</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_op_hash_functions</name><argument_list>(<argument><expr><name>hashop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left_hashfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right_hashfn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find hash function for hash operator %u"</literal></expr></argument>,
                 <argument><expr><name>hashop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>left_hashfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>outer_hashfunctions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>right_hashfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>inner_hashfunctions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashStrict</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>op_strict</name><argument_list>(<argument><expr><name>hashop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Create temporary memory contexts in which to keep the hashtable working
     * storage.  See notes in executor/hashjoin.h.
     */</comment>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashCxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                               <argument><expr><literal type="string">"HashTableContext"</literal></expr></argument>,
                                               <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batchCxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashCxt</name></name></expr></argument>,
                                                <argument><expr><literal type="string">"HashBatchContext"</literal></expr></argument>,
                                                <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Allocate data that will live for the life of the hashjoin */</comment>

    <expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>nbatch</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * allocate and initialize the file arrays in hashCxt
         */</comment>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name></name> <operator>=</operator> <operator>(</operator><name>BufFile</name> <operator>*</operator><operator>*</operator><operator>)</operator>
            <call><name>palloc0</name><argument_list>(<argument><expr><name>nbatch</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BufFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name></name> <operator>=</operator> <operator>(</operator><name>BufFile</name> <operator>*</operator><operator>*</operator><operator>)</operator>
            <call><name>palloc0</name><argument_list>(<argument><expr><name>nbatch</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BufFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* The files will not be opened until needed... */</comment>
        <comment type="block">/* ... but make sure we have temp tablespaces established for them */</comment>
        <expr_stmt><expr><call><name>PrepareTempTablespaces</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Prepare context for the first-scan space allocations; allocate the
     * hashbucket array therein, and set each bucket "empty".
     */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batchCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>dp_buckets</name>                  <operator>=</operator> <call><name>dsa_allocate0</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>nbuckets</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name></name>          <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name> <operator>*</operator><operator>)</operator><name>dp_buckets</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>dp_buckets</name>                  <operator>=</operator> <call><name>dsa_allocate0</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>nbuckets</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets_tail</name></name>     <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name> <operator>*</operator><operator>)</operator><name>dp_buckets</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>dp_wnum</name>                     <operator>=</operator> <call><name>dsa_allocate0</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>nbuckets</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>bucket_tail_wNum</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>dp_wnum</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>dp_wnum</name>                     <operator>=</operator> <call><name>dsa_allocate0</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>nbuckets</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>bucket_wNum</name></name>      <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>dp_wnum</name></expr>;</expr_stmt>
    <comment type="block">/*
     * Set up for skew optimization, if possible and there's a need for more
     * than one batch.  (In a one-batch join, there's no point in it.)
     */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    if (nbatch &gt; 1)
        ExecShmHashBuildSkewHash(hashtable, node, num_skew_mcvs);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>HashJoinTable</name><operator>)</operator><name>dp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        MultiExecShmHash
 *
 *        build share hash table for hashjoin, doing partitioning if more
 *        than one batch is required.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>MultiExecShmHash</name><parameter_list>(<parameter><decl><type><name>HashState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerNode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>hashkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>hashvalue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>      <name>tuple_number</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>dp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsa_area</name> <modifier>*</modifier></type> <name>dsa</name> <init>= <expr><call><name>GetNumWorkerDsa</name><argument_list>(<argument><expr><name>ParallelWorkerNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    
    <comment type="block">/* must provide our own instrumentation support */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>InstrStartNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * get state info from node
     */</comment>
    <expr_stmt><expr><name>outerNode</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>dp</name> <operator>=</operator> <operator>(</operator><name>dsa_pointer</name><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>hashtable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>hashtable</name> <operator>=</operator> <operator>(</operator><name>HashJoinTable</name><operator>)</operator><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * set expression context
     */</comment>
    <expr_stmt><expr><name>hashkeys</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>hashkeys</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * get all inner tuples and insert into the hash table (or temp files)
     */</comment>
    <expr_stmt><expr><name>tuple_number</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        
        <expr_stmt><expr><name>tuple_number</name><operator>++</operator></expr>;</expr_stmt>
        
        <comment type="block">/* We have to compute the hash value */</comment>
        <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ExecHashGetHashValue</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>hashkeys</name></expr></argument>,
                                 <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>keepNulls</name></name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>hashvalue</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>bucketNumber</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>bucketNumber</name> <operator>=</operator> <call><name>ExecHashGetSkewBucket</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>bucketNumber</name> <operator>!=</operator> <name>INVALID_SKEW_BUCKET_NO</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* It's a skew tuple, so put it into that hash table */</comment>
                <expr_stmt><expr><call><name>ExecShmHashSkewTableInsert</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>,
                                           <argument><expr><name>bucketNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewTuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Not subject to skew optimization, so insert normally */</comment>
                <expr_stmt><expr><call><name>ExecShmHashTableInsert</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    <comment type="block">/* debug */</comment>
    if(hashtable-&gt;totalTuples != tuple_number)
    {
        elog(PANIC, "tuple number is mismatch");    
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Account for the buckets in spaceUsed (reported in EXPLAIN ANALYZE) */</comment>
    <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>+=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* must provide our own instrumentation support */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>InstrStopNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>instrument</name></name></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* finish to build share hashtable, flush all the bufFiles */</comment>
    <if_stmt><if>if<condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name><operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* flush bufFile until flush successfully  */</comment>
                <do>do
                <block>{<block_content>
                    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>FlushBufFile</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block> while<condition>(<expr><name>ret</name> <operator>==</operator> <name>EOF</name></expr>)</condition>;</do>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/*
     * We do not return the hash table directly because it's not a subtype of
     * Node, and so would violate the MultiExecProcNode API.  Instead, our
     * parent Hashjoin node is expected to know how to fish it out of our node
     * state.  Ugly but not really worth cleaning up, since Hashjoin knows
     * quite a bit more about Hash besides that.
     */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
