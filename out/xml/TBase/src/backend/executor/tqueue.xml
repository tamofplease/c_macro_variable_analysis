<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/executor/tqueue.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * tqueue.c
 *      Use shm_mq to send &amp; receive tuples between parallel backends
 *
 * Most of the complexity in this module arises from transient RECORD types,
 * which all have type RECORDOID and are distinguished by typmod numbers
 * that are managed per-backend (see src/backend/utils/cache/typcache.c).
 * The sender's set of RECORD typmod assignments probably doesn't match the
 * receiver's.  To deal with this, we make the sender send a description
 * of each transient RECORD type appearing in the data it sends.  The
 * receiver finds or creates a matching type in its own typcache, and then
 * maps the sender's typmod for that type to its own typmod.
 *
 * A DestReceiver of type DestTupleQueue, which is a TQueueDestReceiver
 * under the hood, writes tuples from the executor to a shm_mq.  If
 * necessary, it also writes control messages describing transient
 * record types used within the tuple.
 *
 * A TupleQueueReader reads tuples, and control messages if any are sent,
 * from a shm_mq and returns the tuples.  If transient record types are
 * in use, it registers those types locally based on the control messages
 * and rewrites the typmods sent by the remote side to the corresponding
 * local record typmods.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *      src/backend/executor/tqueue.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/tqueue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rangetypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * The data transferred through the shm_mq is divided into messages.
 * One-byte messages are mode-switch messages, telling the receiver to switch
 * between "control" and "data" modes.  (We always start up in "data" mode.)
 * Otherwise, when in "data" mode, each message is a tuple.  When in "control"
 * mode, each message defines one transient-typmod-to-tupledesc mapping to
 * let us interpret future tuples.  Both of those cases certainly require
 * more than one byte, so no confusion is possible.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TUPLE_QUEUE_MODE_CONTROL</name></cpp:macro>    <cpp:value>'c'</cpp:value></cpp:define> <comment type="block">/* mode-switch message contents */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TUPLE_QUEUE_MODE_DATA</name></cpp:macro>        <cpp:value>'d'</cpp:value></cpp:define>

<comment type="block">/*
 * Both the sender and receiver build trees of TupleRemapInfo nodes to help
 * them identify which (sub) fields of transmitted tuples are composite and
 * may thus need remap processing.  We might need to look within arrays and
 * ranges, not only composites, to find composite sub-fields.  A NULL
 * TupleRemapInfo pointer indicates that it is known that the described field
 * is not composite and has no composite substructure.
 *
 * Note that we currently have to look at each composite field at runtime,
 * even if we believe it's of a named composite type (i.e., not RECORD).
 * This is because we allow the actual value to be a compatible transient
 * RECORD type.  That's grossly inefficient, and it would be good to get
 * rid of the requirement, but it's not clear what would need to change.
 *
 * Also, we allow the top-level tuple structure, as well as the actual
 * structure of composite subfields, to change from one tuple to the next
 * at runtime.  This may well be entirely historical, but it's mostly free
 * to support given the previous requirement; and other places in the system
 * also permit this, so it's not entirely clear if we could drop it.
 */</comment>

<typedef>typedef <type><enum>enum
<block>{
    <decl><name>TQUEUE_REMAP_ARRAY</name></decl>,            <comment type="block">/* array */</comment>
    <decl><name>TQUEUE_REMAP_RANGE</name></decl>,            <comment type="block">/* range */</comment>
    <decl><name>TQUEUE_REMAP_RECORD</name></decl>            <comment type="block">/* composite type, named or transient */</comment>
}</block></enum></type> <name>TupleRemapClass</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>TupleRemapInfo</name></name></type> <name>TupleRemapInfo</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ArrayRemapInfo</name>
<block>{
    <decl_stmt><decl><type><name>int16</name></type>        <name>typlen</name></decl>;</decl_stmt>            <comment type="block">/* array element type's storage properties */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>typbyval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>typalign</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleRemapInfo</name> <modifier>*</modifier></type><name>element_remap</name></decl>;</decl_stmt>    <comment type="block">/* array element type's remap info */</comment>
}</block></struct></type> <name>ArrayRemapInfo</name>;</typedef>

<typedef>typedef <type><struct>struct <name>RangeRemapInfo</name>
<block>{
    <decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>    <comment type="block">/* range type's typcache entry */</comment>
    <decl_stmt><decl><type><name>TupleRemapInfo</name> <modifier>*</modifier></type><name>bound_remap</name></decl>;</decl_stmt>    <comment type="block">/* range bound type's remap info */</comment>
}</block></struct></type> <name>RangeRemapInfo</name>;</typedef>

<typedef>typedef <type><struct>struct <name>RecordRemapInfo</name>
<block>{
    <comment type="block">/* Original (remote) type ID info last seen for this composite field */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>rectypid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>rectypmod</name></decl>;</decl_stmt>
    <comment type="block">/* Local RECORD typmod, or -1 if unset; not used on sender side */</comment>
    <decl_stmt><decl><type><name>int32</name></type>        <name>localtypmod</name></decl>;</decl_stmt>
    <comment type="block">/* If no fields of the record require remapping, these are NULL: */</comment>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupledesc</name></decl>;</decl_stmt>        <comment type="block">/* copy of record's tupdesc */</comment>
    <decl_stmt><decl><type><name>TupleRemapInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>field_remap</name></decl>;</decl_stmt>    <comment type="block">/* each field's remap info */</comment>
}</block></struct></type> <name>RecordRemapInfo</name>;</typedef>

<struct>struct <name>TupleRemapInfo</name>
<block>{
    <decl_stmt><decl><type><name>TupleRemapClass</name></type> <name>remapclass</name></decl>;</decl_stmt>
    <union>union
    <block>{
        <decl_stmt><decl><type><name>ArrayRemapInfo</name></type> <name>arr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RangeRemapInfo</name></type> <name>rng</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RecordRemapInfo</name></type> <name>rec</name></decl>;</decl_stmt>
    }</block>            <decl><name>u</name></decl>;</union>
}</block>;</struct>

<comment type="block">/*
 * DestReceiver object's private contents
 *
 * queue and tupledesc are pointers to data supplied by DestReceiver's caller.
 * The recordhtab and remap info are owned by the DestReceiver and are kept
 * in mycontext.  tmpcontext is a tuple-lifespan context to hold cruft
 * created while traversing each tuple to find record subfields.
 */</comment>
<typedef>typedef <type><struct>struct <name>TQueueDestReceiver</name>
<block>{
    <decl_stmt><decl><type><name>DestReceiver</name></type> <name>pub</name></decl>;</decl_stmt>            <comment type="block">/* public fields */</comment>
    <decl_stmt><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>queue</name></decl>;</decl_stmt>        <comment type="block">/* shm_mq to send to */</comment>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>mycontext</name></decl>;</decl_stmt>    <comment type="block">/* context containing TQueueDestReceiver */</comment>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>tmpcontext</name></decl>;</decl_stmt>    <comment type="block">/* per-tuple context, if needed */</comment>
    <decl_stmt><decl><type><name>HTAB</name>       <modifier>*</modifier></type><name>recordhtab</name></decl>;</decl_stmt>        <comment type="block">/* table of transmitted typmods, if needed */</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name>mode</name></decl>;</decl_stmt>            <comment type="block">/* current message mode */</comment>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupledesc</name></decl>;</decl_stmt>        <comment type="block">/* current top-level tuple descriptor */</comment>
    <decl_stmt><decl><type><name>TupleRemapInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>field_remapinfo</name></decl>;</decl_stmt>    <comment type="block">/* current top-level remap info */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name>        <modifier>*</modifier></type><name>execute_done</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>      <name>send_tuples</name></decl>;</decl_stmt>     <comment type="block">/* total tuples sent to shm_mq */</comment>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>send_total_time</name></decl>;</decl_stmt> <comment type="block">/* total time for sending the tuples */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>TQueueDestReceiver</name>;</typedef>

<comment type="block">/*
 * Hash table entries for mapping remote to local typmods.
 */</comment>
<typedef>typedef <type><struct>struct <name>RecordTypmodMap</name>
<block>{
    <decl_stmt><decl><type><name>int32</name></type>        <name>remotetypmod</name></decl>;</decl_stmt>    <comment type="block">/* hash key (must be first!) */</comment>
    <decl_stmt><decl><type><name>int32</name></type>        <name>localtypmod</name></decl>;</decl_stmt>
}</block></struct></type> <name>RecordTypmodMap</name>;</typedef>

<comment type="block">/*
 * TupleQueueReader object's private contents
 *
 * queue and tupledesc are pointers to data supplied by reader's caller.
 * The typmodmap and remap info are owned by the TupleQueueReader and
 * are kept in mycontext.
 *
 * "typedef struct TupleQueueReader TupleQueueReader" is in tqueue.h
 */</comment>
<struct>struct <name>TupleQueueReader</name>
<block>{
    <decl_stmt><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>queue</name></decl>;</decl_stmt>        <comment type="block">/* shm_mq to receive from */</comment>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>mycontext</name></decl>;</decl_stmt>    <comment type="block">/* context containing TupleQueueReader */</comment>
    <decl_stmt><decl><type><name>HTAB</name>       <modifier>*</modifier></type><name>typmodmap</name></decl>;</decl_stmt>        <comment type="block">/* RecordTypmodMap hashtable, if needed */</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name>mode</name></decl>;</decl_stmt>            <comment type="block">/* current message mode */</comment>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupledesc</name></decl>;</decl_stmt>        <comment type="block">/* current top-level tuple descriptor */</comment>
    <decl_stmt><decl><type><name>TupleRemapInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>field_remapinfo</name></decl>;</decl_stmt>    <comment type="block">/* current top-level remap info */</comment>
}</block>;</struct>

<comment type="block">/* Local function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TQExamine</name><parameter_list>(<parameter><decl><type><name>TQueueDestReceiver</name> <modifier>*</modifier></type><name>tqueue</name></decl></parameter>,
          <parameter><decl><type><name>TupleRemapInfo</name> <modifier>*</modifier></type><name>remapinfo</name></decl></parameter>,
          <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TQExamineArray</name><parameter_list>(<parameter><decl><type><name>TQueueDestReceiver</name> <modifier>*</modifier></type><name>tqueue</name></decl></parameter>,
               <parameter><decl><type><name>ArrayRemapInfo</name> <modifier>*</modifier></type><name>remapinfo</name></decl></parameter>,
               <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TQExamineRange</name><parameter_list>(<parameter><decl><type><name>TQueueDestReceiver</name> <modifier>*</modifier></type><name>tqueue</name></decl></parameter>,
               <parameter><decl><type><name>RangeRemapInfo</name> <modifier>*</modifier></type><name>remapinfo</name></decl></parameter>,
               <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TQExamineRecord</name><parameter_list>(<parameter><decl><type><name>TQueueDestReceiver</name> <modifier>*</modifier></type><name>tqueue</name></decl></parameter>,
                <parameter><decl><type><name>RecordRemapInfo</name> <modifier>*</modifier></type><name>remapinfo</name></decl></parameter>,
                <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TQSendRecordInfo</name><parameter_list>(<parameter><decl><type><name>TQueueDestReceiver</name> <modifier>*</modifier></type><name>tqueue</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
                 <parameter><decl><type><name>TupleDesc</name></type> <name>tupledesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TupleQueueHandleControlMessage</name><parameter_list>(<parameter><decl><type><name>TupleQueueReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>,
                               <parameter><decl><type><name>Size</name></type> <name>nbytes</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>TupleQueueHandleDataMessage</name><parameter_list>(<parameter><decl><type><name>TupleQueueReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>,
                            <parameter><decl><type><name>Size</name></type> <name>nbytes</name></decl></parameter>, <parameter><decl><type><name>HeapTupleHeader</name></type> <name>data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>TQRemapTuple</name><parameter_list>(<parameter><decl><type><name>TupleQueueReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>,
             <parameter><decl><type><name>TupleDesc</name></type> <name>tupledesc</name></decl></parameter>,
             <parameter><decl><type><name>TupleRemapInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>field_remapinfo</name></decl></parameter>,
             <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>TQRemap</name><parameter_list>(<parameter><decl><type><name>TupleQueueReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><name>TupleRemapInfo</name> <modifier>*</modifier></type><name>remapinfo</name></decl></parameter>,
        <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>changed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>TQRemapArray</name><parameter_list>(<parameter><decl><type><name>TupleQueueReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><name>ArrayRemapInfo</name> <modifier>*</modifier></type><name>remapinfo</name></decl></parameter>,
             <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>changed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>TQRemapRange</name><parameter_list>(<parameter><decl><type><name>TupleQueueReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><name>RangeRemapInfo</name> <modifier>*</modifier></type><name>remapinfo</name></decl></parameter>,
             <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>changed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>TQRemapRecord</name><parameter_list>(<parameter><decl><type><name>TupleQueueReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><name>RecordRemapInfo</name> <modifier>*</modifier></type><name>remapinfo</name></decl></parameter>,
              <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>changed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleRemapInfo</name> <modifier>*</modifier></type><name>BuildTupleRemapInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mycontext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleRemapInfo</name> <modifier>*</modifier></type><name>BuildArrayRemapInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>elemtypid</name></decl></parameter>,
                    <parameter><decl><type><name>MemoryContext</name></type> <name>mycontext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleRemapInfo</name> <modifier>*</modifier></type><name>BuildRangeRemapInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>rngtypid</name></decl></parameter>,
                    <parameter><decl><type><name>MemoryContext</name></type> <name>mycontext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleRemapInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>BuildFieldRemapInfo</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupledesc</name></decl></parameter>,
                    <parameter><decl><type><name>MemoryContext</name></type> <name>mycontext</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Receive a tuple from a query, and send it to the designated shm_mq.
 *
 * Returns TRUE if successful, FALSE if shm_mq has been detached.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>tqueueReceiveSlot</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TQueueDestReceiver</name> <modifier>*</modifier></type><name>tqueue</name> <init>= <expr><operator>(</operator><name>TQueueDestReceiver</name> <operator>*</operator><operator>)</operator> <name>self</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupledesc</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>shm_mq_result</name></type> <name>result</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>begin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>end</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>begin</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>tqueue</name><operator>-&gt;</operator><name>execute_done</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>Executor_done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"tqueueReceiveSlot: parallelworker %d pid %d execute done"</literal></expr></argument>, <argument><expr><name>ParallelWorkerNumber</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * If first time through, compute remapping info for the top-level fields.
     * On later calls, if the tupledesc has changed, set up for the new
     * tupledesc.  (This is a strange test both because the executor really
     * shouldn't change the tupledesc, and also because it would be unsafe if
     * the old tupledesc could be freed and a new one allocated at the same
     * address.  But since some very old code in printtup.c uses a similar
     * approach, we adopt it here as well.)
     *
     * Here and elsewhere in this module, when replacing remapping info we
     * pfree the top-level object because that's easy, but we don't bother to
     * recursively free any substructure.  This would lead to query-lifespan
     * memory leaks if the mapping info actually changed frequently, but since
     * we don't expect that to happen, it doesn't seem worth expending code to
     * prevent it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>tqueue</name><operator>-&gt;</operator><name>tupledesc</name></name> <operator>!=</operator> <name>tupledesc</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Is it worth trying to free substructure of the remap tree? */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tqueue</name><operator>-&gt;</operator><name>field_remapinfo</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>tqueue</name><operator>-&gt;</operator><name>field_remapinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>tqueue</name><operator>-&gt;</operator><name>field_remapinfo</name></name> <operator>=</operator> <call><name>BuildFieldRemapInfo</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>,
                                                      <argument><expr><name><name>tqueue</name><operator>-&gt;</operator><name>mycontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tqueue</name><operator>-&gt;</operator><name>tupledesc</name></name> <operator>=</operator> <name>tupledesc</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * When, because of the types being transmitted, no record typmod mapping
     * can be needed, we can skip a good deal of work.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>tqueue</name><operator>-&gt;</operator><name>field_remapinfo</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TupleRemapInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>remapinfo</name> <init>= <expr><name><name>tqueue</name><operator>-&gt;</operator><name>field_remapinfo</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Deform the tuple so we can examine fields, if not done already. */</comment>
        <expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Iterate over each attribute and search it for transient typmods. */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupledesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/* Ignore nulls and types that don't need special handling. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <name><name>remapinfo</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/* Switch to temporary memory context to avoid leaking. */</comment>
            <if_stmt><if>if <condition>(<expr><name>oldcontext</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>tqueue</name><operator>-&gt;</operator><name>tmpcontext</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>tqueue</name><operator>-&gt;</operator><name>tmpcontext</name></name> <operator>=</operator>
                        <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>tqueue</name><operator>-&gt;</operator><name>mycontext</name></name></expr></argument>,
                                              <argument><expr><literal type="string">"tqueue sender temp context"</literal></expr></argument>,
                                              <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>tqueue</name><operator>-&gt;</operator><name>tmpcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Examine the value. */</comment>
            <expr_stmt><expr><call><name>TQExamine</name><argument_list>(<argument><expr><name>tqueue</name></expr></argument>, <argument><expr><name><name>remapinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/* If we used the temp context, reset it and restore prior context. */</comment>
        <if_stmt><if>if <condition>(<expr><name>oldcontext</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>tqueue</name><operator>-&gt;</operator><name>tmpcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* If we entered control mode, switch back to data mode. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tqueue</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>TUPLE_QUEUE_MODE_DATA</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>tqueue</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>TUPLE_QUEUE_MODE_DATA</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>shm_mq_send</name><argument_list>(<argument><expr><name><name>tqueue</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tqueue</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Send the tuple itself. */</comment>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>shm_mq_send</name><argument_list>(<argument><expr><name><name>tqueue</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check for failure. */</comment>
    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>SHM_MQ_DETACHED</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>result</name> <operator>!=</operator> <name>SHM_MQ_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not send tuple to shared-memory queue"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>tqueue</name><operator>-&gt;</operator><name>send_tuples</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tqueue</name><operator>-&gt;</operator><name>send_total_time</name></name> <operator>+=</operator> <operator>(</operator><name>end</name> <operator>-</operator> <name>begin</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Examine the given datum and send any necessary control messages for
 * transient record types contained in it.
 *
 * remapinfo is previously-computed remapping info about the datum's type.
 *
 * This function just dispatches based on the remap class.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TQExamine</name><parameter_list>(<parameter><decl><type><name>TQueueDestReceiver</name> <modifier>*</modifier></type><name>tqueue</name></decl></parameter>, <parameter><decl><type><name>TupleRemapInfo</name> <modifier>*</modifier></type><name>remapinfo</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* This is recursive, so it could be driven to stack overflow. */</comment>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name><name>remapinfo</name><operator>-&gt;</operator><name>remapclass</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>TQUEUE_REMAP_ARRAY</name></expr>:</case>
            <expr_stmt><expr><call><name>TQExamineArray</name><argument_list>(<argument><expr><name>tqueue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>remapinfo</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>arr</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>TQUEUE_REMAP_RANGE</name></expr>:</case>
            <expr_stmt><expr><call><name>TQExamineRange</name><argument_list>(<argument><expr><name>tqueue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>remapinfo</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rng</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>TQUEUE_REMAP_RECORD</name></expr>:</case>
            <expr_stmt><expr><call><name>TQExamineRecord</name><argument_list>(<argument><expr><name>tqueue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>remapinfo</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rec</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Examine a record datum and send any necessary control messages for
 * transient record types contained in it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TQExamineRecord</name><parameter_list>(<parameter><decl><type><name>TQueueDestReceiver</name> <modifier>*</modifier></type><name>tqueue</name></decl></parameter>, <parameter><decl><type><name>RecordRemapInfo</name> <modifier>*</modifier></type><name>remapinfo</name></decl></parameter>,
                <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>typid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>typmod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupledesc</name></decl>;</decl_stmt>

    <comment type="block">/* Extract type OID and typmod from tuple. */</comment>
    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>typid</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>typmod</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If first time through, or if this isn't the same composite type as last
     * time, consider sending a control message, and then look up the
     * necessary information for examining the fields.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>typid</name> <operator>!=</operator> <name><name>remapinfo</name><operator>-&gt;</operator><name>rectypid</name></name> <operator>||</operator> <name>typmod</name> <operator>!=</operator> <name><name>remapinfo</name><operator>-&gt;</operator><name>rectypmod</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Free any old data. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>remapinfo</name><operator>-&gt;</operator><name>tupledesc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FreeTupleDesc</name><argument_list>(<argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>tupledesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* Is it worth trying to free substructure of the remap tree? */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>remapinfo</name><operator>-&gt;</operator><name>field_remap</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>field_remap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Look up tuple descriptor in typcache. */</comment>
        <expr_stmt><expr><name>tupledesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If this is a transient record type, send the tupledesc in a control
         * message.  (TQSendRecordInfo is smart enough to do this only once
         * per typmod.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>typid</name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>TQSendRecordInfo</name><argument_list>(<argument><expr><name>tqueue</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>, <argument><expr><name>tupledesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Figure out whether fields need recursive processing. */</comment>
        <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>field_remap</name></name> <operator>=</operator> <call><name>BuildFieldRemapInfo</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>,
                                                     <argument><expr><name><name>tqueue</name><operator>-&gt;</operator><name>mycontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>remapinfo</name><operator>-&gt;</operator><name>field_remap</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We need to inspect the record contents, so save a copy of the
             * tupdesc.  (We could possibly just reference the typcache's
             * copy, but then it's problematic when to release the refcount.)
             */</comment>
            <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>tqueue</name><operator>-&gt;</operator><name>mycontext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>tupledesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* No fields of the record require remapping. */</comment>
            <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>tupledesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>rectypid</name></name> <operator>=</operator> <name>typid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>rectypmod</name></name> <operator>=</operator> <name>typmod</name></expr>;</expr_stmt>

        <comment type="block">/* Release reference count acquired by lookup_rowtype_tupdesc. */</comment>
        <expr_stmt><expr><call><name>DecrTupleDescRefCount</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If field remapping is required, deform the tuple and examine each
     * field.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>remapinfo</name><operator>-&gt;</operator><name>field_remap</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>isnull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tdata</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <comment type="block">/* Deform the tuple so we can check each column within. */</comment>
        <expr_stmt><expr><name>tupledesc</name> <operator>=</operator> <name><name>remapinfo</name><operator>-&gt;</operator><name>tupledesc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>tupledesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>isnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>tupledesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tdata</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tdata</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tdata</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tdata</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>tup</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tdata</name></expr></argument>, <argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Recursively check each interesting non-NULL attribute. */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupledesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>remapinfo</name><operator>-&gt;</operator><name>field_remap</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>TQExamine</name><argument_list>(<argument><expr><name>tqueue</name></expr></argument>, <argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>field_remap</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Need not clean up, since we're in a short-lived context. */</comment>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Examine an array datum and send any necessary control messages for
 * transient record types contained in it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TQExamineArray</name><parameter_list>(<parameter><decl><type><name>TQueueDestReceiver</name> <modifier>*</modifier></type><name>tqueue</name></decl></parameter>, <parameter><decl><type><name>ArrayRemapInfo</name> <modifier>*</modifier></type><name>remapinfo</name></decl></parameter>,
               <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arr</name> <init>= <expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>typid</name> <init>= <expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>elem_values</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>elem_nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_elems</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Deconstruct the array. */</comment>
    <expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>, <argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
                      <argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>, <argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>,
                      <argument><expr><operator>&amp;</operator><name>elem_values</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem_nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_elems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Examine each element. */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_elems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>elem_nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>TQExamine</name><argument_list>(<argument><expr><name>tqueue</name></expr></argument>, <argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>element_remap</name></name></expr></argument>, <argument><expr><name><name>elem_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Examine a range datum and send any necessary control messages for
 * transient record types contained in it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TQExamineRange</name><parameter_list>(<parameter><decl><type><name>TQueueDestReceiver</name> <modifier>*</modifier></type><name>tqueue</name></decl></parameter>, <parameter><decl><type><name>RangeRemapInfo</name> <modifier>*</modifier></type><name>remapinfo</name></decl></parameter>,
               <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>range</name> <init>= <expr><call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeBound</name></type>    <name>lower</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeBound</name></type>    <name>upper</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>empty</name></decl>;</decl_stmt>

    <comment type="block">/* Extract the lower and upper bounds. */</comment>
    <expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>typcache</name></name></expr></argument>, <argument><expr><name>range</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Nothing to do for an empty range. */</comment>
    <if_stmt><if>if <condition>(<expr><name>empty</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Examine each bound, if present. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>upper</name><operator>.</operator><name>infinite</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>TQExamine</name><argument_list>(<argument><expr><name>tqueue</name></expr></argument>, <argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>bound_remap</name></name></expr></argument>, <argument><expr><name><name>upper</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lower</name><operator>.</operator><name>infinite</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>TQExamine</name><argument_list>(<argument><expr><name>tqueue</name></expr></argument>, <argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>bound_remap</name></name></expr></argument>, <argument><expr><name><name>lower</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Send tuple descriptor information for a transient typmod, unless we've
 * already done so previously.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TQSendRecordInfo</name><parameter_list>(<parameter><decl><type><name>TQueueDestReceiver</name> <modifier>*</modifier></type><name>tqueue</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupledesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Initialize hash table if not done yet. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>tqueue</name><operator>-&gt;</operator><name>recordhtab</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HASHCTL</name></type>        <name>ctl</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Hash table entries are just typmods */</comment>
        <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name><name>tqueue</name><operator>-&gt;</operator><name>mycontext</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tqueue</name><operator>-&gt;</operator><name>recordhtab</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"tqueue sender record type hashtable"</literal></expr></argument>,
                                         <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
                                         <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Have we already seen this record type?  If not, must report it. */</comment>
    <expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>tqueue</name><operator>-&gt;</operator><name>recordhtab</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"sending tqueue control message for record typmod %d"</literal></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If message queue is in data mode, switch to control mode. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>tqueue</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>TUPLE_QUEUE_MODE_CONTROL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>tqueue</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>TUPLE_QUEUE_MODE_CONTROL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>shm_mq_send</name><argument_list>(<argument><expr><name><name>tqueue</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tqueue</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Assemble a control message. */</comment>
    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>typmod</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>tupledesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>tupledesc</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupledesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>tupledesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FormData_pg_attribute</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Send control message. */</comment>
    <expr_stmt><expr><call><name>shm_mq_send</name><argument_list>(<argument><expr><name><name>tqueue</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We assume it's OK to leak buf because we're in a short-lived context. */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare to receive tuples from executor.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tqueueStartupReceiver</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>operation</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>typeinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* do nothing */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Clean up at end of an executor run
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tqueueShutdownReceiver</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TQueueDestReceiver</name> <modifier>*</modifier></type><name>tqueue</name> <init>= <expr><operator>(</operator><name>TQueueDestReceiver</name> <operator>*</operator><operator>)</operator> <name>self</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"TqueueSend: send_tuples:%lu, send_total_time:%ld, avg_time:%lf."</literal></expr></argument>,
                   <argument><expr><name><name>tqueue</name><operator>-&gt;</operator><name>send_tuples</name></name></expr></argument>, <argument><expr><name><name>tqueue</name><operator>-&gt;</operator><name>send_total_time</name></name></expr></argument>,
                   <argument><expr><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name><name>tqueue</name><operator>-&gt;</operator><name>send_total_time</name></name><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name><name>tqueue</name><operator>-&gt;</operator><name>send_tuples</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>shm_mq_detach</name><argument_list>(<argument><expr><call><name>shm_mq_get_queue</name><argument_list>(<argument><expr><name><name>tqueue</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Destroy receiver when done with it
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tqueueDestroyReceiver</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TQueueDestReceiver</name> <modifier>*</modifier></type><name>tqueue</name> <init>= <expr><operator>(</operator><name>TQueueDestReceiver</name> <operator>*</operator><operator>)</operator> <name>self</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>tqueue</name><operator>-&gt;</operator><name>tmpcontext</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>tqueue</name><operator>-&gt;</operator><name>tmpcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>tqueue</name><operator>-&gt;</operator><name>recordhtab</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>tqueue</name><operator>-&gt;</operator><name>recordhtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Is it worth trying to free substructure of the remap tree? */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>tqueue</name><operator>-&gt;</operator><name>field_remapinfo</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>tqueue</name><operator>-&gt;</operator><name>field_remapinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a DestReceiver that writes tuples to a tuple queue.
 */</comment>
<function><type><name>DestReceiver</name> <modifier>*</modifier></type>
<name>CreateTupleQueueDestReceiver</name><parameter_list>(<parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TQueueDestReceiver</name> <modifier>*</modifier></type><name>self</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>self</name> <operator>=</operator> <operator>(</operator><name>TQueueDestReceiver</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TQueueDestReceiver</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>receiveSlot</name></name> <operator>=</operator> <name>tqueueReceiveSlot</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rStartup</name></name> <operator>=</operator> <name>tqueueStartupReceiver</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rShutdown</name></name> <operator>=</operator> <name>tqueueShutdownReceiver</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rDestroy</name></name> <operator>=</operator> <name>tqueueDestroyReceiver</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>mydest</name></name> <operator>=</operator> <name>DestTupleQueue</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>queue</name></name> <operator>=</operator> <name>handle</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>mycontext</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>tmpcontext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>recordhtab</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>TUPLE_QUEUE_MODE_DATA</name></expr>;</expr_stmt>
    <comment type="block">/* Top-level tupledesc is not known yet */</comment>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>tupledesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>field_remapinfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>execute_done</name></name>    <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>send_tuples</name></name>     <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>send_total_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><operator>(</operator><name>DestReceiver</name> <operator>*</operator><operator>)</operator> <name>self</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a tuple queue reader.
 */</comment>
<function><type><name>TupleQueueReader</name> <modifier>*</modifier></type>
<name>CreateTupleQueueReader</name><parameter_list>(<parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupledesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleQueueReader</name> <modifier>*</modifier></type><name>reader</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleQueueReader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>queue</name></name> <operator>=</operator> <name>handle</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>mycontext</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>typmodmap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>TUPLE_QUEUE_MODE_DATA</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>tupledesc</name></name> <operator>=</operator> <name>tupledesc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>field_remapinfo</name></name> <operator>=</operator> <call><name>BuildFieldRemapInfo</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><name><name>reader</name><operator>-&gt;</operator><name>mycontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>reader</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Destroy a tuple queue reader.
 */</comment>
<function><type><name>void</name></type>
<name>DestroyTupleQueueReader</name><parameter_list>(<parameter><decl><type><name>TupleQueueReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>shm_mq_detach</name><argument_list>(<argument><expr><call><name>shm_mq_get_queue</name><argument_list>(<argument><expr><name><name>reader</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>reader</name><operator>-&gt;</operator><name>typmodmap</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>reader</name><operator>-&gt;</operator><name>typmodmap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Is it worth trying to free substructure of the remap tree? */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>reader</name><operator>-&gt;</operator><name>field_remapinfo</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>reader</name><operator>-&gt;</operator><name>field_remapinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch a tuple from a tuple queue reader.
 *
 * The return value is NULL if there are no remaining tuples or if
 * nowait = true and no tuple is ready to return.  *done, if not NULL,
 * is set to true when there are no remaining tuples and otherwise to false.
 *
 * The returned tuple, if any, is allocated in CurrentMemoryContext.
 * That should be a short-lived (tuple-lifespan) context, because we are
 * pretty cavalier about leaking memory in that context if we have to do
 * tuple remapping.
 *
 * Even when shm_mq_receive() returns SHM_MQ_WOULD_BLOCK, this can still
 * accumulate bytes from a partially-read message, so it's useful to call
 * this with nowait = true even if nothing is returned.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>TupleQueueReaderNext</name><parameter_list>(<parameter><decl><type><name>TupleQueueReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nowait</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>done</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>shm_mq_result</name></type> <name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>done</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>done</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Size</name></type>        <name>nbytes</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

        <comment type="block">/* Attempt to read a message. */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>shm_mq_receive</name><argument_list>(<argument><expr><name><name>reader</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbytes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>nowait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If queue is detached, set *done and return NULL. */</comment>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>SHM_MQ_DETACHED</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>done</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* In non-blocking mode, bail out if no message ready yet. */</comment>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>SHM_MQ_WOULD_BLOCK</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result</name> <operator>==</operator> <name>SHM_MQ_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We got a message (see message spec at top of file).  Process it.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Mode switch message. */</comment>
            <expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>data</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>reader</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>TUPLE_QUEUE_MODE_DATA</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Tuple data. */</comment>
            <return>return <expr><call><name>TupleQueueHandleDataMessage</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>reader</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>TUPLE_QUEUE_MODE_CONTROL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Control message, describing a transient record type. */</comment>
            <expr_stmt><expr><call><name>TupleQueueHandleControlMessage</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized tqueue mode: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>reader</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Handle a data message - that is, a tuple - from the remote side.
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>TupleQueueHandleDataMessage</name><parameter_list>(<parameter><decl><type><name>TupleQueueReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>,
                            <parameter><decl><type><name>Size</name></type> <name>nbytes</name></decl></parameter>,
                            <parameter><decl><type><name>HeapTupleHeader</name></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTupleData</name></type> <name>htup</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Set up a dummy HeapTupleData pointing to the data from the shm_mq
     * (which had better be sufficiently aligned).
     */</comment>
    <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>htup</name><operator>.</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>htup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>htup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>htup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Either just copy the data into a regular palloc'd tuple, or remap it,
     * as required.
     */</comment>
    <return>return <expr><call><name>TQRemapTuple</name><argument_list>(<argument><expr><name>reader</name></expr></argument>,
                        <argument><expr><name><name>reader</name><operator>-&gt;</operator><name>tupledesc</name></name></expr></argument>,
                        <argument><expr><name><name>reader</name><operator>-&gt;</operator><name>field_remapinfo</name></name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>htup</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy the given tuple, remapping any transient typmods contained in it.
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>TQRemapTuple</name><parameter_list>(<parameter><decl><type><name>TupleQueueReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>,
             <parameter><decl><type><name>TupleDesc</name></type> <name>tupledesc</name></decl></parameter>,
             <parameter><decl><type><name>TupleRemapInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>field_remapinfo</name></decl></parameter>,
             <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>changed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If no remapping is necessary, just copy the tuple into a single
     * palloc'd chunk, as caller will expect.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>field_remapinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Deform tuple so we can remap record typmods for individual attrs. */</comment>
    <expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>tupledesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>isnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>tupledesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Recursively process each interesting non-NULL attribute. */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupledesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <name><name>field_remapinfo</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>TQRemap</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name><name>field_remapinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>changed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Reconstruct the modified tuple, if anything was modified. */</comment>
    <if_stmt><if>if <condition>(<expr><name>changed</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process the given datum and replace any transient record typmods
 * contained in it.  Set *changed to TRUE if we actually changed the datum.
 *
 * remapinfo is previously-computed remapping info about the datum's type.
 *
 * This function just dispatches based on the remap class.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>TQRemap</name><parameter_list>(<parameter><decl><type><name>TupleQueueReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><name>TupleRemapInfo</name> <modifier>*</modifier></type><name>remapinfo</name></decl></parameter>,
        <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>changed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* This is recursive, so it could be driven to stack overflow. */</comment>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name><name>remapinfo</name><operator>-&gt;</operator><name>remapclass</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>TQUEUE_REMAP_ARRAY</name></expr>:</case>
            <return>return <expr><call><name>TQRemapArray</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>remapinfo</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>arr</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>changed</name></expr></argument>)</argument_list></call></expr>;</return>

        <case>case <expr><name>TQUEUE_REMAP_RANGE</name></expr>:</case>
            <return>return <expr><call><name>TQRemapRange</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>remapinfo</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rng</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>changed</name></expr></argument>)</argument_list></call></expr>;</return>

        <case>case <expr><name>TQUEUE_REMAP_RECORD</name></expr>:</case>
            <return>return <expr><call><name>TQRemapRecord</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>remapinfo</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rec</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>changed</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized tqueue remap class: %d"</literal></expr></argument>,
         <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>remapinfo</name><operator>-&gt;</operator><name>remapclass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Process the given array datum and replace any transient record typmods
 * contained in it.  Set *changed to TRUE if we actually changed the datum.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>TQRemapArray</name><parameter_list>(<parameter><decl><type><name>TupleQueueReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><name>ArrayRemapInfo</name> <modifier>*</modifier></type><name>remapinfo</name></decl></parameter>,
             <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>changed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arr</name> <init>= <expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>typid</name> <init>= <expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>element_changed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>elem_values</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>elem_nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_elems</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Deconstruct the array. */</comment>
    <expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>, <argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
                      <argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>, <argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>,
                      <argument><expr><operator>&amp;</operator><name>elem_values</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem_nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_elems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Remap each element. */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_elems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>elem_nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>elem_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>TQRemap</name><argument_list>(<argument><expr><name>reader</name></expr></argument>,
                                     <argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>element_remap</name></name></expr></argument>,
                                     <argument><expr><name><name>elem_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>element_changed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>element_changed</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Reconstruct and return the array.  */</comment>
        <expr_stmt><expr><operator>*</operator><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>construct_md_array</name><argument_list>(<argument><expr><name>elem_values</name></expr></argument>, <argument><expr><name>elem_nulls</name></expr></argument>,
                                 <argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>typid</name></expr></argument>, <argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
                                 <argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>, <argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Else just return the value as-is. */</comment>
    <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Process the given range datum and replace any transient record typmods
 * contained in it.  Set *changed to TRUE if we actually changed the datum.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>TQRemapRange</name><parameter_list>(<parameter><decl><type><name>TupleQueueReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><name>RangeRemapInfo</name> <modifier>*</modifier></type><name>remapinfo</name></decl></parameter>,
             <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>changed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>range</name> <init>= <expr><call><name>DatumGetRangeType</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>bound_changed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeBound</name></type>    <name>lower</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeBound</name></type>    <name>upper</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>empty</name></decl>;</decl_stmt>

    <comment type="block">/* Extract the lower and upper bounds. */</comment>
    <expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>typcache</name></name></expr></argument>, <argument><expr><name>range</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Nothing to do for an empty range. */</comment>
    <if_stmt><if>if <condition>(<expr><name>empty</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>value</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Remap each bound, if present. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>upper</name><operator>.</operator><name>infinite</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>upper</name><operator>.</operator><name>val</name></name> <operator>=</operator> <call><name>TQRemap</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>bound_remap</name></name></expr></argument>,
                            <argument><expr><name><name>upper</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bound_changed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lower</name><operator>.</operator><name>infinite</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>lower</name><operator>.</operator><name>val</name></name> <operator>=</operator> <call><name>TQRemap</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>bound_remap</name></name></expr></argument>,
                            <argument><expr><name><name>lower</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bound_changed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>bound_changed</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Reserialize.  */</comment>
        <expr_stmt><expr><operator>*</operator><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>range</name> <operator>=</operator> <call><name>range_serialize</name><argument_list>(<argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>typcache</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>RangeTypeGetDatum</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Else just return the value as-is. */</comment>
    <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Process the given record datum and replace any transient record typmods
 * contained in it.  Set *changed to TRUE if we actually changed the datum.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>TQRemapRecord</name><parameter_list>(<parameter><decl><type><name>TupleQueueReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><name>RecordRemapInfo</name> <modifier>*</modifier></type><name>remapinfo</name></decl></parameter>,
              <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>changed</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>typid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>typmod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>changed_typmod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupledesc</name></decl>;</decl_stmt>

    <comment type="block">/* Extract type OID and typmod from tuple. */</comment>
    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>typid</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>typmod</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If first time through, or if this isn't the same composite type as last
     * time, identify the required typmod mapping, and then look up the
     * necessary information for processing the fields.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>typid</name> <operator>!=</operator> <name><name>remapinfo</name><operator>-&gt;</operator><name>rectypid</name></name> <operator>||</operator> <name>typmod</name> <operator>!=</operator> <name><name>remapinfo</name><operator>-&gt;</operator><name>rectypmod</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Free any old data. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>remapinfo</name><operator>-&gt;</operator><name>tupledesc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FreeTupleDesc</name><argument_list>(<argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>tupledesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* Is it worth trying to free substructure of the remap tree? */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>remapinfo</name><operator>-&gt;</operator><name>field_remap</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>field_remap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* If transient record type, look up matching local typmod. */</comment>
        <if_stmt><if>if <condition>(<expr><name>typid</name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RecordTypmodMap</name> <modifier>*</modifier></type><name>mapent</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>reader</name><operator>-&gt;</operator><name>typmodmap</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mapent</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>reader</name><operator>-&gt;</operator><name>typmodmap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>,
                                 <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>mapent</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tqueue received unrecognized remote typmod %d"</literal></expr></argument>,
                     <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>localtypmod</name></name> <operator>=</operator> <name><name>mapent</name><operator>-&gt;</operator><name>localtypmod</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>localtypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* Look up tuple descriptor in typcache. */</comment>
        <expr_stmt><expr><name>tupledesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>localtypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Figure out whether fields need recursive processing. */</comment>
        <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>field_remap</name></name> <operator>=</operator> <call><name>BuildFieldRemapInfo</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>,
                                                     <argument><expr><name><name>reader</name><operator>-&gt;</operator><name>mycontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>remapinfo</name><operator>-&gt;</operator><name>field_remap</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We need to inspect the record contents, so save a copy of the
             * tupdesc.  (We could possibly just reference the typcache's
             * copy, but then it's problematic when to release the refcount.)
             */</comment>
            <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>reader</name><operator>-&gt;</operator><name>mycontext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>tupledesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* No fields of the record require remapping. */</comment>
            <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>tupledesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>rectypid</name></name> <operator>=</operator> <name>typid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>rectypmod</name></name> <operator>=</operator> <name>typmod</name></expr>;</expr_stmt>

        <comment type="block">/* Release reference count acquired by lookup_rowtype_tupdesc. */</comment>
        <expr_stmt><expr><call><name>DecrTupleDescRefCount</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If transient record, replace remote typmod with local typmod. */</comment>
    <if_stmt><if>if <condition>(<expr><name>typid</name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator> <name>typmod</name> <operator>!=</operator> <name><name>remapinfo</name><operator>-&gt;</operator><name>localtypmod</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>typmod</name> <operator>=</operator> <name><name>remapinfo</name><operator>-&gt;</operator><name>localtypmod</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>changed_typmod</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>changed_typmod</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * If we need to change the typmod, or if there are any potentially
     * remappable fields, replace the tuple.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>changed_typmod</name> <operator>||</operator> <name><name>remapinfo</name><operator>-&gt;</operator><name>field_remap</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTupleData</name></type> <name>htup</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>atup</name></decl>;</decl_stmt>

        <comment type="block">/* For now, assume we always need to change the tuple in this case. */</comment>
        <expr_stmt><expr><operator>*</operator><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <comment type="block">/* Copy tuple, possibly remapping contained fields. */</comment>
        <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>htup</name><operator>.</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>htup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>htup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>htup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>tup</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>atup</name> <operator>=</operator> <call><name>TQRemapTuple</name><argument_list>(<argument><expr><name>reader</name></expr></argument>,
                            <argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>tupledesc</name></name></expr></argument>,
                            <argument><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>field_remap</name></name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Apply the correct labeling for a local Datum. */</comment>
        <expr_stmt><expr><call><name>HeapTupleHeaderSetTypeId</name><argument_list>(<argument><expr><name><name>atup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HeapTupleHeaderSetTypMod</name><argument_list>(<argument><expr><name><name>atup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HeapTupleHeaderSetDatumLength</name><argument_list>(<argument><expr><name><name>atup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name><name>htup</name><operator>.</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* And return the results. */</comment>
        <return>return <expr><call><name>HeapTupleHeaderGetDatum</name><argument_list>(<argument><expr><name><name>atup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Else just return the value as-is. */</comment>
    <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Handle a control message from the tuple queue reader.
 *
 * Control messages are sent when the remote side is sending tuples that
 * contain transient record types.  We need to arrange to bless those
 * record types locally and translate between remote and local typmods.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TupleQueueHandleControlMessage</name><parameter_list>(<parameter><decl><type><name>TupleQueueReader</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>nbytes</name></decl></parameter>,
                               <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>remotetypmod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>natts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>hasoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>attrs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupledesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RecordTypmodMap</name> <modifier>*</modifier></type><name>mapent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Extract remote typmod. */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remotetypmod</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <comment type="block">/* Extract attribute count. */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>natts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <comment type="block">/* Extract hasoid flag. */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hasoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <comment type="block">/* Extract attribute details. The tupledesc made here is just transient. */</comment>
    <expr_stmt><expr><name>attrs</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Form_pg_attribute</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FormData_pg_attribute</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FormData_pg_attribute</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FormData_pg_attribute</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* We should have read the whole message. */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>==</operator> <name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Construct TupleDesc, and assign a local typmod. */</comment>
    <expr_stmt><expr><name>tupledesc</name> <operator>=</operator> <call><name>CreateTupleDesc</name><argument_list>(<argument><expr><name>natts</name></expr></argument>, <argument><expr><name>hasoid</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tupledesc</name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create mapping hashtable if it doesn't exist already. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>reader</name><operator>-&gt;</operator><name>typmodmap</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HASHCTL</name></type>        <name>ctl</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RecordTypmodMap</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name><name>reader</name><operator>-&gt;</operator><name>mycontext</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>typmodmap</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"tqueue receiver record type hashtable"</literal></expr></argument>,
                                        <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
                                        <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Create map entry. */</comment>
    <expr_stmt><expr><name>mapent</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>reader</name><operator>-&gt;</operator><name>typmodmap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>remotetypmod</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>,
                         <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"duplicate tqueue control message for typmod %d"</literal></expr></argument>,
             <argument><expr><name>remotetypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>mapent</name><operator>-&gt;</operator><name>localtypmod</name></name> <operator>=</operator> <name><name>tupledesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"tqueue mapping remote typmod %d to local typmod %d"</literal></expr></argument>,
         <argument><expr><name>remotetypmod</name></expr></argument>, <argument><expr><name><name>mapent</name><operator>-&gt;</operator><name>localtypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Build remap info for the specified data type, storing it in mycontext.
 * Returns NULL if neither the type nor any subtype could require remapping.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleRemapInfo</name> <modifier>*</modifier></type>
<name>BuildTupleRemapInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mycontext</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typ</name></decl>;</decl_stmt>

    <comment type="block">/* This is recursive, so it could be driven to stack overflow. */</comment>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<label><name>restart</name>:</label>
    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>typ</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Look through domains to underlying base type. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>typ</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>typid</name> <operator>=</operator> <name><name>typ</name><operator>-&gt;</operator><name>typbasetype</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>restart</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If it's a true array type, deal with it that way. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typ</name><operator>-&gt;</operator><name>typelem</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>typ</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>typid</name> <operator>=</operator> <name><name>typ</name><operator>-&gt;</operator><name>typelem</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>BuildArrayRemapInfo</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><name>mycontext</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Similarly, deal with ranges appropriately. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>typ</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_RANGE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>BuildRangeRemapInfo</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><name>mycontext</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If it's a composite type (including RECORD), set up for remapping.  We
     * don't attempt to determine the status of subfields here, since we do
     * not have enough information yet; just mark everything invalid.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>typ</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name> <operator>||</operator> <name>typid</name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TupleRemapInfo</name> <modifier>*</modifier></type><name>remapinfo</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>remapinfo</name> <operator>=</operator> <operator>(</operator><name>TupleRemapInfo</name> <operator>*</operator><operator>)</operator>
            <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>mycontext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleRemapInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>remapclass</name></name> <operator>=</operator> <name>TQUEUE_REMAP_RECORD</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rec</name><operator>.</operator><name>rectypid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rec</name><operator>.</operator><name>rectypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rec</name><operator>.</operator><name>localtypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rec</name><operator>.</operator><name>tupledesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rec</name><operator>.</operator><name>field_remap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>remapinfo</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Nothing else can possibly need remapping attention. */</comment>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleRemapInfo</name> <modifier>*</modifier></type>
<name>BuildArrayRemapInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>elemtypid</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mycontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleRemapInfo</name> <modifier>*</modifier></type><name>remapinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleRemapInfo</name> <modifier>*</modifier></type><name>element_remapinfo</name></decl>;</decl_stmt>

    <comment type="block">/* See if element type requires remapping. */</comment>
    <expr_stmt><expr><name>element_remapinfo</name> <operator>=</operator> <call><name>BuildTupleRemapInfo</name><argument_list>(<argument><expr><name>elemtypid</name></expr></argument>, <argument><expr><name>mycontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* If not, the array doesn't either. */</comment>
    <if_stmt><if>if <condition>(<expr><name>element_remapinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* OK, set up to remap the array. */</comment>
    <expr_stmt><expr><name>remapinfo</name> <operator>=</operator> <operator>(</operator><name>TupleRemapInfo</name> <operator>*</operator><operator>)</operator>
        <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>mycontext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleRemapInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>remapclass</name></name> <operator>=</operator> <name>TQUEUE_REMAP_ARRAY</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name>elemtypid</name></expr></argument>,
                         <argument><expr><operator>&amp;</operator><name><name>remapinfo</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>arr</name><operator>.</operator><name>typlen</name></name></expr></argument>,
                         <argument><expr><operator>&amp;</operator><name><name>remapinfo</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>arr</name><operator>.</operator><name>typbyval</name></name></expr></argument>,
                         <argument><expr><operator>&amp;</operator><name><name>remapinfo</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>arr</name><operator>.</operator><name>typalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>arr</name><operator>.</operator><name>element_remap</name></name> <operator>=</operator> <name>element_remapinfo</name></expr>;</expr_stmt>
    <return>return <expr><name>remapinfo</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleRemapInfo</name> <modifier>*</modifier></type>
<name>BuildRangeRemapInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>rngtypid</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mycontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleRemapInfo</name> <modifier>*</modifier></type><name>remapinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleRemapInfo</name> <modifier>*</modifier></type><name>bound_remapinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Get range info from the typcache.  We assume this pointer will stay
     * valid for the duration of the query.
     */</comment>
    <expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>rngtypid</name></expr></argument>, <argument><expr><name>TYPECACHE_RANGE_INFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>typcache</name><operator>-&gt;</operator><name>rngelemtype</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"type %u is not a range type"</literal></expr></argument>, <argument><expr><name>rngtypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* See if range bound type requires remapping. */</comment>
    <expr_stmt><expr><name>bound_remapinfo</name> <operator>=</operator> <call><name>BuildTupleRemapInfo</name><argument_list>(<argument><expr><name><name>typcache</name><operator>-&gt;</operator><name>rngelemtype</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>,
                                          <argument><expr><name>mycontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* If not, the range doesn't either. */</comment>
    <if_stmt><if>if <condition>(<expr><name>bound_remapinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* OK, set up to remap the range. */</comment>
    <expr_stmt><expr><name>remapinfo</name> <operator>=</operator> <operator>(</operator><name>TupleRemapInfo</name> <operator>*</operator><operator>)</operator>
        <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>mycontext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleRemapInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>remapclass</name></name> <operator>=</operator> <name>TQUEUE_REMAP_RANGE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rng</name><operator>.</operator><name>typcache</name></name> <operator>=</operator> <name>typcache</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>remapinfo</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>rng</name><operator>.</operator><name>bound_remap</name></name> <operator>=</operator> <name>bound_remapinfo</name></expr>;</expr_stmt>
    <return>return <expr><name>remapinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build remap info for fields of the type described by the given tupdesc.
 * Returns an array of TupleRemapInfo pointers, or NULL if no field
 * requires remapping.  Data is allocated in mycontext.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleRemapInfo</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>BuildFieldRemapInfo</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupledesc</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mycontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleRemapInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>remapinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>noop</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Recursively determine the remapping status of each field. */</comment>
    <expr_stmt><expr><name>remapinfo</name> <operator>=</operator> <operator>(</operator><name>TupleRemapInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator>
        <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>mycontext</name></expr></argument>,
                           <argument><expr><name><name>tupledesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TupleRemapInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupledesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><name><name>tupledesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>remapinfo</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>remapinfo</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BuildTupleRemapInfo</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name>mycontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>remapinfo</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>noop</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* If no fields require remapping, report that by returning NULL. */</comment>
    <if_stmt><if>if <condition>(<expr><name>noop</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>remapinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>remapinfo</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>remapinfo</name></expr>;</return>
</block_content>}</block></function>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>ParallelReceiverSetExecuteDone</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>execute_done</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TQueueDestReceiver</name> <modifier>*</modifier></type><name>tqueue</name> <init>= <expr><operator>(</operator><name>TQueueDestReceiver</name> <operator>*</operator><operator>)</operator> <name>self</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>tqueue</name><operator>-&gt;</operator><name>execute_done</name></name> <operator>=</operator> <name>execute_done</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
