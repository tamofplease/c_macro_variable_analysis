<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/executor/execProcnode.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execProcnode.c
 *     contains dispatch functions which call the appropriate "initialize",
 *     "get a tuple", and "cleanup" routines for the given node type.
 *     If the node has children, then it will presumably call ExecInitNode,
 *     ExecProcNode, or ExecEndNode on its subnodes and do the appropriate
 *     processing.
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/executor/execProcnode.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 *     NOTES
 *        This used to be three files.  It is now all combined into
 *        one file so that it is easier to keep the dispatch routines
 *        in sync when new nodes are added.
 *
 *     EXAMPLE
 *        Suppose we want the age of the manager of the shoe department and
 *        the number of employees in that department.  So we have the query:
 *
 *                select DEPT.no_emps, EMP.age
 *                from DEPT, EMP
 *                where EMP.name = DEPT.mgr and
 *                      DEPT.name = "shoe"
 *
 *        Suppose the planner gives us the following plan:
 *
 *                        Nest Loop (DEPT.mgr = EMP.name)
 *                        /        \
 *                       /         \
 *                   Seq Scan        Seq Scan
 *                    DEPT          EMP
 *                (name = "shoe")
 *
 *        ExecutorStart() is called first.
 *        It calls InitPlan() which calls ExecInitNode() on
 *        the root of the plan -- the nest loop node.
 *
 *      * ExecInitNode() notices that it is looking at a nest loop and
 *        as the code below demonstrates, it calls ExecInitNestLoop().
 *        Eventually this calls ExecInitNode() on the right and left subplans
 *        and so forth until the entire plan is initialized.  The result
 *        of ExecInitNode() is a plan state tree built with the same structure
 *        as the underlying plan tree.
 *
 *      * Then when ExecutorRun() is called, it calls ExecutePlan() which calls
 *        ExecProcNode() repeatedly on the top node of the plan state tree.
 *        Each time this happens, ExecProcNode() will end up calling
 *        ExecNestLoop(), which calls ExecProcNode() on its subplans.
 *        Each of these subplans is a sequential scan so ExecSeqScan() is
 *        called.  The slots returned by ExecSeqScan() may contain
 *        tuples which contain the attributes ExecNestLoop() uses to
 *        form the tuples it returns.
 *
 *      * Eventually ExecSeqScan() stops returning tuples and the nest
 *        loop join ends.  Lastly, ExecutorEnd() calls ExecEndNode() which
 *        calls ExecEndNestLoop() which in turn calls ExecEndNode() on
 *        its subplans which result in ExecEndSeqScan().
 *
 *        This should show how the executor works by having
 *        ExecInitNode(), ExecProcNode() and ExecEndNode() dispatch
 *        their work to the appropriate node support routines which may
 *        in turn call these routines themselves on their subplans.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAgg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAppend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapAnd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapHeapscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapIndexscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapOr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeCtescan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeCustom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeForeignscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeFunctionscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeGather.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeGatherMerge.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeGroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHashjoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeIndexonlyscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeIndexscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeLimit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeLockRows.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeMaterial.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeMergeAppend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeMergejoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeModifyTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeNamedtuplestorescan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeNestloop.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeProjectSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeRecursiveunion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeResult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSamplescan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSeqscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSetOp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSort.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSubplan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSubqueryscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeTableFuncscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeTidscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeUnique.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeValuesscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeWindowAgg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeWorktablescan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecProcNodeFirst</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecProcNodeInstr</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ------------------------------------------------------------------------
 *        ExecInitNode
 *
 *        Recursively initializes all the nodes in the plan tree rooted
 *        at 'node'.
 *
 *        Inputs:
 *          'node' is the current node of the plan produced by the query planner
 *          'estate' is the shared execution state for the plan tree
 *          'eflags' is a bitwise OR of flag bits described in executor.h
 *
 *        Returns a PlanState node corresponding to the given Plan node.
 * ------------------------------------------------------------------------
 */</comment>
<function><type><name>PlanState</name> <modifier>*</modifier></type>
<name>ExecInitNode</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subps</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <comment type="block">/*
     * do nothing when we get to the end of a leaf on tree.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Make sure there's enough stack available. Need to check here, in
     * addition to ExecProcNode() (via ExecProcNodeFirst()), to ensure the
     * stack isn't overrun while initializing the node tree.
     */</comment>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
            <comment type="block">/*
             * control nodes
             */</comment>
        <case>case <expr><name>T_Result</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitResult</name><argument_list>(<argument><expr><operator>(</operator><name>Result</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ProjectSet</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitProjectSet</name><argument_list>(<argument><expr><operator>(</operator><name>ProjectSet</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                      <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ModifyTable</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitModifyTable</name><argument_list>(<argument><expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                       <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_Append</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitAppend</name><argument_list>(<argument><expr><operator>(</operator><name>Append</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_MergeAppend</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitMergeAppend</name><argument_list>(<argument><expr><operator>(</operator><name>MergeAppend</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                       <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_RecursiveUnion</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitRecursiveUnion</name><argument_list>(<argument><expr><operator>(</operator><name>RecursiveUnion</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                          <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_BitmapAnd</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitBitmapAnd</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapAnd</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                     <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_BitmapOr</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitBitmapOr</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapOr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                    <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

            <comment type="block">/*
             * scan nodes
             */</comment>
        <case>case <expr><name>T_SeqScan</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitSeqScan</name><argument_list>(<argument><expr><operator>(</operator><name>SeqScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

            <break>break;</break>

        <case>case <expr><name>T_SampleScan</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitSampleScan</name><argument_list>(<argument><expr><operator>(</operator><name>SampleScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                      <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_IndexScan</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>IndexScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                     <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitIndexOnlyScan</name><argument_list>(<argument><expr><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                         <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitBitmapIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapIndexScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                           <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitBitmapHeapScan</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapHeapScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                          <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_TidScan</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitTidScan</name><argument_list>(<argument><expr><operator>(</operator><name>TidScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SubqueryScan</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitSubqueryScan</name><argument_list>(<argument><expr><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                        <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_FunctionScan</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitFunctionScan</name><argument_list>(<argument><expr><operator>(</operator><name>FunctionScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                        <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_TableFuncScan</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitTableFuncScan</name><argument_list>(<argument><expr><operator>(</operator><name>TableFuncScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                         <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ValuesScan</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitValuesScan</name><argument_list>(<argument><expr><operator>(</operator><name>ValuesScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                      <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CteScan</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitCteScan</name><argument_list>(<argument><expr><operator>(</operator><name>CteScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitNamedTuplestoreScan</name><argument_list>(<argument><expr><operator>(</operator><name>NamedTuplestoreScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                               <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_WorkTableScan</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitWorkTableScan</name><argument_list>(<argument><expr><operator>(</operator><name>WorkTableScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                         <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ForeignScan</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitForeignScan</name><argument_list>(<argument><expr><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                       <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CustomScan</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitCustomScan</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                      <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

            <comment type="block">/*
             * join nodes
             */</comment>
        <case>case <expr><name>T_NestLoop</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitNestLoop</name><argument_list>(<argument><expr><operator>(</operator><name>NestLoop</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                    <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_MergeJoin</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitMergeJoin</name><argument_list>(<argument><expr><operator>(</operator><name>MergeJoin</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                     <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_HashJoin</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitHashJoin</name><argument_list>(<argument><expr><operator>(</operator><name>HashJoin</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                    <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

            <comment type="block">/*
             * materialization nodes
             */</comment>
        <case>case <expr><name>T_Material</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitMaterial</name><argument_list>(<argument><expr><operator>(</operator><name>Material</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                    <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_Sort</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitSort</name><argument_list>(<argument><expr><operator>(</operator><name>Sort</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_Group</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitGroup</name><argument_list>(<argument><expr><operator>(</operator><name>Group</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_Agg</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitAgg</name><argument_list>(<argument><expr><operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                               <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_WindowAgg</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitWindowAgg</name><argument_list>(<argument><expr><operator>(</operator><name>WindowAgg</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                     <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_Unique</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitUnique</name><argument_list>(<argument><expr><operator>(</operator><name>Unique</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_Gather</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitGather</name><argument_list>(<argument><expr><operator>(</operator><name>Gather</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_GatherMerge</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitGatherMerge</name><argument_list>(<argument><expr><operator>(</operator><name>GatherMerge</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                       <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_Hash</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitHash</name><argument_list>(<argument><expr><operator>(</operator><name>Hash</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SetOp</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitSetOp</name><argument_list>(<argument><expr><operator>(</operator><name>SetOp</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_LockRows</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitLockRows</name><argument_list>(<argument><expr><operator>(</operator><name>LockRows</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                    <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_Limit</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitLimit</name><argument_list>(<argument><expr><operator>(</operator><name>Limit</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <case>case <expr><name>T_RemoteQuery</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>RemoteQuery</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                        <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <case>case <expr><name>T_RemoteSubplan</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitRemoteSubplan</name><argument_list>(<argument><expr><operator>(</operator><name>RemoteSubplan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                         <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* XCP */</comment>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>        <comment type="block">/* keep compiler quiet */</comment>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/*
     * Add a wrapper around the ExecProcNode callback that checks stack depth
     * during the first execution.
     */</comment>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>ExecProcNodeReal</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>ExecProcNode</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecProcNodeFirst</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize any initPlans present in this node.  The planner put them in
     * a separate list for us.
     */</comment>
    <expr_stmt><expr><name>subps</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/*
     * If plan being initialized during we should skip doing initPlan here.
     * In case the plan is actually referenced on this step of the distributed
     * plan it will be done in ExecFinishInitProcNode
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_SUBPLAN</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;initPlan</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sstate</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sstate</name> <operator>=</operator> <call><name>ExecInitSubPlan</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>subps</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subps</name></expr></argument>, <argument><expr><name>sstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>initPlan</name></name> <operator>=</operator> <name>subps</name></expr>;</expr_stmt>

    <comment type="block">/* Set up instrumentation for this node if requested */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>instrument</name></name> <operator>=</operator> <call><name>InstrAlloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dn_instrument</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<comment type="block">/*
 * The subplan is referenced on local node, finish initialization
 */</comment>
<function><type><name>void</name></type>
<name>ExecFinishInitProcNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subps</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <comment type="block">/* Exit if we reached leaf of the tree */</comment>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Special cases */</comment>
    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_RemoteSubplanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecFinishInitRemoteSubplan</name><argument_list>(<argument><expr><operator>(</operator><name>RemoteSubplanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AppendState</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>AppendState</name>    <modifier>*</modifier></type><name>append</name> <init>= <expr><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>             <name>i</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>append</name><operator>-&gt;</operator><name>as_nplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecFinishInitProcNode</name><argument_list>(<argument><expr><name><name>append</name><operator>-&gt;</operator><name>appendplans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

            <break>break;</break>
        </block_content>}</block>

        <case>case <expr><name>T_MergeAppendState</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>MergeAppendState</name>    <modifier>*</modifier></type><name>mappend</name> <init>= <expr><operator>(</operator><name>MergeAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>             <name>i</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mappend</name><operator>-&gt;</operator><name>ms_nplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecFinishInitProcNode</name><argument_list>(<argument><expr><name><name>mappend</name><operator>-&gt;</operator><name>mergeplans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

            <break>break;</break>
        </block_content>}</block>

        <case>case <expr><name>T_SubqueryScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecFinishInitProcNode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SubqueryScanState</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/*
     * Common case, recurse the tree
     */</comment>
    <expr_stmt><expr><call><name>ExecFinishInitProcNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecFinishInitProcNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>subps</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;plan-&gt;initPlan</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sstate</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sstate</name> <operator>=</operator> <call><name>ExecInitSubPlan</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>subps</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subps</name></expr></argument>, <argument><expr><name>sstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>initPlan</name></name> <operator>=</operator> <name>subps</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * ExecProcNode wrapper that performs some one-time checks, before calling
 * the relevant node method (possibly via an instrumentation wrapper).
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecProcNodeFirst</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * Perform stack depth check during the first execution of the node.  We
     * only do so the first time round because it turns out to not be cheap on
     * some common architectures (eg. x86).  This relies on the assumption
     * that ExecProcNode calls for a given plan node will always be made at
     * roughly the same stack depth.
     */</comment>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If instrumentation is required, change the wrapper to one that just
     * does instrumentation.  Otherwise we can dispense with all wrappers and
     * have ExecProcNode() directly call the relevant function from now on.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecProcNodeInstr</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ExecProcNode</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ExecProcNodeReal</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <return>return <expr><call><name><name>node</name><operator>-&gt;</operator><name>ExecProcNode</name></name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecProcNode wrapper that performs instrumentation calls.  By keeping
 * this a separate function, we avoid overhead in the normal case where
 * no instrumentation is wanted.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecProcNodeInstr</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>InstrStartNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>node</name><operator>-&gt;</operator><name>ExecProcNodeReal</name></name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>InstrStopNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0.0</literal></expr> </then><else>: <expr><literal type="number">1.0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *        MultiExecProcNode
 *
 *        Execute a node that doesn't return individual tuples
 *        (it might return a hashtable, bitmap, etc).  Caller should
 *        check it got back the expected kind of Node.
 *
 * This has essentially the same responsibilities as ExecProcNode,
 * but it does not do InstrStartNode/InstrStopNode (mainly because
 * it can't tell how many returned tuples to count).  Each per-node
 * function must provide its own instrumentation support.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>MultiExecProcNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* something changed */</comment>
        <expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>        <comment type="block">/* let ReScan handle this */</comment>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
            <comment type="block">/*
             * Only node types that actually support multiexec will be listed
             */</comment>

        <case>case <expr><name>T_HashState</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MultiExecHash</name><argument_list>(<argument><expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_BitmapIndexScanState</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MultiExecBitmapIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapIndexScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_BitmapAndState</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MultiExecBitmapAnd</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapAndState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_BitmapOrState</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MultiExecBitmapOr</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapOrState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *        ExecEndNode
 *
 *        Recursively cleans up all the nodes in the plan rooted
 *        at 'node'.
 *
 *        After this operation, the query plan will not be able to be
 *        processed any further.  This should be called only after
 *        the query plan has been fully executed.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/*
     * do nothing when we get to the end of a leaf on tree.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Make sure there's enough stack available. Need to check here, in
     * addition to ExecProcNode() (via ExecProcNodeFirst()), because it's not
     * guaranteed that ExecProcNode() is reached for all nodes.
     */</comment>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
            <comment type="block">/*
             * control nodes
             */</comment>
        <case>case <expr><name>T_ResultState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndResult</name><argument_list>(<argument><expr><operator>(</operator><name>ResultState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ProjectSetState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndProjectSet</name><argument_list>(<argument><expr><operator>(</operator><name>ProjectSetState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ModifyTableState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndModifyTable</name><argument_list>(<argument><expr><operator>(</operator><name>ModifyTableState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AppendState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndAppend</name><argument_list>(<argument><expr><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_MergeAppendState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndMergeAppend</name><argument_list>(<argument><expr><operator>(</operator><name>MergeAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_RecursiveUnionState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndRecursiveUnion</name><argument_list>(<argument><expr><operator>(</operator><name>RecursiveUnionState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_BitmapAndState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndBitmapAnd</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapAndState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_BitmapOrState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndBitmapOr</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapOrState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

            <comment type="block">/*
             * scan nodes
             */</comment>
        <case>case <expr><name>T_SeqScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndSeqScan</name><argument_list>(<argument><expr><operator>(</operator><name>SeqScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SampleScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndSampleScan</name><argument_list>(<argument><expr><operator>(</operator><name>SampleScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_GatherState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndGather</name><argument_list>(<argument><expr><operator>(</operator><name>GatherState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_GatherMergeState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndGatherMerge</name><argument_list>(<argument><expr><operator>(</operator><name>GatherMergeState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_IndexScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>IndexScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_IndexOnlyScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndIndexOnlyScan</name><argument_list>(<argument><expr><operator>(</operator><name>IndexOnlyScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_BitmapIndexScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndBitmapIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapIndexScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_BitmapHeapScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndBitmapHeapScan</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapHeapScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_TidScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndTidScan</name><argument_list>(<argument><expr><operator>(</operator><name>TidScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SubqueryScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndSubqueryScan</name><argument_list>(<argument><expr><operator>(</operator><name>SubqueryScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_FunctionScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndFunctionScan</name><argument_list>(<argument><expr><operator>(</operator><name>FunctionScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_TableFuncScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndTableFuncScan</name><argument_list>(<argument><expr><operator>(</operator><name>TableFuncScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ValuesScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndValuesScan</name><argument_list>(<argument><expr><operator>(</operator><name>ValuesScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CteScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndCteScan</name><argument_list>(<argument><expr><operator>(</operator><name>CteScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_NamedTuplestoreScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndNamedTuplestoreScan</name><argument_list>(<argument><expr><operator>(</operator><name>NamedTuplestoreScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_WorkTableScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndWorkTableScan</name><argument_list>(<argument><expr><operator>(</operator><name>WorkTableScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ForeignScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndForeignScan</name><argument_list>(<argument><expr><operator>(</operator><name>ForeignScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CustomScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndCustomScan</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

            <comment type="block">/*
             * join nodes
             */</comment>
        <case>case <expr><name>T_NestLoopState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndNestLoop</name><argument_list>(<argument><expr><operator>(</operator><name>NestLoopState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_MergeJoinState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndMergeJoin</name><argument_list>(<argument><expr><operator>(</operator><name>MergeJoinState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_HashJoinState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndHashJoin</name><argument_list>(<argument><expr><operator>(</operator><name>HashJoinState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

            <comment type="block">/*
             * materialization nodes
             */</comment>
        <case>case <expr><name>T_MaterialState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndMaterial</name><argument_list>(<argument><expr><operator>(</operator><name>MaterialState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SortState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndSort</name><argument_list>(<argument><expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_GroupState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndGroup</name><argument_list>(<argument><expr><operator>(</operator><name>GroupState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AggState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndAgg</name><argument_list>(<argument><expr><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_WindowAggState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndWindowAgg</name><argument_list>(<argument><expr><operator>(</operator><name>WindowAggState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_UniqueState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndUnique</name><argument_list>(<argument><expr><operator>(</operator><name>UniqueState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_HashState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndHash</name><argument_list>(<argument><expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SetOpState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndSetOp</name><argument_list>(<argument><expr><operator>(</operator><name>SetOpState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_LockRowsState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndLockRows</name><argument_list>(<argument><expr><operator>(</operator><name>LockRowsState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_LimitState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndLimit</name><argument_list>(<argument><expr><operator>(</operator><name>LimitState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <case>case <expr><name>T_RemoteQueryState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>RemoteQueryState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <case>case <expr><name>T_RemoteSubplanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecEndRemoteSubplan</name><argument_list>(<argument><expr><operator>(</operator><name>RemoteSubplanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* XCP */</comment>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * ExecShutdownNode
 *
 * Give execution nodes a chance to stop asynchronous resource consumption
 * and release any resources still held.  Currently, this is only used for
 * parallel query, but we might want to extend it to other cases also (e.g.
 * FDW).  We might also want to call it sooner, as soon as it's evident that
 * no more rows will be needed (e.g. when a Limit is filled) rather than only
 * at the end of ExecutorRun.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecShutdownNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ExecShutdownNode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_GatherState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecShutdownGather</name><argument_list>(<argument><expr><operator>(</operator><name>GatherState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_ForeignScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecShutdownForeignScan</name><argument_list>(<argument><expr><operator>(</operator><name>ForeignScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_CustomScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecShutdownCustomScan</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_GatherMergeState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecShutdownGatherMerge</name><argument_list>(<argument><expr><operator>(</operator><name>GatherMergeState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
		<case>case <expr><name>T_RemoteSubplanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecShutdownRemoteSubplan</name><argument_list>(<argument><expr><operator>(</operator><name>RemoteSubplanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecShutdownHash</name><argument_list>(<argument><expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>ExecDisconnectNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>ps</name> <init>= <expr><name>node</name></expr></init></decl>;</decl_stmt>
        
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubqueryScanState</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SubqueryScanState</name> <modifier>*</modifier></type><name>substate</name> <init>= <expr><operator>(</operator><name>SubqueryScanState</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>ps</name> <operator>=</operator> <name><name>substate</name><operator>-&gt;</operator><name>subplan</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_RemoteSubplanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecDisconnectRemoteSubplan</name><argument_list>(<argument><expr><operator>(</operator><name>RemoteSubplanState</name> <operator>*</operator><operator>)</operator> <name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        <case>case <expr><name>T_AppendState</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AppendState</name>    <modifier>*</modifier></type><name>append</name> <init>= <expr><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>ps</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>             <name>i</name></decl>;</decl_stmt>

                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>append</name><operator>-&gt;</operator><name>as_nplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ExecDisconnectNode</name><argument_list>(<argument><expr><name><name>append</name><operator>-&gt;</operator><name>appendplans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>

                <return>return;</return>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_MergeAppendState</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>MergeAppendState</name> <modifier>*</modifier></type><name>mstate</name> <init>= <expr><operator>(</operator><name>MergeAppendState</name> <operator>*</operator><operator>)</operator> <name>ps</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mstate</name><operator>-&gt;</operator><name>ms_nplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ExecDisconnectNode</name><argument_list>(<argument><expr><name><name>mstate</name><operator>-&gt;</operator><name>mergeplans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>

                <return>return;</return>
            </block_content>}</block>
            <break>break;</break>
        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>ExecDisconnectNode</name><argument_list>(<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecDisconnectNode</name><argument_list>(<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>bool</name></type>
<name>HasDisconnectNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>ps</name> <init>= <expr><name>node</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteSubplanState</name> <modifier>*</modifier></type><name>remotesubplan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubqueryScanState</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SubqueryScanState</name> <modifier>*</modifier></type><name>substate</name> <init>= <expr><operator>(</operator><name>SubqueryScanState</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>ps</name> <operator>=</operator> <name><name>substate</name><operator>-&gt;</operator><name>subplan</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_RemoteSubplanState</name></expr>:</case>
        <block>{<block_content>
            <expr_stmt><expr><name>remotesubplan</name> <operator>=</operator> <operator>(</operator><name>RemoteSubplanState</name> <operator>*</operator><operator>)</operator> <name>ps</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>remotesubplan</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_DISCONN</name></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block>

        <case>case <expr><name>T_AppendState</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>AppendState</name>    <modifier>*</modifier></type><name>append</name> <init>= <expr><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>ps</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> 			<name>i</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>append</name><operator>-&gt;</operator><name>as_nplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>HasDisconnectNode</name><argument_list>(<argument><expr><name><name>append</name><operator>-&gt;</operator><name>appendplans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <return>return <expr><name>true</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block>

        <case>case <expr><name>T_MergeAppendState</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>MergeAppendState</name> <modifier>*</modifier></type><name>mstate</name> <init>= <expr><operator>(</operator><name>MergeAppendState</name> <operator>*</operator><operator>)</operator> <name>ps</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mstate</name><operator>-&gt;</operator><name>ms_nplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>HasDisconnectNode</name><argument_list>(<argument><expr><name><name>mstate</name><operator>-&gt;</operator><name>mergeplans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <return>return <expr><name>true</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block>

        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><call><name>HasDisconnectNode</name><argument_list>(<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>HasDisconnectNode</name><argument_list>(<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecFinishNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>ps</name> <init>= <expr><name>node</name></expr></init></decl>;</decl_stmt>
        
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubqueryScanState</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SubqueryScanState</name> <modifier>*</modifier></type><name>substate</name> <init>= <expr><operator>(</operator><name>SubqueryScanState</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>ps</name> <operator>=</operator> <name><name>substate</name><operator>-&gt;</operator><name>subplan</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_RemoteSubplanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecFinishRemoteSubplan</name><argument_list>(<argument><expr><operator>(</operator><name>RemoteSubplanState</name> <operator>*</operator><operator>)</operator> <name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        <case>case <expr><name>T_GatherState</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>GatherState</name> <modifier>*</modifier></type><name>gatherState</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GatherState</name></expr></argument>, <argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Gather</name>        <modifier>*</modifier></type><name>gather</name> <init>= <expr><operator>(</operator><name>Gather</name> <operator>*</operator><operator>)</operator> <name><name>gatherState</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gather</name><operator>-&gt;</operator><name>parallelWorker_sendTuple</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ExecFinishGather</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <return>return;</return>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* parallel worker send data */</comment>
                    <return>return;</return>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>T_GatherMergeState</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ExecFinishGatherMerge</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>T_AppendState</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AppendState</name>    <modifier>*</modifier></type><name>append</name> <init>= <expr><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>ps</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>             <name>i</name></decl>;</decl_stmt>

                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>append</name><operator>-&gt;</operator><name>as_nplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ExecFinishNode</name><argument_list>(<argument><expr><name><name>append</name><operator>-&gt;</operator><name>appendplans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>

                <return>return;</return>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_MergeAppendState</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>MergeAppendState</name> <modifier>*</modifier></type><name>mstate</name> <init>= <expr><operator>(</operator><name>MergeAppendState</name> <operator>*</operator><operator>)</operator> <name>ps</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mstate</name><operator>-&gt;</operator><name>ms_nplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ExecFinishNode</name><argument_list>(<argument><expr><name><name>mstate</name><operator>-&gt;</operator><name>mergeplans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>

                <return>return;</return>
            </block_content>}</block>
            <break>break;</break>
		<case>case <expr><name>T_LimitState</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[LIMITSTATE]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>ExecFinishNode</name><argument_list>(<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecFinishNode</name><argument_list>(<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
