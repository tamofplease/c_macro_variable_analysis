<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/executor/nodeIndexonlyscan.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeIndexonlyscan.c
 *      Routines to support index-only scans
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/executor/nodeIndexonlyscan.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 * INTERFACE ROUTINES
 *        ExecIndexOnlyScan            scans an index
 *        IndexOnlyNext                retrieve next tuple
 *        ExecInitIndexOnlyScan        creates and initializes state info.
 *        ExecReScanIndexOnlyScan        rescans the indexed relation.
 *        ExecEndIndexOnlyScan        releases all storage.
 *        ExecIndexOnlyMarkPos        marks scan position.
 *        ExecIndexOnlyRestrPos        restores scan position.
 *        ExecIndexOnlyScanEstimate    estimates DSM space needed for
 *                        parallel index-only scan
 *        ExecIndexOnlyScanInitializeDSM    initialize DSM for parallel
 *                        index-only scan
 *		ExecIndexOnlyScanReInitializeDSM	reinitialize DSM for fresh scan
 *        ExecIndexOnlyScanInitializeWorker attach to DSM info in parallel worker
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/visibilitymap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeIndexonlyscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeIndexscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/mls.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"audit/audit_fga.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>IndexOnlyNext</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StoreIndexTuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>,
                <parameter><decl><type><name>TupleDesc</name></type> <name>itupdesc</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------------------------------------------------------------
 *        IndexOnlyNext
 *
 *        Retrieve a tuple from the IndexOnlyScan node's index.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>IndexOnlyNext</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>EState</name>       <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanDirection</name></type> <name>direction</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>scandesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ItemPointer</name></type> <name>tid</name></decl>;</decl_stmt>

    <comment type="block">/*
     * extract necessary information from index scan node
     */</comment>
    <expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>direction</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name></expr>;</expr_stmt>
    <comment type="block">/* flip direction if this is an overall backward scan */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>indexorderdir</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>direction</name> <operator>=</operator> <name>BackwardScanDirection</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>direction</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>scandesc</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>scandesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We reach here if the index only scan is not parallel, or if we're
         * executing a index only scan that was intended to be parallel
         * serially.
         */</comment>
        <expr_stmt><expr><name>scandesc</name> <operator>=</operator> <call><name>index_beginscan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>,
                                   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_RelationDesc</name></name></expr></argument>,
                                   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>,
                                   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumScanKeys</name></name></expr></argument>,
                                   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumOrderByKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name> <operator>=</operator> <name>scandesc</name></expr>;</expr_stmt>


        <comment type="block">/* Set it up for index-only scan */</comment>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name><operator>-&gt;</operator><name>xs_want_itup</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_VMBuffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>

        <comment type="block">/*
         * If no run-time keys to calculate or they are ready, go ahead and
         * pass the scankeys to the index AM.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumRuntimeKeys</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>ioss_RuntimeKeysReady</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>,
                         <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanKeys</name></name></expr></argument>,
                         <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumScanKeys</name></name></expr></argument>,
                         <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_OrderByKeys</name></name></expr></argument>,
                         <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumOrderByKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * OK, now that we have what we need, fetch the next tuple.
     */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>tid</name> <operator>=</operator> <call><name>index_getnext_tid</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We can skip the heap fetch if the TID references a heap page on
         * which all tuples are known visible to everybody.  In any case,
         * we'll use the index tuple not the heap tuple as the data source.
         *
         * Note on Memory Ordering Effects: visibilitymap_get_status does not
         * lock the visibility map buffer, and therefore the result we read
         * here could be slightly stale.  However, it can't be stale enough to
         * matter.
         *
         * We need to detect clearing a VM bit due to an insert right away,
         * because the tuple is present in the index page but not visible. The
         * reading of the TID by this scan (using a shared lock on the index
         * buffer) is serialized with the insert of the TID into the index
         * (using an exclusive lock on the index buffer). Because the VM bit
         * is cleared before updating the index, and locking/unlocking of the
         * index page acts as a full memory barrier, we are sure to see the
         * cleared bit if we see a recently-inserted TID.
         *
         * Deletes do not update the index page (only VACUUM will clear out
         * the TID), so the clearing of the VM bit by a delete is not
         * serialized with this test below, and we may see a value that is
         * significantly stale. However, we don't care about the delete right
         * away, because the tuple is still visible until the deleting
         * transaction commits or the statement ends (if it's our
         * transaction). In either case, the lock on the VM buffer will have
         * been released (acting as a write barrier) after clearing the bit.
         * And for us to have a snapshot that includes the deleting
         * transaction (making the tuple invisible), we must have acquired
         * ProcArrayLock after that time, acting as a read barrier.
         *
         * It's worth going through this complexity to avoid needing to lock
         * the VM buffer, which could cause significant contention.
         */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VM_ALL_VISIBLE</name><argument_list>(<argument><expr><name><name>scandesc</name><operator>-&gt;</operator><name>heapRelation</name></name></expr></argument>,
                            <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ioss_VMBuffer</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>NeedMvcc</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VM_ALL_VISIBLE</name><argument_list>(<argument><expr><name><name>scandesc</name><operator>-&gt;</operator><name>heapRelation</name></name></expr></argument>,
                            <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ioss_VMBuffer</name></name></expr></argument>)</argument_list></call></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <block>{<block_content>
            <comment type="block">/*
             * Rats, we have to visit the heap to check visibility.
             */</comment>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_HeapFetches</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>index_fetch_heap</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>        <comment type="block">/* no visible tuple, try next index entry */</comment>

            <comment type="block">/*
             * Only MVCC snapshots are supported here, so there should be no
             * need to keep following the HOT chain once a visible entry has
             * been found.  If we did want to allow that, we'd need to keep
             * more state to remember not to call index_getnext_tid next time.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_continue_hot</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"non-MVCC snapshots are not supported in index-only scans"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Note: at this point we are holding a pin on the heap page, as
             * recorded in scandesc-&gt;xs_cbuf.  We could release that pin now,
             * but it's not clear whether it's a win to do so.  The next index
             * entry might require a visit to the same heap page.
             */</comment>
        </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Fill the scan tuple slot with data from the index.  This might be
         * provided in either HeapTuple or IndexTuple format.  Conceivably an
         * index AM might fill both fields, in which case we prefer the heap
         * format, since it's probably a bit cheaper to fill a slot from.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_hitup</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We don't take the trouble to verify that the provided tuple has
             * exactly the slot's format, but it seems worth doing a quick
             * check on the number of fields.
             */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name> <operator>==</operator>
                   <name><name>scandesc</name><operator>-&gt;</operator><name>xs_hitupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_hitup</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_itup</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>StoreIndexTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_itup</name></name></expr></argument>, <argument><expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_itupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no data returned for index-only scan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * If the index was lossy, we have to recheck the index quals.
         * (Currently, this can never happen, but we should support the case
         * for possible future use, eg with GiST indexes.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>scandesc</name><operator>-&gt;</operator><name>xs_recheck</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Fails recheck, so drop it and loop back for another */</comment>
                <expr_stmt><expr><call><name>InstrCountFiltered2</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * We don't currently support rechecking ORDER BY distances.  (In
         * principle, if the index can support retrieval of the originally
         * indexed value, it should be able to produce an exact distance
         * calculation too.  So it's not clear that adding code here for
         * recheck/re-sort would be worth the trouble.  But we should at least
         * throw an error if someone tries it.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>scandesc</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>scandesc</name><operator>-&gt;</operator><name>xs_recheckorderby</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lossy distance functions are not supported in index-only scans"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Predicate locks for index-only scans must be acquired at the page
         * level when the heap is not accessed, since tuple-level predicate
         * locks need the tuple's xmin value.  If we had to visit the tuple
         * anyway, then we already have the tuple-level lock and can skip the
         * page lock.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PredicateLockPage</name><argument_list>(<argument><expr><name><name>scandesc</name><operator>-&gt;</operator><name>heapRelation</name></name></expr></argument>,
                              <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <return>return <expr><name>slot</name></expr>;</return>
    </block_content>}</block></while>

    <comment type="block">/*
     * if we get here it means the index scan failed so we are at the end of
     * the scan..
     */</comment>
    <return>return <expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * StoreIndexTuple
 *        Fill the slot with data from the index tuple.
 *
 * At some point this might be generally-useful functionality, but
 * right now we don't need it elsewhere.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StoreIndexTuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>itupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>nindexatts</name> <init>= <expr><name><name>itupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>values</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>isnull</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Note: we must use the tupdesc supplied by the AM in index_getattr, not
     * the slot's tupdesc, in case the latter has different datatypes (this
     * happens for btree name_ops in particular).  They'd better have the same
     * number of columns though, as well as being datatype-compatible which is
     * something we can't so easily check.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name> <operator>==</operator> <name>nindexatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nindexatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>itupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * IndexOnlyRecheck -- access method routine to recheck a tuple in EvalPlanQual
 *
 * This can't really happen, since an index can't supply CTID which would
 * be necessary data for any potential EvalPlanQual target relation.  If it
 * did happen, the EPQ code would pass us the wrong data, namely a heap
 * tuple not an index tuple.  So throw an error.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IndexOnlyRecheck</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"EvalPlanQual recheck is not supported in index-only scans"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>                <comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecIndexOnlyScan(node)
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecIndexOnlyScan</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>IndexOnlyScanState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * If we have runtime keys and they've not already been set up, do it now.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumRuntimeKeys</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>ioss_RuntimeKeysReady</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><call><name>ExecScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>,
                    <argument><expr><operator>(</operator><name>ExecScanAccessMtd</name><operator>)</operator> <name>IndexOnlyNext</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>ExecScanRecheckMtd</name><operator>)</operator> <name>IndexOnlyRecheck</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecReScanIndexOnlyScan(node)
 *
 *        Recalculates the values of any scan keys whose value depends on
 *        information known at runtime, then rescans the indexed relation.
 *
 *        Updating the scan key was formerly done separately in
 *        ExecUpdateIndexScanKeys. Integrating it into ReScan makes
 *        rescans of indices and relations/general streams more uniform.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecReScanIndexOnlyScan</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * If we are doing runtime key calculations (ie, any of the index key
     * values weren't simple Consts), compute the new key values.  But first,
     * reset the context so we don't leak memory as each outer tuple is
     * scanned.  Note this assumes that we will recalculate *all* runtime keys
     * on each call.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumRuntimeKeys</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ioss_RuntimeContext</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExecIndexEvalRuntimeKeys</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>,
                                 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_RuntimeKeys</name></name></expr></argument>,
                                 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumRuntimeKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_RuntimeKeysReady</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/* reset index scan */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name></expr></argument>,
                     <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanKeys</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumScanKeys</name></name></expr></argument>,
                     <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_OrderByKeys</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumOrderByKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>ExecScanReScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *        ExecEndIndexOnlyScan
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndIndexOnlyScan</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>indexRelationDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>indexScanDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>relation</name></decl>;</decl_stmt>

    <comment type="block">/*
     * extract information from the node
     */</comment>
    <expr_stmt><expr><name>indexRelationDesc</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ioss_RelationDesc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>indexScanDesc</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>relation</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr>;</expr_stmt>

    <comment type="block">/* Release VM buffer pin, if any. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ioss_VMBuffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_VMBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_VMBuffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Free the exprcontext(s) ... now dead code, see ExecFreeExprContext
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
    <expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ioss_RuntimeContext</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FreeExprContext</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_RuntimeContext</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * clear out tuple table slots
     */</comment>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * close the index relation (no-op if we didn't open it)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>indexScanDesc</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>index_endscan</name><argument_list>(<argument><expr><name>indexScanDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>indexRelationDesc</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRelationDesc</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * close the heap relation.
     */</comment>
    <expr_stmt><expr><call><name>ExecCloseScanRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecIndexOnlyMarkPos
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecIndexOnlyMarkPos</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>index_markpos</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecIndexOnlyRestrPos
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecIndexOnlyRestrPos</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>index_restrpos</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecInitIndexOnlyScan
 *
 *        Initializes the index scan's state information, creates
 *        scan keys, and opens the base and index relations.
 *
 *        Note: index scans have 2 sets of state information because
 *              we have to keep track of the base relation and the
 *              index relation.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type>
<name>ExecInitIndexOnlyScan</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>indexstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>currentRelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>relistarget</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupDesc</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>ListCell</name>      <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

    <comment type="block">/*
     * create state structure
     */</comment>
    <expr_stmt><expr><name>indexstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexOnlyScanState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecIndexOnlyScan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_HeapFetches</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Miscellaneous initialization
     *
     * create expression context for node
     */</comment>
    <expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * initialize child expressions
     *
     * Note: we don't initialize all of the indexorderby expression, only the
     * sub-parts corresponding to runtime keys (see below).
     */</comment>
    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
        <call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>indexstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>indexqual</name></name> <operator>=</operator>
        <call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>indexstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>enable_fga</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>foreach</name> <argument_list>(<argument>item</argument>, <argument>node-&gt;scan.plan.audit_fga_quals</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>AuditFgaPolicy</name> <modifier>*</modifier></type><name>audit_fga_qual</name> <init>= <expr><operator>(</operator><name>AuditFgaPolicy</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            
            <decl_stmt><decl><type><name>audit_fga_policy_state</name> <modifier>*</modifier></type> <name>audit_fga_policy_state_item</name>
                    <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>audit_fga_policy_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>audit_fga_policy_state_item</name><operator>-&gt;</operator><name>policy_name</name></name> <operator>=</operator> <name><name>audit_fga_qual</name><operator>-&gt;</operator><name>policy_name</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>audit_fga_policy_state_item</name><operator>-&gt;</operator><name>query_string</name></name> <operator>=</operator> <name><name>audit_fga_qual</name><operator>-&gt;</operator><name>query_string</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>audit_fga_policy_state_item</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> 
                <call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>audit_fga_qual</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>indexstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>audit_fga_qual</name></name> <operator>=</operator> 
                <call><name>lappend</name><argument_list>(<argument><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>audit_fga_qual</name></name></expr></argument>, <argument><expr><name>audit_fga_policy_state_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>      
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>     

    <comment type="block">/*
     * tuple table initialization
     */</comment>
    <expr_stmt><expr><call><name>ExecInitResultTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecInitScanTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * open the base relation and acquire appropriate lock on it.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>ispartchild</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>currentRelation</name> <operator>=</operator> <call><name>ExecOpenScanRelationPartition</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                                                <argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></argument>,
                                                <argument><expr><name>eflags</name></expr></argument>,
                                                <argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>childidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>currentRelation</name> <operator>=</operator> <call><name>ExecOpenScanRelation</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <expr_stmt><expr><call><name>mls_check_datamask_need_passby</name><argument_list>(<argument><expr><operator>(</operator><name>ScanState</name><operator>*</operator><operator>)</operator><name>indexstate</name></expr></argument>, <argument><expr><name><name>currentRelation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name> <operator>=</operator> <name>currentRelation</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentScanDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>    <comment type="block">/* no heap scan here */</comment>

    <comment type="block">/*
     * Build the scan tuple type using the indextlist generated by the
     * planner.  We use this, rather than the index's physical tuple
     * descriptor, because the latter contains storage column types not the
     * types of the original datums.  (It's the AM's responsibility to return
     * suitable data anyway.)
     */</comment>
    <expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>ExecTypeFromTL</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>indextlist</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
	<expr_stmt><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>tdatamask</name></name> <operator>=</operator> <name><name>currentRelation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdatamask</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>ExecAssignScanType</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize result tuple type and projection info.  The node's
     * targetlist will contain Vars with varno = INDEX_VAR, referencing the
     * scan tuple.
     */</comment>
    <expr_stmt><expr><call><name>ExecAssignResultTypeFromTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecAssignScanProjectionInfoWithVarno</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>, <argument><expr><name>INDEX_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we are just doing EXPLAIN (ie, aren't going to run the plan), stop
     * here.  This allows an index-advisor plugin to EXPLAIN a plan containing
     * references to nonexistent indexes.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>indexstate</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Open the index relation.
     *
     * If the parent table is one of the target relations of the query, then
     * InitPlan already opened and write-locked the index, so we can avoid
     * taking another lock here.  Otherwise we need a normal reader's lock.
     */</comment>
    <expr_stmt><expr><name>relistarget</name> <operator>=</operator> <call><name>ExecRelationIsTargetRelation</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_RelationDesc</name></name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexid</name></name></expr></argument>,
                                               <argument><expr><ternary><condition><expr><name>relistarget</name></expr> ?</condition><then> <expr><name>NoLock</name></expr> </then><else>: <expr><name>AccessShareLock</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize index-specific scan state
     */</comment>
    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_RuntimeKeysReady</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_RuntimeKeys</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_NumRuntimeKeys</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * build the index scan keys from the index qualification
     */</comment>
    <expr_stmt><expr><call><name>ExecIndexBuildScanKeys</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>indexstate</name></expr></argument>,
                           <argument><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_RelationDesc</name></name></expr></argument>,
                           <argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>,
                           <argument><expr><name>false</name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_ScanKeys</name></name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_NumScanKeys</name></name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_RuntimeKeys</name></name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_NumRuntimeKeys</name></name></expr></argument>,
                           <argument><expr><name>NULL</name></expr></argument>,    <comment type="block">/* no ArrayKeys */</comment>
                           <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * any ORDER BY exprs have to be turned into scankeys in the same way
     */</comment>
    <expr_stmt><expr><call><name>ExecIndexBuildScanKeys</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>indexstate</name></expr></argument>,
                           <argument><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_RelationDesc</name></name></expr></argument>,
                           <argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexorderby</name></name></expr></argument>,
                           <argument><expr><name>true</name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_OrderByKeys</name></name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_NumOrderByKeys</name></name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_RuntimeKeys</name></name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_NumRuntimeKeys</name></name></expr></argument>,
                           <argument><expr><name>NULL</name></expr></argument>,    <comment type="block">/* no ArrayKeys */</comment>
                           <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we have runtime keys, we need an ExprContext to evaluate them. The
     * node's standard context won't do because we want to reset that context
     * for every tuple.  So, build another context just like the other one...
     * -tgl 7/11/00
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_NumRuntimeKeys</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>stdecontext</name> <init>= <expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_RuntimeContext</name></name> <operator>=</operator> <name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name> <operator>=</operator> <name>stdecontext</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>indexstate</name><operator>-&gt;</operator><name>ioss_RuntimeContext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * all done.
     */</comment>
    <return>return <expr><name>indexstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        Parallel Index-only Scan Support
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecIndexOnlyScanEstimate
 *
 *    estimates the space required to serialize index-only scan node.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecIndexOnlyScanEstimate</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                          <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EState</name>       <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_PscanLen</name></name> <operator>=</operator> <call><name>index_parallelscan_estimate</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_RelationDesc</name></name></expr></argument>,
                                                      <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_PscanLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecIndexOnlyScanInitializeDSM
 *
 *        Set up a parallel index-only scan descriptor.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecIndexOnlyScanInitializeDSM</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                               <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EState</name>       <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelIndexScanDesc</name></type> <name>piscan</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>piscan</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_PscanLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>index_parallelscan_initialize</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>,
                                  <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_RelationDesc</name></name></expr></argument>,
                                  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>,
                                  <argument><expr><name>piscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>, <argument><expr><name>piscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name> <operator>=</operator>
        <call><name>index_beginscan_parallel</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>,
                                 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_RelationDesc</name></name></expr></argument>,
                                 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumScanKeys</name></name></expr></argument>,
                                 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumOrderByKeys</name></name></expr></argument>,
                                 <argument><expr><name>piscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name><operator>-&gt;</operator><name>xs_want_itup</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_VMBuffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>

    <comment type="block">/*
     * If no run-time keys to calculate or they are ready, go ahead and pass
     * the scankeys to the index AM.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumRuntimeKeys</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>ioss_RuntimeKeysReady</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name></expr></argument>,
                     <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanKeys</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumScanKeys</name></name></expr></argument>,
                     <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_OrderByKeys</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumOrderByKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecIndexOnlyScanReInitializeDSM
 *
 *		Reset shared state before beginning a fresh scan.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecIndexOnlyScanReInitializeDSM</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
								 <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>index_parallelrescan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecIndexOnlyScanInitializeWorker
 *
 *        Copy relevant information from TOC into planstate.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecIndexOnlyScanInitializeWorker</name><parameter_list>(<parameter><decl><type><name>IndexOnlyScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
								  <parameter><decl><type><name>ParallelWorkerContext</name> <modifier>*</modifier></type><name>pwcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParallelIndexScanDesc</name></type> <name>piscan</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>piscan</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name><name>pwcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name> <operator>=</operator>
        <call><name>index_beginscan_parallel</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>,
                                 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_RelationDesc</name></name></expr></argument>,
                                 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumScanKeys</name></name></expr></argument>,
                                 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumOrderByKeys</name></name></expr></argument>,
                                 <argument><expr><name>piscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name><operator>-&gt;</operator><name>xs_want_itup</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/*
     * If no run-time keys to calculate or they are ready, go ahead and pass
     * the scankeys to the index AM.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumRuntimeKeys</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>ioss_RuntimeKeysReady</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanDesc</name></name></expr></argument>,
                     <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_ScanKeys</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumScanKeys</name></name></expr></argument>,
                     <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_OrderByKeys</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ioss_NumOrderByKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
