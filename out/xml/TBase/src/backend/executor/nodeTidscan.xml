<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/executor/nodeTidscan.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeTidscan.c
 *      Routines to support direct tid scans of relations
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/executor/nodeTidscan.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 * INTERFACE ROUTINES
 *
 *        ExecTidScan            scans a relation using tids
 *        ExecInitTidScan        creates and initializes state info.
 *        ExecReScanTidScan    rescans the tid relation.
 *        ExecEndTidScan        releases all storage.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeTidscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/mls.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"audit/audit_fga.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IsCTIDVar</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro>  \
    <cpp:value>((node) != NULL &amp;&amp; \
     IsA((node), Var) &amp;&amp; \
     ((Var *) (node))-&gt;varattno == SelfItemPointerAttributeNumber &amp;&amp; \
     ((Var *) (node))-&gt;varlevelsup == 0)</cpp:value></cpp:define>

<comment type="block">/* one element in tss_tidexprs */</comment>
<typedef>typedef <type><struct>struct <name>TidExpr</name>
<block>{
    <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>exprstate</name></decl>;</decl_stmt>        <comment type="block">/* ExprState for a TID-yielding subexpr */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isarray</name></decl>;</decl_stmt>        <comment type="block">/* if true, it yields tid[] not just tid */</comment>
    <decl_stmt><decl><type><name>CurrentOfExpr</name> <modifier>*</modifier></type><name>cexpr</name></decl>;</decl_stmt>        <comment type="block">/* alternatively, we can have CURRENT OF */</comment>
}</block></struct></type> <name>TidExpr</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TidExprListCreate</name><parameter_list>(<parameter><decl><type><name>TidScanState</name> <modifier>*</modifier></type><name>tidstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TidListEval</name><parameter_list>(<parameter><decl><type><name>TidScanState</name> <modifier>*</modifier></type><name>tidstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>itemptr_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>TidNext</name><parameter_list>(<parameter><decl><type><name>TidScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Extract the qual subexpressions that yield TIDs to search for,
 * and compile them into ExprStates if they're ordinary expressions.
 *
 * CURRENT OF is a special case that we can't compile usefully;
 * just drop it into the TidExpr list as-is.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TidExprListCreate</name><parameter_list>(<parameter><decl><type><name>TidScanState</name> <modifier>*</modifier></type><name>tidstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TidScan</name>    <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>TidScan</name> <operator>*</operator><operator>)</operator> <name><name>tidstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>tidstate</name><operator>-&gt;</operator><name>tss_tidexprs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tidstate</name><operator>-&gt;</operator><name>tss_isCurrentOf</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;tidquals</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TidExpr</name>    <modifier>*</modifier></type><name>tidexpr</name> <init>= <expr><operator>(</operator><name>TidExpr</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TidExpr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>is_opclause</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>arg1</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>arg2</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>arg1</name> <operator>=</operator> <call><name>get_leftop</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>arg2</name> <operator>=</operator> <call><name>get_rightop</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>IsCTIDVar</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>tidexpr</name><operator>-&gt;</operator><name>exprstate</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>arg2</name></expr></argument>,
                                                  <argument><expr><operator>&amp;</operator><name><name>tidstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><call><name>IsCTIDVar</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>tidexpr</name><operator>-&gt;</operator><name>exprstate</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>arg1</name></expr></argument>,
                                                  <argument><expr><operator>&amp;</operator><name><name>tidstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not identify CTID variable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><name><name>tidexpr</name><operator>-&gt;</operator><name>isarray</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>saex</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsCTIDVar</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>saex</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tidexpr</name><operator>-&gt;</operator><name>exprstate</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>saex</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><operator>&amp;</operator><name><name>tidstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tidexpr</name><operator>-&gt;</operator><name>isarray</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>CurrentOfExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>CurrentOfExpr</name> <modifier>*</modifier></type><name>cexpr</name> <init>= <expr><operator>(</operator><name>CurrentOfExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>tidexpr</name><operator>-&gt;</operator><name>cexpr</name></name> <operator>=</operator> <name>cexpr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tidstate</name><operator>-&gt;</operator><name>tss_isCurrentOf</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not identify CTID expression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name><name>tidstate</name><operator>-&gt;</operator><name>tss_tidexprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tidstate</name><operator>-&gt;</operator><name>tss_tidexprs</name></name></expr></argument>, <argument><expr><name>tidexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* CurrentOfExpr could never appear OR'd with something else */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>tidstate</name><operator>-&gt;</operator><name>tss_tidexprs</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator>
           <operator>!</operator><name><name>tidstate</name><operator>-&gt;</operator><name>tss_isCurrentOf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute the list of TIDs to be visited, by evaluating the expressions
 * for them.
 *
 * (The result is actually an array, not a list.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TidListEval</name><parameter_list>(<parameter><decl><type><name>TidScanState</name> <modifier>*</modifier></type><name>tidstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>tidstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>tidList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numAllocTids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numTids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We silently discard any TIDs that are out of range at the time of scan
     * start.  (Since we hold at least AccessShareLock on the table, it won't
     * be possible for someone to truncate away the blocks we intend to
     * visit.)
     */</comment>
    <expr_stmt><expr><name>nblocks</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name><name>tidstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We initialize the array with enough slots for the case that all quals
     * are simple OpExprs or CurrentOfExprs.  If there are any
     * ScalarArrayOpExprs, we may have to enlarge the array.
     */</comment>
    <expr_stmt><expr><name>numAllocTids</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>tidstate</name><operator>-&gt;</operator><name>tss_tidexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tidList</name> <operator>=</operator> <operator>(</operator><name>ItemPointerData</name> <operator>*</operator><operator>)</operator>
        <call><name>palloc</name><argument_list>(<argument><expr><name>numAllocTids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>numTids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tidstate-&gt;tss_tidexprs</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TidExpr</name>    <modifier>*</modifier></type><name>tidexpr</name> <init>= <expr><operator>(</operator><name>TidExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ItemPointer</name></type> <name>itemptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isNull</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>tidexpr</name><operator>-&gt;</operator><name>exprstate</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tidexpr</name><operator>-&gt;</operator><name>isarray</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>itemptr</name> <operator>=</operator> <operator>(</operator><name>ItemPointer</name><operator>)</operator>
                <call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name><name>tidexpr</name><operator>-&gt;</operator><name>exprstate</name></name></expr></argument>,
                                                          <argument><expr><name>econtext</name></expr></argument>,
                                                          <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name> <operator>&amp;&amp;</operator>
                <call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><name>itemptr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>itemptr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>nblocks</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>numTids</name> <operator>&gt;=</operator> <name>numAllocTids</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>numAllocTids</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tidList</name> <operator>=</operator> <operator>(</operator><name>ItemPointerData</name> <operator>*</operator><operator>)</operator>
                        <call><name>repalloc</name><argument_list>(<argument><expr><name>tidList</name></expr></argument>,
                                 <argument><expr><name>numAllocTids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>tidList</name><index>[<expr><name>numTids</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>itemptr</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>tidexpr</name><operator>-&gt;</operator><name>exprstate</name></name> <operator>&amp;&amp;</operator> <name><name>tidexpr</name><operator>-&gt;</operator><name>isarray</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Datum</name></type>        <name>arraydatum</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>itemarray</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>ipdatums</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>ipnulls</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>ndatums</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>arraydatum</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name><name>tidexpr</name><operator>-&gt;</operator><name>exprstate</name></name></expr></argument>,
                                                   <argument><expr><name>econtext</name></expr></argument>,
                                                   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>itemarray</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>itemarray</name></expr></argument>,
                              <argument><expr><name>TIDOID</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>ipdatums</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ipnulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ndatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>numTids</name> <operator>+</operator> <name>ndatums</name> <operator>&gt;</operator> <name>numAllocTids</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>numAllocTids</name> <operator>=</operator> <name>numTids</name> <operator>+</operator> <name>ndatums</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>tidList</name> <operator>=</operator> <operator>(</operator><name>ItemPointerData</name> <operator>*</operator><operator>)</operator>
                    <call><name>repalloc</name><argument_list>(<argument><expr><name>tidList</name></expr></argument>,
                             <argument><expr><name>numAllocTids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ipnulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>itemptr</name> <operator>=</operator> <operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>ipdatums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><name>itemptr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                        <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>itemptr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>nblocks</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>tidList</name><index>[<expr><name>numTids</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>itemptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ipdatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ipnulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>ItemPointerData</name></type> <name>cursor_tid</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tidexpr</name><operator>-&gt;</operator><name>cexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>execCurrentOf</name><argument_list>(<argument><expr><name><name>tidexpr</name><operator>-&gt;</operator><name>cexpr</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>,
                              <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>tidstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>cursor_tid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>numTids</name> <operator>&gt;=</operator> <name>numAllocTids</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>numAllocTids</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tidList</name> <operator>=</operator> <operator>(</operator><name>ItemPointerData</name> <operator>*</operator><operator>)</operator>
                        <call><name>repalloc</name><argument_list>(<argument><expr><name>tidList</name></expr></argument>,
                                 <argument><expr><name>numAllocTids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>tidList</name><index>[<expr><name>numTids</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>cursor_tid</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Sort the array of TIDs into order, and eliminate duplicates.
     * Eliminating duplicates is necessary since we want OR semantics across
     * the list.  Sorting makes it easier to detect duplicates, and as a bonus
     * ensures that we will visit the heap in the most efficient way.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>numTids</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>lastTid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <comment type="block">/* CurrentOfExpr could never appear OR'd with something else */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>tidstate</name><operator>-&gt;</operator><name>tss_isCurrentOf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tidList</name></expr></argument>, <argument><expr><name>numTids</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>,
              <argument><expr><name>itemptr_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lastTid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTids</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tidList</name><index>[<expr><name>lastTid</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tidList</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>tidList</name><index>[<expr><operator>++</operator><name>lastTid</name></expr>]</index></name> <operator>=</operator> <name><name>tidList</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>numTids</name> <operator>=</operator> <name>lastTid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>tidstate</name><operator>-&gt;</operator><name>tss_TidList</name></name> <operator>=</operator> <name>tidList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tidstate</name><operator>-&gt;</operator><name>tss_NumTids</name></name> <operator>=</operator> <name>numTids</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tidstate</name><operator>-&gt;</operator><name>tss_TidPtr</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * qsort comparator for ItemPointerData items
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>itemptr_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ItemPointerData</name> <modifier>*</modifier></type><name>ipa</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ItemPointerData</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ItemPointerData</name> <modifier>*</modifier></type><name>ipb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ItemPointerData</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>ba</name> <init>= <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>ipa</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>bb</name> <init>= <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>ipb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>oa</name> <init>= <expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>ipa</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>ob</name> <init>= <expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>ipb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>ba</name> <operator>&lt;</operator> <name>bb</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>ba</name> <operator>&gt;</operator> <name>bb</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>oa</name> <operator>&lt;</operator> <name>ob</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>oa</name> <operator>&gt;</operator> <name>ob</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        TidNext
 *
 *        Retrieve a tuple from the TidScan node's currentRelation
 *        using the tids in the TidScanState information.
 *
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>TidNext</name><parameter_list>(<parameter><decl><type><name>TidScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>EState</name>       <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanDirection</name></type> <name>direction</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Snapshot</name></type>    <name>snapshot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>heapRelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>tidList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numTids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>bBackward</name></decl>;</decl_stmt>

    <comment type="block">/*
     * extract necessary information from tid scan node
     */</comment>
    <expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>direction</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>snapshot</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>heapRelation</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * First time through, compute the list of TIDs to be visited
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>tss_TidList</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>TidListEval</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>tidList</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>tss_TidList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>numTids</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>tss_NumTids</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * We use node-&gt;tss_htup as the tuple pointer; note this can't just be a
     * local variable here, as the scan tuple slot will keep a pointer to it.
     */</comment>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>tss_htup</name></name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize or advance scan position, depending on direction.
     */</comment>
    <expr_stmt><expr><name>bBackward</name> <operator>=</operator> <call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>bBackward</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>tss_TidPtr</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* initialize for backward scan */</comment>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tss_TidPtr</name></name> <operator>=</operator> <name>numTids</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tss_TidPtr</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>tss_TidPtr</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* initialize for forward scan */</comment>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tss_TidPtr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tss_TidPtr</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <while>while <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>tss_TidPtr</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>tss_TidPtr</name></name> <operator>&lt;</operator> <name>numTids</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <name><name>tidList</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>tss_TidPtr</name></name></expr>]</index></name></expr>;</expr_stmt>

        <comment type="block">/*
         * For WHERE CURRENT OF, the tuple retrieved from the cursor might
         * since have been updated; if so, we should fetch the version that is
         * current according to our snapshot.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>tss_isCurrentOf</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>heap_get_latest_tid</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>heap_fetch</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * store the scanned tuple in the scan tuple slot of the scan
             * state.  Eventually we will only do this and not return a tuple.
             * Note: we pass 'false' because tuples returned by amgetnext are
             * pointers onto disk pages and were not created with palloc() and
             * so should not be pfree()'d.
             */</comment>
            <expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,    <comment type="block">/* tuple to store */</comment>
                           <argument><expr><name>slot</name></expr></argument>,    <comment type="block">/* slot to store in */</comment>
                           <argument><expr><name>buffer</name></expr></argument>,    <comment type="block">/* buffer associated with tuple  */</comment>
                           <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* don't pfree */</comment>

            <comment type="block">/*
             * At this point we have an extra pin on the buffer, because
             * ExecStoreTuple incremented the pin count. Drop our local pin.
             */</comment>
            <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <return>return <expr><name>slot</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Bad TID or failed snapshot qual; try next */</comment>
        <if_stmt><if>if <condition>(<expr><name>bBackward</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tss_TidPtr</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tss_TidPtr</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * if we get here it means the tid scan failed so we are at the end of the
     * scan..
     */</comment>
    <return>return <expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TidRecheck -- access method routine to recheck a tuple in EvalPlanQual
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TidRecheck</name><parameter_list>(<parameter><decl><type><name>TidScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * XXX shouldn't we check here to make sure tuple matches TID list? In
     * runtime-key case this is not certain, is it?  However, in the WHERE
     * CURRENT OF case it might not match anyway ...
     */</comment>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *        ExecTidScan(node)
 *
 *        Scans the relation using tids and returns
 *           the next qualifying tuple in the direction specified.
 *        We call the ExecScan() routine and pass it the appropriate
 *        access method functions.
 *
 *        Conditions:
 *          -- the "cursor" maintained by the AMI is positioned at the tuple
 *             returned previously.
 *
 *        Initial States:
 *          -- the relation indicated is opened for scanning so that the
 *             "cursor" is positioned before the first qualifying tuple.
 *          -- tidPtr is -1.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecTidScan</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TidScanState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>TidScanState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>ExecScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>,
                    <argument><expr><operator>(</operator><name>ExecScanAccessMtd</name><operator>)</operator> <name>TidNext</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>ExecScanRecheckMtd</name><operator>)</operator> <name>TidRecheck</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecReScanTidScan(node)
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecReScanTidScan</name><parameter_list>(<parameter><decl><type><name>TidScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>tss_TidList</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tss_TidList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tss_TidList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tss_NumTids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tss_TidPtr</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ExecScanReScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecEndTidScan
 *
 *        Releases any storage allocated through C routines.
 *        Returns nothing.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndTidScan</name><parameter_list>(<parameter><decl><type><name>TidScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * Free the exprcontext
     */</comment>
    <expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * clear out tuple table slots
     */</comment>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * close the heap relation.
     */</comment>
    <expr_stmt><expr><call><name>ExecCloseScanRelation</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecInitTidScan
 *
 *        Initializes the tid scan's state information, creates
 *        scan keys, and opens the base and tid relations.
 *
 *        Parameters:
 *          node: TidNode node produced by the planner.
 *          estate: the execution state initialized in InitPlan.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>TidScanState</name> <modifier>*</modifier></type>
<name>ExecInitTidScan</name><parameter_list>(<parameter><decl><type><name>TidScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TidScanState</name> <modifier>*</modifier></type><name>tidstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>currentRelation</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>ListCell</name>      <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

    <comment type="block">/*
     * create state structure
     */</comment>
    <expr_stmt><expr><name>tidstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TidScanState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tidstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tidstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tidstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecTidScan</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Miscellaneous initialization
     *
     * create expression context for node
     */</comment>
    <expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tidstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * initialize child expressions
     */</comment>
    <expr_stmt><expr><name><name>tidstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
        <call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>tidstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>enable_fga</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>foreach</name> <argument_list>(<argument>item</argument>, <argument>node-&gt;scan.plan.audit_fga_quals</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>AuditFgaPolicy</name> <modifier>*</modifier></type><name>audit_fga_qual</name> <init>= <expr><operator>(</operator><name>AuditFgaPolicy</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            
            <decl_stmt><decl><type><name>audit_fga_policy_state</name> <modifier>*</modifier></type> <name>audit_fga_policy_state_item</name>
                    <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>audit_fga_policy_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>audit_fga_policy_state_item</name><operator>-&gt;</operator><name>policy_name</name></name> <operator>=</operator> <name><name>audit_fga_qual</name><operator>-&gt;</operator><name>policy_name</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>audit_fga_policy_state_item</name><operator>-&gt;</operator><name>query_string</name></name> <operator>=</operator> <name><name>audit_fga_qual</name><operator>-&gt;</operator><name>query_string</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>audit_fga_policy_state_item</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> 
                <call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>audit_fga_qual</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>tidstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>tidstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>audit_fga_qual</name></name> <operator>=</operator> 
                <call><name>lappend</name><argument_list>(<argument><expr><name><name>tidstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>audit_fga_qual</name></name></expr></argument>, <argument><expr><name>audit_fga_policy_state_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>      
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>     

    <expr_stmt><expr><call><name>TidExprListCreate</name><argument_list>(<argument><expr><name>tidstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * tuple table initialization
     */</comment>
    <expr_stmt><expr><call><name>ExecInitResultTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tidstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecInitScanTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tidstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * mark tid list as not computed yet
     */</comment>
    <expr_stmt><expr><name><name>tidstate</name><operator>-&gt;</operator><name>tss_TidList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tidstate</name><operator>-&gt;</operator><name>tss_NumTids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tidstate</name><operator>-&gt;</operator><name>tss_TidPtr</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * open the base relation and acquire appropriate lock on it.
     */</comment>
    <expr_stmt><expr><name>currentRelation</name> <operator>=</operator> <call><name>ExecOpenScanRelation</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <expr_stmt><expr><call><name>mls_check_datamask_need_passby</name><argument_list>(<argument><expr><operator>(</operator><name>ScanState</name><operator>*</operator><operator>)</operator><name>tidstate</name></expr></argument>, <argument><expr><name><name>currentRelation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

    <expr_stmt><expr><name><name>tidstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name> <operator>=</operator> <name>currentRelation</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tidstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentScanDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* no heap scan here */</comment>

    <comment type="block">/*
     * get the scan type from the relation descriptor.
     */</comment>
    <expr_stmt><expr><call><name>ExecAssignScanType</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tidstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>currentRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize result tuple type and projection info.
     */</comment>
    <expr_stmt><expr><call><name>ExecAssignResultTypeFromTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tidstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecAssignScanProjectionInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tidstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * all done.
     */</comment>
    <return>return <expr><name>tidstate</name></expr>;</return>
</block_content>}</block></function>
</unit>
