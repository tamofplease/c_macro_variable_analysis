<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/executor/execTuples.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execTuples.c
 *      Routines dealing with TupleTableSlots.  These are used for resource
 *      management associated with tuples (eg, releasing buffer pins for
 *      tuples in disk buffers, or freeing the memory occupied by transient
 *      tuples).  Slots also provide access abstraction that lets us implement
 *      "virtual" tuples to reduce data-copying overhead.
 *
 *      Routines dealing with the type information for tuples. Currently,
 *      the type information for a tuple is an array of FormData_pg_attribute.
 *      This information is needed by routines manipulating tuples
 *      (getattribute, formtuple, etc.).
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/executor/execTuples.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 * INTERFACE ROUTINES
 *
 *     SLOT CREATION/DESTRUCTION
 *        MakeTupleTableSlot        - create an empty slot
 *        ExecAllocTableSlot        - create a slot within a tuple table
 *        ExecResetTupleTable        - clear and optionally delete a tuple table
 *        MakeSingleTupleTableSlot - make a standalone slot, set its descriptor
 *        ExecDropSingleTupleTableSlot - destroy a standalone slot
 *
 *     SLOT ACCESSORS
 *        ExecSetSlotDescriptor    - set a slot's tuple descriptor
 *        ExecStoreTuple            - store a physical tuple in the slot
 *        ExecStoreMinimalTuple    - store a minimal physical tuple in the slot
 *        ExecClearTuple            - clear contents of a slot
 *        ExecStoreVirtualTuple    - mark slot as containing a virtual tuple
 *        ExecCopySlotTuple        - build a physical tuple from a slot
 *        ExecCopySlotMinimalTuple - build a minimal physical tuple from a slot
 *        ExecMaterializeSlot        - convert virtual to physical storage
 *        ExecCopySlot            - copy one slot's contents to another
 *
 *     CONVENIENCE INITIALIZATION ROUTINES
 *        ExecInitResultTupleSlot    \    convenience routines to initialize
 *        ExecInitScanTupleSlot        \    the various tuple slots for nodes
 *        ExecInitExtraTupleSlot        /    which store copies of tuples.
 *        ExecInitNullTupleSlot       /
 *
 *     Routines that probably belong somewhere else:
 *        ExecTypeFromTL            - form a TupleDesc from a target list
 *
 *     EXAMPLE OF HOW TABLE ROUTINES WORK
 *        Suppose we have a query such as SELECT emp.name FROM emp and we have
 *        a single SeqScan node in the query plan.
 *
 *        At ExecutorStart()
 *        ----------------
 *        - ExecInitSeqScan() calls ExecInitScanTupleSlot() and
 *          ExecInitResultTupleSlot() to construct TupleTableSlots
 *          for the tuples returned by the access methods and the
 *          tuples resulting from performing target list projections.
 *
 *        During ExecutorRun()
 *        ----------------
 *        - SeqNext() calls ExecStoreTuple() to place the tuple returned
 *          by the access methods into the scan tuple slot.
 *
 *        - ExecSeqScan() calls ExecStoreTuple() to take the result
 *          tuple from ExecProject() and place it into the result tuple slot.
 *
 *        - ExecutePlan() calls the output function.
 *
 *        The important thing to watch in the executor code is how pointers
 *        to the slots containing tuples are passed instead of the tuples
 *        themselves.  This facilitates the communication of related information
 *        (such as whether or not a tuple should be pfreed, what buffer contains
 *        this tuple, the tuple's tuple descriptor, etc).  It also allows us
 *        to avoid physically constructing projection tuples in many cases.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/printtup.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>TupleDesc</name></type> <name>ExecTypeFromTLInternal</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
                       <parameter><decl><type><name>bool</name></type> <name>hasoid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipjunk</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------------------------------------------------------------
 *                  tuple table create/delete functions
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* --------------------------------
 *        MakeTupleTableSlot
 *
 *        Basic routine to make an empty TupleTableSlot.
 * --------------------------------
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>MakeTupleTableSlot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TupleTableSlot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isempty</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFree</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFreeMin</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFreeRow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_drowcxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_attinmeta</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_buffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mintuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mls_mcxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>,
                                                  <argument><expr><literal type="string">"mls memory context"</literal></expr></argument>,
                                                  <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
                                                  <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
                                                  <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *        ExecAllocTableSlot
 *
 *        Create a tuple table slot within a tuple table (which is just a List).
 * --------------------------------
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecAllocTableSlot</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>tupleTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>MakeTupleTableSlot</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>tupleTable</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>tupleTable</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *        ExecResetTupleTable
 *
 *        This releases any resources (buffer pins, tupdesc refcounts)
 *        held by the tuple table, and optionally releases the memory
 *        occupied by the tuple table data structure.
 *        It is expected that this routine be called by EndPlan().
 * --------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecResetTupleTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tupleTable</name></decl></parameter>,    <comment type="block">/* tuple table */</comment>
                    <parameter><decl><type><name>bool</name></type> <name>shouldFree</name></decl></parameter>)</parameter_list>    <comment type="block">/* true if we should free memory */</comment>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tupleTable</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TupleTableSlot</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Always release resources and reset the slot to empty */</comment>
        <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* If shouldFree, release memory occupied by the slot itself */</comment>
        <if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/* If shouldFree, release the list structure */</comment>
    <if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>tupleTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *        MakeSingleTupleTableSlot
 *
 *        This is a convenience routine for operations that need a
 *        standalone TupleTableSlot not gotten from the main executor
 *        tuple table.  It makes a single slot and initializes it
 *        to use the given tuple descriptor.
 * --------------------------------
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>MakeSingleTupleTableSlot</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>MakeTupleTableSlot</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *        ExecDropSingleTupleTableSlot
 *
 *        Release a TupleTableSlot made with MakeSingleTupleTableSlot.
 *        DON'T use this on a slot that's part of a tuple table list!
 * --------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecDropSingleTupleTableSlot</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* This should match ExecResetTupleTable's processing of one slot */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>TupleTableSlot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *                  tuple table slot accessor functions
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* --------------------------------
 *        ExecSetSlotDescriptor
 *
 *        This function is used to set the tuple descriptor associated
 *        with the slot's tuple.  The passed descriptor must have lifespan
 *        at least equal to the slot's.  If it is a reference-counted descriptor
 *        then the reference count is incremented for as long as the slot holds
 *        a reference.
 * --------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecSetSlotDescriptor</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <comment type="block">/* slot to change */</comment>
                      <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>    <comment type="block">/* new tuple descriptor */</comment>
<block>{<block_content>
    <comment type="block">/* For safety, make sure slot is empty before changing it */</comment>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Release any old descriptor.  Also release old Datum/isnull arrays if
     * present (we don't bother to check if they could be re-used).
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/* XXX there in no routine to release AttInMetadata instance */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_attinmeta</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_attinmeta</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Install the new descriptor; if it's refcounted, bump its refcount.
     */</comment>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PinTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Allocate Datum/isnull arrays of the appropriate size.  These must have
     * the same lifetime as the slot, so allocate in the slot's own context.
     */</comment>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator>
        <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>, <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator>
        <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>, <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *        ExecStoreTuple
 *
 *        This function is used to store a physical tuple into a specified
 *        slot in the tuple table.
 *
 *        tuple:    tuple to store
 *        slot:    slot to store it in
 *        buffer: disk buffer if tuple is in a disk page, else InvalidBuffer
 *        shouldFree: true if ExecClearTuple should pfree() the tuple
 *                    when done with it
 *
 * If 'buffer' is not InvalidBuffer, the tuple table code acquires a pin
 * on the buffer which is held until the slot is cleared, so that the tuple
 * won't go away on us.
 *
 * shouldFree is normally set 'true' for tuples constructed on-the-fly.
 * It must always be 'false' for tuples that are stored in disk pages,
 * since we don't want to try to pfree those.
 *
 * Another case where it is 'false' is when the referenced tuple is held
 * in a tuple table slot belonging to a lower-level executor Proc node.
 * In this case the lower-level slot retains ownership and responsibility
 * for eventually releasing the tuple.  When this method is used, we must
 * be certain that the upper-level Proc node will lose interest in the tuple
 * sooner than the lower-level one does!  If you're not certain, copy the
 * lower-level tuple with heap_copytuple and let the upper-level table
 * slot assume ownership of the copy!
 *
 * Return value is just the passed-in slot pointer.
 *
 * NOTE: before PostgreSQL 8.1, this function would accept a NULL tuple
 * pointer and effectively behave like ExecClearTuple (though you could
 * still specify a buffer to pin, which would be an odd combination).
 * This saved a couple lines of code in a few places, but seemed more likely
 * to mask logic errors than to be really useful, so it's now disallowed.
 * --------------------------------
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecStoreTuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
               <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
               <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>,
               <parameter><decl><type><name>bool</name></type> <name>shouldFree</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/*
     * sanity checks
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuple</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* passing shouldFree=true for a tuple on a disk page is not sane */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><ternary><condition><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>(</operator><operator>!</operator><name>shouldFree</name><operator>)</operator></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Free any old physical tuple belonging to the slot.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFree</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFreeMin</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>heap_free_minimal_tuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mintuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFreeRow</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_drowcxt</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_drowcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFreeRow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>        
    <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mls_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Store the new tuple into the specified slot.
     */</comment>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isempty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFree</name></name> <operator>=</operator> <name>shouldFree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFreeMin</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mintuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* Mark extracted state invalid */</comment>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * If tuple is on a disk page, keep the page pinned as long as we hold a
     * pointer into it.  We assume the caller already has such a pin.
     *
     * This is coded to optimize the case where the slot previously held a
     * tuple on the same disk page: in that case releasing and re-acquiring
     * the pin is a waste of cycles.  This is a common situation during
     * seqscans, so it's worth troubling over.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_buffer</name></name> <operator>!=</operator> <name>buffer</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_buffer</name></name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>IncrBufferRefCount</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *        ExecStoreMinimalTuple
 *
 *        Like ExecStoreTuple, but insert a "minimal" tuple into the slot.
 *
 * No 'buffer' parameter since minimal tuples are never stored in relations.
 * --------------------------------
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecStoreMinimalTuple</name><parameter_list>(<parameter><decl><type><name>MinimalTuple</name></type> <name>mtup</name></decl></parameter>,
                      <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name></type> <name>shouldFree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * sanity checks
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mtup</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Free any old physical tuple belonging to the slot.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFree</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFreeMin</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>heap_free_minimal_tuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mintuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFreeRow</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_drowcxt</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_drowcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFreeRow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Drop the pin on the referenced buffer, if there is one.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_buffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Store the new tuple into the specified slot.
     */</comment>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isempty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFree</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFreeMin</name></name> <operator>=</operator> <name>shouldFree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_minhdr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mintuple</name></name> <operator>=</operator> <name>mtup</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_minhdr</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <name><name>mtup</name><operator>-&gt;</operator><name>t_len</name></name> <operator>+</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_minhdr</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>mtup</name> <operator>-</operator> <name>MINIMAL_TUPLE_OFFSET</name><operator>)</operator></expr>;</expr_stmt>
    <comment type="block">/* no need to set t_self or t_tableOid since we won't allow access */</comment>

    <comment type="block">/* Mark extracted state invalid */</comment>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *        ExecClearTuple
 *
 *        This function is used to clear out a slot in the tuple table.
 *
 *        NB: only the tuple is cleared, not the tuple descriptor (if any).
 * --------------------------------
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>                <comment type="block">/* return: slot passed */</comment>
<name>ExecClearTuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>    <comment type="block">/* slot in which to store tuple */</comment>
<block>{<block_content>
    <comment type="block">/*
     * sanity checks
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Free the old physical tuple if necessary.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFree</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFreeMin</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>heap_free_minimal_tuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mintuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFreeRow</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFreeRow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mintuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFree</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFreeMin</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Drop the pin on the referenced buffer, if there is one.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_buffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Mark it empty.
     */</comment>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isempty</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *        ExecStoreVirtualTuple
 *            Mark a slot as containing a virtual tuple.
 *
 * The protocol for loading a slot with virtual tuple data is:
 *        * Call ExecClearTuple to mark the slot empty.
 *        * Store data into the Datum/isnull arrays.
 *        * Call ExecStoreVirtualTuple to mark the slot valid.
 * This is a bit unclean but it avoids one round of data copying.
 * --------------------------------
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecStoreVirtualTuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * sanity checks
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isempty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isempty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

    <return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *        ExecStoreAllNullTuple
 *            Set up the slot to contain a null in every column.
 *
 * At first glance this might sound just like ExecClearTuple, but it's
 * entirely different: the slot ends up full, not empty.
 * --------------------------------
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecStoreAllNullTuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * sanity checks
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clear any old contents */</comment>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Fill all the columns of the virtual tuple with nulls
     */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
           <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
           <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *        ExecCopySlotTuple
 *            Obtain a copy of a slot's regular physical tuple.  The copy is
 *            palloc'd in the current memory context.
 *            The slot itself is undisturbed.
 *
 *        This works even if the slot contains a virtual or minimal tuple;
 *        however the "system columns" of the result will not be meaningful.
 * --------------------------------
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>ExecCopySlotTuple_shard</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hasshard</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>diskey</name></decl></parameter>,
                                 <parameter><decl><type><name>AttrNumber</name></type> <name>secdiskey</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * sanity checks
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_isempty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we have a physical tuple (either format) then just copy it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TTS_HAS_PHYSICAL_TUPLE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<block>{<block_content>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>hasshard</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>HeapTupleHeaderSetShardId</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>InvalidShardID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>tuple</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <return>return <expr><call><name>heap_copytuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mintuple</name></name></expr>)</condition>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<block>{<block_content>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_tuple_from_minimal_tuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mintuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>hasshard</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>HeapTupleHeaderSetShardId</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>InvalidShardID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>tuple</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <return>return <expr><call><name>heap_tuple_from_minimal_tuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mintuple</name></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/*
     * Ensure values are extracted from data row to the Datum array
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Otherwise we need to build a tuple from the Datum array.
     */</comment>
    <if_stmt><if>if<condition>(<expr><name>hasshard</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>heap_form_tuple_plain</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
                           <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>,
                           <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>,
                           <argument><expr><name>diskey</name></expr></argument>, <argument><expr><name>secdiskey</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>, 
                           <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>,
                           <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *        ExecCopySlotMinimalTuple
 *            Obtain a copy of a slot's minimal physical tuple.  The copy is
 *            palloc'd in the current memory context.
 *            The slot itself is undisturbed.
 * --------------------------------
 */</comment>
<function><type><name>MinimalTuple</name></type>
<name>ExecCopySlotMinimalTuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/*
     * sanity checks
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_isempty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we have a physical tuple then just copy it.  Prefer to copy
     * tts_mintuple since that's a tad cheaper.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mintuple</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>heap_copy_minimal_tuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mintuple</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr>)</condition>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>TTS_HAS_PHYSICAL_TUPLE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>HeapTupleHeaderGetNatts</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call>
            <operator>&lt;</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>minimal_expand_tuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></argument>,
                                        <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><call><name>minimal_tuple_from_heap_tuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/*
     * Ensure values are extracted from data row to the Datum array
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Otherwise we need to build a tuple from the Datum array.
     */</comment>
    <return>return <expr><call><name>heap_form_minimal_tuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
                                   <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>,
                                   <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<comment type="block">/* --------------------------------
 *        ExecCopySlotDatarow
 *            Obtain a copy of a slot's data row.  The copy is
 *            palloc'd in the current memory context.
 *            The slot itself is undisturbed
 * --------------------------------
 */</comment>
<function><type><name>RemoteDataRow</name></type>
<name>ExecCopySlotDatarow</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>tmpcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>RemoteDataRow</name></type> <name>datarow</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name><operator>-&gt;</operator><name>msglen</name></name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* if we already have datarow make a copy */</comment>
        <expr_stmt><expr><name>datarow</name> <operator>=</operator> <operator>(</operator><name>RemoteDataRow</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RemoteDataRowData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>datarow</name><operator>-&gt;</operator><name>msgnode</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name><operator>-&gt;</operator><name>msgnode</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>datarow</name><operator>-&gt;</operator><name>msglen</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>datarow</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>datarow</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>TupleDesc</name></type>         <name>tdesc</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type>    <name>savecxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>StringInfoData</name></type>    <name>buf</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint16</name></type>             <name>n16</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>             <name>i</name></decl>;</decl_stmt>

        <comment type="block">/* ensure we have all values */</comment>
        <expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* if temporary memory context is specified reset it */</comment>
        <if_stmt><if>if <condition>(<expr><name>tmpcxt</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>tmpcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>savecxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>tmpcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Number of parameter values */</comment>
        <expr_stmt><expr><name>n16</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name><name>tdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n16</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>uint32</name></type> <name>n32</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><name><name>tdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>        <name>typOutput</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>    <name>typIsVarlena</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Datum</name></type>    <name>pval</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>pstring</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>        <name>len</name></decl>;</decl_stmt>

                <comment type="block">/* Get info needed to output the value */</comment>
                <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typOutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIsVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/*
                 * If we have a toasted datum, forcibly detoast it here to avoid
                 * memory leakage inside the type's output routine.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>typIsVarlena</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>pval</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>pval</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <comment type="block">/*
                  * column is composite type, need to send tupledesc to remote node
                  */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator> <name>in_data_pump</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>rec</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Oid</name></type>            <name>tupType</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int32</name></type>        <name>tupTypmod</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>StringInfoData</name></type>  <name>tupdesc_data</name></decl>;</decl_stmt>
                    
                    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tupdesc_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    
                    <comment type="block">/* -2 to indicate this is composite type */</comment>
                    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>rec</name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* Extract type info from the tuple itself */</comment>
                    <expr_stmt><expr><name>tupType</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tupTypmod</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>tupType</name></expr></argument>, <argument><expr><name>tupTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>FormRowDescriptionMessage</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>tupdesc_data</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* write rowDesctiption */</comment>
                    <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>tupdesc_data</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>tupdesc_data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/* Convert Datum to string */</comment>
                <expr_stmt><expr><name>pstring</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typOutput</name></expr></argument>, <argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* copy data to the buffer */</comment>
                <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pstring</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* restore memory context to allocate result */</comment>
        <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* copy data to the buffer */</comment>
        <expr_stmt><expr><name>datarow</name> <operator>=</operator> <operator>(</operator><name>RemoteDataRow</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RemoteDataRowData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>datarow</name><operator>-&gt;</operator><name>msgnode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>datarow</name><operator>-&gt;</operator><name>msglen</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>datarow</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>datarow</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* --------------------------------
 *        ExecFetchSlotTuple
 *            Fetch the slot's regular physical tuple.
 *
 *        If the slot contains a virtual tuple, we convert it to physical
 *        form.  The slot retains ownership of the physical tuple.
 *        If it contains a minimal tuple we convert to regular form and store
 *        that in addition to the minimal tuple (not instead of, because
 *        callers may hold pointers to Datums within the minimal tuple).
 *
 * The main difference between this and ExecMaterializeSlot() is that this
 * does not guarantee that the contained tuple is local storage.
 * Hence, the result must be treated as read-only.
 * --------------------------------
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>ExecFetchSlotTuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * sanity checks
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_isempty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we have a regular physical tuple then just return it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TTS_HAS_PHYSICAL_TUPLE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>HeapTupleHeaderGetNatts</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
            <name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
 
            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name> <operator>=</operator> <call><name>heap_expand_tuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></argument>,
                                                <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFree</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr>;</return>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <return>return <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Otherwise materialize the slot...
     */</comment>
    <return>return <expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *        ExecFetchSlotMinimalTuple
 *            Fetch the slot's minimal physical tuple.
 *
 *        If the slot contains a virtual tuple, we convert it to minimal
 *        physical form.  The slot retains ownership of the minimal tuple.
 *        If it contains a regular tuple we convert to minimal form and store
 *        that in addition to the regular tuple (not instead of, because
 *        callers may hold pointers to Datums within the regular tuple).
 *
 * As above, the result must be treated as read-only.
 * --------------------------------
 */</comment>
<function><type><name>MinimalTuple</name></type>
<name>ExecFetchSlotMinimalTuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

    <comment type="block">/*
     * sanity checks
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_isempty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we have a minimal physical tuple (local or not) then just return it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mintuple</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mintuple</name></name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Otherwise, copy or build a minimal tuple, and store it into the slot.
     *
     * We may be called in a context that is shorter-lived than the tuple
     * slot, but we have to ensure that the materialized tuple will survive
     * anyway.
     */</comment>
    <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mintuple</name></name> <operator>=</operator> <call><name>ExecCopySlotMinimalTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFreeMin</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Note: we may now have a situation where we have a local minimal tuple
     * attached to a virtual or non-local physical tuple.  There seems no harm
     * in that at the moment, but if any materializes, we should change this
     * function to force the slot into minimal-tuple-only state.
     */</comment>

    <return>return <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mintuple</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *        ExecFetchSlotTupleDatum
 *            Fetch the slot's tuple as a composite-type Datum.
 *
 *        The result is always freshly palloc'd in the caller's memory context.
 * --------------------------------
 */</comment>
<function><type><name>Datum</name></type>
<name>ExecFetchSlotTupleDatum</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>

    <comment type="block">/* Fetch slot's contents in regular-physical-tuple form */</comment>
    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>ExecFetchSlotTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>;</expr_stmt>

    <comment type="block">/* Convert to Datum form */</comment>
    <return>return <expr><call><name>heap_copy_tuple_as_datum</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *        ExecMaterializeSlot
 *            Force a slot into the "materialized" state.
 *
 *        This causes the slot's tuple to be a local copy not dependent on
 *        any external storage.  A pointer to the contained tuple is returned.
 *
 *        A typical use for this operation is to prepare a computed tuple
 *        for being stored on disk.  The original data may or may not be
 *        virtual, but in any case we need a private copy for heap_insert
 *        to scribble on.
 * --------------------------------
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>ExecMaterializeSlot_shard</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>hasshard</name></decl></parameter>,
                        <parameter><decl><type><name>AttrNumber</name></type> <name>diskey</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>secdiskey</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

    <comment type="block">/*
     * sanity checks
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_isempty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we have a regular physical tuple, and it's locally palloc'd, we have
     * nothing to do.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name> <operator>&amp;&amp;</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFree</name></name></expr>)</condition>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>hasshard</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_tuple_set_shardid</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>slot</name></expr></argument>, <argument><expr><name>diskey</name></expr></argument>, <argument><expr><name>secdiskey</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr>;</return>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Otherwise, copy or build a physical tuple, and store it into the slot.
     *
     * We may be called in a context that is shorter-lived than the tuple
     * slot, but we have to ensure that the materialized tuple will survive
     * anyway.
     */</comment>
    <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name> <operator>=</operator> <call><name>ExecCopySlotTuple_shard</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>hasshard</name></expr></argument>, <argument><expr><name>diskey</name></expr></argument>, <argument><expr><name>secdiskey</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFree</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>hasshard</name> <operator>&amp;&amp;</operator> <call><name>HeapTupleHeaderGetShardId</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidShardID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_tuple_set_shardid</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>slot</name></expr></argument>, <argument><expr><name>diskey</name></expr></argument>, <argument><expr><name>secdiskey</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Drop the pin on the referenced buffer, if there is one.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_buffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Mark extracted state invalid.  This is important because the slot is
     * not supposed to depend any more on the previous external data; we
     * mustn't leave any dangling pass-by-reference datums in tts_values.
     * However, we have not actually invalidated any such datums, if there
     * happen to be any previously fetched from the slot.  (Note in particular
     * that we have not pfree'd tts_mintuple, if there is one.)
     */</comment>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * On the same principle of not depending on previous remote storage,
     * forget the mintuple if it's not local storage.  (If it is local
     * storage, we must not pfree it now, since callers might have already
     * fetched datum pointers referencing it.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFreeMin</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mintuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFreeRow</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *        ExecCopySlot
 *            Copy the source slot's contents into the destination slot.
 *
 *        The destination acquires a private copy that will not go away
 *        if the source is cleared.
 *
 *        The caller must ensure the slots have compatible tupdescs.
 * --------------------------------
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecCopySlot</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>dstslot</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>srcslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>newTuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

    <comment type="block">/*
     * There might be ways to optimize this when the source is virtual, but
     * for now just always build a physical copy.  Make sure it is in the
     * right context.
     */</comment>
    <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>dstslot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>newTuple</name> <operator>=</operator> <call><name>ExecCopySlotTuple</name><argument_list>(<argument><expr><name>srcslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>newTuple</name></expr></argument>, <argument><expr><name>dstslot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *                convenience initialization routines
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* --------------------------------
 *        ExecInit{Result,Scan,Extra}TupleSlot
 *
 *        These are convenience routines to initialize the specified slot
 *        in nodes inheriting the appropriate state.  ExecInitExtraTupleSlot
 *        is used for initializing special-purpose slots.
 * --------------------------------
 */</comment>

<comment type="block">/* ----------------
 *        ExecInitResultTupleSlot
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecInitResultTupleSlot</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ResultTupleSlot</name></name> <operator>=</operator> <call><name>ExecAllocTableSlot</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        ExecInitScanTupleSlot
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecInitScanTupleSlot</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ScanState</name> <modifier>*</modifier></type><name>scanstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss_ScanTupleSlot</name></name> <operator>=</operator> <call><name>ExecAllocTableSlot</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        ExecInitExtraTupleSlot
 * ----------------
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecInitExtraTupleSlot</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ExecAllocTableSlot</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        ExecInitNullTupleSlot
 *
 * Build a slot containing an all-nulls tuple of the given type.
 * This is used as a substitute for an input tuple when performing an
 * outer join.
 * ----------------
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecInitNullTupleSlot</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tupType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>ExecStoreAllNullTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecTypeFromTL
 *
 *        Generate a tuple descriptor for the result tuple of a targetlist.
 *        (A parse/plan tlist must be passed, not an ExprState tlist.)
 *        Note that resjunk columns, if any, are included in the result.
 *
 *        Currently there are about 4 different places where we create
 *        TupleDescriptors.  They should all be merged, or perhaps
 *        be rewritten to call BuildDesc().
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>ExecTypeFromTL</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hasoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ExecTypeFromTLInternal</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>hasoid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecCleanTypeFromTL
 *
 *        Same as above, but resjunk columns are omitted from the result.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>ExecCleanTypeFromTL</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hasoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>ExecTypeFromTLInternal</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>hasoid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleDesc</name></type>
<name>ExecTypeFromTLInternal</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hasoid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipjunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>typeInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>cur_resno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>skipjunk</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ExecCleanTargetListLength</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ExecTargetListLength</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name>typeInfo</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>hasoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>targetList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>skipjunk</name> <operator>&amp;&amp;</operator> <name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>typeInfo</name></expr></argument>,
                           <argument><expr><name>cur_resno</name></expr></argument>,
                           <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>,
                           <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntryCollation</name><argument_list>(<argument><expr><name>typeInfo</name></expr></argument>,
                                    <argument><expr><name>cur_resno</name></expr></argument>,
                                    <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cur_resno</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>typeInfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecTypeFromExprList - build a tuple descriptor from a list of Exprs
 *
 * This is roughly like ExecTypeFromTL, but we work from bare expressions
 * not TargetEntrys.  No names are attached to the tupledesc's columns.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>ExecTypeFromExprList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>typeInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>cur_resno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>typeInfo</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>exprList</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>exprList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>typeInfo</name></expr></argument>,
                           <argument><expr><name>cur_resno</name></expr></argument>,
                           <argument><expr><name>NULL</name></expr></argument>,
                           <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntryCollation</name><argument_list>(<argument><expr><name>typeInfo</name></expr></argument>,
                                    <argument><expr><name>cur_resno</name></expr></argument>,
                                    <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cur_resno</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>typeInfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecTypeSetColNames - set column names in a TupleDesc
 *
 * Column names must be provided as an alias list (list of String nodes).
 *
 * For some callers, the supplied tupdesc has a named rowtype (not RECORD)
 * and it is moderately likely that the alias list matches the column names
 * already present in the tupdesc.  If we do change any column names then
 * we must reset the tupdesc's type to anonymous RECORD; but we avoid doing
 * so if no names change.
 */</comment>
<function><type><name>void</name></type>
<name>ExecTypeSetColNames</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>typeInfo</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>namesList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>modified</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>colno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>namesList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>

        <comment type="block">/* Guard against too-long names list */</comment>
        <if_stmt><if>if <condition>(<expr><name>colno</name> <operator>&gt;=</operator> <name><name>typeInfo</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>attr</name> <operator>=</operator> <name><name>typeInfo</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>colno</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

        <comment type="block">/* Ignore empty aliases (these must be for dropped columns) */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Change tupdesc only if alias is actually different */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cname</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>cname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>modified</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/* If we modified the tupdesc, it's now a new record type */</comment>
    <if_stmt><if>if <condition>(<expr><name>modified</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>typeInfo</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>=</operator> <name>RECORDOID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>typeInfo</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * BlessTupleDesc - make a completed tuple descriptor useful for SRFs
 *
 * Rowtype Datums returned by a function must contain valid type information.
 * This happens "for free" if the tupdesc came from a relcache entry, but
 * not if we have manufactured a tupdesc for a transient RECORD datatype.
 * In that case we have to notify typcache.c of the existence of the type.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>BlessTupleDesc</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator>
        <name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>assign_record_type_typmod</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>tupdesc</name></expr>;</return>                <comment type="block">/* just for notational convenience */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * TupleDescGetSlot - Initialize a slot based on the supplied tupledesc
 *
 * Note: this is obsolete; it is sufficient to call BlessTupleDesc on
 * the tupdesc.  We keep it around just for backwards compatibility with
 * existing user-written SRFs.
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>TupleDescGetSlot</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

    <comment type="block">/* The useful work is here */</comment>
    <expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make a standalone slot */</comment>
    <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return the slot */</comment>
    <return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TupleDescGetAttInMetadata - Build an AttInMetadata structure based on the
 * supplied TupleDesc. AttInMetadata can be used in conjunction with C strings
 * to produce a properly formed tuple.
 */</comment>
<function><type><name>AttInMetadata</name> <modifier>*</modifier></type>
<name>TupleDescGetAttInMetadata</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>natts</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>atttypeid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>attinfuncid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>attinfuncinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>attioparams</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name>       <modifier>*</modifier></type><name>atttypmods</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>attinmeta</name> <operator>=</operator> <operator>(</operator><name>AttInMetadata</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttInMetadata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* "Bless" the tupledesc so that we can make rowtype datums with it */</comment>
    <expr_stmt><expr><name><name>attinmeta</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Gather info needed later to call the "in" function for each attribute
     */</comment>
    <expr_stmt><expr><name>attinfuncinfo</name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>attioparams</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>atttypmods</name> <operator>=</operator> <operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* Ignore dropped attributes */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>atttypeid</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name>atttypeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attinfuncid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>attioparams</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>attinfuncid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>attinfuncinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>atttypmods</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>atttypmod</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>attinmeta</name><operator>-&gt;</operator><name>attinfuncs</name></name> <operator>=</operator> <name>attinfuncinfo</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attinmeta</name><operator>-&gt;</operator><name>attioparams</name></name> <operator>=</operator> <name>attioparams</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attinmeta</name><operator>-&gt;</operator><name>atttypmods</name></name> <operator>=</operator> <name>atttypmods</name></expr>;</expr_stmt>

    <return>return <expr><name>attinmeta</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * BuildTupleFromCStrings - build a HeapTuple given user data in C string form.
 * values is an array of C strings, one for each attribute of the return tuple.
 * A NULL string pointer indicates we want to create a NULL field.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>BuildTupleFromCStrings</name><parameter_list>(<parameter><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name> <init>= <expr><name><name>attinmeta</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>natts</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>dvalues</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>dvalues</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Call the "in" function for each non-dropped attribute */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Non-dropped attributes */</comment>
            <expr_stmt><expr><name><name>dvalues</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>attinmeta</name><operator>-&gt;</operator><name>attinfuncs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                           <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                           <argument><expr><name><name>attinmeta</name><operator>-&gt;</operator><name>attioparams</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                           <argument><expr><name><name>attinmeta</name><operator>-&gt;</operator><name>atttypmods</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Handle dropped attributes by setting to NULL */</comment>
            <expr_stmt><expr><name><name>dvalues</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Form a tuple
     */</comment>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>dvalues</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Release locally palloc'd space.  XXX would probably be good to pfree
     * values of pass-by-reference datums, as well.
     */</comment>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * HeapTupleHeaderGetDatum - convert a HeapTupleHeader pointer to a Datum.
 *
 * This must *not* get applied to an on-disk tuple; the tuple should be
 * freshly made by heap_form_tuple or some wrapper routine for it (such as
 * BuildTupleFromCStrings).  Be sure also that the tupledesc used to build
 * the tuple has a properly "blessed" rowtype.
 *
 * Formerly this was a macro equivalent to PointerGetDatum, relying on the
 * fact that heap_form_tuple fills in the appropriate tuple header fields
 * for a composite Datum.  However, we now require that composite Datums not
 * contain any external TOAST pointers.  We do not want heap_form_tuple itself
 * to enforce that; more specifically, the rule applies only to actual Datums
 * and not to HeapTuple structures.  Therefore, HeapTupleHeaderGetDatum is
 * now a function that detects whether there are externally-toasted fields
 * and constructs a new tuple with inlined fields if so.  We still need
 * heap_form_tuple to insert the Datum header fields, because otherwise this
 * code would have no way to obtain a tupledesc for the tuple.
 *
 * Note that if we do build a new tuple, it's palloc'd in the current
 * memory context.  Beware of code that changes context between the initial
 * heap_form_tuple/etc call and calling HeapTuple(Header)GetDatum.
 *
 * For performance-critical callers, it could be worthwhile to take extra
 * steps to ensure that there aren't TOAST pointers in the output of
 * heap_form_tuple to begin with.  It's likely however that the costs of the
 * typcache lookup and tuple disassembly/reassembly are swamped by TOAST
 * dereference costs, so that the benefits of such extra effort would be
 * minimal.
 *
 * XXX it would likely be better to create wrapper functions that produce
 * a composite Datum from the field values in one step.  However, there's
 * enough code using the existing APIs that we couldn't get rid of this
 * hack anytime soon.
 */</comment>
<function><type><name>Datum</name></type>
<name>HeapTupleHeaderGetDatum</name><parameter_list>(<parameter><decl><type><name>HeapTupleHeader</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupDesc</name></decl>;</decl_stmt>

    <comment type="block">/* No work if there are no external TOAST pointers in the tuple */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleHeaderHasExternal</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Use the type data saved by heap_form_tuple to look up the rowtype */</comment>
    <expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* And do the flattening */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>toast_flatten_tuple_to_datum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
                                          <argument><expr><call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Functions for sending tuples to the frontend (or other specified destination)
 * as though it is a SELECT result. These are used by utility commands that
 * need to project directly to the destination and don't need or want full
 * table function capability. Currently used by EXPLAIN and SHOW ALL.
 */</comment>
<function><type><name>TupOutputState</name> <modifier>*</modifier></type>
<name>begin_tup_output_tupdesc</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupOutputState</name> <modifier>*</modifier></type><name>tstate</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tstate</name> <operator>=</operator> <operator>(</operator><name>TupOutputState</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupOutputState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>tstate</name><operator>-&gt;</operator><name>slot</name></name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tstate</name><operator>-&gt;</operator><name>dest</name></name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt>

    <expr_stmt><expr><call>(<modifier>*</modifier><name><name>tstate</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>rStartup</name></name>) <argument_list>(<argument><expr><name><name>tstate</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>CMD_SELECT</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>tstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * write a single tuple
 */</comment>
<function><type><name>void</name></type>
<name>do_tup_output</name><parameter_list>(<parameter><decl><type><name>TupOutputState</name> <modifier>*</modifier></type><name>tstate</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>tstate</name><operator>-&gt;</operator><name>slot</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>natts</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* make sure the slot is clear */</comment>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* insert data */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* mark slot as containing a virtual tuple */</comment>
    <expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* send the tuple to the receiver */</comment>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call>(<modifier>*</modifier><name><name>tstate</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>receiveSlot</name></name>) <argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>tstate</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* clean up */</comment>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * write a chunk of text, breaking at newline characters
 *
 * Should only be used with a single-TEXT-attribute tupdesc.
 */</comment>
<function><type><name>void</name></type>
<name>do_text_output_multiline</name><parameter_list>(<parameter><decl><type><name>TupOutputState</name> <modifier>*</modifier></type><name>tstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>txt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>isnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><operator>*</operator><name>txt</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eol</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>eol</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>txt</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>eol</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <name>eol</name> <operator>-</operator> <name>txt</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>eol</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>txt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>eol</name> <operator>=</operator> <name>txt</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name>txt</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>do_tup_output</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>txt</name> <operator>=</operator> <name>eol</name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>end_tup_output</name><parameter_list>(<parameter><decl><type><name>TupOutputState</name> <modifier>*</modifier></type><name>tstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call>(<modifier>*</modifier><name><name>tstate</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>rShutdown</name></name>) <argument_list>(<argument><expr><name><name>tstate</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* note that destroying the dest is not ours to do */</comment>
    <expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>tstate</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<comment type="block">/* --------------------------------
 *        ExecStoreDataRowTuple
 *
 *        Store a buffer in DataRow message format into the slot.
 *
 * --------------------------------
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecStoreDataRowTuple</name><parameter_list>(<parameter><decl><type><name>RemoteDataRow</name></type> <name>datarow</name></decl></parameter>,
                      <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name></type> <name>shouldFree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * sanity checks
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>datarow</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Free any old physical tuple belonging to the slot.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFree</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFreeMin</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>heap_free_minimal_tuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mintuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFreeRow</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_drowcxt</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_drowcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Drop the pin on the referenced buffer, if there is one.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_buffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Store the new tuple into the specified slot.
     */</comment>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isempty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFree</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFreeMin</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_shouldFreeRow</name></name> <operator>=</operator> <name>shouldFree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mintuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name> <operator>=</operator> <name>datarow</name></expr>;</expr_stmt>

    <comment type="block">/* Mark extracted state invalid */</comment>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
