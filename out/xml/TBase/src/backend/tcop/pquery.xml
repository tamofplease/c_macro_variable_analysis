<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/tcop/pquery.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pquery.c
 *      POSTGRES process query command code
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/tcop/pquery.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/tstoreReceiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_trace.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/producerReceiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/nodemgr.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_rusage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/squeue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execParallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/explain_dist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><name>bool</name></type>     <name>paramPassDown</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Hooks for plugins to get control in PortalStart */</comment>
<decl_stmt><decl><type><name>PortalStart_hook_type</name></type> <name>PortalStart_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * ActivePortal is the currently executing Portal (the most closely nested,
 * if there are several).
 */</comment>
<decl_stmt><decl><type><name>Portal</name></type>        <name>ActivePortal</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessQuery</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
             <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourceText</name></decl></parameter>,
             <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
             <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
             <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
			 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>instrument</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FillPortalStore</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>RunFromStore</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>count</name></decl></parameter>,
             <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>PortalRunSelect</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forward</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>count</name></decl></parameter>,
                <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PortalRunUtility</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
                 <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>setHoldSnapshot</name></decl></parameter>,
                 <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PortalRunMulti</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>,
               <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>setHoldSnapshot</name></decl></parameter>,
               <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>altdest</name></decl></parameter>,
               <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>DoPortalRunFetch</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>,
                 <parameter><decl><type><name>FetchDirection</name></type> <name>fdirection</name></decl></parameter>,
                 <parameter><decl><type><name>long</name></type> <name>count</name></decl></parameter>,
                 <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DoPortalRewind</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GetGtmInfoFromUserCmd</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>NeedSnapshot</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * CreateQueryDesc
 */</comment>
<function><type><name>QueryDesc</name> <modifier>*</modifier></type>
<name>CreateQueryDesc</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourceText</name></decl></parameter>,
                <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
                <parameter><decl><type><name>Snapshot</name></type> <name>crosscheck_snapshot</name></decl></parameter>,
                <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
                <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
                <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
                <parameter><decl><type><name>int</name></type> <name>instrument_options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>qd</name> <init>= <expr><operator>(</operator><name>QueryDesc</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueryDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>operation</name></name> <operator>=</operator> <name><name>plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>;</expr_stmt>    <comment type="block">/* operation */</comment>
    <expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>plannedstmt</name></name> <operator>=</operator> <name>plannedstmt</name></expr>;</expr_stmt>    <comment type="block">/* plan */</comment>
    <expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>sourceText</name></name> <operator>=</operator> <name>sourceText</name></expr>;</expr_stmt>    <comment type="block">/* query text */</comment>
    <expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* snapshot */</comment>
    <comment type="block">/* RI check snapshot */</comment>
    <expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>crosscheck_snapshot</name></name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><name>crosscheck_snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>dest</name></name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt>            <comment type="block">/* output dest */</comment>
    <expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>params</name></name> <operator>=</operator> <name>params</name></expr>;</expr_stmt>        <comment type="block">/* parameter values passed into query */</comment>
    <expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>queryEnv</name></name> <operator>=</operator> <name>queryEnv</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>instrument_options</name></name> <operator>=</operator> <name>instrument_options</name></expr>;</expr_stmt>    <comment type="block">/* instrumentation wanted? */</comment>

    <comment type="block">/* null these fields until set by ExecutorStart */</comment>
    <expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>planstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>totaltime</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>squeue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>myindex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>sender</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>es_param_exec_vals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>epqContext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* not yet executed */</comment>
    <expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>already_executed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <return>return <expr><name>qd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FreeQueryDesc
 */</comment>
<function><type><name>void</name></type>
<name>FreeQueryDesc</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>qdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Can't be a live query */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>estate</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* forget our snapshots */</comment>
    <expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>crosscheck_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Only the QueryDesc itself need be freed */</comment>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>qdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ProcessQuery
 *        Execute a single plannable query within a PORTAL_MULTI_QUERY,
 *        PORTAL_ONE_RETURNING, or PORTAL_ONE_MOD_WITH portal
 *
 *    plan: the plan tree for the query
 *    sourceText: the source text of the query
 *    params: any parameters needed
 *    dest: where to send results
 *    completionTag: points to a buffer of size COMPLETION_TAG_BUFSIZE
 *        in which to store a command completion status string.
 *
 * completionTag may be NULL if caller doesn't want a status string.
 *
 * Must be called in a memory context that will be reset or deleted on
 * error; otherwise the executor's memory usage will be leaked.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessQuery</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
             <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourceText</name></decl></parameter>,
             <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
             <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
             <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
			 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>instrument</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>         <name>eflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>queryDesc</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Create the QueryDesc object
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>need_snapshot</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>g_set_global_snapshot</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>queryDesc</name> <operator>=</operator> <call><name>CreateQueryDesc</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>sourceText</name></expr></argument>,
                            <argument><expr><name>InvalidSnapshot</name></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>,
							<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><name>instrument</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>queryDesc</name> <operator>=</operator> <call><name>CreateQueryDesc</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>sourceText</name></expr></argument>,
                                <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>,
								<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><name>instrument</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>hasReturning</name></name></expr>)</condition>
	<block>{<block_content>
	    <expr_stmt><expr><name>eflags</name> <operator>|=</operator> <name>EXEC_FLAG_RETURNING</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Call ExecutorStart to prepare the plan for execution
     */</comment>
	<expr_stmt><expr><call><name>ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Run the plan to completion.
     */</comment>
    <expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Build command completion status string, if caller wants one.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>completionTag</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>lastOid</name></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>CMD_SELECT</name></expr>:</case>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name>COMPLETION_TAG_BUFSIZE</name></expr></argument>,
                         <argument><expr><literal type="string">"SELECT "</literal> <name>UINT64_FORMAT</name></expr></argument>,
                         <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>CMD_INSERT</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>lastOid</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_lastoid</name></name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>lastOid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name>COMPLETION_TAG_BUFSIZE</name></expr></argument>,
                         <argument><expr><literal type="string">"INSERT %u "</literal> <name>UINT64_FORMAT</name></expr></argument>,
                         <argument><expr><name>lastOid</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name>COMPLETION_TAG_BUFSIZE</name></expr></argument>,
                         <argument><expr><literal type="string">"UPDATE "</literal> <name>UINT64_FORMAT</name></expr></argument>,
                         <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>CMD_DELETE</name></expr>:</case>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name>COMPLETION_TAG_BUFSIZE</name></expr></argument>,
                         <argument><expr><literal type="string">"DELETE "</literal> <name>UINT64_FORMAT</name></expr></argument>,
                         <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><literal type="string">"???"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>instrument</name> <operator>&amp;&amp;</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SendLocalInstr</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Now, we close down all the scans and free allocated resources.
     */</comment>
    <expr_stmt><expr><call><name>ExecutorFinish</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>planTree</name></name></expr></argument>, <argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Update coordinator statistics
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <switch>switch <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>CMD_INSERT</name></expr>:</case>
                        <comment type="block">/* One statement can insert into only one relation */</comment>
                        <expr_stmt><expr><call><name>pgstat_count_remote_insert</name><argument_list>(
                                <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ri_RelationDesc</name></expr></argument>,
                                <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
                    <case>case <expr><name>CMD_DELETE</name></expr>:</case>
                        <block>{<block_content>
                            <comment type="block">/*
                             * We can not determine here how many row were updated
                             * or delete in each table, so assume same number of
                             * affected row in each table.
                             * If resulting number of rows is 0 because of rounding,
                             * increment each counter at least on 1.
                             */</comment>
                            <decl_stmt><decl><type><name>int</name></type>        <name>i</name></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>int</name></type>     <name>n</name></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>bool</name></type>     <name>update</name></decl>;</decl_stmt>

                            <expr_stmt><expr><name>update</name> <operator>=</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name><operator>)</operator></expr>;</expr_stmt>
                            <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>/</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>Relation</name></type> <name>r</name></decl>;</decl_stmt>
                                <expr_stmt><expr><name>r</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ri_RelationDesc</name></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><name>update</name></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><call><name>pgstat_count_remote_update</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                                <else>else<block type="pseudo"><block_content>
                                    <expr_stmt><expr><call><name>pgstat_count_remote_delete</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                            </block_content>}</block></for>
                        </block_content>}</block>
                        <break>break;</break>
                    <default>default:</default>
                        <comment type="block">/* nothing to count */</comment>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ExecutorEnd</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FreeQueryDesc</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ChoosePortalStrategy
 *        Select portal execution strategy given the intended statement list.
 *
 * The list elements can be Querys or PlannedStmts.
 * That's more general than portals need, but plancache.c uses this too.
 *
 * See the comments in portal.h.
 */</comment>
<function><type><name>PortalStrategy</name></type>
<name>ChoosePortalStrategy</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmts</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>nSetTag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/*
     * PORTAL_ONE_SELECT and PORTAL_UTIL_SELECT need only consider the
     * single-statement case, since there are no rewrite rules that can add
     * auxiliary queries to a SELECT or a utility command. PORTAL_ONE_MOD_WITH
     * likewise allows only one top-level statement.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>PORTAL_ONE_MOD_WITH</name></expr>;</return></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <return>return <expr><name>PORTAL_ONE_SELECT</name></expr>;</return></block_content></block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>UtilityReturnsTuples</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>PORTAL_UTIL_SELECT</name></expr>;</return></block_content></block></if></if_stmt>
                    <comment type="block">/* it can't be ONE_RETURNING, so give up */</comment>
                    <return>return <expr><name>PORTAL_MULTI_QUERY</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
                <comment type="block">/*
                 * This is possible with an EXECUTE DIRECT in a SPI.
                 * PGXCTODO: there might be a better way to manage the
                 * cases with EXECUTE DIRECT here like using a special
                 * utility command and redirect it to a correct portal
                 * strategy.
                 * Something like PORTAL_UTIL_SELECT might be far better.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator>
                    <name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                    <call><name>IsA</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>step</name> <init>= <expr><operator>(</operator><name>RemoteQuery</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>
                    <comment type="block">/*
                     * Let's choose PORTAL_ONE_SELECT for now
                     * After adding more PGXC functionality we may have more
                     * sophisticated algorithm of determining portal strategy
                     *
                     * EXECUTE DIRECT is a utility but depending on its inner query
                     * it can return tuples or not depending on the query used.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>==</operator> <name>EXEC_DIRECT_SELECT</name>
                        <operator>||</operator> <name><name>step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>==</operator> <name>EXEC_DIRECT_UPDATE</name>
                        <operator>||</operator> <name><name>step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>==</operator> <name>EXEC_DIRECT_DELETE</name>
                        <operator>||</operator> <name><name>step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>==</operator> <name>EXEC_DIRECT_INSERT</name>
                        <operator>||</operator> <name><name>step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>==</operator> <name>EXEC_DIRECT_LOCAL</name></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>PORTAL_ONE_SELECT</name></expr>;</return></block_content></block></if>
                    <if type="elseif">else if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>==</operator> <name>EXEC_DIRECT_UTILITY</name>
                             <operator>||</operator> <name><name>step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>==</operator> <name>EXEC_DIRECT_LOCAL_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>PORTAL_MULTI_QUERY</name></expr>;</return></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <return>return <expr><name>PORTAL_ONE_SELECT</name></expr>;</return></block_content></block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>step</name> <init>= <expr><operator>(</operator><name>RemoteQuery</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>
            <comment type="block">/*
             * Let's choose PORTAL_ONE_SELECT for now
             * After adding more PGXC functionality we may have more
             * sophisticated algorithm of determining portal strategy.
             *
             * EXECUTE DIRECT is a utility but depending on its inner query
             * it can return tuples or not depending on the query used.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>==</operator> <name>EXEC_DIRECT_SELECT</name>
                <operator>||</operator> <name><name>step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>==</operator> <name>EXEC_DIRECT_UPDATE</name>
                <operator>||</operator> <name><name>step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>==</operator> <name>EXEC_DIRECT_DELETE</name>
                <operator>||</operator> <name><name>step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>==</operator> <name>EXEC_DIRECT_INSERT</name>
                <operator>||</operator> <name><name>step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>==</operator> <name>EXEC_DIRECT_LOCAL</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>PORTAL_ONE_SELECT</name></expr>;</return></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>==</operator> <name>EXEC_DIRECT_UTILITY</name>
                     <operator>||</operator> <name><name>step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>==</operator> <name>EXEC_DIRECT_LOCAL_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>PORTAL_MULTI_QUERY</name></expr>;</return></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <return>return <expr><name>PORTAL_ONE_SELECT</name></expr>;</return></block_content></block></else></if_stmt>
        </block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name> <init>= <expr><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>distributionRestrict</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>PORTAL_DISTRIBUTED</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>PORTAL_ONE_MOD_WITH</name></expr>;</return></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <return>return <expr><name>PORTAL_ONE_SELECT</name></expr>;</return></block_content></block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>UtilityReturnsTuples</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>PORTAL_UTIL_SELECT</name></expr>;</return></block_content></block></if></if_stmt>
                    <comment type="block">/* it can't be ONE_RETURNING, so give up */</comment>
                    <return>return <expr><name>PORTAL_MULTI_QUERY</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * PORTAL_ONE_RETURNING has to allow auxiliary queries added by rewrite.
     * Choose PORTAL_ONE_RETURNING if there is exactly one canSetTag query and
     * it has a RETURNING list.
     */</comment>
    <expr_stmt><expr><name>nSetTag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmts</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>++</operator><name>nSetTag</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>PORTAL_MULTI_QUERY</name></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* no need to look further */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name> <operator>||</operator>
                    <name><name>query</name><operator>-&gt;</operator><name>returningList</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>PORTAL_MULTI_QUERY</name></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* no need to look further */</comment>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name> <init>= <expr><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>++</operator><name>nSetTag</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>PORTAL_MULTI_QUERY</name></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* no need to look further */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name> <operator>||</operator>
                    <operator>!</operator><name><name>pstmt</name><operator>-&gt;</operator><name>hasReturning</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>PORTAL_MULTI_QUERY</name></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* no need to look further */</comment>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block>
    <if_stmt><if>if <condition>(<expr><name>nSetTag</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>PORTAL_ONE_RETURNING</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Else, it's the general case... */</comment>
    <return>return <expr><name>PORTAL_MULTI_QUERY</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FetchPortalTargetList
 *        Given a portal that returns tuples, extract the query targetlist.
 *        Returns NIL if the portal doesn't have a determinable targetlist.
 *
 * Note: do not modify the result.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>FetchPortalTargetList</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* no point in looking if we determined it doesn't return tuples */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PORTAL_MULTI_QUERY</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* get the primary statement and find out what it returns */</comment>
    <return>return <expr><call><name>FetchStatementTargetList</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>PortalGetPrimaryStmt</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FetchStatementTargetList
 *        Given a statement that returns tuples, extract the query targetlist.
 *        Returns NIL if the statement doesn't have a determinable targetlist.
 *
 * This can be applied to a Query or a PlannedStmt.
 * That's more general than portals need, but plancache.c uses this too.
 *
 * Note: do not modify the result.
 *
 * XXX be careful to keep this in sync with UtilityReturnsTuples.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>FetchStatementTargetList</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>stmt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* transfer attention to utility statement */</comment>
            <expr_stmt><expr><name>stmt</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr>;</return></block_content></block></if></if_stmt>
            <return>return <expr><name>NIL</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name> <init>= <expr><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* transfer attention to utility statement */</comment>
            <expr_stmt><expr><name>stmt</name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name><name>pstmt</name><operator>-&gt;</operator><name>planTree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>hasReturning</name></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name><name>pstmt</name><operator>-&gt;</operator><name>planTree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</return></block_content></block></if></if_stmt>
            <return>return <expr><name>NIL</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>FetchStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>FetchStmt</name>  <modifier>*</modifier></type><name>fstmt</name> <init>= <expr><operator>(</operator><name>FetchStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Portal</name></type>        <name>subportal</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>fstmt</name><operator>-&gt;</operator><name>ismove</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>subportal</name> <operator>=</operator> <call><name>GetPortalByName</name><argument_list>(<argument><expr><name><name>fstmt</name><operator>-&gt;</operator><name>portalname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>subportal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>FetchPortalTargetList</name><argument_list>(<argument><expr><name>subportal</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>ExecuteStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ExecuteStmt</name> <modifier>*</modifier></type><name>estmt</name> <init>= <expr><operator>(</operator><name>ExecuteStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name><name>estmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>FetchPreparedStatementTargetList</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PortalStart
 *        Prepare a portal for execution.
 *
 * Caller must already have created the portal, done PortalDefineQuery(),
 * and adjusted portal options if needed.
 *
 * If parameters are needed by the query, they must be passed in "params"
 * (caller is responsible for giving them appropriate lifetime).
 *
 * The caller can also provide an initial set of "eflags" to be passed to
 * ExecutorStart (but note these can be modified internally, and they are
 * currently only honored for PORTAL_ONE_SELECT portals).  Most callers
 * should simply pass zero.
 *
 * The caller can optionally pass a snapshot to be used; pass InvalidSnapshot
 * for the normal behavior of setting a new snapshot.  This parameter is
 * presently ignored for non-PORTAL_ONE_SELECT portals (it's only intended
 * to be used for cursors).
 *
 * On return, portal is ready to accept PortalRun() calls, and the result
 * tupdesc (if any) is known.
 */</comment>
<function><type><name>void</name></type>
<name>PortalStart</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
            <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Portal</name></type>        <name>saveActivePortal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResourceOwner</name></type> <name>saveResourceOwner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>savePortalContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>queryDesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>queryDesc</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int</name></type>            <name>myeflags</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type> <name>snapshot_set</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>PORTAL_DEFINED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Set up global portal context pointers.
     */</comment>
    <expr_stmt><expr><name>saveActivePortal</name> <operator>=</operator> <name>ActivePortal</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>saveResourceOwner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>savePortalContext</name> <operator>=</operator> <name>PortalContext</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>portal</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <call><name>PortalGetHeapMemory</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>PortalGetHeapMemory</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Must remember portal param list, if any */</comment>
        <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalParams</name></name> <operator>=</operator> <name>params</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Determine the portal execution strategy
         */</comment>
        <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <call><name>ChoosePortalStrategy</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Fire her up according to the strategy
         */</comment>
        <switch>switch <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
            <case>case <expr><name>PORTAL_DISTRIBUTED</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>  <name>i</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type> <name>paramNeedPassDown</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				
                <comment type="block">/* No special ability is needed */</comment>
                <expr_stmt><expr><name>eflags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <comment type="block">/* Must set snapshot before starting executor. */</comment>
                <if_stmt><if>if <condition>(<expr><name>snapshot</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <comment type="block">/*
                 * Create QueryDesc in portal's context; for the moment, set
                 * the destination to DestNone.
                 */</comment>
                <expr_stmt><expr><name>queryDesc</name> <operator>=</operator> <call><name>CreateQueryDesc</name><argument_list>(<argument><expr><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>sourceText</name></name></expr></argument>,
                                            <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>,
                                            <argument><expr><name>InvalidSnapshot</name></expr></argument>,
                                            <argument><expr><name>None_Receiver</name></expr></argument>,
                                            <argument><expr><name>params</name></expr></argument>,
                                            <argument><expr><name>NULL</name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                                            <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>up_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                                            <expr_stmt><expr><literal type="number">0</literal></expr></expr_stmt>)</block_content></block><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<comment type="block">/*
				 * set information about EvalPlanQual if any, they will be fill in
				 * estate later after it been created.
				 */</comment>
				<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>epqContext</name></name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>epqContext</name></name></expr>;</expr_stmt>
				
                <comment type="block">/*
                 * If parent node have sent down parameters, and at least one
                 * of them is PARAM_EXEC we should avoid "single execution"
                 * model. All parent nodes deliver the same values for
                 * PARAM_EXTERN since these values are provided by client and
                 * they are not changed during the query execution.
                 * On the contrary, values of PARAM_EXEC are results of execution
                 * on the parent node and in general diferent parents send to
                 * this node different values and executions are not equivalent.
                 * Since PARAM_EXECs are always at the end of the list we just
                 * need to check last item to figure out if there are any
                 * PARAM_EXECs.
                 * NB: Check queryDesc-&gt;plannedstmt-&gt;nParamExec &gt; 0 is incorrect
                 * here since queryDesc-&gt;plannedstmt-&gt;nParamExec may be used
                 * just to allocate space for them and no actual values passed.
				 *
				 * Also, if we are doing EvalPlanQual, we will be rescan soon, which
				 * is not supported in SharedQueue mode. Force to do it traditionally.
                 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>nParamRemote</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                        <decl_stmt><decl><type><name>RemoteParam</name> <modifier>*</modifier></type><name>rparam</name> <init>= <expr><operator>&amp;</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>remoteparams</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name><name>rparam</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_EXEC</name> <operator>&amp;&amp;</operator>
                            <name><name>rparam</name><operator>-&gt;</operator><name>paramused</name></name> <operator>!=</operator> <name>REMOTE_PARAM_INITPLAN</name></expr>)</condition> <comment type="block">/* if it's from initplan, still work with shared queue */</comment>
                        <block>{<block_content>
                                <expr_stmt><expr><name>paramNeedPassDown</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                                <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>

                <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>paramPassDown</name> <operator>&amp;&amp;</operator> <name>paramNeedPassDown</name><operator>)</operator> <operator>||</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>epqContext</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>   
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>nParamRemote</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                        <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>remoteparams</name><index>[<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>nParamRemote</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>paramkind</name> <operator>==</operator> <name>PARAM_EXEC</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name>        <modifier>*</modifier></type><name>consMap</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type>         <name>len</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Locator</name>       <modifier>*</modifier></type><name>locator</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Oid</name></type>            <name>keytype</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <decl_stmt><decl><type><name>int16</name></type> <name><name>nodeMap</name><index>[<expr><name>MAX_NODES_NUMBER</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>distributionNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>consMap</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>squeue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>myindex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>PGXC_PARENT_NODE_ID</name> <operator>=</operator> <call><name>PGXCNodeGetNodeIdFromName</name><argument_list>(<argument><expr><name>PGXC_PARENT_NODE</name></expr></argument>,
                                                       <argument><expr><operator>&amp;</operator><name>PGXC_PARENT_NODE_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <comment type="block">/* init nodemap */</comment>
                    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_NODES_NUMBER</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>nodeMap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>SQ_CONS_INIT</name></expr>;</expr_stmt>
                    </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>queryDesc-&gt;plannedstmt-&gt;distributionNodes</argument>)</argument_list></macro>
                    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                        <decl_stmt><decl><type><name>int</name></type> <name>nodeid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><name>PGXC_PARENT_NODE_ID</name> <operator>==</operator> <name>nodeid</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>consMap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>SQ_CONS_SELF</name></expr>;</expr_stmt>

                            <expr_stmt><expr><name><name>nodeMap</name><index>[<expr><name>nodeid</name></expr>]</index></name> <operator>=</operator> <name>SQ_CONS_SELF</name></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>consMap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>SQ_CONS_NONE</name></expr>;</expr_stmt>

                            <expr_stmt><expr><name><name>nodeMap</name><index>[<expr><name>nodeid</name></expr>]</index></name> <operator>=</operator> <name>SQ_CONS_NONE</name></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <if_stmt><if>if <condition>(<expr><name>PGXC_PARENT_NODE_ID</name> <operator>==</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>consMap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>SQ_CONS_SELF</name></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>consMap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>SQ_CONS_NONE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block>
                    <comment type="block">/*
                     * Multiple executions of the RemoteSubplan may lead to name
                     * conflict of SharedQueue, if the subplan has more
                     * RemoteSubplan nodes in the execution plan tree.
                     * We need to make them unique.
                     */</comment>
                    <expr_stmt><expr><call><name>RemoteSubplanMakeUnique</name><argument_list>(
                            <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></argument>,
							<argument><expr><name>PGXC_PARENT_NODE_ID</name></expr></argument>, <argument><expr><name>parentPGXCPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"RemoteSubplanMakeUnique for PARAM_EXEC unique: %d, portal: %s"</literal></expr></argument>,
                         <argument><expr><name>PGXC_PARENT_NODE_ID</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/*
                     * Call ExecutorStart to prepare the plan for execution
                     */</comment>
                    <expr_stmt><expr><call><name>ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Set up locator if result distribution is requested
                     */</comment>
                    <expr_stmt><expr><name>keytype</name> <operator>=</operator> <ternary><condition><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>distributionKey</name></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr> ?</condition><then>
                            <expr><name>InvalidOid</name></expr> </then><else>:
                            <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>distributionKey</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr></else></ternary></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
                    <expr_stmt><expr><name>locator</name> <operator>=</operator> <call><name>createLocator</name><argument_list>(
                            <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>distributionType</name></name></expr></argument>,
                            <argument><expr><name>RELATION_ACCESS_INSERT</name></expr></argument>,
                            <argument><expr><name>keytype</name></expr></argument>,
                            <argument><expr><name>LOCATOR_LIST_INT</name></expr></argument>,
                            <argument><expr><name>len</name></expr></argument>,
                            <argument><expr><name>consMap</name></expr></argument>,
                            <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><name>false</name></expr></argument>,
                            <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidAttrNumber</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>        
                    <expr_stmt><expr><name>locator</name> <operator>=</operator> <call><name>createLocator</name><argument_list>(
                            <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>distributionType</name></name></expr></argument>,
                            <argument><expr><name>RELATION_ACCESS_INSERT</name></expr></argument>,
                            <argument><expr><name>keytype</name></expr></argument>,
                            <argument><expr><name>LOCATOR_LIST_INT</name></expr></argument>,
                            <argument><expr><name>len</name></expr></argument>,
                            <argument><expr><name>consMap</name></expr></argument>,
                            <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>DestProducer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>SetProducerDestReceiverParams</name><argument_list>(<argument><expr><name>dest</name></expr></argument>,
                            <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>distributionKey</name></name></expr></argument>,
                            <argument><expr><name>locator</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>squeue</name></name></expr></argument>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                            ,
                            <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <comment type="block">/* set nodemap for shard distribution */</comment>
                    <if_stmt><if>if <condition>(<expr><name>LOCATOR_TYPE_SHARD</name> <operator>==</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>distributionType</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>SetProducerNodeMap</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>nodeMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name>        <modifier>*</modifier></type><name>consMap</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type>         <name>len</name></decl>;</decl_stmt>

                    <comment type="block">/* Distributed data requested, bind shared queue for data exchange */</comment>
                    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>distributionNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>consMap</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>squeue</name></name> <operator>=</operator> <call><name>SharedQueueBind</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                                <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>distributionRestrict</name></name></expr></argument>,
                                <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>distributionNodes</name></name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>myindex</name></name></expr></argument>, <argument><expr><name>consMap</name></expr></argument>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                                ,<argument><expr><operator>&amp;</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                )</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>myindex</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* producer */</comment>
                        <decl_stmt><decl><type><name>Locator</name>       <modifier>*</modifier></type><name>locator</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>Oid</name></type>            <name>keytype</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                        <if_stmt><if>if <condition>(<expr><name>distributed_query_analyze</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>StoreQueryAnalyzeInfo</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                        <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <block>{<block_content>
                            <comment type="block">/*
                             * Call ExecutorStart to prepare the plan for execution
                             */</comment>
                            <expr_stmt><expr><call><name>ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>
                        <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <block>{<block_content>
                            <comment type="block">/* Ensure SharedQueue is released */</comment>
                            <expr_stmt><expr><call><name>SharedQueueUnBind</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>squeue</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>squeue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>
                        <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/*
                         * This tells PortalCleanup to shut down the executor
                         */</comment>
                        <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>queryDesc</name></name> <operator>=</operator> <name>queryDesc</name></expr>;</expr_stmt>

                        <comment type="block">/*
                         * Some basic sanity checking against invalid remote plans.
                         */</comment>
                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>distributionKey</name></name> <operator>==</operator> <name>InvalidAttrNumber</name><operator>)</operator> <operator>||</operator>
                               <operator>(</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>distributionKey</name></name> <operator>&lt;=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/*
                         * Set up locator if result distribution is requested
                         */</comment>
                        <expr_stmt><expr><name>keytype</name> <operator>=</operator> <ternary><condition><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>distributionKey</name></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr> ?</condition><then>
                                <expr><name>InvalidOid</name></expr> </then><else>:
                                <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>distributionKey</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr></else></ternary></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
                        <expr_stmt><expr><name>locator</name> <operator>=</operator> <call><name>createLocator</name><argument_list>(
                                <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>distributionType</name></name></expr></argument>,
                                <argument><expr><name>RELATION_ACCESS_INSERT</name></expr></argument>,
                                <argument><expr><name>keytype</name></expr></argument>,
                                <argument><expr><name>LOCATOR_LIST_INT</name></expr></argument>,
                                <argument><expr><name>len</name></expr></argument>,
                                <argument><expr><name>consMap</name></expr></argument>,
                                <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><name>false</name></expr></argument>,
                                <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidAttrNumber</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <expr_stmt><expr><name>locator</name> <operator>=</operator> <call><name>createLocator</name><argument_list>(
                                <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>distributionType</name></name></expr></argument>,
                                <argument><expr><name>RELATION_ACCESS_INSERT</name></expr></argument>,
                                <argument><expr><name>keytype</name></expr></argument>,
                                <argument><expr><name>LOCATOR_LIST_INT</name></expr></argument>,
                                <argument><expr><name>len</name></expr></argument>,
                                <argument><expr><name>consMap</name></expr></argument>,
                                <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                        <if_stmt><if>if <condition>(<expr><call><name>needParallelSend</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>squeue</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>SetLocatorInfo</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>squeue</name></name></expr></argument>, <argument><expr><name>consMap</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, 
                                           <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>distributionType</name></name></expr></argument>, <argument><expr><name>keytype</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>distributionKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>DestProducer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>SetProducerDestReceiverParams</name><argument_list>(<argument><expr><name>dest</name></expr></argument>,
                                <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>distributionKey</name></name></expr></argument>,
                                <argument><expr><name>locator</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>squeue</name></name></expr></argument>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                              ,
                            <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                )</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt>

                        <expr_stmt><expr><call><name>addProducingPortal</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="block">/*
                         * We do not need to initialize executor, but need
                         * a tuple descriptor
                         */</comment>
                        <expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <call><name>ExecCleanTypeFromTL</name><argument_list>(
                                <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>planTree</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
                                <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>consMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>queryDesc</name></name> <operator>=</operator> <name>queryDesc</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Remember tuple descriptor (computed by ExecutorStart)
                 */</comment>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Reset cursor position data to "start of query"
                 */</comment>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>    <comment type="block">/* allow fetches */</comment>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></switch>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <case>case <expr><name>PORTAL_ONE_SELECT</name></expr>:</case>
                <comment type="block">/* Must set snapshot before starting executor. */</comment>
                <if_stmt><if>if <condition>(<expr><name>snapshot</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <block>{<block_content>
                    <comment type="block">/*
                     * set snapshot if needed
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>NeedSnapshot</name><argument_list>(<argument><expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                     <block>{<block_content>
                         <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>snapshot_set</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <comment type="block">/*
                 * Create QueryDesc in portal's context; for the moment, set
                 * the destination to DestNone.
                 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>snapshot_set</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>queryDesc</name> <operator>=</operator> <call><name>CreateQueryDesc</name><argument_list>(<argument><expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                                <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>sourceText</name></name></expr></argument>,
                                                <argument><expr><name>InvalidSnapshot</name></expr></argument>,
                                                <argument><expr><name>InvalidSnapshot</name></expr></argument>,
                                                <argument><expr><name>None_Receiver</name></expr></argument>,
                                                <argument><expr><name>params</name></expr></argument>,
                                                <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>,
                                                <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>up_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><name>queryDesc</name> <operator>=</operator> <call><name>CreateQueryDesc</name><argument_list>(<argument><expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>sourceText</name></name></expr></argument>,
                                            <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>,
                                            <argument><expr><name>InvalidSnapshot</name></expr></argument>,
                                            <argument><expr><name>None_Receiver</name></expr></argument>,
                                            <argument><expr><name>params</name></expr></argument>,
                                            <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                                            <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>up_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                                            <expr_stmt><expr><literal type="number">0</literal></expr></expr_stmt>)</block_content></block><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/*
				 * set information about EvalPlanQual if any, they will be fill in
				 * estate later after it been created.
				 */</comment>
				<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>epqContext</name></name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>epqContext</name></name></expr>;</expr_stmt>
				
				<comment type="block">/*
                 * If it's a scrollable cursor, executor needs to support
                 * REWIND and backwards scan, as well as whatever the caller
                 * might've asked for.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>cursorOptions</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_SCROLL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>myeflags</name> <operator>=</operator> <name>eflags</name> <operator>|</operator> <name>EXEC_FLAG_REWIND</name> <operator>|</operator> <name>EXEC_FLAG_BACKWARD</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>myeflags</name> <operator>=</operator> <name>eflags</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <comment type="block">/*
                 * Call ExecutorStart to prepare the plan for execution
                 */</comment>
                <expr_stmt><expr><call><name>ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>myeflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * This tells PortalCleanup to shut down the executor
                 */</comment>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>queryDesc</name></name> <operator>=</operator> <name>queryDesc</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Remember tuple descriptor (computed by ExecutorStart)
                 */</comment>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Reset cursor position data to "start of query"
                 */</comment>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>    <comment type="block">/* allow fetches */</comment>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><name>snapshot_set</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <break>break;</break>

            <case>case <expr><name>PORTAL_ONE_RETURNING</name></expr>:</case>
            <case>case <expr><name>PORTAL_ONE_MOD_WITH</name></expr>:</case>

                <comment type="block">/*
                 * We don't start the executor until we are told to run the
                 * portal.  We do need to set up the result tupdesc.
                 */</comment>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name>pstmt</name> <operator>=</operator> <call><name>PortalGetPrimaryStmt</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PORTAL_ONE_RETURNING</name> <operator>&amp;&amp;</operator>
						<name><name>pstmt</name><operator>-&gt;</operator><name>parseTree</name></name> <operator>&amp;&amp;</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>parseTree</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>parseTree</name><operator>-&gt;</operator><name>returningList</name></name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>planTree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator>
						<call><name>ExecCleanTypeFromTL</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>

                <comment type="block">/*
                 * Reset cursor position data to "start of query"
                 */</comment>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>    <comment type="block">/* allow fetches */</comment>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>PORTAL_UTIL_SELECT</name></expr>:</case>

                <comment type="block">/*
                 * We don't set snapshot here, because PortalRunUtility will
                 * take care of it if needed.
                 */</comment>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name> <init>= <expr><call><name>PortalGetPrimaryStmt</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <call><name>UtilityTupleDescriptor</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>

                <comment type="block">/*
                 * Reset cursor position data to "start of query"
                 */</comment>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>    <comment type="block">/* allow fetches */</comment>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>PORTAL_MULTI_QUERY</name></expr>:</case>
                <comment type="block">/* Need do nothing now */</comment>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></function>
		
		<if_stmt><if>if <condition>(<expr><name>PortalStart_hook</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PortalStart_hook</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    }
    PG_CATCH<expr_stmt><expr><operator>(</operator><operator>)</operator></expr>;</expr_stmt>
    <block>{<block_content>
        <comment type="block">/* Uncaught error while executing portal: mark it dead */</comment>
        <expr_stmt><expr><call><name>MarkPortalFailed</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>queryDesc</name> <operator>&amp;&amp;</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>squeue</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Associate the query desc with the portal so it is unbound upon
             * transaction end.
             */</comment>
            <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>queryDesc</name></name> <operator>=</operator> <name>queryDesc</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* Restore global vars and propagate error */</comment>
        <expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>saveActivePortal</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>saveResourceOwner</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <name>savePortalContext</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>saveActivePortal</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>saveResourceOwner</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <name>savePortalContext</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>PORTAL_READY</name></expr>;</expr_stmt>
}

<comment type="block">/*
 * PortalSetResultFormat
 *        Select the format codes for a portal's output.
 *
 * This must be run after PortalStart for a portal that will be read by
 * a DestRemote or DestRemoteExecute destination.  It is not presently needed
 * for other destination types.
 *
 * formats[] is the client format request, as per Bind message conventions.
 */</comment>
void
<macro><name>PortalSetResultFormat</name><argument_list>(<argument>Portal portal</argument>, <argument>int nFormats</argument>, <argument>int16 *formats</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>natts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Do nothing if portal won't return tuples */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>natts</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>formats</name></name> <operator>=</operator> <operator>(</operator><name>int16</name> <operator>*</operator><operator>)</operator>
        <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><call><name>PortalGetHeapMemory</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nFormats</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* format specified for each column */</comment>
        <if_stmt><if>if <condition>(<expr><name>nFormats</name> <operator>!=</operator> <name>natts</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bind message has %d result formats but query has %d columns"</literal></expr></argument>,
                            <argument><expr><name>nFormats</name></expr></argument>, <argument><expr><name>natts</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>formats</name></name></expr></argument>, <argument><expr><name>formats</name></expr></argument>, <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>nFormats</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* single format specified, use for all columns */</comment>
        <decl_stmt><decl><type><name>int16</name></type>        <name>format1</name> <init>= <expr><name><name>formats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>formats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>format1</name></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* use default format for all columns */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>formats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></else></if_stmt>
</block_content>}</block>

<comment type="block">/*
 * PortalRun
 *        Run a portal's query or queries.
 *
 * count &lt;= 0 is interpreted as a no-op: the destination gets started up
 * and shut down, but nothing else happens.  Also, count == FETCH_ALL is
 * interpreted as "all rows".  Note that count is ignored in multi-query
 * situations, where we always run the portal to completion.
 *
 * isTopLevel: true if query is being executed at backend "top level"
 * (that is, directly from a client command message)
 *
 * dest: where to send output of primary (canSetTag) query
 *
 * altdest: where to send output of non-primary queries
 *
 * completionTag: points to a buffer of size COMPLETION_TAG_BUFSIZE
 *        in which to store a command completion status string.
 *        May be NULL if caller doesn't want a status string.
 *
 * Returns TRUE if the portal's execution is complete, FALSE if it was
 * suspended due to exhaustion of the count parameter.
 */</comment>
<function><type><name>bool</name></type>
<name>PortalRun</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>run_once</name></decl></parameter>,
          <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>altdest</name></decl></parameter>,
          <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>nprocessed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResourceOwner</name></type> <name>saveTopTransactionResourceOwner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>saveTopTransactionContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Portal</name></type>        <name>saveActivePortal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResourceOwner</name></type> <name>saveResourceOwner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>savePortalContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>saveMemoryContext</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_EXECUTE_START</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Initialize completion tag to empty string */</comment>
    <if_stmt><if>if <condition>(<expr><name>completionTag</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>completionTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_executor_stats</name> <operator>&amp;&amp;</operator> <name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PORTAL_MULTI_QUERY</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"PortalRun"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* PORTAL_MULTI_QUERY logs its own stats per query */</comment>
        <expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Check for improper portal use, and mark portal active.
     */</comment>
    <expr_stmt><expr><call><name>MarkPortalActive</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set run_once flag.  Shouldn't be clear if previously set. */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>portal</name><operator>-&gt;</operator><name>run_once</name></name> <operator>||</operator> <name>run_once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>run_once</name></name> <operator>=</operator> <name>run_once</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Set up global portal context pointers.
     *
     * We have to play a special game here to support utility commands like
     * VACUUM and CLUSTER, which internally start and commit transactions.
     * When we are called to execute such a command, CurrentResourceOwner will
     * be pointing to the TopTransactionResourceOwner --- which will be
     * destroyed and replaced in the course of the internal commit and
     * restart.  So we need to be prepared to restore it as pointing to the
     * exit-time TopTransactionResourceOwner.  (Ain't that ugly?  This idea of
     * internally starting whole new transactions is not good.)
     * CurrentMemoryContext has a similar problem, but the other pointers we
     * save here will be NULL or pointing to longer-lived objects.
     */</comment>
    <expr_stmt><expr><name>saveTopTransactionResourceOwner</name> <operator>=</operator> <name>TopTransactionResourceOwner</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>saveTopTransactionContext</name> <operator>=</operator> <name>TopTransactionContext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>saveActivePortal</name> <operator>=</operator> <name>ActivePortal</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>saveResourceOwner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>savePortalContext</name> <operator>=</operator> <name>PortalContext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>saveMemoryContext</name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name>parallelExecutionError</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>portal</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <call><name>PortalGetHeapMemory</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>PortalContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>PORTAL_ONE_SELECT</name></expr>:</case>
            <case>case <expr><name>PORTAL_ONE_RETURNING</name></expr>:</case>
            <case>case <expr><name>PORTAL_ONE_MOD_WITH</name></expr>:</case>
            <case>case <expr><name>PORTAL_UTIL_SELECT</name></expr>:</case>

                <comment type="block">/*
                 * If we have not yet run the command, do so, storing its
                 * results in the portal's tuplestore.  But we don't do that
                 * for the PORTAL_ONE_SELECT case.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PORTAL_ONE_SELECT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>FillPortalStore</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * Now fetch desired portion of results.
                 */</comment>
                <expr_stmt><expr><name>nprocessed</name> <operator>=</operator> <call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * If the portal result contains a command tag and the caller
                 * gave us a pointer to store it, copy it. Patch the "SELECT"
                 * tag to also provide the rowcount.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>completionTag</name> <operator>&amp;&amp;</operator> <name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name>COMPLETION_TAG_BUFSIZE</name></expr></argument>,
                                 <argument><expr><literal type="string">"SELECT "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>nprocessed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* Mark portal not active */</comment>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>PORTAL_READY</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Since it's a forward fetch, say DONE iff atEnd is now true.
                 */</comment>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>PORTAL_MULTI_QUERY</name></expr>:</case>
                <expr_stmt><expr><call><name>PortalRunMulti</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                               <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>altdest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Prevent portal's commands from being re-executed */</comment>
                <expr_stmt><expr><call><name>MarkPortalDone</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Always complete at end of RunMulti */</comment>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
            <case>case <expr><name>PORTAL_DISTRIBUTED</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <name>FETCH_ALL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>nprocessed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>queryDesc</name><operator>-&gt;</operator><name>myindex</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>queryDesc</name><operator>-&gt;</operator><name>squeue</name></name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* Make sure the producer is advancing */</comment>
                        <while>while <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>nprocessed</name> <operator>&lt;</operator> <name>count</name></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>portal</name><operator>-&gt;</operator><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_finished</name></name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>AdvanceProducingPortal</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            <comment type="block">/* make read pointer active */</comment>
                            <expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <comment type="block">/* perform reads */</comment>
                            <expr_stmt><expr><name>nprocessed</name> <operator>+=</operator> <call><name>RunFromStore</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
                                                       <argument><expr><name>ForwardScanDirection</name></expr></argument>,
                                               <argument><expr><ternary><condition><expr><name>count</name></expr> ?</condition><then> <expr><name>count</name> <operator>-</operator> <name>nprocessed</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
                                                       <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <comment type="block">/*
                             * Switch back to the write pointer
                             * We do not want to seek if the tuplestore operates
                             * with a file, so copy pointer before.
                             * Also advancing write pointer would allow to free some
                             * memory.
                             */</comment>
                            <expr_stmt><expr><call><name>tuplestore_copy_read_pointer</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <comment type="block">/* try to release occupied memory */</comment>
                            <expr_stmt><expr><call><name>tuplestore_trim</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <comment type="block">/* Break if we can not get more rows */</comment>
                            <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_finished</name></name></expr>)</condition><block type="pseudo"><block_content>
                                <break>break;</break></block_content></block></if></if_stmt>
                        </block_content>}</block></while>
                        <if_stmt><if>if <condition>(<expr><name>nprocessed</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* OK to go backward now */</comment>
                        <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_finished</name></name> <operator>&amp;&amp;</operator>
                            <call><name>tuplestore_ateof</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name> <operator>+=</operator> <name>nprocessed</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                        <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>removeProducingPortal</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>olddest</name></decl>;</decl_stmt>

                        <expr_stmt><expr><name>count</name> <operator>=</operator> <name>FETCH_ALL</name></expr>;</expr_stmt>

                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>queryDesc</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>mydest</name></name> <operator>==</operator> <name>DestProducer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>olddest</name> <operator>=</operator> <call><name>SetSelfConsumerDestReceiver</name><argument_list>(
                                <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/*
                         * Now fetch desired portion of results.
                         */</comment>
                        <expr_stmt><expr><name>nprocessed</name> <operator>=</operator> <call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>count</name></expr></argument>,
                                                     <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>SetSelfConsumerDestReceiver</name><argument_list>(
                                <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>, <argument><expr><name>olddest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name>QueryDesc</name>       <modifier>*</modifier></type><name>queryDesc</name> <init>= <expr><name><name>portal</name><operator>-&gt;</operator><name>queryDesc</name></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>SharedQueue</name></type>        <name>squeue</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>squeue</name></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type>             <name>myindex</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>myindex</name></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>squeue</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"squeue: %s is null, myindex: %d, atStart: %d, atEnd: %d"</literal></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>myindex</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/*
                     * We are the consumer.
                     * We have skipped plan initialization, hence we do not have
                     * a tuple table to get a slot to receive tuples, so prepare
                     * standalone slot.
                     */</comment>
                    <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call>(<modifier>*</modifier><name><name>dest</name><operator>-&gt;</operator><name>rStartup</name></name>) <argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>CMD_SELECT</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Loop until we've processed the proper number of tuples
                     * from the plan.
                     */</comment>
                    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>producing</name> <init>= <expr><call><name>getProducingPortals</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>bool</name></type> <name>done</name></decl>;</decl_stmt>

                        <comment type="block">/*
                         * Obtain a tuple from the queue.
                         * If the session is running producing cursors it is
                         * not safe to wait for available tuple. Two sessions
                         * may deadlock each other. So if session is producing
                         * it should keep advancing producing cursors.
                         */</comment>

                        <expr_stmt><expr><name>done</name> <operator>=</operator> <call><name>SharedQueueRead</name><argument_list>(<argument><expr><name>squeue</name></expr></argument>, <argument><expr><name>myindex</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
                                               <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>producing</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/*
                         * if the tuple is null, then we assume there is nothing
                         * more to process so we end the loop...
                         * Also if null tuple is returned the squeue is reset
                         * already, we want to prevent resetting it again
                         */</comment>
                        <if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>done</name> <operator>&amp;&amp;</operator> <name>producing</name></expr>)</condition>
                            <block>{<block_content>
                                <comment type="block">/* No data to read, advance producing portals */</comment>
                                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name>producing</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                <while>while <condition>(<expr><name>lc</name></expr>)</condition>
                                <block>{<block_content>
                                    <decl_stmt><decl><type><name>Portal</name></type> <name>p</name> <init>= <expr><operator>(</operator><name>Portal</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                    <comment type="block">/* Get reference to next entry before
                                     * advancing current portal, because the
                                     * function may remove current entry from
                                     * the list.
                                     */</comment>
                                    <expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <expr_stmt><expr><call><name>AdvanceProducingPortal</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></while>
                                <continue>continue;</continue>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>squeue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                                <break>break;</break>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block></if></if_stmt>
                        <comment type="block">/*
                         * Send the tuple
                         */</comment>
                        <expr_stmt><expr><call>(<modifier>*</modifier><name><name>dest</name><operator>-&gt;</operator><name>receiveSlot</name></name>) <argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/*
                         * increment the number of processed tuples and check count.
                         * If we've processed the proper number then quit, else
                         * loop again and process more tuples. Zero count means
                         * no limit.
                         */</comment>
                        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&amp;&amp;</operator> <name>count</name> <operator>==</operator> <operator>++</operator><name>nprocessed</name></expr>)</condition><block type="pseudo"><block_content>
                            <break>break;</break></block_content></block></if></if_stmt>
                    </block_content>}</block></for>
                    <expr_stmt><expr><call>(<modifier>*</modifier><name><name>dest</name><operator>-&gt;</operator><name>rShutdown</name></name>) <argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>nprocessed</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>        <comment type="block">/* OK to go backward now */</comment>
                    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                        <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>nprocessed</name> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>count</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* we retrieved 'em all */</comment>
                    <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name> <operator>+=</operator> <name>nprocessed</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <comment type="block">/* Mark portal not active */</comment>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>PORTAL_READY</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name></expr>;</expr_stmt>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized portal strategy: %d"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* keep compiler quiet */</comment>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>HandleParallelExecutionError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Uncaught error while executing portal: mark it dead */</comment>
        <expr_stmt><expr><call><name>MarkPortalFailed</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Restore global vars and propagate error */</comment>
        <if_stmt><if>if <condition>(<expr><name>saveMemoryContext</name> <operator>==</operator> <name>saveTopTransactionContext</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>saveMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>saveActivePortal</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>saveResourceOwner</name> <operator>==</operator> <name>saveTopTransactionResourceOwner</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>TopTransactionResourceOwner</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>saveResourceOwner</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <name>savePortalContext</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>saveMemoryContext</name> <operator>==</operator> <name>saveTopTransactionContext</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/*
     * saveMemoryContext points to subtransaction's memorycontext, but ROLLBACK SUBTXN
     * has already released the resource, so we need to switch to current transaction context.
     */</comment>
    <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK SUBTXN"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>curTransactionContext</name> <init>= <expr><call><name>GetCurrentTransactionContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>curTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>saveMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>saveActivePortal</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>saveResourceOwner</name> <operator>==</operator> <name>saveTopTransactionResourceOwner</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>TopTransactionResourceOwner</name></expr>;</expr_stmt></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/*
     * saveResourceOwner points to subtransaction's resourceOwner, but ROLLBACK SUBTXN
     * has already released the resource, so we need to switch to current transaction owner.
     */</comment>
	<if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK SUBTXN"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <call><name>GetCurrentTransactionResourceOwner</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>saveResourceOwner</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <name>savePortalContext</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_executor_stats</name> <operator>&amp;&amp;</operator> <name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PORTAL_MULTI_QUERY</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"EXECUTOR STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_EXECUTE_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PortalRunSelect
 *        Execute a portal's query in PORTAL_ONE_SELECT mode, and also
 *        when fetching from a completed holdStore in PORTAL_ONE_RETURNING,
 *        PORTAL_ONE_MOD_WITH, and PORTAL_UTIL_SELECT cases.
 *
 * This handles simple N-rows-forward-or-backward cases.  For more complex
 * nonsequential access to a portal, see PortalRunFetch.
 *
 * count &lt;= 0 is interpreted as a no-op: the destination gets started up
 * and shut down, but nothing else happens.  Also, count == FETCH_ALL is
 * interpreted as "all rows".  (cf FetchStmt.howMany)
 *
 * Caller must already have validated the Portal and done appropriate
 * setup (cf. PortalRun).
 *
 * Returns number of rows processed (suitable for use in result tag)
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>PortalRunSelect</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>,
                <parameter><decl><type><name>bool</name></type> <name>forward</name></decl></parameter>,
                <parameter><decl><type><name>long</name></type> <name>count</name></decl></parameter>,
                <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>queryDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanDirection</name></type> <name>direction</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>nprocessed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name>        <name>rusage</name></name></type> <name>start_r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name>        <name>timeval</name></name></type> <name>start_t</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_executor_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ResetUsageCommon</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start_r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/*
     * NB: queryDesc will be NULL if we are fetching from a held cursor or a
     * completed utility query; can't use it in that path.
     */</comment>
    <expr_stmt><expr><name>queryDesc</name> <operator>=</operator> <call><name>PortalGetQueryDesc</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Caller messed up if we have neither a ready query nor held data. */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryDesc</name> <operator>||</operator> <name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Force the queryDesc destination to the right thing.  This supports
     * MOVE, for example, which will pass in dest = DestNone.  This is okay to
     * change as long as we do it on every fetch.  (The Executor must not
     * assume that dest never changes.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>queryDesc</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Determine which direction to go in, and check to see if we're already
     * at the end of the available tuples in that direction.  If so, set the
     * direction to NoMovement to avoid trying to fetch any tuples.  (This
     * check exists because not all plan node types are robust about being
     * called again if they've already returned NULL once.)  Then call the
     * executor (we must not skip this, because the destination needs to see a
     * setup and shutdown even if no tuples are available).  Finally, update
     * the portal position state depending on the number of tuples that were
     * retrieved.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>forward</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name> <operator>||</operator> <name>count</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>direction</name> <operator>=</operator> <name>NoMovementScanDirection</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>            <comment type="block">/* don't pass negative count to executor */</comment>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>direction</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* In the executor, zero count processes all rows */</comment>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <name>FETCH_ALL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>nprocessed</name> <operator>=</operator> <call><name>RunFromStore</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>count</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>count</name></expr></argument>,
                        <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>run_once</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nprocessed</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ScanDirectionIsNoMovement</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>nprocessed</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* OK to go backward now */</comment>
            <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>nprocessed</name> <operator>&lt;</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>count</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* we retrieved 'em all */</comment>
            <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name> <operator>+=</operator> <name>nprocessed</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>cursorOptions</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_NO_SCROLL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor can only scan forward"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Declare it with SCROLL option to enable backward scan."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name> <operator>||</operator> <name>count</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>direction</name> <operator>=</operator> <name>NoMovementScanDirection</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>            <comment type="block">/* don't pass negative count to executor */</comment>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>direction</name> <operator>=</operator> <name>BackwardScanDirection</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* In the executor, zero count processes all rows */</comment>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <name>FETCH_ALL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>nprocessed</name> <operator>=</operator> <call><name>RunFromStore</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>count</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>count</name></expr></argument>,
                        <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>run_once</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nprocessed</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ScanDirectionIsNoMovement</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>nprocessed</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>    <comment type="block">/* OK to go forward now */</comment>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name><operator>++</operator></expr>;</expr_stmt>    <comment type="block">/* adjust for endpoint case */</comment>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>nprocessed</name> <operator>&lt;</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>count</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> <comment type="block">/* we retrieved 'em all */</comment>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name> <operator>-=</operator> <name>nprocessed</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_executor_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ShowUsageCommon</name><argument_list>(<argument><expr><literal type="string">"PortalRunSelect"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>nprocessed</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FillPortalStore
 *        Run the query and load result tuples into the portal's tuple store.
 *
 * This is used for PORTAL_ONE_RETURNING, PORTAL_ONE_MOD_WITH, and
 * PORTAL_UTIL_SELECT cases only.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FillPortalStore</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>treceiver</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>completionTag</name><index>[<expr><name>COMPLETION_TAG_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PortalCreateHoldStore</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>treceiver</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>DestTuplestore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetTuplestoreDestReceiverParams</name><argument_list>(<argument><expr><name>treceiver</name></expr></argument>,
                                    <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr></argument>,
                                    <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdContext</name></name></expr></argument>,
                                    <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>completionTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PORTAL_ONE_RETURNING</name></expr>:</case>
        <case>case <expr><name>PORTAL_ONE_MOD_WITH</name></expr>:</case>

            <comment type="block">/*
             * Run the portal to completion just as for the default
             * MULTI_QUERY case, but send the primary query's output to the
             * tuplestore.  Auxiliary query outputs are discarded.  Set the
             * portal's holdSnapshot to the snapshot used (or a copy of it).
             */</comment>
            <expr_stmt><expr><call><name>PortalRunMulti</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                           <argument><expr><name>treceiver</name></expr></argument>, <argument><expr><name>None_Receiver</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PORTAL_UTIL_SELECT</name></expr>:</case>
            <expr_stmt><expr><call><name>PortalRunUtility</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>treceiver</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported portal strategy: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/* Override default completion tag with actual command result */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>completionTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call>(<modifier>*</modifier><name><name>treceiver</name><operator>-&gt;</operator><name>rDestroy</name></name>) <argument_list>(<argument><expr><name>treceiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RunFromStore
 *        Fetch tuples from the portal's tuple store.
 *
 * Calling conventions are similar to ExecutorRun, except that we
 * do not depend on having a queryDesc or estate.  Therefore we return the
 * number of tuples processed as the result, not in estate-&gt;es_processed.
 *
 * One difference from ExecutorRun is that the destination receiver functions
 * are run in the caller's memory context (since we have no estate).  Watch
 * out for memory leaks.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>RunFromStore</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>count</name></decl></parameter>,
             <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>current_tuple_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call>(<modifier>*</modifier><name><name>dest</name><operator>-&gt;</operator><name>rStartup</name></name>) <argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>CMD_SELECT</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsNoMovement</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* do nothing except start/stop the destination */</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>        <name>forward</name> <init>= <expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>ok</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr></argument>, <argument><expr><name>forward</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <comment type="block">/*
             * If we are not able to send the tuple, we assume the destination
             * has closed and no more tuples can be sent. If that's the case,
             * end the loop.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call>(<modifier>*</modifier><name><name>dest</name><operator>-&gt;</operator><name>receiveSlot</name></name>) <argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * check our tuple count.. if we've processed the proper number
             * then quit, else loop again and process more tuples. Zero count
             * means no limit.
             */</comment>
            <expr_stmt><expr><name>current_tuple_count</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&amp;&amp;</operator> <name>count</name> <operator>==</operator> <name>current_tuple_count</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call>(<modifier>*</modifier><name><name>dest</name><operator>-&gt;</operator><name>rShutdown</name></name>) <argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>current_tuple_count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PortalRunUtility
 *        Execute a utility statement inside a portal.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PortalRunUtility</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
                 <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>setHoldSnapshot</name></decl></parameter>,
                 <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>utilityStmt</name> <init>= <expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Snapshot</name></type>    <name>snapshot</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* 
     * If process alter gtm node OR create gtm node command, we set NewGtmHost and NewGtmPort here.
     * Fucntion GetTransactionSnapshot will try to connect gtm using this gtm info.
     */</comment>
    <expr_stmt><expr><call><name>GetGtmInfoFromUserCmd</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Set snapshot if utility stmt needs one.  Most reliable way to do this
	 * seems to be to enumerate those that do not need one; this is a short
	 * list.  Transaction control, LOCK, and SET must *not* set a snapshot
	 * since they need to be executable at the start of a transaction-snapshot
	 * mode transaction without freezing a snapshot.  By extension we allow
	 * SHOW not to set a snapshot.  The other stmts listed are just efficiency
	 * hacks.  Beware of listing anything that can modify the database --- if,
	 * say, it has to update an index with expressions that invoke
	 * user-defined functions, then it had better have a snapshot.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>TransactionStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
		  <call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>LockStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
		  <call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>VariableSetStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
		  <call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>VariableShowStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
		  <call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>ConstraintsSetStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
	<comment type="block">/* efficiency hacks from here down */</comment>
		  <call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>FetchStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
		  <call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>ListenStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
		  <call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>NotifyStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
		  <call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>UnlistenStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		  <comment type="block">/* Node Lock/Unlock do not modify any data */</comment>
		  <call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>LockNodeStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
          <call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>PauseClusterStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
          <call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>BarrierStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
          <operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>CheckPointStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>IS_PGXC_DATANODE</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <expr_stmt><expr><call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>CheckPointStmt</name></expr></argument>)</argument_list></call></expr></expr_stmt></block_content></block></if></if_stmt>)</block_content></block></function>)
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
		<comment type="block">/* Avoid the start timestamp to be too old to execute on DNs */</comment>
		<if_stmt><if>if<condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>VacuumStmt</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>AlterNodeStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>GetLocalTransactionSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
        <block>{<block_content>
            <expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* If told to, register the snapshot we're using and save in portal */</comment>
        <if_stmt><if>if <condition>(<expr><name>setHoldSnapshot</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>holdSnapshot</name></name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* PushActiveSnapshot might have copied the snapshot */</comment>
        <expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <if_stmt><else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>snapshot</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>ProcessUtility</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>,
                   <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>sourceText</name></name></expr></argument>,
                   <argument><expr><ternary><condition><expr><name>isTopLevel</name></expr> ?</condition><then> <expr><name>PROCESS_UTILITY_TOPLEVEL</name></expr> </then><else>: <expr><name>PROCESS_UTILITY_QUERY</name></expr></else></ternary></expr></argument>,
                   <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalParams</name></name></expr></argument>,
                   <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>,
                   <argument><expr><name>dest</name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
                   <argument><expr><name>false</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>
                   <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Some utility statements may change context on us */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>PortalGetHeapMemory</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Some utility commands may pop the ActiveSnapshot stack from under us,
     * so be careful to only pop the stack if our snapshot is still at the
     * top.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>snapshot</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
        <name>snapshot</name> <operator>==</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Clear snapshots created in process QueryRewriteCTAS */</comment>
		<while>while <condition>(<expr><call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>S_FOR_CTAS</name> <operator>==</operator> <call><name>GetActiveSnapshotStatus</name><argument_list>()</argument_list></call> <operator>||</operator>
				<name>snapshot</name> <operator>==</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>
}

<comment type="block">/*
 * PortalRunMulti
 *        Execute a portal's queries in the general case (multi queries
 *        or non-SELECT-like queries)
 */</comment>
static <function><type><name>void</name></type>
<name>PortalRunMulti</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>,
               <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>setHoldSnapshot</name></decl></parameter>,
               <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>altdest</name></decl></parameter>,
               <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>active_snapshot_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>stmtlist_item</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <decl_stmt><decl><type><name>CombineTag</name></type>    <name>combine</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>combine</name><operator>.</operator><name>cmdType</name></name> <operator>=</operator> <name>CMD_UNKNOWN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combine</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If the destination is DestRemoteExecute, change to DestNone.  The
     * reason is that the client won't be expecting any tuples, and indeed has
     * no way to know what they are, since there is no provision for Describe
     * to send a RowDescription message when this portal execution strategy is
     * in effect.  This presently will only affect SELECT commands added to
     * non-SELECT queries by rewrite rules: such commands will be executed,
     * but the results will be discarded unless you use "simple Query"
     * protocol.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>dest</name><operator>-&gt;</operator><name>mydest</name></name> <operator>==</operator> <name>DestRemoteExecute</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>dest</name> <operator>=</operator> <name>None_Receiver</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>altdest</name><operator>-&gt;</operator><name>mydest</name></name> <operator>==</operator> <name>DestRemoteExecute</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>altdest</name> <operator>=</operator> <name>None_Receiver</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Loop to handle the individual queries generated from a single parsetree
     * by analysis and rewrite.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>stmtlist_item</argument>, <argument>portal-&gt;stmts</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>stmtlist_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If we got a cancel signal in prior command, quit
         */</comment>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * process a plannable query.
             */</comment>
            <expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_EXECUTE_START</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>log_executor_stats</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Must always have a snapshot for plannable queries.  First time
             * through, take a new snapshot; for subsequent queries in the
             * same portal, just update the snapshot's copy of the command
             * counter.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>active_snapshot_set</name></expr>)</condition>
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>setHoldSnapshot</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NeedSnapshot</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* will set snapshot when execute */</comment>
                    <expr_stmt><expr><name>active_snapshot_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <decl_stmt><decl><type><name>Snapshot</name></type>    <name>snapshot</name> <init>= <expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="block">/* If told to, register the snapshot and save in portal */</comment>
                <if_stmt><if>if <condition>(<expr><name>setHoldSnapshot</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>holdSnapshot</name></name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * We can't have the holdSnapshot also be the active one,
                 * because UpdateActiveSnapshotCommandId would complain.  So
                 * force an extra snapshot copy.  Plain PushActiveSnapshot
                 * would have copied the transaction snapshot anyway, so this
                 * only adds a copy step when setHoldSnapshot is true.  (It's
                 * okay for the command ID of the active snapshot to diverge
                 * from what holdSnapshot has.)
                 */</comment>
                <expr_stmt><expr><call><name>PushCopiedSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>active_snapshot_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                </block_content>}</block></else></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>SetSendCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>UpdateActiveSnapshotCommandId</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* statement can set tag string */</comment>
                <expr_stmt><expr><call><name>ProcessQuery</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>,
                             <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>sourceText</name></name></expr></argument>,
                             <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalParams</name></name></expr></argument>,
                             <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>,
							 <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>,
							 <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>up_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
                <comment type="block">/* it's special for INSERT */</comment>
                <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator>
                    <name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>HandleCmdComplete</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>combine</name></expr></argument>,
                            <argument><expr><name>completionTag</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* stmt added by rewrite cannot set tag */</comment>
                <expr_stmt><expr><call><name>ProcessQuery</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>,
                             <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>sourceText</name></name></expr></argument>,
                             <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalParams</name></name></expr></argument>,
                             <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>,
							 <argument><expr><name>altdest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>up_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>log_executor_stats</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"EXECUTOR STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_EXECUTE_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * process utility functions (create, destroy, etc..)
             *
             * We must not set a snapshot here for utility commands (if one is
             * needed, PortalRunUtility will do it).  If a utility command is
             * alone in a portal then everything's fine.  The only case where
             * a utility command can be part of a longer list is that rules
             * are allowed to include NotifyStmt.  NotifyStmt doesn't care
             * whether it has a snapshot or not, so we just leave the current
             * snapshot alone if we have one.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>active_snapshot_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* statement can set tag string */</comment>
                <expr_stmt><expr><call><name>PortalRunUtility</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                 <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>NotifyStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* stmt added by rewrite cannot set tag */</comment>
                <expr_stmt><expr><call><name>PortalRunUtility</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                 <argument><expr><name>altdest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * Increment command counter between queries, but not after the last
         * one.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>stmtlist_item</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Clear subsidiary contexts to recover temporary memory.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PortalGetHeapMemory</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemoryContextDeleteChildren</name><argument_list>(<argument><expr><call><name>PortalGetHeapMemory</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Pop the snapshot if we pushed one. */</comment>
    <if_stmt><if>if <condition>(<expr><name>active_snapshot_set</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If a command completion tag was supplied, use it.  Otherwise use the
     * portal's commandTag as the default completion tag.
     *
     * Exception: Clients expect INSERT/UPDATE/DELETE tags to have counts, so
     * fake them with zeros.  This can happen with DO INSTEAD rules if there
     * is no replacement query of the same type as the original.  We print "0
     * 0" here because technically there is no query of the matching tag type,
     * and printing a non-zero count for a different query type seems wrong,
     * e.g.  an INSERT that does an UPDATE instead should not print "0 1" if
     * one row was updated.  See QueryRewrite(), step 3, for details.
     */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <name><name>combine</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name><name>combine</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>completionTag</name> <operator>&amp;&amp;</operator> <name><name>completionTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><literal type="string">"SELECT 0 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><literal type="string">"INSERT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><literal type="string">"INSERT 0 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><literal type="string">"UPDATE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><literal type="string">"UPDATE 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><literal type="string">"DELETE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><literal type="string">"DELETE 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PortalRunFetch
 *        Variant form of PortalRun that supports SQL FETCH directions.
 *
 * Note: we presently assume that no callers of this want isTopLevel = true.
 *
 * count &lt;= 0 is interpreted as a no-op: the destination gets started up
 * and shut down, but nothing else happens.  Also, count == FETCH_ALL is
 * interpreted as "all rows".  (cf FetchStmt.howMany)
 *
 * Returns number of rows processed (suitable for use in result tag)
 */</comment>
<function><type><name>uint64</name></type>
<name>PortalRunFetch</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>,
               <parameter><decl><type><name>FetchDirection</name></type> <name>fdirection</name></decl></parameter>,
               <parameter><decl><type><name>long</name></type> <name>count</name></decl></parameter>,
               <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Portal</name></type>        <name>saveActivePortal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResourceOwner</name></type> <name>saveResourceOwner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>savePortalContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check for improper portal use, and mark portal active.
     */</comment>
    <expr_stmt><expr><call><name>MarkPortalActive</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If supporting FETCH, portal can't be run-once. */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>portal</name><operator>-&gt;</operator><name>run_once</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Set up global portal context pointers.
     */</comment>
    <expr_stmt><expr><name>saveActivePortal</name> <operator>=</operator> <name>ActivePortal</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>saveResourceOwner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>savePortalContext</name> <operator>=</operator> <name>PortalContext</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>portal</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <call><name>PortalGetHeapMemory</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>PortalContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>PORTAL_ONE_SELECT</name></expr>:</case>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DoPortalRunFetch</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>fdirection</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>PORTAL_ONE_RETURNING</name></expr>:</case>
            <case>case <expr><name>PORTAL_ONE_MOD_WITH</name></expr>:</case>
            <case>case <expr><name>PORTAL_UTIL_SELECT</name></expr>:</case>

                <comment type="block">/*
                 * If we have not yet run the command, do so, storing its
                 * results in the portal's tuplestore.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>FillPortalStore</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* isTopLevel */</comment> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * Now fetch desired portion of results.
                 */</comment>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DoPortalRunFetch</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>fdirection</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported portal strategy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>        <comment type="block">/* keep compiler quiet */</comment>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <comment type="block">/* Uncaught error while executing portal: mark it dead */</comment>
        <expr_stmt><expr><call><name>MarkPortalFailed</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Restore global vars and propagate error */</comment>
        <expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>saveActivePortal</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>saveResourceOwner</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <name>savePortalContext</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Mark portal not active */</comment>
    <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>PORTAL_READY</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>saveActivePortal</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>saveResourceOwner</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <name>savePortalContext</name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * DoPortalRunFetch
 *        Guts of PortalRunFetch --- the portal context is already set up
 *
 * count &lt;= 0 is interpreted as a no-op: the destination gets started up
 * and shut down, but nothing else happens.  Also, count == FETCH_ALL is
 * interpreted as "all rows".  (cf FetchStmt.howMany)
 *
 * Returns number of rows processed (suitable for use in result tag)
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>DoPortalRunFetch</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>,
                 <parameter><decl><type><name>FetchDirection</name></type> <name>fdirection</name></decl></parameter>,
                 <parameter><decl><type><name>long</name></type> <name>count</name></decl></parameter>,
                 <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>forward</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PORTAL_ONE_SELECT</name> <operator>||</operator>
           <name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PORTAL_ONE_RETURNING</name> <operator>||</operator>
           <name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PORTAL_ONE_MOD_WITH</name> <operator>||</operator>
           <name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PORTAL_UTIL_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>fdirection</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>FETCH_FORWARD</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>fdirection</name> <operator>=</operator> <name>FETCH_BACKWARD</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>count</name> <operator>=</operator> <operator>-</operator><name>count</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* fall out of switch to share code with FETCH_BACKWARD */</comment>
            <break>break;</break>
        <case>case <expr><name>FETCH_BACKWARD</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>fdirection</name> <operator>=</operator> <name>FETCH_FORWARD</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>count</name> <operator>=</operator> <operator>-</operator><name>count</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* fall out of switch to share code with FETCH_FORWARD */</comment>
            <break>break;</break>
        <case>case <expr><name>FETCH_ABSOLUTE</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Definition: Rewind to start, advance count-1 rows, return
                 * next row (if any).
                 *
                 * In practice, if the goal is less than halfway back to the
                 * start, it's better to scan from where we are.
                 *
                 * Also, if current portalPos is outside the range of "long",
                 * do it the hard way to avoid possible overflow of the count
                 * argument to PortalRunSelect.  We must exclude exactly
                 * LONG_MAX, as well, lest the count look like FETCH_ALL.
                 *
                 * In any case, we arrange to fetch the target row going
                 * forwards.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>uint64</name><operator>)</operator> <operator>(</operator><name>count</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;=</operator> <name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name> <operator>/</operator> <literal type="number">2</literal> <operator>||</operator>
                    <name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name> <operator>&gt;=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>LONG_MAX</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>DoPortalRewind</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>count</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
                                        <argument><expr><name>None_Receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name>long</name></type>        <name>pos</name> <init>= <expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* need one extra fetch if off end */</comment>
                    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;=</operator> <name>pos</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>pos</name> <operator>-</operator> <name>count</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                                        <argument><expr><name>None_Receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <if type="elseif">else if <condition>(<expr><name>count</name> <operator>&gt;</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>count</name> <operator>-</operator> <name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
                                        <argument><expr><name>None_Receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
                <return>return <expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">1L</literal></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Definition: Advance to end, back up abs(count)-1 rows,
                 * return prior row (if any).  We could optimize this if we
                 * knew in advance where the end was, but typically we won't.
                 * (Is it worth considering case where count &gt; half of size of
                 * query?  We could rewind once we know the size ...)
                 */</comment>
                <expr_stmt><expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>FETCH_ALL</name></expr></argument>, <argument><expr><name>None_Receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><name>count</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>None_Receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <return>return <expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">1L</literal></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* count == 0 */</comment>
                <comment type="block">/* Rewind to start, return zero rows */</comment>
                <expr_stmt><expr><call><name>DoPortalRewind</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><name>FETCH_RELATIVE</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Definition: advance count-1 rows, return next row (if any).
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>count</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>None_Receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <return>return <expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">1L</literal></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Definition: back up abs(count)-1 rows, return prior row (if
                 * any).
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><name>count</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>None_Receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <return>return <expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">1L</literal></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* count == 0 */</comment>
                <comment type="block">/* Same as FETCH FORWARD 0, so fall out of switch */</comment>
                <expr_stmt><expr><name>fdirection</name> <operator>=</operator> <name>FETCH_FORWARD</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus direction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/*
     * Get here with fdirection == FETCH_FORWARD or FETCH_BACKWARD, and count
     * &gt;= 0.
     */</comment>
    <expr_stmt><expr><name>forward</name> <operator>=</operator> <operator>(</operator><name>fdirection</name> <operator>==</operator> <name>FETCH_FORWARD</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/*
     * Zero count means to re-fetch the current row, if any (per SQL)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>        <name>on_row</name></decl>;</decl_stmt>

        <comment type="block">/* Are we sitting on a row? */</comment>
        <expr_stmt><expr><name>on_row</name> <operator>=</operator> <operator>(</operator><operator>!</operator><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name><operator>)</operator></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>dest</name><operator>-&gt;</operator><name>mydest</name></name> <operator>==</operator> <name>DestNone</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* MOVE 0 returns 0/1 based on if FETCH 0 would return a row */</comment>
            <return>return <expr><ternary><condition><expr><name>on_row</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * If we are sitting on a row, back up one so we can re-fetch it.
             * If we are not sitting on a row, we still have to start up and
             * shut down the executor so that the destination is initialized
             * and shut down correctly; so keep going.  To PortalRunSelect,
             * count == 0 means we will retrieve no row.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>on_row</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">1L</literal></expr></argument>, <argument><expr><name>None_Receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Set up to fetch one row forward */</comment>
                <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>forward</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Optimize MOVE BACKWARD ALL into a Rewind.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>forward</name> <operator>&amp;&amp;</operator> <name>count</name> <operator>==</operator> <name>FETCH_ALL</name> <operator>&amp;&amp;</operator> <name><name>dest</name><operator>-&gt;</operator><name>mydest</name></name> <operator>==</operator> <name>DestNone</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>uint64</name></type>        <name>result</name> <init>= <expr><name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>DoPortalRewind</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>forward</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * DoPortalRewind - rewind a Portal to starting point
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DoPortalRewind</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>queryDesc</name></decl>;</decl_stmt>

    <comment type="block">/* Rewind holdStore, if we have one */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>tuplestore_rescan</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Rewind executor, if active */</comment>
    <expr_stmt><expr><name>queryDesc</name> <operator>=</operator> <call><name>PortalGetQueryDesc</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>queryDesc</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExecutorRewind</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<comment type="block">/*
 * Execute the specified portal's query and distribute tuples to consumers.
 * Returs 1 if portal should keep producing, 0 if all consumers have enough
 * rows in the buffers to pause producing temporarily, -1 if the query is
 * completed.
 */</comment>
<function><type><name>int</name></type>
<name>AdvanceProducingPortal</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>can_wait</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Portal</name></type>        <name>saveActivePortal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResourceOwner</name></type> <name>saveResourceOwner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>savePortalContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>queryDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SharedQueue</name></type> <name>squeue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>treceiver</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>queryDesc</name> <operator>=</operator> <call><name>PortalGetQueryDesc</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>squeue</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>squeue</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Make sure the portal is producing */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>squeue</name> <operator>&amp;&amp;</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>myindex</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Make sure there is proper receiver */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name> <operator>&amp;&amp;</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>mydest</name></name> <operator>==</operator> <name>DestProducer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Set up global portal context pointers.
     */</comment>
    <expr_stmt><expr><name>saveActivePortal</name> <operator>=</operator> <name>ActivePortal</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>saveResourceOwner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>savePortalContext</name> <operator>=</operator> <name>PortalContext</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>portal</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <call><name>PortalGetHeapMemory</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>PortalGetHeapMemory</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * That is the first pass thru if the hold store is not initialized yet,
         * Need to initialize stuff.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>portal</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>PORTAL_FAILED</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name> <name>idx</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type> <name><name>storename</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>PortalCreateProducerStore</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>treceiver</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>DestTuplestore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SetTuplestoreDestReceiverParams</name><argument_list>(<argument><expr><name>treceiver</name></expr></argument>,
                                            <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr></argument>,
                                            <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdContext</name></name></expr></argument>,
                                            <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SetSelfConsumerDestReceiver</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>, <argument><expr><name>treceiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SetProducerTempMemory</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>tmpContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>storename</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="string">"%s producer store"</literal></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>tuplestore_collect_stat</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr></argument>, <argument><expr><name>storename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/*
             * Tuplestore does not clear eof flag on the active read pointer,
             * causing the store is always in EOF state once reached when
             * there is a single read pointer. We do not want behavior like this
             * and workaround by using secondary read pointer.
             * Primary read pointer (0) is active when we are writing to
             * the tuple store, secondary read pointer is for reading, and its
             * eof flag is cleared if a tuple is written to the store.
             * We know the extra read pointer has index 1, so do not store it.
             */</comment>
            <expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>tuplestore_alloc_read_pointer</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>idx</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_finished</name></name> <operator>&amp;&amp;</operator>
                <name><name>portal</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>PORTAL_FAILED</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If the portal's hold store has tuples available for read and
             * all consumer queues are not empty we skip advancing the portal
             * (pause it) to prevent buffering too many rows at the producer.
             * NB just created portal store would not be in EOF state, but in
             * this case consumer queues will be empty and do not allow
             * erroneous pause. After the first call to AdvanceProducingPortal
             * portal will try to read the hold store and EOF flag will be set
             * correctly.
             */</comment>
            <expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_ateof</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                    <call><name>SharedQueueCanPause</name><argument_list>(<argument><expr><name>squeue</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Execute query and dispatch tuples via dest receiver */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRODUCE_TUPLES</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>
                <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>g_UseDataPump</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* get all tuples */</comment>
                    <expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                            <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>run_once</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>PRODUCE_TUPLES</name></expr></argument>,
                            <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>run_once</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>g_UseDataPump</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ExecutorFinish</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>&lt;</operator> <name>PRODUCE_TUPLES</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * Finish the executor, but we may still have some tuples
                         * in the local storages.
                         * We should keep trying pushing them into the squeue, so do not
                         * remove the portal from the list of producers.
                         */</comment>
                        <expr_stmt><expr><call><name>ExecutorFinish</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Try to dump local tuplestores */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_finished</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
                <call><name>ProducerReceiverPushBuffers</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>can_wait</name> <operator>&amp;&amp;</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call>(<modifier>*</modifier><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>rDestroy</name></name>) <argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>queryDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>squeue</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>removeProducingPortal</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FreeQueryDesc</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Current context is the portal context, which is going
                 * to be deleted
                 */</comment>
                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>saveActivePortal</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>saveResourceOwner</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <name>savePortalContext</name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>bool</name></type>        <name>isCommit</name> <init>= <expr><operator>(</operator><name><name>portal</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>PORTAL_FAILED</name><operator>)</operator></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr></argument>,
                                         <argument><expr><name>RESOURCE_RELEASE_BEFORE_LOCKS</name></expr></argument>,
                                         <argument><expr><name>isCommit</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr></argument>,
                                         <argument><expr><name>RESOURCE_RELEASE_LOCKS</name></expr></argument>,
                                         <argument><expr><name>isCommit</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr></argument>,
                                         <argument><expr><name>RESOURCE_RELEASE_AFTER_LOCKS</name></expr></argument>,
                                         <argument><expr><name>isCommit</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ResourceOwnerDelete</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Delete tuplestore if present.  We should do this even under error
                 * conditions; since the tuplestore would have been using cross-
                 * transaction storage, its temp files need to be explicitly deleted.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* delete tuplestore storage, if any */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>holdContext</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/* release subsidiary storage */</comment>
                <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><call><name>PortalGetHeapMemory</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* release portal struct (it's in PortalMemory) */</comment>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* report portal is not producing */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><call><name>SharedQueueCanPause</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>squeue</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <comment type="block">/* Uncaught error while executing portal: mark it dead */</comment>
        <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>PORTAL_FAILED</name></expr>;</expr_stmt>
        <comment type="block">/*
         * Reset producer to allow consumers to finish, so receiving node will
         * handle the error.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>squeue</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>SharedQueueReset</name><argument_list>(<argument><expr><name>squeue</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Restore global vars and propagate error */</comment>
        <expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>saveActivePortal</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>saveResourceOwner</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <name>savePortalContext</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>saveActivePortal</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>saveResourceOwner</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <name>savePortalContext</name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Iterate over producing portal, determine already closed, and clean them up,
 * waiting while consumers finish their work. Closed producers should be
 * cleaned up and resources are released before proceeding with handling of
 * next request.
 */</comment>
<function><type><name>void</name></type>
<name>cleanupClosedProducers</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><call><name>getProducingPortals</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>lc</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Portal</name></type> <name>p</name> <init>= <expr><operator>(</operator><name>Portal</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>queryDesc</name> <init>= <expr><call><name>PortalGetQueryDesc</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SharedQueue</name></type> <name>squeue</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>squeue</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Get next already, because next call may remove cell from
         * the list and invalidate next reference
         */</comment>
        <expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* When portal is closed executor state is not set */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Set up global portal context pointers.
             */</comment>
            <decl_stmt><decl><type><name>Portal</name></type>        <name>saveActivePortal</name> <init>= <expr><name>ActivePortal</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ResourceOwner</name></type> <name>saveResourceOwner</name> <init>= <expr><name>CurrentResourceOwner</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>MemoryContext</name></type> <name>savePortalContext</name> <init>= <expr><name>PortalContext</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <block>{<block_content>
                <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>resowner</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <call><name>PortalGetHeapMemory</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>PortalGetHeapMemory</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call>(<modifier>*</modifier><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>rDestroy</name></name>) <argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>queryDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>squeue</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>removeProducingPortal</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FreeQueryDesc</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Current context is the portal context, which is going
                 * to be deleted
                 */</comment>
                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>saveActivePortal</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>saveResourceOwner</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <name>savePortalContext</name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>resowner</name></name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>bool</name></type>        <name>isCommit</name> <init>= <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>PORTAL_FAILED</name><operator>)</operator></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>resowner</name></name></expr></argument>,
                                         <argument><expr><name>RESOURCE_RELEASE_BEFORE_LOCKS</name></expr></argument>,
                                         <argument><expr><name>isCommit</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>resowner</name></name></expr></argument>,
                                         <argument><expr><name>RESOURCE_RELEASE_LOCKS</name></expr></argument>,
                                         <argument><expr><name>isCommit</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>resowner</name></name></expr></argument>,
                                         <argument><expr><name>RESOURCE_RELEASE_AFTER_LOCKS</name></expr></argument>,
                                         <argument><expr><name>isCommit</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ResourceOwnerDelete</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>resowner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>resowner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Delete tuplestore if present.  We should do this even under error
                 * conditions; since the tuplestore would have been using cross-
                 * transaction storage, its temp files need to be explicitly deleted.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>holdStore</name></name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>holdContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>holdStore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>holdStore</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* delete tuplestore storage, if any */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>holdContext</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>holdContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/* release subsidiary storage */</comment>
                <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><call><name>PortalGetHeapMemory</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* release portal struct (it's in PortalMemory) */</comment>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <block>{<block_content>
                <comment type="block">/* Uncaught error while executing portal: mark it dead */</comment>
                <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>PORTAL_FAILED</name></expr>;</expr_stmt>
                <comment type="block">/*
                 * Reset producer to allow consumers to finish, so receiving node will
                 * handle the error.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>squeue</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>SharedQueueReset</name><argument_list>(<argument><expr><name>squeue</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/* Restore global vars and propagate error */</comment>
                <expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>saveActivePortal</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>saveResourceOwner</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <name>savePortalContext</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>saveActivePortal</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>saveResourceOwner</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <name>savePortalContext</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
<function><type><name>bool</name></type> <name>PortalGetQueryInfo</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier><modifier>*</modifier></type> <name>parseTree</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type> <name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type> <name>l</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>portal</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <name>parseTree</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <name>queryString</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* 00. try get QueryInfo from PlannedStmt only */</comment>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>portal-&gt;stmts</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type> <name>pstmt</name> <init>= <expr><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> 
            <name><name>pstmt</name><operator>-&gt;</operator><name>parseTree</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
            <name><name>pstmt</name><operator>-&gt;</operator><name>queryString</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>parseTree</name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>parseTree</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>queryString</name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>queryString</name></name></expr>;</expr_stmt>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/* 01. try get QueryInfo from PlannedStmt and QueryString from Portal*/</comment>
    <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>sourceText</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>queryString</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>sourceText</name></name></expr>;</expr_stmt>

        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>portal-&gt;stmts</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type> <name>pstmt</name> <init>= <expr><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> 
                <name><name>pstmt</name><operator>-&gt;</operator><name>parseTree</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>parseTree</name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>parseTree</name></name></expr>;</expr_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GetGtmInfoFromUserCmd</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>option</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>options</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* 
     * If process alter gtm node OR create gtm node command, we set NewGtmHost and NewGtmPort here.
     * Fucntion GetTransactionSnapshot later will try to connect gtm using this gtm info. 
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>AlterNodeStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>PGXC_NODE_GTM</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>AlterNodeStmt</name><operator>*</operator><operator>)</operator><name>stmt</name><operator>)</operator><operator>-&gt;</operator><name>node_type</name><operator>)</operator><operator>)</operator> <operator>||</operator>
         <operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>CreateNodeStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>PGXC_NODE_GTM</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>CreateNodeStmt</name><operator>*</operator><operator>)</operator><name>stmt</name><operator>)</operator><operator>-&gt;</operator><name>node_type</name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>NewGtmHost</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>NewGtmHost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>NewGtmHost</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>T_CreateNodeStmt</name></expr>:</case>
                <expr_stmt><expr><name>options</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>CreateNodeStmt</name><operator>*</operator><operator>)</operator><name>stmt</name><operator>)</operator><operator>-&gt;</operator><name>options</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>T_AlterNodeStmt</name></expr>:</case>
                <expr_stmt><expr><name>options</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>AlterNodeStmt</name><operator>*</operator><operator>)</operator><name>stmt</name><operator>)</operator><operator>-&gt;</operator><name>options</name></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>

        <macro><name>foreach</name><argument_list>(<argument>option</argument>, <argument>options</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"host"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>NewGtmHost</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"port"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>NewGtmPort</name> <operator>=</operator> <call><name>defGetTypeLength</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>NewGtmPort</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>NewGtmPort</name></expr></argument> &gt;</argument_list></name> <literal type="number">65535</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"port value is out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_remote_query</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>remote_subplan</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><name>node</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>plan</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RemoteSubplan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RemoteSubplan</name> <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>RemoteSubplan</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>remote_subplan</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>remote_subplan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_global_snapshot</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>node_count</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            
            <if_stmt><if>if <condition>(<expr><name>node_count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>need_global_snapshot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>node_count</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>executed_node_list</name> <operator>=</operator> <call><name>list_append_unique_int</name><argument_list>(<argument><expr><name>executed_node_list</name></expr></argument>, <argument><expr><call><name>linitial_int</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>executed_node_list</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>need_global_snapshot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>subquery</name> <init>= <expr><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>subquery</name><operator>-&gt;</operator><name>subplan</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Append</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Append</name> <modifier>*</modifier></type><name>append</name> <init>= <expr><operator>(</operator><name>Append</name> <operator>*</operator><operator>)</operator><name>plan</name></expr></init></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>append-&gt;appendplans</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>appendplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>appendplan</name> <operator>&amp;&amp;</operator> <call><name>contain_remote_query</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>appendplan</name></expr></argument>, <argument><expr><name>remote_subplan</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>MergeAppend</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MergeAppend</name> <modifier>*</modifier></type><name>mergeappend</name> <init>= <expr><operator>(</operator><name>MergeAppend</name> <operator>*</operator><operator>)</operator><name>plan</name></expr></init></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>mergeappend-&gt;mergeplans</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>mergeappendplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>mergeappendplan</name> <operator>&amp;&amp;</operator> <call><name>contain_remote_query</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>mergeappendplan</name></expr></argument>, <argument><expr><name>remote_subplan</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>contain_remote_query</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><call><name>outerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>remote_subplan</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>innerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>contain_remote_query</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><call><name>innerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>remote_subplan</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If query meets those conditions:
 *    coordinator
 *    read committed(isolation)
 *    execute RemoteQuery or plan with remotesubplan
 *    no subplans
 *    DML without triggers/returning/cte
 *    SELECT
 * do not get snapshot until execution
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>NeedSnapshot</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>plannedstmt</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_LOCAL_COORDINATOR</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>g_set_global_snapshot</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>remote_subplan</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>plannedstmt</name><operator>-&gt;</operator><name>subplans</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>contain_remote_query</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name><name>plannedstmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>remote_subplan</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>remote_subplan</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <switch>switch<condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>CMD_SELECT</name></expr>:</case>
                <block>{<block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>need_snapshot</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block>
                <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
                <case>case <expr><name>CMD_INSERT</name></expr>:</case>
                <case>case <expr><name>CMD_DELETE</name></expr>:</case>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></argument>, <argument><expr><name>ModifyTable</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>plannedstmt</name><operator>-&gt;</operator><name>hasReturning</name></name>
                        <operator>&amp;&amp;</operator> <operator>!</operator><name><name>plannedstmt</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>need_snapshot</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <break>break;</break>
                <default>default:</default>
                    <break>break;</break>
            </block_content>}</block></switch>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
