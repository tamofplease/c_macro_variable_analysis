<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/tcop/postgres.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * postgres.c
 *      POSTGRES C Backend Interface
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 *
 * IDENTIFICATION
 *      src/backend/tcop/postgres.c
 *
 * NOTES
 *      this is the "main" module of the postgres backend and
 *      hence the main module of the "traffic cop".
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/prctl.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SELECT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/printtup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/print.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parser.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_getopt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicallauncher.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicalworker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/slot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/fastpath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timeout.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gtm.h"</cpp:file></cpp:include>
<comment type="block">/* PGXC_COORD */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/barrier.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/poolmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxcnode.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/squeue.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/copy.h"</cpp:file></cpp:include>
<comment type="block">/* PGXC_DATANODE */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/nodelock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execParallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/poolutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/explain_dist.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"audit/audit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/auditlogger.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/mls.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicalrelation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/worker_internal.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type>    <name>optind</name></decl>;</decl_stmt>

<comment type="block">/* ----------------
 *        global variables
 * ----------------
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>debug_query_string</name></decl>;</decl_stmt> <comment type="block">/* client-supplied query string */</comment>

<comment type="block">/* Note: whereToSendOutput is initialized for the bootstrap/standalone case */</comment>
<decl_stmt><decl><type><name>CommandDest</name></type> <name>whereToSendOutput</name> <init>= <expr><name>DestDebug</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* flag for logging end of session */</comment>
<decl_stmt><decl><type><name>bool</name></type>        <name>Log_disconnections</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>            <name>log_statement</name> <init>= <expr><name>LOGSTMT_NONE</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* GUC variable for maximum stack depth (measured in kilobytes) */</comment>
<decl_stmt><decl><type><name>int</name></type>            <name>max_stack_depth</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* wait N seconds to allow attach from a debugger */</comment>
<decl_stmt><decl><type><name>int</name></type>            <name>PostAuthDelay</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* ----------------
 *        private variables
 * ----------------
 */</comment>

<comment type="block">/* max_stack_depth converted to bytes for speed of checking */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>max_stack_depth_bytes</name> <init>= <expr><literal type="number">100</literal> <operator>*</operator> <literal type="number">1024L</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Stack base pointer -- initialized by PostmasterMain and inherited by
 * subprocesses. This is not static because old versions of PL/Java modify
 * it directly. Newer versions use set_stack_base(), but we want to stay
 * binary-compatible for the time being.
 */</comment>
<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>stack_base_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * On IA64 we also have to remember the register stack base.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ia64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ia64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>register_stack_base_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Flag to keep track of whether we have started a transaction.
 * For extended query protocol this has to be remembered across messages.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>xact_started</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Flag to indicate that we are doing the outer loop's read-from-client,
 * as opposed to any random read from client that might happen within
 * commands like COPY FROM STDIN.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>DoingCommandRead</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Flags to implement skip-till-Sync-after-error behavior for messages of
 * the extended query protocol.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>doing_extended_query_message</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>ignore_till_sync</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * If an unnamed prepared statement exists, it's stored here.
 * We keep it separate from the hashtable kept by commands/prepare.c
 * in order to reduce overhead for short-lived queries.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>CachedPlanSource</name> <modifier>*</modifier></type><name>unnamed_stmt_psrc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* assorted command-line switches */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>userDoption</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* -D switch */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>EchoQuery</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* -E switch */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>UseSemiNewlineNewline</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* -j switch */</comment>

<comment type="block">/* whether or not, and why, we were canceled by conflict with recovery */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>RecoveryConflictPending</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>RecoveryConflictRetryable</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ProcSignalReason</name></type> <name>RecoveryConflictReason</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>remotePrepareGID</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* for error code contrib */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>g_is_in_init_phase</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>g_snapshot_for_analyze</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>IsNormalPostgres</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>explain_stmt</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>g_commandTag</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* ----------------------------------------------------------------
 *        decls for routines only used in this file
 * ----------------------------------------------------------------
 */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>InteractiveBackend</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>inBuf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>interactive_getc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>SocketBackend</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>inBuf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>ReadCommand</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>inBuf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>forbidden_in_wal_sender</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>firstchar</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>pg_rewrite_query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_log_statement</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmt_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>errdetail_execute</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>raw_parsetree_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>errdetail_params</name><parameter_list>(<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>errdetail_abort</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>errdetail_recovery_conflict</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>start_xact_command</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>finish_xact_command</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsTransactionExitStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsTransactionExitStmtList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pstmts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsTransactionStmtList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pstmts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>drop_unnamed_stmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>log_disconnections</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>replace_null_with_blank</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>NeedResourceOwner</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
<comment type="block">/*
 * Release memory alloc in TopMemoryContext and only used in single Session.
 * When session is quit, release memory.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> 
<name>ReleaseSessionMemory</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>g_TempKeyValueList</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>g_TempKeyValueList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>g_TempKeyValueList</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef> <comment type="block">/* PGXC_DATANODE */</comment>
<comment type="block">/* ----------------------------------------------------------------
 *        PG-XC routines
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Called when the backend is ending.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DataNodeShutdown</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Close connection with GTM, if active */</comment>
    <expr_stmt><expr><call><name>CloseGTM</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ----------------------------------------------------------------
 *        routines to obtain user input
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------
 *    InteractiveBackend() is called for user interactive connections
 *
 *    the string entered by the user is placed in its parameter inBuf,
 *    and we act like a Q message was received.
 *
 *    EOF is returned if end-of-file input is seen; time to shut down.
 * ----------------
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>InteractiveBackend</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>inBuf</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>c</name></decl>;</decl_stmt>                <comment type="block">/* character read from getc() */</comment>

    <comment type="block">/*
     * display a prompt and obtain input from the user
     */</comment>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"backend&gt; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Read characters until EOF or the appropriate delimiter is seen.
     */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>interactive_getc</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <name>EOF</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>UseSemiNewlineNewline</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * In -j mode, semicolon followed by two newlines ends the
                 * command; otherwise treat newline as regular character.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>inBuf</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
                    <name><name>inBuf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>inBuf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator>
                    <name><name>inBuf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>inBuf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">';'</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* might as well drop the second newline */</comment>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * In plain mode, newline ends the command unless preceded by
                 * backslash.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>inBuf</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                    <name><name>inBuf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>inBuf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* discard backslash from inBuf */</comment>
                    <expr_stmt><expr><name><name>inBuf</name><operator>-&gt;</operator><name>data</name><index>[<expr><operator>--</operator><name><name>inBuf</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                    <comment type="block">/* discard newline too */</comment>
                    <continue>continue;</continue>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* keep the newline character, but end the command */</comment>
                    <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Not newline, or newline treated as regular character */</comment>
        <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* No input before EOF signal means time to quit. */</comment>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>EOF</name> <operator>&amp;&amp;</operator> <name><name>inBuf</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * otherwise we have a user query so process it.
     */</comment>

    <comment type="block">/* Add '\0' to make it look the same as message case. */</comment>
    <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>)</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * if the query echo flag was given, print the query..
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>EchoQuery</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"statement: %s\n"</literal></expr></argument>, <argument><expr><name><name>inBuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><literal type="char">'Q'</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * interactive_getc -- collect one character from stdin
 *
 * Even though we are not reading from a "client" process, we still want to
 * respond to signals, particularly SIGTERM/SIGQUIT.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>interactive_getc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>c</name></decl>;</decl_stmt>

    <comment type="block">/*
     * This will not process catchup interrupts or notifications while
     * reading. But those can't really be relevant for a standalone backend
     * anyway. To properly handle SIGTERM there's a hack in die() that
     * directly processes interrupts at this stage...
     */</comment>
    <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ProcessClientReadInterrupt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *    SocketBackend()        Is called for frontend-backend connections
 *
 *    Returns the message type code, and loads message body data into inBuf.
 *
 *    EOF is returned if the connection is lost.
 * ----------------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>SocketBackend</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>inBuf</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>qtype</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Get message type code from the frontend.
     */</comment>
    <expr_stmt><expr><call><name>HOLD_CANCEL_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_startmsgread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/*
     * Session from data node may need to do some background work if it is
     * running producing subplans. So just poll the connection, and if it does
     * not have input for us do the work.
     * If we do not have producing portals we should use the blocking read
     * to avoid loop consuming 100% of CPU
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <call><name>IsConnFromDatanode</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Advance producing portals or poll client connection until we have
         * a client command to handle.
         */</comment>
        <while>while <condition>(<expr><name>true</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>qtype</name> <operator>=</operator> <call><name>pq_getbyte_if_available</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>qtype</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>            <comment type="block">/* no commands, do producing */</comment>
            <block>{<block_content>
                <comment type="block">/*
                 * No command yet, try to advance producing portals, and
                 * depending on result do:
                 * -1 No producing portals, block and wait for client command
                 * 0  All producing portals are paused, sleep for a moment and
                 *    then check again either we have client command or some
                 *    portal is awaken.
                 * 1  check for client command and more continue advancing
                 *    producers immediately
                 */</comment>
                <decl_stmt><decl><type><name>int</name></type> <name>activePortals</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><call><name>getProducingPortals</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><name>lc</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Portal</name></type> <name>p</name> <init>= <expr><operator>(</operator><name>Portal</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

                    <comment type="block">/*
                     * Get next already, because next call may remove cell from
                     * the list and invalidate next reference
                     */</comment>
                    <expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>AdvanceProducingPortal</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* Portal is paused */</comment>
                        <if_stmt><if>if <condition>(<expr><name>activePortals</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>activePortals</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>result</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>activePortals</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>activePortals</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><name>activePortals</name> <operator>+=</operator> <name>result</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></while>
                <if_stmt><if>if <condition>(<expr><name>activePortals</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* no producers at all, we may wait while next command */</comment>
                    <expr_stmt><expr><name>qtype</name> <operator>=</operator> <call><name>pq_getbyte</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>activePortals</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* all producers are paused, sleep a little to allow other
                     * processes to go */</comment>
                    <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">10000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>qtype</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* command code in c is defined, move it to qtype
                 * and break to handle the command */</comment>
                <expr_stmt><expr><name>qtype</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* error, default handling, qtype is already set to EOF */</comment>
                <break>break;</break>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Get message type code from the frontend.
         */</comment>
        <expr_stmt><expr><name>qtype</name> <operator>=</operator> <call><name>pq_getbyte</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>qtype</name> <operator>=</operator> <call><name>pq_getbyte</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>qtype</name> <operator>==</operator> <name>EOF</name></expr>)</condition>            <comment type="block">/* frontend disconnected */</comment>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection with an open transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Can't send DEBUG log messages to client at this point. Since
             * we're disconnecting right away, we don't need to restore
             * whereToSendOutput.
             */</comment>
            <expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_DOES_NOT_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>qtype</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Validate message type code before trying to read body; if we have lost
     * sync, better to say "command unknown" than to run out of memory because
     * we used garbage as a length word.
     *
     * This also gives us a place to set the doing_extended_query_message flag
     * as soon as possible.
     */</comment>
    <switch>switch <condition>(<expr><name>qtype</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="char">'Q'</literal></expr>:</case>                <comment type="block">/* simple query */</comment>
            <expr_stmt><expr><name>doing_extended_query_message</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* old style without length word; convert */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>pq_getstring</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection with an open transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="block">/*
                         * Can't send DEBUG log messages to client at this
                         * point. Since we're disconnecting right away, we
                         * don't need to restore whereToSendOutput.
                         */</comment>
                        <expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_DOES_NOT_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <return>return <expr><name>EOF</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><literal type="char">'F'</literal></expr>:</case>                <comment type="block">/* fastpath function call */</comment>
            <expr_stmt><expr><name>doing_extended_query_message</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>GetOldFunctionMessage</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection with an open transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="block">/*
                         * Can't send DEBUG log messages to client at this
                         * point. Since we're disconnecting right away, we
                         * don't need to restore whereToSendOutput.
                         */</comment>
                        <expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_DOES_NOT_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <return>return <expr><name>EOF</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><literal type="char">'X'</literal></expr>:</case>                <comment type="block">/* terminate */</comment>
            <expr_stmt><expr><name>doing_extended_query_message</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ignore_till_sync</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><literal type="char">'B'</literal></expr>:</case>                <comment type="block">/* bind */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef> <comment type="block">/* PGXC_DATANODE */</comment>
        <case>case <expr><literal type="char">'p'</literal></expr>:</case>                <comment type="block">/* plan */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><literal type="char">'C'</literal></expr>:</case>                <comment type="block">/* close */</comment>
        <case>case <expr><literal type="char">'D'</literal></expr>:</case>                <comment type="block">/* describe */</comment>
        <case>case <expr><literal type="char">'E'</literal></expr>:</case>                <comment type="block">/* execute */</comment>
        <case>case <expr><literal type="char">'H'</literal></expr>:</case>                <comment type="block">/* flush */</comment>
        <case>case <expr><literal type="char">'P'</literal></expr>:</case>                <comment type="block">/* parse */</comment>
            <expr_stmt><expr><name>doing_extended_query_message</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <comment type="block">/* these are only legal in protocol 3 */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid frontend message type %d"</literal></expr></argument>, <argument><expr><name>qtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><literal type="char">'L'</literal></expr>:</case>
        <case>case <expr><literal type="char">'S'</literal></expr>:</case>                <comment type="block">/* sync */</comment>
            <comment type="block">/* stop any active skip-till-Sync */</comment>
            <expr_stmt><expr><name>ignore_till_sync</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <comment type="block">/* mark not-extended, so that a new error doesn't begin skip */</comment>
            <expr_stmt><expr><name>doing_extended_query_message</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <comment type="block">/* only legal in protocol 3 */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid frontend message type %d"</literal></expr></argument>, <argument><expr><name>qtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><literal type="char">'d'</literal></expr>:</case>                <comment type="block">/* copy data */</comment>
        <case>case <expr><literal type="char">'c'</literal></expr>:</case>                <comment type="block">/* copy done */</comment>
        <case>case <expr><literal type="char">'f'</literal></expr>:</case>                <comment type="block">/* copy fail */</comment>
            <expr_stmt><expr><name>doing_extended_query_message</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <comment type="block">/* these are only legal in protocol 3 */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid frontend message type %d"</literal></expr></argument>, <argument><expr><name>qtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef> <comment type="block">/* PGXC_DATANODE */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <case>case <expr><literal type="char">'N'</literal></expr>:</case>
		<case>case <expr><literal type="char">'U'</literal></expr>:</case>				<comment type="block">/* coord info: coord_pid and top_xid */</comment>
		<case>case <expr><literal type="char">'o'</literal></expr>:</case>               <comment type="block">/* global session id */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><literal type="char">'M'</literal></expr>:</case>                <comment type="block">/* Command ID */</comment>
        <case>case <expr><literal type="char">'g'</literal></expr>:</case>                <comment type="block">/* GXID */</comment>
        <case>case <expr><literal type="char">'s'</literal></expr>:</case>                <comment type="block">/* Snapshot */</comment>
        <case>case <expr><literal type="char">'t'</literal></expr>:</case>                <comment type="block">/* Timestamp */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
        <case>case <expr><literal type="char">'T'</literal></expr>:</case>                <comment type="block">/* Global Timestamp */</comment>
        <case>case <expr><literal type="char">'Z'</literal></expr>:</case>                <comment type="block">/* Global Prepare Timestamp */</comment>
        <case>case <expr><literal type="char">'G'</literal></expr>:</case>                <comment type="block">/* Explicit prepared gid */</comment>
        <case>case <expr><literal type="char">'W'</literal></expr>:</case>                <comment type="block">/* Prefinish phase */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><literal type="char">'b'</literal></expr>:</case>                <comment type="block">/* Barrier */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
        <case>case <expr><literal type="char">'a'</literal></expr>:</case>                <comment type="block">/* logical apply */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
        <case>case <expr><literal type="char">'e'</literal></expr>:</case>               <comment type="block">/* startnode of 2pc transaction */</comment>
        <case>case <expr><literal type="char">'R'</literal></expr>:</case>               <comment type="block">/* PartNodes */</comment>
        <case>case <expr><literal type="char">'x'</literal></expr>:</case>               <comment type="block">/* xid of 2pc transaction in startnode */</comment>
        <case>case <expr><literal type="char">'n'</literal></expr>:</case>               <comment type="block">/* run in pg_clean */</comment>
        <case>case <expr><literal type="char">'r'</literal></expr>:</case>               <comment type="block">/* send readonly in pg_clean */</comment>
        <case>case <expr><literal type="char">'A'</literal></expr>:</case>               <comment type="block">/* send after prepare phase in pg_clean */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>            
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <default>default:</default>

            <comment type="block">/*
             * Otherwise we got garbage from the frontend.  We treat this as
             * fatal because we have probably lost message boundary sync, and
             * there's no good way to recover.
             */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid frontend message type %d"</literal></expr></argument>, <argument><expr><name>qtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/*
     * In protocol version 3, all frontend messages have a length word next
     * after the type code; we can read the message contents independently of
     * the type.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>pq_getmessage</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* suitable message already logged */</comment>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pq_endmsgread</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>RESUME_CANCEL_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>qtype</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        ReadCommand reads a command from either the frontend or
 *        standard input, places it in inBuf, and returns the
 *        message type code (first byte of the message).
 *        EOF is returned if end of file.
 * ----------------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ReadCommand</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>inBuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>SocketBackend</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>InteractiveBackend</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ProcessClientReadInterrupt() - Process interrupts specific to client reads
 *
 * This is called just after low-level reads. That might be after the read
 * finished successfully, or it was interrupted via interrupt.
 *
 * Must preserve errno!
 */</comment>
<function><type><name>void</name></type>
<name>ProcessClientReadInterrupt</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>blocked</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>DoingCommandRead</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Check for general interrupts that arrived while reading */</comment>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Process sinval catchup interrupts that happened while reading */</comment>
        <if_stmt><if>if <condition>(<expr><name>catchupInterruptPending</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ProcessCatchupInterrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Process sinval catchup interrupts that happened while reading */</comment>
        <if_stmt><if>if <condition>(<expr><name>notifyInterruptPending</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ProcessNotifyInterrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>ProcDiePending</name> <operator>&amp;&amp;</operator> <name>blocked</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We're dying. It's safe (and sane) to handle that now.
         */</comment>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ProcessClientWriteInterrupt() - Process interrupts specific to client writes
 *
 * This is called just after low-level writes. That might be after the read
 * finished successfully, or it was interrupted via interrupt. 'blocked' tells
 * us whether the
 *
 * Must preserve errno!
 */</comment>
<function><type><name>void</name></type>
<name>ProcessClientWriteInterrupt</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>blocked</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * We only want to process the interrupt here if socket writes are
     * blocking to increase the chance to get an error message to the client.
     * If we're not blocked there'll soon be a CHECK_FOR_INTERRUPTS(). But if
     * we're blocked we'll never get out of that situation if the client has
     * died.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>ProcDiePending</name> <operator>&amp;&amp;</operator> <name>blocked</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We're dying. It's safe (and sane) to handle that now. But we don't
         * want to send the client the error message as that a) would possibly
         * block again b) would possibly lead to sending an error message to
         * the client, while we already started to send something else.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Do raw parsing (only).
 *
 * A list of parsetrees (RawStmt nodes) is returned, since there might be
 * multiple commands in the given string.
 *
 * NOTE: for interactive queries, it is important to keep this routine
 * separate from the analysis &amp; rewrite stages.  Analysis and rewriting
 * cannot be done in an aborted transaction, since they require access to
 * database tables.  So, we rely on the raw parser to determine whether
 * we've seen a COMMIT or ABORT command; when we are in abort state, other
 * commands are not processed any further than the raw parse stage.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>pg_parse_query</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>raw_parsetree_list</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_PARSE_START</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>raw_parsetree_list</name> <operator>=</operator> <call><name>raw_parser</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"PARSER STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COPY_PARSE_PLAN_TREES</name></cpp:ifdef>
    <comment type="block">/* Optional debugging check: pass raw parsetrees through copyObject() */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>new_list</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>raw_parsetree_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* This checks both copyObject() and the equal() routines... */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>new_list</name></expr></argument>, <argument><expr><name>raw_parsetree_list</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"copyObject() failed to produce an equal raw parse tree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>raw_parsetree_list</name> <operator>=</operator> <name>new_list</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_PARSE_DONE</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>raw_parsetree_list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a raw parsetree (gram.y output), and optionally information about
 * types of parameter symbols ($n), perform parse analysis and rule rewriting.
 *
 * A list of Query nodes is returned, since either the analyzer or the
 * rewriter might expand one query to several.
 *
 * NOTE: for reasons mentioned above, this must be separate from raw parsing.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>pg_analyze_and_rewrite</name><parameter_list>(<parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>,
                       <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>paramTypes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numParams</name></decl></parameter>,
                       <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>querytree_list</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_REWRITE_START</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * (1) Perform parse analysis.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>parse_analyze</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>paramTypes</name></expr></argument>, <argument><expr><name>numParams</name></expr></argument>,
                          <argument><expr><name>queryEnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"PARSE ANALYSIS STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name> <operator>&amp;&amp;</operator>
        <call><name>IsA</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>CreateTableAsStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <name>xact_started</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * first read utility from CreateTableAsStmt
         */</comment>
        <expr_stmt><expr><call><name>AuditReadQueryList</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * (2) Rewrite the queries, as necessary
     */</comment>
    <expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>pg_rewrite_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_REWRITE_DONE</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>querytree_list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Do parse analysis and rewriting.  This is the same as pg_analyze_and_rewrite
 * except that external-parameter resolution is determined by parser callback
 * hooks instead of a fixed list of parameter datatypes.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>pg_analyze_and_rewrite_params</name><parameter_list>(<parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>,
                              <parameter><decl><type><name>ParserSetupHook</name></type> <name>parserSetup</name></decl></parameter>,
                              <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>parserSetupArg</name></decl></parameter>,
                              <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>querytree_list</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>query_string</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* required as of 8.4 */</comment>

    <expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_REWRITE_START</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * (1) Perform parse analysis.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>query_string</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_queryEnv</name></name> <operator>=</operator> <name>queryEnv</name></expr>;</expr_stmt>
    <expr_stmt><expr><call>(<modifier>*</modifier><name>parserSetup</name>) <argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parserSetupArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>transformTopLevelStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>post_parse_analyze_hook</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call>(<modifier>*</modifier><name>post_parse_analyze_hook</name>) <argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"PARSE ANALYSIS STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name> <operator>&amp;&amp;</operator>
        <call><name>IsA</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>CreateTableAsStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <name>xact_started</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * first read utility from CreateTableAsStmt
         */</comment>
        <expr_stmt><expr><call><name>AuditReadQueryList</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * (2) Rewrite the queries, as necessary
     */</comment>
    <expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>pg_rewrite_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_REWRITE_DONE</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>querytree_list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform rewriting of a query produced by parse analysis.
 *
 * Note: query must just have come from the parser, because we do not do
 * AcquireRewriteLocks() on it.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>pg_rewrite_query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>querytree_list</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>Debug_print_parse</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog_node_display</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"parse tree"</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>,
                          <argument><expr><name>Debug_pretty_print</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name> <operator>&amp;&amp;</operator>
	    <call><name>IsA</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>CreateTableAsStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * CREATE TABLE AS SELECT and SELECT INTO are rewritten so that the
		 * target table is created first. The SELECT query is then transformed
		 * into an INSERT INTO statement
		 */</comment>
		<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>QueryRewriteCTAS</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* don't rewrite utilities, just dump 'em into result list */</comment>
        <expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* rewrite regular queries */</comment>
        <expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>QueryRewrite</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"REWRITER STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COPY_PARSE_PLAN_TREES</name></cpp:ifdef>
    <comment type="block">/* Optional debugging check: pass querytree output through copyObject() */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>new_list</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>new_list</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* This checks both copyObject() and the equal() routines... */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>new_list</name></expr></argument>, <argument><expr><name>querytree_list</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"copyObject() failed to produce equal parse tree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <name>new_list</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>Debug_print_rewritten</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog_node_display</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"rewritten parse tree"</literal></expr></argument>, <argument><expr><name>querytree_list</name></expr></argument>,
                          <argument><expr><name>Debug_pretty_print</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>querytree_list</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Generate a plan for a single already-rewritten query.
 * This is a thin wrapper around planner() and takes the same parameters.
 */</comment>
<function><type><name>PlannedStmt</name> <modifier>*</modifier></type>
<name>pg_plan_query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>querytree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>

    <comment type="block">/* Utility commands have no plans. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>querytree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Planner must have a snapshot in case it calls user-defined functions. */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_PLAN_START</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_planner_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* call the optimizer */</comment>
    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>planner</name><argument_list>(<argument><expr><name>querytree</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>queryString</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parseTree</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>querytree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>log_planner_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"PLANNER STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COPY_PARSE_PLAN_TREES</name></cpp:ifdef>
    <comment type="block">/* Optional debugging check: pass plan output through copyObject() */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>new_plan</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * equal() currently does not have routines to compare Plan nodes, so
         * don't try to test equality here.  Perhaps fix someday?
         */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
        <comment type="block">/* This checks both copyObject() and the equal() routines... */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>new_plan</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"copyObject() failed to produce an equal plan tree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <name>new_plan</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Print plan if debugging.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>Debug_print_plan</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog_node_display</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"plan"</literal></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Debug_pretty_print</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_PLAN_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate plans for a list of already-rewritten queries.
 *
 * For normal optimizable statements, invoke the planner.  For utility
 * statements, just make a wrapper PlannedStmt node.
 *
 * The result is a list of PlannedStmt nodes.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>pg_plan_queries</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>querytrees</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>stmt_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>query_list</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>query_list</argument>, <argument>querytrees</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>query_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Utility commands require no planning. */</comment>
            <expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>stmt_location</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>stmt_len</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>pg_plan_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>stmt_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmt_list</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>stmt_list</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ch_is_space</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'\t'</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'\f'</literal></expr>)</condition>
	<block>{<block_content>
	    <return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get myself query string from original query string,
 * if the query string contain multi stmt
 */</comment>
<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type>
<name>get_myself_query_string</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>query_string</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>out_query_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>string_delimeter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>myself_query_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>myself_query_string_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>in_quotation</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>query_string_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>query_string</name> <operator>&amp;&amp;</operator> <name><name>query_string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* skip space and redundant ';' */</comment>
        <while>while <condition>(<expr><operator>*</operator><name>query_string</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>ch_is_space</name><argument_list>(<argument><expr><operator>*</operator><name>query_string</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>query_string</name> <operator>==</operator> <literal type="char">';'</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>query_string</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>

        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>query_string</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>out_query_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* find ';' in query string, be careful of '\'' */</comment>
        <expr_stmt><expr><name>query_string_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>query_string_len</name></expr>;</condition> <incr><expr><name>pos</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>query_string</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>in_quotation</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>in_quotation</name><operator>)</operator></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>query_string</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">';'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>in_quotation</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>string_delimeter</name> <operator>=</operator> <operator>&amp;</operator><name><name>query_string</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>string_delimeter</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>myself_query_string</name> <operator>=</operator> <name>query_string</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>query_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>myself_query_string_len</name> <operator>=</operator> <name>string_delimeter</name> <operator>-</operator> <name>query_string</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>myself_query_string</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>myself_query_string_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>myself_query_string</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>myself_query_string_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>myself_query_string</name><index>[<expr><name>myself_query_string_len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

            <expr_stmt><expr><name>query_string</name> <operator>=</operator> <name>string_delimeter</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>out_query_string</name> <operator>=</operator> <name>myself_query_string</name></expr>;</expr_stmt>
    <return>return <expr><name>query_string</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * exec_simple_query
 *
 * Execute a "simple Query" protocol message.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_simple_query</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CommandDest</name></type> <name>dest</name> <init>= <expr><name>whereToSendOutput</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>parsetree_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>parsetree_item</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>save_log_statement_stats</name> <init>= <expr><name>log_statement_stats</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>was_logged</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isTopLevel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>multiCommands</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>query_string_tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Report query to various monitoring facilities.
     */</comment>
    <expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>query_string</name></expr>;</expr_stmt>


    <expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_START</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We use save_log_statement_stats so ShowUsage doesn't report incorrect
     * results because ResetUsage wasn't called.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Start up a transaction command.  All queries generated by the
     * query_string will be in this same command block, *unless* we find a
     * BEGIN/COMMIT/ABORT statement; we have to force a new xact command after
     * one of those, else bad things will happen in xact.c. (Note that this
     * will normally change current memory context.)
     */</comment>
    <expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Zap any pre-existing unnamed statement.  (While not strictly necessary,
     * it seems best to define simple-Query mode as if it used the unnamed
     * statement and portal; this ensures we recover any storage used by prior
     * unnamed operations.)
     */</comment>
    <expr_stmt><expr><call><name>drop_unnamed_stmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Switch to appropriate context for constructing parsetrees.
     */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Do basic parsing of the query or queries (this should be safe even if
     * we are in aborted transaction state!)
     */</comment>
    <expr_stmt><expr><name>parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * There is a bug in old code, if one query contains multiple utility
         * statements, entire query may be sent multiple times to the Datanodes
         * for execution. That is becoming a severe problem, if query contains
         * COMMIT or ROLLBACK. After executed for the first time the transaction
         * handling statement would write CLOG entry for current xid, but other
         * executions would be done with the same xid, causing PANIC on the
         * Datanodes because of already existing CLOG record. Datanode is
         * restarting all sessions if it PANICs, and affects all cluster users.
         * Multiple utility statements may result in strange error messages,
         * but somteime they work, and used in many applications, so we do not
         * want to disable them completely, just protect against severe
         * vulnerability here.
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>parsetree_item</argument>, <argument>parsetree_list</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>parsetree_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>IsTransactionExitStmt</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STATEMENT_TOO_COMPLEX</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COMMIT or ROLLBACK "</literal>
                                <literal type="string">"in multi-statement queries not allowed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>

        <expr_stmt><expr><name>query_string_tmp</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>query_string</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * XXX We may receive multi-command string and the coordinator is not
     * equipped to handle multiple command-complete messages. So just send a
     * single command-complete until we fix the coordinator side of things
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IS_PGXC_LOCAL_COORDINATOR</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>multiCommands</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>is_mls_user</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <call><name>mls_query_string_prune</name><argument_list>(<argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Log immediately if dictated by log_statement */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>check_log_statement</name><argument_list>(<argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"statement: %s"</literal></expr></argument>, <argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail_execute</name><argument_list>(<argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>was_logged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Switch back to transaction context to enter the loop.
     */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We'll tell PortalRun it's a top-level command iff there's exactly one
     * raw parsetree.  If more than one, it's effectively a transaction block
     * and we want PreventTransactionChain to reject unsafe commands. (Note:
     * we're assuming that query rewrite cannot add commands that are
     * significant to PreventTransactionChain.)
     */</comment>
    <expr_stmt><expr><name>isTopLevel</name> <operator>=</operator> <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/*
     * Run through the raw parsetree(s) and process each one.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>parsetree_item</argument>, <argument>parsetree_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>parsetree_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>snapshot_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandTag</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>completionTag</name><index>[<expr><name>COMPLETION_TAG_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>querytree_list</name></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>plantree_list</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Portal</name></type>        <name>portal</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>receiver</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int16</name></type>        <name>format</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>myself_query_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>query_string_tmp</name> <operator>&amp;&amp;</operator> <name><name>query_string_tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* get this portal's query when has multi parse tree */</comment>
            <expr_stmt><expr><name>query_string_tmp</name> <operator>=</operator> <call><name>get_myself_query_string</name><argument_list>(<argument><expr><name>query_string_tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myself_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>

        <comment type="block">/*
         * By default we do not want Datanodes or client Coordinators to contact GTM directly,
         * it should get this information passed down to it.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>||</operator> <call><name>IsConnFromCoord</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>SetForceXidFromGTM</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * Get the command name for use in status display (it also becomes the
         * default completion tag, down inside PortalRun).  Set ps_status and
         * do any special start-of-SQL-command processing needed by the
         * destination.
         */</comment>
        <expr_stmt><expr><name>commandTag</name> <operator>=</operator> <call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
        <expr_stmt><expr><name>g_commandTag</name> <operator>=</operator> <name>commandTag</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>HeavyLockCheck</name><argument_list>(<argument><expr><name>commandTag</name></expr></argument>, <argument><expr><name>CMD_UNKNOWN</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>groupOids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>explain_stmt</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>commandTag</name></expr></argument>, <argument><expr><literal type="string">"EXPLAIN"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>explain_stmt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>commandTag</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>BeginCommand</name><argument_list>(<argument><expr><name>commandTag</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If we are in an aborted transaction, reject all commands except
         * COMMIT/ABORT.  It is important that this test occur before we try
         * to do parse analysis, rewrite, or planning, since all those phases
         * try to do database accesses, which may fail in abort state. (It
         * might be safe to allow some additional utility commands in this
         * state, but not many...)
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>IsTransactionExitStmt</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"current transaction is aborted, "</literal>
                            <literal type="string">"commands ignored until end of transaction block"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail_abort</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Make sure we are in a transaction command */</comment>
        <expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If we got a cancel signal in parsing or prior command, quit */</comment>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Set up a snapshot if parse analysis/planning will need one.
         */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>analyze_requires_snapshot</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>g_snapshot_for_analyze</name></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <comment type="block">/* use local snapshot instead of global if told so */</comment>
            <if_stmt><if>if <condition>(<expr><name>g_set_global_snapshot</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetLocalTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>snapshot_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * OK to analyze, rewrite, and plan this query.
         *
         * Switch to appropriate context for constructing querytrees (again,
         * these must outlive the execution context).
         */</comment>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>pg_analyze_and_rewrite</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>,
                                                <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>xact_started</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>AuditReadQueryList</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>querytree_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>plantree_list</name> <operator>=</operator> <call><name>pg_plan_queries</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>,
                                        <argument><expr><name>CURSOR_OPT_PARALLEL_OK</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Done with the snapshot used for parsing/planning */</comment>
        <if_stmt><if>if <condition>(<expr><name>snapshot_set</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* If we got a cancel signal in analysis or planning, quit */</comment>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <comment type="block">/* 
         * Force getting Xid from GTM for vacuum, cluster and reindex for
         * database or schema
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <name>IsPostmasterEnvironment</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>, <argument><expr><name>VacuumStmt</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>, <argument><expr><name>ClusterStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                 <expr_stmt><expr><call><name>SetForceXidFromGTM</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>, <argument><expr><name>ReindexStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ReindexStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ReindexStmt</name> <operator>*</operator><operator>)</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>REINDEX_OBJECT_SCHEMA</name> <operator>||</operator>
                    <name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>REINDEX_OBJECT_DATABASE</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>SetForceXidFromGTM</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * Create unnamed portal to run the query or queries in. If there
         * already is one, silently drop it.
         */</comment>
        <expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>CreatePortal</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Don't display the portal in pg_cursors */</comment>
        <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>visible</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/*
         * try to transform 'insert into values...' to 'COPY FROM'
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>, <argument><expr><name>InsertStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>list_length</name><argument_list>(<argument><expr><name>plantree_list</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>planstmt</name> <init>= <expr><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name>plantree_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>planstmt</name><operator>-&gt;</operator><name>parseTree</name></name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* only handle multi-values without triggers */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>isMultiValues</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>hasUnshippableTriggers</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>bool</name></type> <name>success</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>InsertStmt</name> <modifier>*</modifier></type><name>insert_stmt</name> <init>= <expr><operator>(</operator><name>InsertStmt</name><operator>*</operator><operator>)</operator><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>plantree_list</name> <operator>=</operator> <call><name>transformInsertValuesIntoCopyFrom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>insert_stmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>success</name></expr></argument>, 
                                                                  <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>copy_filename</name></name></expr></argument>, <argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/*
         * We don't have to copy anything into the portal, because everything
         * we are passing here is in MessageContext, which will outlive the
         * portal anyway.
         */</comment>
        <expr_stmt><expr><call><name>PortalDefineQuery</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><ternary><condition><expr><operator>(</operator><name>myself_query_string</name><operator>)</operator></expr> ?</condition><then> <expr><name>myself_query_string</name></expr> </then><else>: <expr><name>query_string</name></expr></else></ternary></expr></argument>,
                          <argument><expr><name>commandTag</name></expr></argument>,
                          <argument><expr><name>plantree_list</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * Start the portal.  No parameters here.
         */</comment>
        <expr_stmt><expr><call><name>PortalStart</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/* store query info, only SELECT cmd */</comment>
        <if_stmt><if>if <condition>(<expr><name>distributed_query_analyze</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>plantree_list</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name> <init>= <expr><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>plantree_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>StoreQueryAnalyzeInfo</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * Select the appropriate output format: text unless we are doing a
         * FETCH from a binary cursor.  (Pretty grotty to have to do this here
         * --- but it avoids grottiness in other places.  Ah, the joys of
         * backward compatibility...)
         */</comment>
        <expr_stmt><expr><name>format</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                <comment type="block">/* TEXT is default */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>, <argument><expr><name>FetchStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>FetchStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>FetchStmt</name> <operator>*</operator><operator>)</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>ismove</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Portal</name></type>        <name>fportal</name> <init>= <expr><call><name>GetPortalByName</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>portalname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>fportal</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                    <operator>(</operator><name><name>fportal</name><operator>-&gt;</operator><name>cursorOptions</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_BINARY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>format</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* BINARY */</comment>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>PortalSetResultFormat</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Now we can create the destination receiver object.
         */</comment>
        <expr_stmt><expr><name>receiver</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>dest</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>SetRemoteDestReceiverParams</name><argument_list>(<argument><expr><name>receiver</name></expr></argument>, <argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Switch back to transaction context for execution.
         */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Run the portal to completion, and then drop it (and the receiver).
         */</comment>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>PortalRun</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
                         <argument><expr><name>FETCH_ALL</name></expr></argument>,
                         <argument><expr><name>isTopLevel</name></expr></argument>,
                         <argument><expr><name>true</name></expr></argument>,
                         <argument><expr><name>receiver</name></expr></argument>,
                         <argument><expr><name>receiver</name></expr></argument>,
                         <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call>(<modifier>*</modifier><name><name>receiver</name><operator>-&gt;</operator><name>rDestroy</name></name>) <argument_list>(<argument><expr><name>receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PortalDrop</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/* remove query info */</comment>
        <if_stmt><if>if <condition>(<expr><name>distributed_query_analyze</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>plantree_list</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name> <init>= <expr><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>plantree_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>DropQueryAnalyzeInfo</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>, <argument><expr><name>TransactionStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>xact_started</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>AuditProcessResultInfo</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/*
             * If this was a transaction control statement, commit it. We will
             * start a new xact command for the next command (if any).
             */</comment>
            <expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>parsetree_item</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>xact_started</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>AuditProcessResultInfo</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/*
             * If this is the last parsetree of the query string, close down
             * transaction statement before reporting command-complete.  This
             * is so that any end-of-transaction errors are reported before
             * the command-complete message is issued, to avoid confusing
             * clients who will expect either a command-complete message or an
             * error, not one and then the other.  But for compatibility with
             * historical Postgres behavior, we do not force a transaction
             * boundary between queries appearing in a single query string.
             */</comment>
            <expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * We need a CommandCounterIncrement after every query, except
             * those that start or end a transaction block.
             */</comment>
            <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * Tell client that we're done with this query.  Note we emit exactly
         * one EndCommand report for each raw parsetree, thus one for each SQL
         * command the client sent, regardless of rewriting. (But a command
         * aborted by error will not send an EndCommand report at all.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>multiCommands</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>EndCommand</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>                            <comment type="block">/* end loop over parsetrees */</comment>

    <if_stmt><if>if <condition>(<expr><name>multiCommands</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>EndCommand</name><argument_list>(<argument><expr><literal type="string">"MultiCommand"</literal></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>xact_started</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>AuditProcessResultInfo</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Close down transaction statement, if one is open.
     */</comment>
    <expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If there were no parsetrees, return EmptyQueryResponse message.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>parsetree_list</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>NullCommand</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Emit duration logging if appropriate.
     */</comment>
    <switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>was_logged</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="number">1</literal></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms"</literal></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="number">2</literal></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms  statement: %s"</literal></expr></argument>,
                            <argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail_execute</name><argument_list>(<argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"QUERY STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_DONE</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * exec_parse_message
 *
 * Execute a "Parse" protocol message.
 * If paramTypeNames is specified, paraTypes is filled with corresponding OIDs.
 * The caller is expected to allocate space for the paramTypes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_parse_message</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>,    <comment type="block">/* string to execute */</comment>
                   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl></parameter>,    <comment type="block">/* name for prepared stmt */</comment>
                   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>paramTypes</name></decl></parameter>, <comment type="block">/* parameter types */</comment>
                   <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>paramTypeNames</name></decl></parameter>,    <comment type="block">/* parameter type names */</comment>
				   <parameter><decl><type><name>int</name></type> <name>numParams</name></decl></parameter>, <comment type="block">/* number of parameters */</comment>
				   <parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name>need_rewrite</name></decl></parameter>)</parameter_list> <comment type="block">/* plancache need to be rewritted */</comment>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>unnamed_stmt_context</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>parsetree_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>raw_parse_tree</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandTag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>querytree_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>psrc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_named</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>save_log_statement_stats</name> <init>= <expr><name>log_statement_stats</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type>        <name>use_resowner</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Report query to various monitoring facilities.
     */</comment>
    <expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>query_string</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>is_mls_user</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <call><name>mls_query_string_prune</name><argument_list>(<argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"PARSE"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parse %s: %s"</literal></expr></argument>,
                    <argument><expr><ternary><condition><expr><operator>*</operator><name>stmt_name</name></expr> ?</condition><then> <expr><name>stmt_name</name></expr> </then><else>: <expr><literal type="string">"&lt;unnamed&gt;"</literal></expr></else></ternary></expr></argument>,
                    <argument><expr><name>query_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Start up a transaction command so we can run parse analysis etc. (Note
     * that this will normally change current memory context.) Nothing happens
     * if we are already in one.
     */</comment>
    <expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Switch to appropriate context for constructing parsetrees.
     *
     * We have two strategies depending on whether the prepared statement is
     * named or not.  For a named prepared statement, we do parsing in
     * MessageContext and copy the finished trees into the prepared
     * statement's plancache entry; then the reset of MessageContext releases
     * temporary space used by parsing and rewriting. For an unnamed prepared
     * statement, we assume the statement isn't going to hang around long, so
     * getting rid of temp space quickly is probably not worth the costs of
     * copying parse trees.  So in this case, we create the plancache entry's
     * query_context here, and do all the parsing work therein.
     */</comment>
    <expr_stmt><expr><name>is_named</name> <operator>=</operator> <operator>(</operator><name><name>stmt_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>is_named</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Named prepared statement --- parse in MessageContext */</comment>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><name>use_resowner</name> <operator>=</operator> <call><name>NeedResourceOwner</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>use_resowner</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_COORDINATOR</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"name with prefix %s/%s/%s for prepared stmt is forbidden"</literal></expr></argument>,
                        <argument><expr><name>INSERT_TRIGGER</name></expr></argument>, <argument><expr><name>UPDATE_TRIGGER</name></expr></argument>, <argument><expr><name>DELETE_TRIGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Unnamed prepared statement --- release any prior unnamed stmt */</comment>
        <expr_stmt><expr><call><name>drop_unnamed_stmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Create context for parsing */</comment>
        <expr_stmt><expr><name>unnamed_stmt_context</name> <operator>=</operator>
            <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>,
                                  <argument><expr><literal type="string">"unnamed prepared statement"</literal></expr></argument>,
                                  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>unnamed_stmt_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/*
     * if we have the parameter types passed, which happens only in case of
     * connection from Coordinators, fill paramTypes with their OIDs for
     * subsequent use. We have to do name to OID conversion, in a transaction
     * context.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>paramTypeNames</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>cnt_param</name></decl>;</decl_stmt>
        <comment type="block">/* we don't expect type mod */</comment>
        <for>for <control>(<init><expr><name>cnt_param</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt_param</name> <operator>&lt;</operator> <name>numParams</name></expr>;</condition> <incr><expr><name>cnt_param</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>parseTypeString</name><argument_list>(<argument><expr><name><name>paramTypeNames</name><index>[<expr><name>cnt_param</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>paramTypes</name><index>[<expr><name>cnt_param</name></expr>]</index></name></expr></argument>,
                            <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>

    <comment type="block">/*
     * Do basic parsing of the query or queries (this should be safe even if
     * we are in aborted transaction state!)
     */</comment>
    <expr_stmt><expr><name>parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We only allow a single user statement in a prepared statement. This is
     * mainly to keep the protocol simple --- otherwise we'd need to worry
     * about multiple result tupdescs and things like that.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot insert multiple commands into a prepared statement"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>parsetree_list</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>snapshot_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>raw_parse_tree</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Get the command name for possible use in status display.
         */</comment>
        <expr_stmt><expr><name>commandTag</name> <operator>=</operator> <call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>raw_parse_tree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><name>explain_stmt</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>commandTag</name></expr></argument>, <argument><expr><literal type="string">"EXPLAIN"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>explain_stmt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>HeavyLockCheck</name><argument_list>(<argument><expr><name>commandTag</name></expr></argument>, <argument><expr><name>CMD_UNKNOWN</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>raw_parse_tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * If we are in an aborted transaction, reject all commands except
         * COMMIT/ROLLBACK.  It is important that this test occur before we
         * try to do parse analysis, rewrite, or planning, since all those
         * phases try to do database accesses, which may fail in abort state.
         * (It might be safe to allow some additional utility commands in this
         * state, but not many...)
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>IsTransactionExitStmt</name><argument_list>(<argument><expr><name><name>raw_parse_tree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"current transaction is aborted, "</literal>
                            <literal type="string">"commands ignored until end of transaction block"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail_abort</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Create the CachedPlanSource before we do parse analysis, since it
         * needs to see the unmodified raw parse tree.
         */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <expr_stmt><expr><name>psrc</name> <operator>=</operator> <call><name>CreateCachedPlan</name><argument_list>(<argument><expr><name>raw_parse_tree</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>commandTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>psrc</name> <operator>=</operator> <call><name>CreateCachedPlan</name><argument_list>(<argument><expr><name>raw_parse_tree</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>commandTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * Set up a snapshot if parse analysis will need one.
         */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>analyze_requires_snapshot</name><argument_list>(<argument><expr><name>raw_parse_tree</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>g_snapshot_for_analyze</name></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <comment type="block">/* use local snapshot instead of global if told so */</comment>
            <if_stmt><if>if <condition>(<expr><name>g_set_global_snapshot</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetLocalTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>snapshot_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Analyze and rewrite the query.  Note that the originally specified
         * parameter set is not required to be complete, so we have to use
         * parse_analyze_varparams().
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>parse_analyze_varparams</name><argument_list>(<argument><expr><name>raw_parse_tree</name></expr></argument>,
                                        <argument><expr><name>query_string</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>paramTypes</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>numParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>isMultiValues</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>hasUnshippableTriggers</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>InsertStmt</name> <modifier>*</modifier></type><name>src_insert</name> <init>= <expr><operator>(</operator><name>InsertStmt</name> <operator>*</operator><operator>)</operator><name><name>raw_parse_tree</name><operator>-&gt;</operator><name>stmt</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>InsertStmt</name> <modifier>*</modifier></type><name>dest_insert</name> <init>= <expr><operator>(</operator><name>InsertStmt</name> <operator>*</operator><operator>)</operator><name><name>psrc</name><operator>-&gt;</operator><name>raw_parse_tree</name><operator>-&gt;</operator><name>stmt</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>psrc</name><operator>-&gt;</operator><name>insert_into</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dest_insert</name><operator>-&gt;</operator><name>ninsert_columns</name></name> <operator>=</operator> <name><name>src_insert</name><operator>-&gt;</operator><name>ninsert_columns</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * Check all parameter types got determined.
         */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numParams</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>ptype</name> <init>= <expr><name><name>paramTypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator> <name>ptype</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDETERMINATE_DATATYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine data type of parameter $%d"</literal></expr></argument>,
                                <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"PARSE ANALYSIS STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>pg_rewrite_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Done with the snapshot used for parsing */</comment>
        <if_stmt><if>if <condition>(<expr><name>snapshot_set</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Empty input string.  This is legal. */</comment>
        <expr_stmt><expr><name>raw_parse_tree</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>commandTag</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <expr_stmt><expr><name>psrc</name> <operator>=</operator> <call><name>CreateCachedPlan</name><argument_list>(<argument><expr><name>raw_parse_tree</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>commandTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>psrc</name> <operator>=</operator> <call><name>CreateCachedPlan</name><argument_list>(<argument><expr><name>raw_parse_tree</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>commandTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * CachedPlanSource must be a direct child of MessageContext before we
     * reparent unnamed_stmt_context under it, else we have a disconnected
     * circular subgraph.  Klugy, but less so than flipping contexts even more
     * above.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>unnamed_stmt_context</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextSetParent</name><argument_list>(<argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Finish filling in the CachedPlanSource */</comment>
    <expr_stmt><expr><call><name>CompleteCachedPlan</name><argument_list>(<argument><expr><name>psrc</name></expr></argument>,
                       <argument><expr><name>querytree_list</name></expr></argument>,
                       <argument><expr><name>unnamed_stmt_context</name></expr></argument>,
                       <argument><expr><name>paramTypes</name></expr></argument>,
                       <argument><expr><name>numParams</name></expr></argument>,
                       <argument><expr><name>NULL</name></expr></argument>,
                       <argument><expr><name>NULL</name></expr></argument>,
                       <argument><expr><name>CURSOR_OPT_PARALLEL_OK</name></expr></argument>,    <comment type="block">/* allow parallel mode */</comment>
                       <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* fixed result */</comment>

    <comment type="block">/* If we got a cancel signal during analysis, quit */</comment>
    <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>is_named</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Store the query as a prepared statement.
         */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>use_resowner</name></expr>)</condition>
        <block>{<block_content>
			<expr_stmt><expr><call><name>StorePreparedStatement</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>psrc</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>need_rewrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>StorePreparedStatement</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>psrc</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>need_rewrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * We just save the CachedPlanSource into unnamed_stmt_psrc.
         */</comment>
        <expr_stmt><expr><call><name>SaveCachedPlan</name><argument_list>(<argument><expr><name>psrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>unnamed_stmt_psrc</name> <operator>=</operator> <name>psrc</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We do NOT close the open transaction command here; that only happens
     * when the client sends Sync.  Instead, do CommandCounterIncrement just
     * in case something happened during parse/plan.
     */</comment>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Send ParseComplete.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'1'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Emit duration logging if appropriate.
     */</comment>
    <switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="number">1</literal></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms"</literal></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="number">2</literal></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms  parse %s: %s"</literal></expr></argument>,
                            <argument><expr><name>msec_str</name></expr></argument>,
                            <argument><expr><ternary><condition><expr><operator>*</operator><name>stmt_name</name></expr> ?</condition><then> <expr><name>stmt_name</name></expr> </then><else>: <expr><literal type="string">"&lt;unnamed&gt;"</literal></expr></else></ternary></expr></argument>,
                            <argument><expr><name>query_string</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"PARSE MESSAGE STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<comment type="block">/*
 * exec_plan_message
 *
 * Execute a "Plan" protocol message - already planned statement.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_plan_message</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>,    <comment type="block">/* source of the query */</comment>
                  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl></parameter>,        <comment type="block">/* name for prepared stmt */</comment>
                  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>plan_string</name></decl></parameter>,        <comment type="block">/* encoded plan to execute */</comment>
                  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>paramTypeNames</name></decl></parameter>,    <comment type="block">/* parameter type names */</comment>
				  <parameter><decl><type><name>int</name></type> <name>numParams</name></decl></parameter>,		<comment type="block">/* number of parameters */</comment>
				  <parameter><decl><type><name>int</name></type> <name>instrument_options</name></decl></parameter>)</parameter_list>		<comment type="block">/* explain analyze option */</comment>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>save_log_statement_stats</name> <init>= <expr><name>log_statement_stats</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>paramTypes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>psrc</name></decl>;</decl_stmt>

    <comment type="block">/* coord name + remote node + whatever */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type>        <name><name>commandTag</name><index>[<expr><name>NAMEDATALEN</name> <operator>+</operator> <name>NAMEDATALEN</name> <operator>+</operator> <literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* Statement name should not be empty */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Report query to various monitoring facilities.
     */</comment>
    <expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>query_string</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>is_mls_user</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <call><name>mls_query_string_prune</name><argument_list>(<argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"PLAN"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"plan %s: %s"</literal></expr></argument>,
                    <argument><expr><ternary><condition><expr><operator>*</operator><name>stmt_name</name></expr> ?</condition><then> <expr><name>stmt_name</name></expr> </then><else>: <expr><literal type="string">"&lt;unnamed&gt;"</literal></expr></else></ternary></expr></argument>,
                    <argument><expr><name>query_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Start up a transaction command so we can decode plan etc. (Note
     * that this will normally change current memory context.) Nothing happens
     * if we are already in one.
     */</comment>
    <expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * XXX
     * Postgres decides about memory context to use based on "named/unnamed"
     * assuming named statement is executed multiple times and unnamed is
     * executed once.
     * Plan message always provide statement name, but we may use different
     * criteria, like if plan is referencing "internal" parameters it probably
     * will be executed multiple times, if not - once.
     * So far optimize for multiple executions.
     */</comment>
    <comment type="block">/* Named prepared statement --- parse in MessageContext */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="line">//    unnamed_stmt_context =</comment>
<comment type="line">//        AllocSetContextCreate(CacheMemoryContext,</comment>
<comment type="line">//                              "unnamed prepared statement",</comment>
<comment type="line">//                              ALLOCSET_DEFAULT_MINSIZE,</comment>
<comment type="line">//                              ALLOCSET_DEFAULT_INITSIZE,</comment>
<comment type="line">//                              ALLOCSET_DEFAULT_MAXSIZE);</comment>
<comment type="line">//    oldcontext = MemoryContextSwitchTo(unnamed_stmt_context);</comment>

    <comment type="block">/*
     * Determine parameter types
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>numParams</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>cnt_param</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>paramTypes</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numParams</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* we don't expect type mod */</comment>
        <for>for <control>(<init><expr><name>cnt_param</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt_param</name> <operator>&lt;</operator> <name>numParams</name></expr>;</condition> <incr><expr><name>cnt_param</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>parseTypeString</name><argument_list>(<argument><expr><name><name>paramTypeNames</name><index>[<expr><name>cnt_param</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>paramTypes</name><index>[<expr><name>cnt_param</name></expr>]</index></name></expr></argument>,
                                <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If we got a cancel signal, quit */</comment>
    <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>commandTag</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>commandTag</name></expr></argument>)</argument_list></sizeof></expr></argument>,
            <argument><expr><literal type="string">"REMOTE SUBPLAN (%s:%d) (%c:%s:%d)"</literal></expr></argument>,
            <argument><expr><name>MyCoordName</name></expr></argument>, <argument><expr><name>MyCoordPid</name></expr></argument>,
            <argument><expr><ternary><condition><expr><name>remoteConnType</name> <operator>==</operator> <name>REMOTE_CONN_APP</name></expr> ?</condition><then> <expr><literal type="char">'A'</literal></expr> </then><else>: 
                <expr><ternary><condition><expr><name>remoteConnType</name> <operator>==</operator> <name>REMOTE_CONN_DATANODE</name></expr> ?</condition><then> <expr><literal type="char">'D'</literal></expr> </then><else>:
                <expr><ternary><condition><expr><name>remoteConnType</name> <operator>==</operator> <name>REMOTE_CONN_COORD</name></expr> ?</condition><then> <expr><literal type="char">'C'</literal></expr> </then><else>: <expr><literal type="char">'U'</literal></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></argument>,
            <argument><expr><name>parentPGXCNode</name></expr></argument>, <argument><expr><name>parentPGXCPid</name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>psrc</name> <operator>=</operator> <call><name>CreateCachedPlan</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>commandTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CompleteCachedPlan</name><argument_list>(<argument><expr><name>psrc</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>paramTypes</name></expr></argument>, <argument><expr><name>numParams</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                       <argument><expr><name>CURSOR_OPT_GENERIC_PLAN</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Store the query as a prepared statement.  See above comments.
     */</comment>
	<expr_stmt><expr><call><name>StorePreparedStatement</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>psrc</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'N'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SetRemoteSubplan</name><argument_list>(<argument><expr><name>psrc</name></expr></argument>, <argument><expr><name>plan_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* set instrument_options, default 0 */</comment>
	<expr_stmt><expr><name><name>psrc</name><operator>-&gt;</operator><name>instrument_options</name></name> <operator>=</operator> <name>instrument_options</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We do NOT close the open transaction command here; that only happens
     * when the client sends Sync.    Instead, do CommandCounterIncrement just
     * in case something happened during parse/plan.
     */</comment>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Send ParseComplete.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'1'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Emit duration logging if appropriate.
     */</comment>
    <switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="number">1</literal></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms"</literal></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="number">2</literal></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms  parse %s: %s"</literal></expr></argument>,
                            <argument><expr><name>msec_str</name></expr></argument>,
                            <argument><expr><ternary><condition><expr><operator>*</operator><name>stmt_name</name></expr> ?</condition><then> <expr><name>stmt_name</name></expr> </then><else>: <expr><literal type="string">"&lt;unnamed&gt;"</literal></expr></else></ternary></expr></argument>,
                            <argument><expr><name>query_string</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"PLAN MESSAGE STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * exec_bind_message
 *
 * Process a "Bind" message to create a portal from a prepared statement
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_bind_message</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>input_message</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portal_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numPFormats</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name>       <modifier>*</modifier></type><name>pformats</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numParams</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numRFormats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>num_epq_tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name>       <modifier>*</modifier></type><name>rformats</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>psrc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>cplan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Portal</name></type>        <name>portal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>query_string</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>saved_stmt_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParamListInfo</name></type> <name>params</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>save_log_statement_stats</name> <init>= <expr><name>log_statement_stats</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>snapshot_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type> <name>ncolumns</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>column_index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>data_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_top</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Get the fixed part of the message */</comment>
    <expr_stmt><expr><name>portal_name</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>stmt_name</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bind %s to %s"</literal></expr></argument>,
                    <argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><name>portal_name</name></expr> </then><else>: <expr><literal type="string">"&lt;unnamed&gt;"</literal></expr></else></ternary></expr></argument>,
                    <argument><expr><ternary><condition><expr><operator>*</operator><name>stmt_name</name></expr> ?</condition><then> <expr><name>stmt_name</name></expr> </then><else>: <expr><literal type="string">"&lt;unnamed&gt;"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"pid:%d, exec_bind_message:%s %s"</literal></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><name>portal_name</name></expr> </then><else>: <expr><literal type="string">"&lt;unnamed&gt;"</literal></expr></else></ternary></expr></argument>,
               <argument><expr><ternary><condition><expr><operator>*</operator><name>stmt_name</name></expr> ?</condition><then> <expr><name>stmt_name</name></expr> </then><else>: <expr><literal type="string">"&lt;unnamed&gt;"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Find prepared statement */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>pstmt</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>psrc</name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>plansource</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* special-case the unnamed statement */</comment>
        <expr_stmt><expr><name>psrc</name> <operator>=</operator> <name>unnamed_stmt_psrc</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>psrc</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_PSTATEMENT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unnamed prepared statement does not exist"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Report query to various monitoring facilities.
     */</comment>
    <expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name><name>psrc</name><operator>-&gt;</operator><name>query_string</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>is_mls_user</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <call><name>mls_query_string_prune</name><argument_list>(<argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<expr_stmt><expr><call><name>HeavyLockCheck</name><argument_list>(<argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>commandTag</name></name></expr></argument>, <argument><expr><name>CMD_UNKNOWN</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"BIND"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Start up a transaction command so we can call functions etc. (Note that
     * this will normally change current memory context.) Nothing happens if
     * we are already in one.
     */</comment>
    <expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Switch back to message context */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get the parameter format codes */</comment>
    <expr_stmt><expr><name>numPFormats</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>numPFormats</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>pformats</name> <operator>=</operator> <operator>(</operator><name>int16</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numPFormats</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numPFormats</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>pformats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Get the parameter value count */</comment>
    <expr_stmt><expr><name>numParams</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>numPFormats</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>numPFormats</name> <operator>!=</operator> <name>numParams</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bind message has %d parameter formats but %d parameters"</literal></expr></argument>,
                        <argument><expr><name>numPFormats</name></expr></argument>, <argument><expr><name>numParams</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>numParams</name> <operator>!=</operator> <name><name>psrc</name><operator>-&gt;</operator><name>num_params</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bind message supplies %d parameters, but prepared statement \"%s\" requires %d"</literal></expr></argument>,
                        <argument><expr><name>numParams</name></expr></argument>, <argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>num_params</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/*
     * if we told to do copy from instead of insert into multi-values,
     * also need to do some check to ensure we can do copy from 
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>psrc</name><operator>-&gt;</operator><name>insert_into</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>query_list</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* reset stmt_list */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>psrc</name><operator>-&gt;</operator><name>gplan</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>psrc</name><operator>-&gt;</operator><name>gplan</name><operator>-&gt;</operator><name>stmt_list_backup</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>psrc</name><operator>-&gt;</operator><name>gplan</name><operator>-&gt;</operator><name>stmt_list</name></name> <operator>=</operator> <name><name>psrc</name><operator>-&gt;</operator><name>gplan</name><operator>-&gt;</operator><name>stmt_list_backup</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>psrc</name><operator>-&gt;</operator><name>raw_parse_tree</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>raw_parse_tree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>, <argument><expr><name>InsertStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* number of params must be times the insert columns */</comment>
                <decl_stmt><decl><type><name>InsertStmt</name> <modifier>*</modifier></type><name>insert_stmt</name> <init>= <expr><operator>(</operator><name>InsertStmt</name> <operator>*</operator><operator>)</operator><name><name>psrc</name><operator>-&gt;</operator><name>raw_parse_tree</name><operator>-&gt;</operator><name>stmt</name></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>ncolumns</name> <operator>=</operator> <name><name>insert_stmt</name><operator>-&gt;</operator><name>ninsert_columns</name></name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>ncolumns</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>numParams</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>numParams</name> <operator>%</operator> <name>ncolumns</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>psrc</name><operator>-&gt;</operator><name>insert_into</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>psrc</name><operator>-&gt;</operator><name>insert_into</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>psrc</name><operator>-&gt;</operator><name>insert_into</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>psrc</name><operator>-&gt;</operator><name>insert_into</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>old_top</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>data_list</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>numParams</name> <operator>/</operator> <name>ncolumns</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>numParams</name> <operator>/</operator> <name>ncolumns</name><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>data_list</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><name>column_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If we are in aborted transaction state, the only portals we can
     * actually run are those containing COMMIT or ROLLBACK commands. We
     * disallow binding anything else to avoid problems with infrastructure
     * that expects to run inside a valid transaction.  We also disallow
     * binding any parameters, since we can't risk calling user-defined I/O
     * functions.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
        <operator>(</operator><operator>!</operator><operator>(</operator><name><name>psrc</name><operator>-&gt;</operator><name>raw_parse_tree</name></name> <operator>&amp;&amp;</operator>
           <call><name>IsTransactionExitStmt</name><argument_list>(<argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>raw_parse_tree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
         <name>numParams</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"current transaction is aborted, "</literal>
                        <literal type="string">"commands ignored until end of transaction block"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail_abort</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Create the portal.  Allow silent replacement of an existing portal only
     * if the unnamed portal is specified.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>portal_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>CreatePortal</name><argument_list>(<argument><expr><name>portal_name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>CreatePortal</name><argument_list>(<argument><expr><name>portal_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Prepare to copy stuff into the portal's memory context.  We do all this
     * copying first, because it could possibly fail (out-of-memory) and we
     * don't want a failure to occur between GetCachedPlan and
     * PortalDefineQuery; that would result in leaking our plancache refcount.
     */</comment>
    <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>PortalGetHeapMemory</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Copy the plan's query string into the portal */</comment>
    <expr_stmt><expr><name>query_string</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portal</name> <operator>&amp;&amp;</operator> <name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>g_commandTag</name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>g_commandTag</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Likewise make a copy of the statement name, unless it's unnamed */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>saved_stmt_name</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>saved_stmt_name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Set a snapshot if we have parameters to fetch (since the input
     * functions might need it) or the query isn't a utility command (and
     * hence could require redoing parse analysis and planning).  We keep the
     * snapshot active till we're done, so that plancache.c doesn't have to
     * take new ones.
     */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>numParams</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
        <operator>(</operator><name><name>psrc</name><operator>-&gt;</operator><name>raw_parse_tree</name></name> <operator>&amp;&amp;</operator>
		 <call><name>analyze_requires_snapshot</name><argument_list>(<argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>raw_parse_tree</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <name>g_snapshot_for_analyze</name></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/* use local snapshot instead of global if told so */</comment>
        <if_stmt><if>if <condition>(<expr><name>g_set_global_snapshot</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetLocalTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>snapshot_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Fetch parameters, if any, and store in the portal's memory context.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>numParams</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>paramno</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>params</name> <operator>=</operator> <operator>(</operator><name>ParamListInfo</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ParamListInfoData</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call> <operator>+</operator>
                                        <name>numParams</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParamExternData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* we have static list of params, so no hooks needed */</comment>
        <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>paramFetch</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>paramFetchArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>parserSetup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>parserSetupArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>numParams</name></name> <operator>=</operator> <name>numParams</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>paramMask</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <for>for <control>(<init><expr><name>paramno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>paramno</name> <operator>&lt;</operator> <name>numParams</name></expr>;</condition> <incr><expr><name>paramno</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>ptype</name> <init>= <expr><name><name>psrc</name><operator>-&gt;</operator><name>param_types</name><index>[<expr><name>paramno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name></type>        <name>plength</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type>        <name>pval</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>isNull</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>StringInfoData</name></type> <name>pbuf</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type>        <name>csave</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int16</name></type>        <name>pformat</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>plength</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>isNull</name> <operator>=</operator> <operator>(</operator><name>plength</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pvalue</name> <init>= <expr><call><name>pq_getmsgbytes</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><name>plength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="block">/*
                 * Rather than copying data around, we just set up a phony
                 * StringInfo pointing to the correct portion of the message
                 * buffer.  We assume we can scribble on the message buffer so
                 * as to maintain the convention that StringInfos have a
                 * trailing null.  This is grotty but is a big win when
                 * dealing with very large parameter strings.
                 */</comment>
                <expr_stmt><expr><name><name>pbuf</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>pvalue</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pbuf</name><operator>.</operator><name>maxlen</name></name> <operator>=</operator> <name>plength</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pbuf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>plength</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pbuf</name><operator>.</operator><name>cursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

                <expr_stmt><expr><name>csave</name> <operator>=</operator> <name><name>pbuf</name><operator>.</operator><name>data</name><index>[<expr><name>plength</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pbuf</name><operator>.</operator><name>data</name><index>[<expr><name>plength</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>pbuf</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>    <comment type="block">/* keep compiler quiet */</comment>
                <expr_stmt><expr><name>csave</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if_stmt><if>if <condition>(<expr><name>numPFormats</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>pformat</name> <operator>=</operator> <name><name>pformats</name><index>[<expr><name>paramno</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>numPFormats</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>pformat</name> <operator>=</operator> <name><name>pformats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>pformat</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>    <comment type="block">/* default = text */</comment>

            <if_stmt><if>if <condition>(<expr><name>pformat</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>    <comment type="block">/* text mode */</comment>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>typinput</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>typioparam</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>pstring</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typinput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * We have to do encoding conversion before calling the
                 * typinput routine.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>pstring</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <if_stmt><if>if <condition>(<expr><name>enable_null_string</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
                    <block>{<block_content>
                        <switch>switch <condition>(<expr><name>ptype</name></expr>)</condition>
                        <block>{<block_content>
                            <case>case <expr><name>CHAROID</name></expr>:</case> 
                            <case>case <expr><name>TEXTOID</name></expr>:</case>
                            <case>case <expr><name>VARCHAROID</name></expr>:</case>
                            <case>case <expr><name>BPCHAROID</name></expr>:</case>
                            <case>case <expr><name>VARCHAR2OID</name></expr>:</case>
                            <case>case <expr><name>NVARCHAR2OID</name></expr>:</case>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>replace_null_with_blank</name><argument_list>(<argument><expr><name><name>pbuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>plength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <break>break;</break>
                                </block_content>}</block>
                            <default>default:</default>
                                <break>break;</break>
                        </block_content>}</block></switch>
                    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><name>pstring</name> <operator>=</operator> <call><name>pg_client_to_server</name><argument_list>(<argument><expr><name><name>pbuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>plength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <expr_stmt><expr><name>pval</name> <operator>=</operator> <call><name>OidInputFunctionCall</name><argument_list>(<argument><expr><name>typinput</name></expr></argument>, <argument><expr><name>pstring</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><name><name>psrc</name><operator>-&gt;</operator><name>insert_into</name></name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>data_list</name><index>[<expr><name>column_index</name></expr>]</index><index>[<expr><name>index</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                        
                        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name>ncolumns</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>column_index</name><operator>++</operator></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>old_top</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>data_list</name><index>[<expr><name>column_index</name></expr>]</index><index>[<expr><name>index</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>pstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        
                        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name>ncolumns</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>column_index</name><operator>++</operator></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/* Free result of encoding conversion, if any */</comment>
                <if_stmt><if>if <condition>(<expr><name>pstring</name> <operator>&amp;&amp;</operator> <name>pstring</name> <operator>!=</operator> <name><name>pbuf</name><operator>.</operator><name>data</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>pformat</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>    <comment type="block">/* binary mode */</comment>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>typreceive</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>typioparam</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>StringInfo</name></type>    <name>bufptr</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * Call the parameter type's binary input converter
                 */</comment>
                <expr_stmt><expr><call><name>getTypeBinaryInputInfo</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typreceive</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>bufptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>bufptr</name> <operator>=</operator> <operator>&amp;</operator><name>pbuf</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <expr_stmt><expr><name>pval</name> <operator>=</operator> <call><name>OidReceiveFunctionCall</name><argument_list>(<argument><expr><name>typreceive</name></expr></argument>, <argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>

                <if_stmt><if>if <condition>(<expr><name><name>psrc</name><operator>-&gt;</operator><name>insert_into</name></name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>data_list</name><index>[<expr><name>column_index</name></expr>]</index><index>[<expr><name>index</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                        
                        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name>ncolumns</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>column_index</name><operator>++</operator></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>Oid</name></type>        <name>typOutput</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>bool</name></type>    <name>typIsVarlena</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>Datum</name></type>    <name>value</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>pstring</name></decl>;</decl_stmt>

                        <expr_stmt><expr><name>old_top</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/* Get info needed to output the value */</comment>
                        <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typOutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIsVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/*
                         * If we have a toasted datum, forcibly detoast it here to avoid
                         * memory leakage inside the type's output routine.
                         */</comment>
                        <if_stmt><if>if <condition>(<expr><name>typIsVarlena</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><name>value</name> <operator>=</operator> <name>pval</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                        <comment type="block">/* Convert Datum to string */</comment>
                        <expr_stmt><expr><name>pstring</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typOutput</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name><name>data_list</name><index>[<expr><name>column_index</name></expr>]</index><index>[<expr><name>index</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>pstring</name></expr>;</expr_stmt>
                        
                        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name>ncolumns</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>column_index</name><operator>++</operator></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><name>enable_null_string</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_LOCAL_COORDINATOR</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isNull</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><call><name>DatumGetChar</name><argument_list>(<argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <switch>switch <condition>(<expr><name>ptype</name></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><name>CHAROID</name></expr>:</case> 
                            <block>{<block_content>
                                <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name>src</name> <operator>=</operator> <operator>&amp;</operator><name>c</name></expr>;</expr_stmt>
                                <break>break;</break>
                            </block_content>}</block>
                        <case>case <expr><name>TEXTOID</name></expr>:</case>
                        <case>case <expr><name>VARCHAROID</name></expr>:</case>
                        <case>case <expr><name>BPCHAROID</name></expr>:</case>
                        <case>case <expr><name>VARCHAR2OID</name></expr>:</case>
                        <case>case <expr><name>NVARCHAR2OID</name></expr>:</case>
                            <block>{<block_content>
                                <expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name>src</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <break>break;</break>
                            </block_content>}</block>
                        <default>default:</default>
                            <break>break;</break>
                    </block_content>}</block></switch>

                    <if_stmt><if>if <condition>(<expr><name>length</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>replace_null_with_blank</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <comment type="block">/* Trouble if it didn't eat the whole buffer */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name> <operator>&amp;&amp;</operator> <name><name>pbuf</name><operator>.</operator><name>cursor</name></name> <operator>!=</operator> <name><name>pbuf</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"incorrect binary data format in bind parameter %d"</literal></expr></argument>,
                                    <argument><expr><name>paramno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported format code: %d"</literal></expr></argument>,
                                <argument><expr><name>pformat</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>        <comment type="block">/* keep compiler quiet */</comment>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* Restore message buffer contents */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>pbuf</name><operator>.</operator><name>data</name><index>[<expr><name>plength</name></expr>]</index></name> <operator>=</operator> <name>csave</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>pval</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>isNull</name></expr>;</expr_stmt>

            <comment type="block">/*
             * We mark the params as CONST.  This ensures that any custom plan
             * makes full use of the parameter values.
             */</comment>
            <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>.</operator><name>pflags</name> <operator>=</operator> <name>PARAM_FLAG_CONST</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>.</operator><name>ptype</name> <operator>=</operator> <name>ptype</name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>params</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>psrc</name><operator>-&gt;</operator><name>insert_into</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>column_index</name> <operator>!=</operator> <operator>(</operator><name>numParams</name> <operator>/</operator> <name>ncolumns</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"number of datarows mismatched, expected %d, result %d"</literal></expr></argument>,
                         <argument><expr><name>numParams</name> <operator>/</operator> <name>ncolumns</name></expr></argument>, <argument><expr><name>column_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Done storing stuff in portal's context */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get the result format codes */</comment>
    <expr_stmt><expr><name>numRFormats</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>numRFormats</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>rformats</name> <operator>=</operator> <operator>(</operator><name>int16</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numRFormats</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numRFormats</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>rformats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>

	<comment type="block">/* Get epq context, only datanodes need them */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsConnFromDatanode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><name>num_epq_tuple</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>num_epq_tuple</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
            
            <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>epqContext</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RemoteEPQContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>epqContext</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>=</operator> <name>num_epq_tuple</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>epqContext</name><operator>-&gt;</operator><name>tid</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_epq_tuple</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>epqContext</name><operator>-&gt;</operator><name>rtidx</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_epq_tuple</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>epqContext</name><operator>-&gt;</operator><name>nodeid</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_epq_tuple</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_epq_tuple</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>epqContext</name><operator>-&gt;</operator><name>rtidx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>epqContext</name><operator>-&gt;</operator><name>tid</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>ip_blkid</name><operator>.</operator><name>bi_hi</name></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>epqContext</name><operator>-&gt;</operator><name>tid</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>ip_blkid</name><operator>.</operator><name>bi_lo</name></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>epqContext</name><operator>-&gt;</operator><name>tid</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ip_posid</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>epqContext</name><operator>-&gt;</operator><name>nodeid</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	
    <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Obtain a plan from the CachedPlanSource.  Any cruft from (re)planning
     * will be generated in MessageContext.  The plan refcount will be
     * assigned to the Portal, so it will be released at portal destruction.
     */</comment>
    <expr_stmt><expr><name>cplan</name> <operator>=</operator> <call><name>GetCachedPlan</name><argument_list>(<argument><expr><name>psrc</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>cplan</name><operator>-&gt;</operator><name>stmt_list_backup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>psrc</name><operator>-&gt;</operator><name>insert_into</name></name> <operator>&amp;&amp;</operator> <name>data_list</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>success</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>copy_filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>query_list</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>InsertStmt</name> <modifier>*</modifier></type><name>insert_stmt</name> <init>= <expr><operator>(</operator><name>InsertStmt</name> <operator>*</operator><operator>)</operator><name><name>psrc</name><operator>-&gt;</operator><name>raw_parse_tree</name><operator>-&gt;</operator><name>stmt</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>cplan</name><operator>-&gt;</operator><name>stmt_list_backup</name></name> <operator>=</operator> <name><name>cplan</name><operator>-&gt;</operator><name>stmt_list</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>old</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>copy_filename</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>copy_filename</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"Insert_into to Copy_from(Extended Protocol)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>insert_stmt</name><operator>-&gt;</operator><name>data_list</name></name> <operator>=</operator> <name>data_list</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>insert_stmt</name><operator>-&gt;</operator><name>ndatarows</name></name> <operator>=</operator> <name>column_index</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>cplan</name><operator>-&gt;</operator><name>stmt_list</name></name> <operator>=</operator> <call><name>transformInsertValuesIntoCopyFrom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>InsertStmt</name><operator>*</operator><operator>)</operator><name><name>psrc</name><operator>-&gt;</operator><name>raw_parse_tree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>success</name></expr></argument>, 
                                                             <argument><expr><name>copy_filename</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Now we can define the portal.
     *
     * DO NOT put any code that could possibly throw an error between the
     * above GetCachedPlan call and here.
     */</comment>
    <expr_stmt><expr><call><name>PortalDefineQuery</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
                      <argument><expr><name>saved_stmt_name</name></expr></argument>,
                      <argument><expr><name>query_string</name></expr></argument>,
                      <argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>commandTag</name></name></expr></argument>,
                      <argument><expr><name><name>cplan</name><operator>-&gt;</operator><name>stmt_list</name></name></expr></argument>,
                      <argument><expr><name>cplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set instrument before PortalStart, default 0 */</comment>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>up_instrument</name></name> <operator>=</operator> <name><name>psrc</name><operator>-&gt;</operator><name>instrument_options</name></name></expr>;</expr_stmt>
	
    <comment type="block">/* Done with the snapshot used for parameter I/O and parsing/planning */</comment>
    <if_stmt><if>if <condition>(<expr><name>snapshot_set</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * And we're ready to start portal execution.
     */</comment>
    <expr_stmt><expr><call><name>PortalStart</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Apply the result format requests to the portal.
     */</comment>
    <expr_stmt><expr><call><name>PortalSetResultFormat</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>numRFormats</name></expr></argument>, <argument><expr><name>rformats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Send BindComplete.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'2'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Emit duration logging if appropriate.
     */</comment>
    <switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="number">1</literal></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms"</literal></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="number">2</literal></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms  bind %s%s%s: %s"</literal></expr></argument>,
                            <argument><expr><name>msec_str</name></expr></argument>,
                            <argument><expr><ternary><condition><expr><operator>*</operator><name>stmt_name</name></expr> ?</condition><then> <expr><name>stmt_name</name></expr> </then><else>: <expr><literal type="string">"&lt;unnamed&gt;"</literal></expr></else></ternary></expr></argument>,
                            <argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><literal type="string">"/"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                            <argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><name>portal_name</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                            <argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail_params</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"BIND MESSAGE STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * exec_execute_message
 *
 * Process an "Execute" message for a portal
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_execute_message</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portal_name</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>max_rows</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CommandDest</name></type> <name>dest</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>receiver</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Portal</name></type>        <name>portal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>completed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>completionTag</name><index>[<expr><name>COMPLETION_TAG_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourceText</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prepStmtName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParamListInfo</name></type> <name>portalParams</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>save_log_statement_stats</name> <init>= <expr><name>log_statement_stats</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_xact_command</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>execute_is_fetch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>was_logged</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>instrument</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>

    <comment type="block">/* Adjust destination to tell printtup.c what to do */</comment>
    <expr_stmt><expr><name>dest</name> <operator>=</operator> <name>whereToSendOutput</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dest</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>dest</name> <operator>=</operator> <name>DestRemoteExecute</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>GetPortalByName</name><argument_list>(<argument><expr><name>portal_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_CURSOR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"portal \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>portal_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If the original query was a null string, just return
     * EmptyQueryResponse.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NullCommand</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Does the portal contain a transaction command? */</comment>
    <expr_stmt><expr><name>is_xact_command</name> <operator>=</operator> <call><name>IsTransactionStmtList</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We must copy the sourceText and prepStmtName into MessageContext in
     * case the portal is destroyed during finish_xact_command. Can avoid the
     * copy if it's not an xact command, though.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_xact_command</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>sourceText</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>sourceText</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>prepStmtName</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>prepStmtName</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>prepStmtName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>prepStmtName</name> <operator>=</operator> <literal type="string">"&lt;unnamed&gt;"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * An xact command shouldn't have any parameters, which is a good
         * thing because they wouldn't be around after finish_xact_command.
         */</comment>
        <expr_stmt><expr><name>portalParams</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>sourceText</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>sourceText</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>prepStmtName</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>prepStmtName</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>prepStmtName</name></name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>prepStmtName</name> <operator>=</operator> <literal type="string">"&lt;unnamed&gt;"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>portalParams</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>portalParams</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Report query to various monitoring facilities.
     */</comment>
    <expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>sourceText</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>is_mls_user</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <call><name>mls_query_string_prune</name><argument_list>(<argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>BeginCommand</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create dest receiver in MessageContext (we don't want it in transaction
     * context, because that may get deleted if portal contains VACUUM).
     */</comment>
    <expr_stmt><expr><name>receiver</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dest</name> <operator>==</operator> <name>DestRemoteExecute</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SetRemoteDestReceiverParams</name><argument_list>(<argument><expr><name>receiver</name></expr></argument>, <argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Ensure we are in a transaction command (this should normally be the
     * case already due to prior BIND).
     */</comment>
    <expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we re-issue an Execute protocol request against an existing portal,
     * then we are only fetching more rows rather than completely re-executing
     * the query from the start. atStart is never reset for a v3 portal, so we
     * are safe to use this check.
     */</comment>
    <expr_stmt><expr><name>execute_is_fetch</name> <operator>=</operator> <operator>!</operator><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name></expr>;</expr_stmt>

    <comment type="block">/* Log immediately if dictated by log_statement */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>check_log_statement</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s %s%s%s: %s"</literal></expr></argument>,
                        <argument><expr><ternary><condition><expr><name>execute_is_fetch</name></expr> ?</condition><then>
                        <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"execute fetch from"</literal></expr></argument>)</argument_list></call></expr> </then><else>:
                        <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"execute"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
                        <argument><expr><name>prepStmtName</name></expr></argument>,
                        <argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><literal type="string">"/"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                        <argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><name>portal_name</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>                        
                        <argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call><operator>,</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                        
                 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail_params</name><argument_list>(<argument><expr><name>portalParams</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>was_logged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If we are in aborted transaction state, the only portals we can
     * actually run are those containing COMMIT or ROLLBACK commands.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>IsTransactionExitStmtList</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"current transaction is aborted, "</literal>
                        <literal type="string">"commands ignored until end of transaction block"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail_abort</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check for cancel signal before we start execution */</comment>
    <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>xact_started</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type> <name>parse_tree</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>query_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><call><name>PortalGetQueryInfo</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parse_tree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>query_string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>true</name> <operator>&amp;&amp;</operator> <name>parse_tree</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>query_string</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>AuditReadQueryList</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>parse_tree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Okay to run the portal.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>max_rows</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>max_rows</name> <operator>=</operator> <name>FETCH_ALL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>completed</name> <operator>=</operator> <call><name>PortalRun</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
                          <argument><expr><name>max_rows</name></expr></argument>,
                          <argument><expr><name>true</name></expr></argument>, <comment type="block">/* always top level */</comment>
                          <argument><expr><operator>!</operator><name>execute_is_fetch</name> <operator>&amp;&amp;</operator> <name>max_rows</name> <operator>==</operator> <name>FETCH_ALL</name></expr></argument>,
                          <argument><expr><name>receiver</name></expr></argument>,
                          <argument><expr><name>receiver</name></expr></argument>,
                          <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call>(<modifier>*</modifier><name><name>receiver</name><operator>-&gt;</operator><name>rDestroy</name></name>) <argument_list>(<argument><expr><name>receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>cplan</name></name> <operator>&amp;&amp;</operator> <name><name>portal</name><operator>-&gt;</operator><name>cplan</name><operator>-&gt;</operator><name>stmt_list_backup</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>cplan</name><operator>-&gt;</operator><name>stmt_list</name></name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>cplan</name><operator>-&gt;</operator><name>stmt_list_backup</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>cplan</name><operator>-&gt;</operator><name>stmt_list_backup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>PortalGetQueryDesc</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>instrument</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>up_instrument</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>xact_started</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>AuditProcessResultInfo</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>completed</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>is_xact_command</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If this was a transaction control statement, commit it.  We
             * will start a new xact command for the next command (if any).
             */</comment>
            <expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * We need a CommandCounterIncrement after every query, except
             * those that start or end a transaction block.
             */</comment>
            <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>instrument</name> <operator>&amp;&amp;</operator>
		    <name>desc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		    <name><name>desc</name><operator>-&gt;</operator><name>myindex</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SendLocalInstr</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Send appropriate CommandComplete to client */</comment>
        <expr_stmt><expr><call><name>EndCommand</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"pid %d EndCommand"</literal></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Portal run not complete, so send PortalSuspended */</comment>
        <if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'s'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Emit duration logging if appropriate.
     */</comment>
    <switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>was_logged</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="number">1</literal></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms"</literal></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="number">2</literal></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms  %s %s%s%s: %s"</literal></expr></argument>,
                            <argument><expr><name>msec_str</name></expr></argument>,
                            <argument><expr><ternary><condition><expr><name>execute_is_fetch</name></expr> ?</condition><then>
                            <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"execute fetch from"</literal></expr></argument>)</argument_list></call></expr> </then><else>:
                            <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"execute"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
                            <argument><expr><name>prepStmtName</name></expr></argument>,
                            <argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><literal type="string">"/"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                            <argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><name>portal_name</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                            <argument><expr><name>sourceText</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail_params</name><argument_list>(<argument><expr><name>portalParams</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"EXECUTE MESSAGE STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check_log_statement
 *        Determine whether command should be logged because of log_statement
 *
 * stmt_list can be either raw grammar output or a list of planned
 * statements
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_log_statement</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmt_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>stmt_item</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_statement</name> <operator>==</operator> <name>LOGSTMT_NONE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>log_statement</name> <operator>==</operator> <name>LOGSTMT_ALL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Else we have to inspect the statement(s) to see whether to log */</comment>
    <macro><name>foreach</name><argument_list>(<argument>stmt_item</argument>, <argument>stmt_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>stmt_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>log_statement</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check_log_duration
 *        Determine whether current command's duration should be logged
 *
 * Returns:
 *        0 if no logging is needed
 *        1 if just the duration should be logged
 *        2 if duration and query details should be logged
 *
 * If logging is needed, the duration in msec is formatted into msec_str[],
 * which must be a 32-byte buffer.
 *
 * was_logged should be TRUE if caller already logged query details (this
 * essentially prevents 2 from being returned).
 */</comment>
<function><type><name>int</name></type>
<name>check_log_duration</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>msec_str</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>was_logged</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>log_duration</name> <operator>||</operator> <name>log_min_duration_statement</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type>        <name>secs</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>usecs</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>msecs</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>exceeded</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Since GetCurrentTimestamp() returns OS time, use local time for
         * statement-start for accurate comparison
         */</comment>
        <expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><call><name>GetCurrentLocalStatementStartTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
                            <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>msecs</name> <operator>=</operator> <name>usecs</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

        <comment type="block">/*
         * This odd-looking test for log_min_duration_statement being exceeded
         * is designed to avoid integer overflow with very long durations:
         * don't compute secs * 1000 until we've verified it will fit in int.
         */</comment>
        <expr_stmt><expr><name>exceeded</name> <operator>=</operator> <operator>(</operator><name>log_min_duration_statement</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                    <operator>(</operator><name>log_min_duration_statement</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                     <operator>(</operator><name>secs</name> <operator>&gt;</operator> <name>log_min_duration_statement</name> <operator>/</operator> <literal type="number">1000</literal> <operator>||</operator>
                      <name>secs</name> <operator>*</operator> <literal type="number">1000</literal> <operator>+</operator> <name>msecs</name> <operator>&gt;=</operator> <name>log_min_duration_statement</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>exceeded</name> <operator>||</operator> <name>log_duration</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="string">"%ld.%03d"</literal></expr></argument>,
                     <argument><expr><name>secs</name> <operator>*</operator> <literal type="number">1000</literal> <operator>+</operator> <name>msecs</name></expr></argument>, <argument><expr><name>usecs</name> <operator>%</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>exceeded</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>was_logged</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * errdetail_execute
 *
 * Add an errdetail() line showing the query referenced by an EXECUTE, if any.
 * The argument is the raw parsetree list.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>errdetail_execute</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>raw_parsetree_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>parsetree_item</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>parsetree_item</argument>, <argument>raw_parsetree_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>parsetree_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>, <argument><expr><name>ExecuteStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ExecuteStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ExecuteStmt</name> <operator>*</operator><operator>)</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>pstmt</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>pstmt</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"prepare: %s"</literal></expr></argument>, <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="number">0</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * errdetail_params
 *
 * Add an errdetail() line showing bind-parameter data, if available.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>errdetail_params</name><parameter_list>(<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* We mustn't call user-defined I/O functions when in an aborted xact */</comment>
    <if_stmt><if>if <condition>(<expr><name>params</name> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>numParams</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>StringInfoData</name></type> <name>param_str</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>paramno</name></decl>;</decl_stmt>

        <comment type="block">/* Make sure any trash is generated in MessageContext */</comment>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>paramno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>paramno</name> <operator>&lt;</operator> <name><name>params</name><operator>-&gt;</operator><name>numParams</name></name></expr>;</condition> <incr><expr><name>paramno</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>paramno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>typoutput</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>typisvarlena</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>pstring</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param_str</name></expr></argument>, <argument><expr><literal type="string">"%s$%d = "</literal></expr></argument>,
                             <argument><expr><ternary><condition><expr><name>paramno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                             <argument><expr><name>paramno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param_str</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>pstring</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typoutput</name></expr></argument>, <argument><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param_str</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>pstring</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* double single quotes */</comment>
                    <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param_str</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param_str</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param_str</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"parameters: %s"</literal></expr></argument>, <argument><expr><name><name>param_str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>param_str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * errdetail_abort
 *
 * Add an errdetail() line showing abort reason, if any.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>errdetail_abort</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>MyProc</name><operator>-&gt;</operator><name>recoveryConflictPending</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"abort reason: recovery conflict"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * errdetail_recovery_conflict
 *
 * Add an errdetail() line showing conflict source.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>errdetail_recovery_conflict</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name>RecoveryConflictReason</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_BUFFERPIN</name></expr>:</case>
            <expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"User was holding shared buffer pin for too long."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_LOCK</name></expr>:</case>
            <expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"User was holding a relation lock for too long."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_TABLESPACE</name></expr>:</case>
            <expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"User was or might have been using tablespace that must be dropped."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_SNAPSHOT</name></expr>:</case>
            <expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"User query might have needed to see row versions that must be removed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK</name></expr>:</case>
            <expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"User transaction caused buffer deadlock with recovery."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_DATABASE</name></expr>:</case>
            <expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"User was connected to a database that must be dropped."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <break>break;</break>
            <comment type="block">/* no errdetail */</comment>
    </block_content>}</block></switch>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * exec_describe_statement_message
 *
 * Process a "Describe" message for a prepared statement
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_describe_statement_message</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>psrc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Start up a transaction command. (Note that this will normally change
     * current memory context.) Nothing happens if we are already in one.
     */</comment>
    <expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Switch back to message context */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Find prepared statement */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>pstmt</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>psrc</name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>plansource</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* special-case the unnamed statement */</comment>
        <expr_stmt><expr><name>psrc</name> <operator>=</operator> <name>unnamed_stmt_psrc</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>psrc</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_PSTATEMENT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unnamed prepared statement does not exist"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Prepared statements shouldn't have changeable result descs */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>fixed_result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we are in aborted transaction state, we can't run
     * SendRowDescriptionMessage(), because that needs catalog accesses.
     * Hence, refuse to Describe statements that return data.  (We shouldn't
     * just refuse all Describes, since that might break the ability of some
     * clients to issue COMMIT or ROLLBACK commands, if they use code that
     * blindly Describes whatever it does.)  We can Describe parameters
     * without doing anything dangerous, so we don't restrict that.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
        <name><name>psrc</name><operator>-&gt;</operator><name>resultDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"current transaction is aborted, "</literal>
                        <literal type="string">"commands ignored until end of transaction block"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail_abort</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>!=</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>                    <comment type="block">/* can't actually do anything... */</comment>

    <comment type="block">/*
     * First describe the parameters...
     */</comment>
    <expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'t'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* parameter description message type */</comment>
    <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>num_params</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>psrc</name><operator>-&gt;</operator><name>num_params</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>ptype</name> <init>= <expr><name><name>psrc</name><operator>-&gt;</operator><name>param_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>ptype</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Next send RowDescription or NoData to describe the result...
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>psrc</name><operator>-&gt;</operator><name>resultDesc</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>

        <comment type="block">/* Get the plan's primary targetlist */</comment>
        <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>CachedPlanGetTargetList</name><argument_list>(<argument><expr><name>psrc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>SendRowDescriptionMessage</name><argument_list>(<argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>resultDesc</name></name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>    <comment type="block">/* NoData */</comment>

</block_content>}</block></function>

<comment type="block">/*
 * exec_describe_portal_message
 *
 * Process a "Describe" message for a portal
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_describe_portal_message</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portal_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Portal</name></type>        <name>portal</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Start up a transaction command. (Note that this will normally change
     * current memory context.) Nothing happens if we are already in one.
     */</comment>
    <expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Switch back to message context */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>GetPortalByName</name><argument_list>(<argument><expr><name>portal_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_CURSOR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"portal \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>portal_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If we are in aborted transaction state, we can't run
     * SendRowDescriptionMessage(), because that needs catalog accesses.
     * Hence, refuse to Describe portals that return data.  (We shouldn't just
     * refuse all Describes, since that might break the ability of some
     * clients to issue COMMIT or ROLLBACK commands, if they use code that
     * blindly Describes whatever it does.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
        <name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"current transaction is aborted, "</literal>
                        <literal type="string">"commands ignored until end of transaction block"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail_abort</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>!=</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>                    <comment type="block">/* can't actually do anything... */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SendRowDescriptionMessage</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>,
                                  <argument><expr><call><name>FetchPortalTargetList</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>formats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>    <comment type="block">/* NoData */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * Convenience routines for starting/committing a single command.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>start_xact_command</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>xact_started</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Set statement timeout running, if any */</comment>
        <comment type="block">/* NB: this mustn't be enabled until we are within an xact */</comment>
        <if_stmt><if>if <condition>(<expr><name>StatementTimeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>enable_timeout_after</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>, <argument><expr><name>StatementTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>disable_timeout</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>xact_started</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>finish_xact_command</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>xact_started</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"finish xact"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Cancel any active statement timeout before committing */</comment>
        <expr_stmt><expr><call><name>disable_timeout</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MEMORY_CONTEXT_CHECKING</name></cpp:ifdef>
        <comment type="block">/* Check all memory contexts that weren't freed during commit */</comment>
        <comment type="block">/* (those that were, were checked before being deleted) */</comment>
        <expr_stmt><expr><call><name>MemoryContextCheck</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHOW_MEMORY_STATS</name></cpp:ifdef>
        <comment type="block">/* Print mem stats after each commit for leak tracking */</comment>
        <expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><name>xact_started</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><name>is_txn_has_parallel_ddl</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Convenience routines for checking whether a statement is one of the
 * ones that we allow in transaction-aborted state.
 */</comment>

<comment type="block">/* Test a bare parsetree */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsTransactionExitStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>parsetree</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>TransactionStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TransactionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>TransactionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>TRANS_STMT_COMMIT</name> <operator>||</operator>
            <name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>TRANS_STMT_PREPARE</name> <operator>||</operator>
            <name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>TRANS_STMT_ROLLBACK</name> <operator>||</operator>
            <name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>TRANS_STMT_ROLLBACK_TO</name> <operator>||</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>TRANS_STMT_ROLLBACK_SUBTXN</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            )</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Test a list that contains PlannedStmt nodes */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsTransactionExitStmtList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pstmts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>pstmts</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>pstmts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name> <operator>&amp;&amp;</operator>
            <call><name>IsTransactionExitStmt</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Test a list that contains PlannedStmt nodes */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsTransactionStmtList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pstmts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>pstmts</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>pstmts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name> <operator>&amp;&amp;</operator>
            <call><name>IsA</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>TransactionStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Release any existing unnamed prepared statement */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>drop_unnamed_stmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* paranoia to avoid a dangling pointer in case of error */</comment>
    <if_stmt><if>if <condition>(<expr><name>unnamed_stmt_psrc</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>psrc</name> <init>= <expr><name>unnamed_stmt_psrc</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>unnamed_stmt_psrc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DropCachedPlan</name><argument_list>(<argument><expr><name>psrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* --------------------------------
 *        signal handler routines used in PostgresMain()
 * --------------------------------
 */</comment>

<comment type="block">/*
 * quickdie() occurs when signalled SIGQUIT by the postmaster.
 *
 * Some backend has bought the farm,
 * so we need to stop what we're doing and exit.
 */</comment>
<function><type><name>void</name></type>
<name>quickdie</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>, <argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* prevent nested calls */</comment>
    <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Prevent interrupts while exiting; though we just blocked signals that
     * would queue new interrupts, one may have been pending.  We don't want a
     * quickdie() downgraded to a mere query cancel.
     */</comment>
    <expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>SqueueProducerExit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If we're aborting out of client auth, don't risk trying to send
     * anything to the client; we will likely violate the protocol, not to
     * mention that we may have interrupted the guts of OpenSSL or some
     * authentication library.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>ClientAuthInProgress</name> <operator>&amp;&amp;</operator> <name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Ideally this should be ereport(FATAL), but then we'd not get control
     * back...
     */</comment>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CRASH_SHUTDOWN</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating connection because of crash of another server process"</literal></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The postmaster has commanded this server process to roll back"</literal>
                       <literal type="string">" the current transaction and exit, because another"</literal>
                       <literal type="string">" server process exited abnormally and possibly corrupted"</literal>
                       <literal type="string">" shared memory."</literal></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"In a moment you should be able to reconnect to the"</literal>
                     <literal type="string">" database and repeat your command."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We DO NOT want to run proc_exit() callbacks -- we're here because
     * shared memory may be corrupted, so we don't want to try to clean up our
     * transaction.  Just nail the windows shut and get out of town.  Now that
     * there's an atexit callback to prevent third-party code from breaking
     * things by calling exit() directly, we have to reset the callbacks
     * explicitly to make this work as intended.
     */</comment>
    <expr_stmt><expr><call><name>on_exit_reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Note we do exit(2) not exit(0).  This is to force the postmaster into a
     * system reset cycle if some idiot DBA sends a manual SIGQUIT to a random
     * backend.  This is necessary precisely because we don't clean up our
     * shared memory state.  (The "dead man switch" mechanism in pmsignal.c
     * should ensure the postmaster sees this as a crash, too, but no harm in
     * being doubly sure.)
     */</comment>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Shutdown signal from postmaster: abort transaction and exit
 * at soonest convenient time
 */</comment>
<function><type><name>void</name></type>
<name>die</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Don't joggle the elbow of proc_exit */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>proc_exit_inprogress</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ProcDiePending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/* release cluster lock if holding it */</comment>
    <if_stmt><if>if <condition>(<expr><name>cluster_ex_lock_held</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ReleaseClusterLock</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* If we're still here, waken anything waiting on the process latch */</comment>
    <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we're in single user mode, we want to quit immediately - we can't
     * rely on latches as they wouldn't work when stdin/stdout is a file.
     * Rather ugly, but it's unlikely to be worthwhile to invest much more
     * effort just for the benefit of single user mode.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>DoingCommandRead</name> <operator>&amp;&amp;</operator> <name>whereToSendOutput</name> <operator>!=</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ProcessInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Query-cancel signal from postmaster: abort current transaction
 * at soonest convenient time
 */</comment>
<function><type><name>void</name></type>
<name>StatementCancelHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Don't joggle the elbow of proc_exit
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>proc_exit_inprogress</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If we're still here, waken anything waiting on the process latch */</comment>
    <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>IsSqueueConsumer</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsSqueueProducer</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SetSqueueError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* signal handler for floating point exception */</comment>
<function><type><name>void</name></type>
<name>FloatExceptionHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* We're not returning, so no need to save errno */</comment>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FLOATING_POINT_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"floating-point exception"</literal></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"An invalid floating-point operation was signaled. "</literal>
                       <literal type="string">"This probably means an out-of-range result or an "</literal>
                       <literal type="string">"invalid operation, such as division by zero."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SIGHUP: set flag to re-read config file at next convenient time.
 *
 * Sets the ConfigReloadPending flag, which should be checked at convenient
 * places inside main loops. (Better than doing the reading in the signal
 * handler, ey?)
 */</comment>
<function><type><name>void</name></type>
<name>PostgresSigHupHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>ConfigReloadPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RecoveryConflictInterrupt: out-of-line portion of recovery conflict
 * handling following receipt of SIGUSR1. Designed to be similar to die()
 * and StatementCancelHandler(). Called only by a normal user backend
 * that begins a transaction during recovery.
 */</comment>
<function><type><name>void</name></type>
<name>RecoveryConflictInterrupt</name><parameter_list>(<parameter><decl><type><name>ProcSignalReason</name></type> <name>reason</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Don't joggle the elbow of proc_exit
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>proc_exit_inprogress</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>RecoveryConflictReason</name> <operator>=</operator> <name>reason</name></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>reason</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK</name></expr>:</case>

                <comment type="block">/*
                 * If we aren't waiting for a lock we can never deadlock.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsWaitingForLock</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return;</return></block_content></block></if></if_stmt>

                <comment type="block">/* Intentional drop through to check wait for pin */</comment>

            <case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_BUFFERPIN</name></expr>:</case>

                <comment type="block">/*
                 * If we aren't blocking the Startup process there is nothing
                 * more to do.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HoldingBufferPinThatDelaysRecovery</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return;</return></block_content></block></if></if_stmt>

                <expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>recoveryConflictPending</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                <comment type="block">/* Intentional drop through to error handling */</comment>

            <case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_LOCK</name></expr>:</case>
            <case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_TABLESPACE</name></expr>:</case>
            <case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_SNAPSHOT</name></expr>:</case>

                <comment type="block">/*
                 * If we aren't in a transaction any longer then ignore.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTransactionOrTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return;</return></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * If we can abort just the current subtransaction then we are
                 * OK to throw an ERROR to resolve the conflict. Otherwise
                 * drop through to the FATAL case.
                 *
                 * XXX other times that we can throw just an ERROR *may* be
                 * PROCSIG_RECOVERY_CONFLICT_LOCK if no locks are held in
                 * parent transactions
                 *
                 * PROCSIG_RECOVERY_CONFLICT_SNAPSHOT if no snapshots are held
                 * by parent transactions and the transaction is not
                 * transaction-snapshot mode
                 *
                 * PROCSIG_RECOVERY_CONFLICT_TABLESPACE if no temp files or
                 * cursors open in parent transactions
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSubTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * If we already aborted then we no longer need to cancel.
                     * We do this here since we do not wish to ignore aborted
                     * subtransactions, which must cause FATAL, currently.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return;</return></block_content></block></if></if_stmt>

                    <expr_stmt><expr><name>RecoveryConflictPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* Intentional drop through to session cancel */</comment>

            <case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_DATABASE</name></expr>:</case>
                <expr_stmt><expr><name>RecoveryConflictPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>ProcDiePending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"unrecognized conflict mode: %d"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>RecoveryConflictPending</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>QueryCancelPending</name> <operator>||</operator> <name>ProcDiePending</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * All conflicts apart from database cause dynamic errors where the
         * command or transaction can be retried at a later point with some
         * potential for success. No need to reset this, since non-retryable
         * conflict errors are currently FATAL.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>reason</name> <operator>==</operator> <name>PROCSIG_RECOVERY_CONFLICT_DATABASE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>RecoveryConflictRetryable</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Set the process latch. This function essentially emulates signal
     * handlers like die() and StatementCancelHandler() and it seems prudent
     * to behave similarly as they do.
     */</comment>
    <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ProcessInterrupts: out-of-line portion of CHECK_FOR_INTERRUPTS() macro
 *
 * If an interrupt condition is pending, and it's safe to service it,
 * then clear the flag and accept the interrupt.  Called only when
 * InterruptPending is true.
 */</comment>
<function><type><name>void</name></type>
<name>ProcessInterrupts</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* OK to accept any interrupts now? */</comment>
    <if_stmt><if>if <condition>(<expr><name>InterruptHoldoffCount</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>CritSectionCount</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>ProcDiePending</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ProcDiePending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* ProcDie trumps QueryCancel */</comment>
        <expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* As in quickdie, don't risk sending to client during auth */</comment>
        <if_stmt><if>if <condition>(<expr><name>ClientAuthInProgress</name> <operator>&amp;&amp;</operator> <name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>ClientAuthInProgress</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_QUERY_CANCELED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling authentication due to timeout"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ADMIN_SHUTDOWN</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating autovacuum process due to administrator command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>IsLogicalWorker</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ADMIN_SHUTDOWN</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating logical replication worker due to administrator command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>IsLogicalLauncher</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical replication launcher shutting down"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * The logical replication launcher can be stopped at any time.
             * Use exit status 1 so the background worker is restarted.
             */</comment>
            <expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>RecoveryConflictPending</name> <operator>&amp;&amp;</operator> <name>RecoveryConflictRetryable</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pgstat_report_recovery_conflict</name><argument_list>(<argument><expr><name>RecoveryConflictReason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating connection due to conflict with recovery"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail_recovery_conflict</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>RecoveryConflictPending</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Currently there is only one non-retryable recovery conflict */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>RecoveryConflictReason</name> <operator>==</operator> <name>PROCSIG_RECOVERY_CONFLICT_DATABASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pgstat_report_recovery_conflict</name><argument_list>(<argument><expr><name>RecoveryConflictReason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATABASE_DROPPED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating connection due to conflict with recovery"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail_recovery_conflict</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ADMIN_SHUTDOWN</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating connection due to administrator command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>ClientConnectionLost</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* lost connection trumps QueryCancel */</comment>
        <expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* don't send to client, we already know the connection to be dead. */</comment>
        <expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection to client lost"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If a recovery conflict happens while we are waiting for input from the
     * client, the client is presumably just sitting idle in a transaction,
     * preventing recovery from making progress.  Terminate the connection to
     * dislodge it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>RecoveryConflictPending</name> <operator>&amp;&amp;</operator> <name>DoingCommandRead</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* this trumps QueryCancel */</comment>
        <expr_stmt><expr><name>RecoveryConflictPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pgstat_report_recovery_conflict</name><argument_list>(<argument><expr><name>RecoveryConflictReason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating connection due to conflict with recovery"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail_recovery_conflict</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"In a moment you should be able to reconnect to the"</literal>
                         <literal type="string">" database and repeat your command."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>QueryCancelPending</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>        <name>lock_timeout_occurred</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>stmt_timeout_occurred</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Don't allow query cancel interrupts while reading input from the
         * client, because we might lose sync in the FE/BE protocol.  (Die
         * interrupts are OK, because we won't read any further messages from
         * the client in that case.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>QueryCancelHoldoffCount</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Re-arm InterruptPending so that we process the cancel request
             * as soon as we're done reading the message.
             */</comment>
            <expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <comment type="block">/*
         * If LOCK_TIMEOUT and STATEMENT_TIMEOUT indicators are both set, we
         * need to clear both, so always fetch both.
         */</comment>
        <expr_stmt><expr><name>lock_timeout_occurred</name> <operator>=</operator> <call><name>get_timeout_indicator</name><argument_list>(<argument><expr><name>LOCK_TIMEOUT</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>stmt_timeout_occurred</name> <operator>=</operator> <call><name>get_timeout_indicator</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If both were set, we want to report whichever timeout completed
         * earlier; this ensures consistent behavior if the machine is slow
         * enough that the second timeout triggers before we get here.  A tie
         * is arbitrarily broken in favor of reporting a lock timeout.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>lock_timeout_occurred</name> <operator>&amp;&amp;</operator> <name>stmt_timeout_occurred</name> <operator>&amp;&amp;</operator>
            <call><name>get_timeout_finish_time</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>get_timeout_finish_time</name><argument_list>(<argument><expr><name>LOCK_TIMEOUT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>lock_timeout_occurred</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* report stmt timeout */</comment>

        <if_stmt><if>if <condition>(<expr><name>lock_timeout_occurred</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_NOT_AVAILABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling statement due to lock timeout"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>stmt_timeout_occurred</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_QUERY_CANCELED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling statement due to statement timeout"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_QUERY_CANCELED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling autovacuum task"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>RecoveryConflictPending</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>RecoveryConflictPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pgstat_report_recovery_conflict</name><argument_list>(<argument><expr><name>RecoveryConflictReason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling statement due to conflict with recovery"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail_recovery_conflict</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If we are reading a command from the client, just ignore the cancel
         * request --- sending an extra error message won't accomplish
         * anything.  Otherwise, go ahead and throw the error.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>DoingCommandRead</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_QUERY_CANCELED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling statement due to user request"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>IdleInTransactionSessionTimeoutPending</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Has the timeout setting changed since last we looked? */</comment>
        <if_stmt><if>if <condition>(<expr><name>IdleInTransactionSessionTimeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IDLE_IN_TRANSACTION_SESSION_TIMEOUT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating connection due to idle-in-transaction timeout"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>IdleInTransactionSessionTimeoutPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>ParallelMessagePending</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>HandleParallelMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PoolerMessagesPending</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>HandlePoolerMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>IsQueryCancelPending</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>QueryCancelPending</name> <operator>&amp;&amp;</operator> <name>InterruptPending</name> <operator>&amp;&amp;</operator> 
        <operator>!</operator><name>ProcDiePending</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>ClientConnectionLost</name> <operator>&amp;&amp;</operator>
        <operator>!</operator><operator>(</operator><name>RecoveryConflictPending</name> <operator>&amp;&amp;</operator> <name>DoingCommandRead</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IA64-specific code to fetch the AR.BSP register for stack depth checks.
 *
 * We currently support gcc, icc, and HP-UX's native compiler here.
 *
 * Note: while icc accepts gcc asm blocks on x86[_64], this is not true on
 * ia64 (at least not in icc versions before 12.x).  So we have to carry a
 * separate implementation for it.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ia64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ia64</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__hpux</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__INTEL_COMPILER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Assume it's HP-UX native compiler */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ia64/sys/inline.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ia64_get_bsp</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>((char *) (_Asm_mov_from_ar(_AREG_BSP, _NO_FENCE)))</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__INTEL_COMPILER</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<comment type="block">/* icc */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;asm/ia64regs.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ia64_get_bsp</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>((char *) __getReg(_IA64_REG_AR_BSP))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* gcc */</comment>
<function><type><specifier>static</specifier> <name>__inline__</name> <name>char</name> <modifier>*</modifier></type>
<name>ia64_get_bsp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

    <comment type="block">/* the ;; is a "stop", seems to be required before fetching BSP */</comment>
    <asm>__asm__ <specifier>__volatile__</specifier>(
                         ";;\n"
                         "    mov    %0=ar.bsp    \n"
:                         "=r"(ret));</asm>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* IA64 */</comment>


<comment type="block">/*
 * set_stack_base: set up reference point for stack depth checking
 *
 * Returns the old reference point, if any.
 */</comment>
<function><type><name>pg_stack_base_t</name></type>
<name>set_stack_base</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name>stack_base</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_stack_base_t</name></type> <name>old</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ia64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ia64</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><name><name>old</name><operator>.</operator><name>stack_base_ptr</name></name> <operator>=</operator> <name>stack_base_ptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>old</name><operator>.</operator><name>register_stack_base_ptr</name></name> <operator>=</operator> <name>register_stack_base_ptr</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>old</name> <operator>=</operator> <name>stack_base_ptr</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Set up reference point for stack depth checking */</comment>
    <expr_stmt><expr><name>stack_base_ptr</name> <operator>=</operator> <operator>&amp;</operator><name>stack_base</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ia64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ia64</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><name>register_stack_base_ptr</name> <operator>=</operator> <call><name>ia64_get_bsp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>old</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * restore_stack_base: restore reference point for stack depth checking
 *
 * This can be used after set_stack_base() to restore the old value. This
 * is currently only used in PL/Java. When PL/Java calls a backend function
 * from different thread, the thread's stack is at a different location than
 * the main thread's stack, so it sets the base pointer before the call, and
 * restores it afterwards.
 */</comment>
<function><type><name>void</name></type>
<name>restore_stack_base</name><parameter_list>(<parameter><decl><type><name>pg_stack_base_t</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ia64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ia64</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><name>stack_base_ptr</name> <operator>=</operator> <name><name>base</name><operator>.</operator><name>stack_base_ptr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>register_stack_base_ptr</name> <operator>=</operator> <name><name>base</name><operator>.</operator><name>register_stack_base_ptr</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>stack_base_ptr</name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * check_stack_depth/stack_is_too_deep: check for excessively deep recursion
 *
 * This should be called someplace in any recursive routine that might possibly
 * recurse deep enough to overflow the stack.  Most Unixen treat stack
 * overflow as an unrecoverable SIGSEGV, so we want to error out ourselves
 * before hitting the hardware limit.
 *
 * check_stack_depth() just throws an error summarily.  stack_is_too_deep()
 * can be used by code that wants to handle the error condition itself.
 */</comment>
<function><type><name>void</name></type>
<name>check_stack_depth</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>stack_is_too_deep</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STATEMENT_TOO_COMPLEX</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"stack depth limit exceeded"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Increase the configuration parameter \"max_stack_depth\" (currently %dkB), "</literal>
                         <literal type="string">"after ensuring the platform's stack depth limit is adequate."</literal></expr></argument>,
                         <argument><expr><name>max_stack_depth</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>stack_is_too_deep</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name>stack_top_loc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>stack_depth</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Compute distance from reference point to my local variables
     */</comment>
    <expr_stmt><expr><name>stack_depth</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name>stack_base_ptr</name> <operator>-</operator> <operator>&amp;</operator><name>stack_top_loc</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/*
     * Take abs value, since stacks grow up on some machines, down on others
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>stack_depth</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>stack_depth</name> <operator>=</operator> <operator>-</operator><name>stack_depth</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Trouble?
     *
     * The test on stack_base_ptr prevents us from erroring out if called
     * during process setup or in a non-backend process.  Logically it should
     * be done first, but putting it here avoids wasting cycles during normal
     * cases.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>stack_depth</name> <operator>&gt;</operator> <name>max_stack_depth_bytes</name> <operator>&amp;&amp;</operator>
        <name>stack_base_ptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * On IA64 there is a separate "register" stack that requires its own
     * independent check.  For this, we have to measure the change in the
     * "BSP" pointer from PostgresMain to here.  Logic is just as above,
     * except that we know IA64's register stack grows up.
     *
     * Note we assume that the same max_stack_depth applies to both stacks.
     */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ia64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ia64</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><name>stack_depth</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><call><name>ia64_get_bsp</name><argument_list>()</argument_list></call> <operator>-</operator> <name>register_stack_base_ptr</name><operator>)</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>stack_depth</name> <operator>&gt;</operator> <name>max_stack_depth_bytes</name> <operator>&amp;&amp;</operator>
        <name>register_stack_base_ptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* IA64 */</comment>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* GUC check hook for max_stack_depth */</comment>
<function><type><name>bool</name></type>
<name>check_max_stack_depth</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>long</name></type>        <name>newval_bytes</name> <init>= <expr><operator>*</operator><name>newval</name> <operator>*</operator> <literal type="number">1024L</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>stack_rlimit</name> <init>= <expr><call><name>get_stack_depth_rlimit</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>stack_rlimit</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>newval_bytes</name> <operator>&gt;</operator> <name>stack_rlimit</name> <operator>-</operator> <name>STACK_DEPTH_SLOP</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"\"max_stack_depth\" must not exceed %ldkB."</literal></expr></argument>,
                            <argument><expr><operator>(</operator><name>stack_rlimit</name> <operator>-</operator> <name>STACK_DEPTH_SLOP</name><operator>)</operator> <operator>/</operator> <literal type="number">1024L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GUC_check_errhint</name><argument_list>(<argument><expr><literal type="string">"Increase the platform's stack depth limit via \"ulimit -s\" or local equivalent."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* GUC assign hook for max_stack_depth */</comment>
<function><type><name>void</name></type>
<name>assign_max_stack_depth</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>long</name></type>        <name>newval_bytes</name> <init>= <expr><name>newval</name> <operator>*</operator> <literal type="number">1024L</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>max_stack_depth_bytes</name> <operator>=</operator> <name>newval_bytes</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * set_debug_options --- apply "-d N" command line option
 *
 * -d is not quite the same as setting log_min_messages because it enables
 * other output options.
 */</comment>
<function><type><name>void</name></type>
<name>set_debug_options</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>debug_flag</name></decl></parameter>, <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>debug_flag</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>debugstr</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>debugstr</name></expr></argument>, <argument><expr><literal type="string">"debug%d"</literal></expr></argument>, <argument><expr><name>debug_flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_min_messages"</literal></expr></argument>, <argument><expr><name>debugstr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_min_messages"</literal></expr></argument>, <argument><expr><literal type="string">"notice"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>debug_flag</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>context</name> <operator>==</operator> <name>PGC_POSTMASTER</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_connections"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_disconnections"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>debug_flag</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_statement"</literal></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>debug_flag</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"debug_print_parse"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>debug_flag</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"debug_print_plan"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>debug_flag</name> <operator>&gt;=</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"debug_print_rewritten"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>bool</name></type>
<name>set_plan_disabling_options</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="char">'s'</literal></expr>:</case>                <comment type="block">/* seqscan */</comment>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_seqscan"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'i'</literal></expr>:</case>                <comment type="block">/* indexscan */</comment>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_indexscan"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'o'</literal></expr>:</case>                <comment type="block">/* indexonlyscan */</comment>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_indexonlyscan"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'b'</literal></expr>:</case>                <comment type="block">/* bitmapscan */</comment>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_bitmapscan"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'t'</literal></expr>:</case>                <comment type="block">/* tidscan */</comment>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_tidscan"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'n'</literal></expr>:</case>                <comment type="block">/* nestloop */</comment>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_nestloop"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'m'</literal></expr>:</case>                <comment type="block">/* mergejoin */</comment>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_mergejoin"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'h'</literal></expr>:</case>                <comment type="block">/* hashjoin */</comment>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_hashjoin"</literal></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
    <if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_stats_option_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="char">'p'</literal></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>optarg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* "parser" */</comment>
                <return>return <expr><literal type="string">"log_parser_stats"</literal></expr>;</return></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>optarg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'l'</literal></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* "planner" */</comment>
                <return>return <expr><literal type="string">"log_planner_stats"</literal></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><literal type="char">'e'</literal></expr>:</case>                <comment type="block">/* "executor" */</comment>
            <return>return <expr><literal type="string">"log_executor_stats"</literal></expr>;</return>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 * process_postgres_switches
 *       Parse command line arguments for PostgresMain
 *
 * This is called twice, once for the "secure" options coming from the
 * postmaster or command line, and once for the "insecure" options coming
 * from the client's startup packet.  The latter have the same syntax but
 * may be restricted in what they can do.
 *
 * argv[0] is ignored in either case (it's assumed to be the program name).
 *
 * ctx is PGC_POSTMASTER for secure options, PGC_BACKEND for insecure options
 * coming from the client, or PGC_SU_BACKEND for insecure options coming from
 * a superuser client.
 *
 * If a database name is present in the command line arguments, it's
 * returned into *dbname (this is allowed only if *dbname is initially NULL).
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>process_postgres_switches</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>GucContext</name></type> <name>ctx</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>dbname</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>secure</name> <init>= <expr><operator>(</operator><name>ctx</name> <operator>==</operator> <name>PGC_POSTMASTER</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>errs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GucSource</name></type>    <name>gucsource</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>flag</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type>        <name>singleuser</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>secure</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>gucsource</name> <operator>=</operator> <name>PGC_S_ARGV</name></expr>;</expr_stmt> <comment type="block">/* switches came from command line */</comment>

        <comment type="block">/* Ignore the initial --single argument, if present */</comment>
        <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--single"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>argv</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>argc</name><operator>--</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
            <expr_stmt><expr><name>singleuser</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>gucsource</name> <operator>=</operator> <name>PGC_S_CLIENT</name></expr>;</expr_stmt>    <comment type="block">/* switches came from client */</comment>
    </block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT_OPTERR</name></cpp:ifdef>

    <comment type="block">/*
     * Turn this off because it's either printed to stderr and not the log
     * where we'd want it, or argv[0] is now "--single", which would make for
     * a weird error message.  We print our own error message below.
     */</comment>
    <expr_stmt><expr><name>opterr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Parse command-line options.  CAUTION: keep this in sync with
     * postmaster/postmaster.c (the option sets should not conflict) and with
     * the common help() function in main/main.c.
     */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>flag</name> <operator>=</operator> <call><name>getopt</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"B:bc:C:D:d:EeFf:h:ijk:lN:nOo:Pp:r:S:sTt:v:W:-:"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <switch>switch <condition>(<expr><name>flag</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'B'</literal></expr>:</case>
                <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"shared_buffers"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'b'</literal></expr>:</case>
                <comment type="block">/* Undocumented flag used for binary upgrades */</comment>
                <if_stmt><if>if <condition>(<expr><name>secure</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>IsBinaryUpgrade</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'C'</literal></expr>:</case>
                <comment type="block">/* ignored for consistency with the postmaster */</comment>
                <break>break;</break>

            <case>case <expr><literal type="char">'D'</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>secure</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>userDoption</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'d'</literal></expr>:</case>
                <expr_stmt><expr><call><name>set_debug_options</name><argument_list>(<argument><expr><call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'E'</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>secure</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>EchoQuery</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'e'</literal></expr>:</case>
                <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"datestyle"</literal></expr></argument>, <argument><expr><literal type="string">"euro"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'F'</literal></expr>:</case>
                <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"fsync"</literal></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'f'</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>set_plan_disabling_options</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>errs</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'h'</literal></expr>:</case>
                <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"listen_addresses"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'i'</literal></expr>:</case>
                <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"listen_addresses"</literal></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'j'</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>secure</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>UseSemiNewlineNewline</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'k'</literal></expr>:</case>
                <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"unix_socket_directories"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'l'</literal></expr>:</case>
                <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"ssl"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'N'</literal></expr>:</case>
                <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"max_connections"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'n'</literal></expr>:</case>
                <comment type="block">/* ignored for consistency with postmaster */</comment>
                <break>break;</break>

            <case>case <expr><literal type="char">'O'</literal></expr>:</case>
                <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"allow_system_table_mods"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'o'</literal></expr>:</case>
                <expr_stmt><expr><name>errs</name><operator>++</operator></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'P'</literal></expr>:</case>
                <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"ignore_system_indexes"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'p'</literal></expr>:</case>
                <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"port"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'r'</literal></expr>:</case>
                <comment type="block">/* send output (stdout and stderr) to the given file */</comment>
                <if_stmt><if>if <condition>(<expr><name>secure</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>OutputFileName</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'S'</literal></expr>:</case>
                <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"work_mem"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'s'</literal></expr>:</case>
                <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_statement_stats"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'T'</literal></expr>:</case>
                <comment type="block">/* ignored for consistency with the postmaster */</comment>
                <break>break;</break>

            <case>case <expr><literal type="char">'t'</literal></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>get_stats_option_name</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>errs</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    <break>break;</break>
                </block_content>}</block>

            <case>case <expr><literal type="char">'v'</literal></expr>:</case>

                <comment type="block">/*
                 * -v is no longer used in normal operation, since
                 * FrontendProtocol is already set before we get here. We keep
                 * the switch only for possible use in standalone operation,
                 * in case we ever support using normal FE/BE protocol with a
                 * standalone backend.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>secure</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>FrontendProtocol</name> <operator>=</operator> <operator>(</operator><name>ProtocolVersion</name><operator>)</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'W'</literal></expr>:</case>
                <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"post_auth_delay"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'c'</literal></expr>:</case>
            <case>case <expr><literal type="char">'-'</literal></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>name</name></decl>,
                               <decl><type ref="prev"><modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>ParseLongOption</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
                    <comment type="block">/* A Coordinator is being activated */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"coordinator"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                        <operator>!</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>isPGXCCoordinator</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
                    <comment type="block">/* A Datanode is being activated */</comment>
                    <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"datanode"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                             <operator>!</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>isPGXCDataNode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
                    <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"localxid"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                             <operator>!</operator><name>value</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>singleuser</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"local xids can be used only in single user mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <expr_stmt><expr><name>useLocalXid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else <comment type="block">/* default case */</comment>
                    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>flag</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"--%s requires a value"</literal></expr></argument>,
                                            <argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"-c %s requires a value"</literal></expr></argument>,
                                            <argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
                    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <break>break;</break>
                </block_content>}</block>

            <default>default:</default>
                <expr_stmt><expr><name>errs</name><operator>++</operator></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><name>errs</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/*
     * Make sure we specified the mode if Coordinator or Datanode.
     * Allow for the exception of initdb by checking config option
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <name>IsUnderPostmaster</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Postgres-XL: must start as either a Coordinator (--coordinator) or Datanode (-datanode)\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsPostmasterEnvironment</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Treat it as a Datanode for initdb to work properly */</comment>
        <expr_stmt><expr><name>isPGXCDataNode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Optional database name should be there only if *dbname is NULL.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>errs</name> <operator>&amp;&amp;</operator> <name>dbname</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>dbname</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>argc</name> <operator>-</operator> <name>optind</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>dbname</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>errs</name> <operator>||</operator> <name>argc</name> <operator>!=</operator> <name>optind</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errs</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>optind</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>            <comment type="block">/* complain about the previous argument */</comment>

        <comment type="block">/* spell the error message a bit differently depending on context */</comment>
        <if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid command-line argument for server process: %s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information."</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: invalid command-line argument: %s"</literal></expr></argument>,
                            <argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information."</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Reset getopt(3) library so that it will work correctly in subprocesses
     * or when this function is called a second time with another array.
     */</comment>
    <expr_stmt><expr><name>optind</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT_OPTRESET</name></cpp:ifdef>
    <expr_stmt><expr><name>optreset</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>                <comment type="block">/* some systems need this too */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 * PostgresMain
 *       postgres main loop -- all backends, interactive or otherwise start here
 *
 * argc/argv are the command line arguments to be used.  (When being forked
 * by the postmaster, these are not the original argv array of the process.)
 * dbname is the name of the database to connect to, or NULL if the database
 * name should be extracted from the command line arguments or defaulted.
 * username is the PostgreSQL user name to be used for the session.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>PostgresMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>,
             <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>,
             <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>firstchar</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>input_message</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sigjmp_buf</name></type>    <name>local_sigjmp_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type> <name>send_ready_for_query</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>disable_idle_in_transaction_timeout</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef> <comment type="block">/* PGXC_DATANODE */</comment>
    <comment type="block">/* Snapshot info */</comment>
    <decl_stmt><decl><type><name>TransactionId</name>             <name>xmin</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name>             <name>xmax</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GlobalTimestamp</name></type>            <name>gts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>                        <name>xcnt</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name>             <modifier>*</modifier><name>xip</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
    <comment type="block">/* Timestamp info */</comment>
    <decl_stmt><decl><type><name>TimestampTz</name></type>        <name>timestamp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>remoteConnType</name> <operator>=</operator> <name>REMOTE_CONN_APP</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <expr_stmt><expr><name>parentPGXCNode</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>parentPGXCNodeId</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>parentPGXCNodeType</name> <operator>=</operator> <name>PGXC_NODE_DATANODE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cluster_lock_held</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cluster_ex_lock_held</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* XCP */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* for error code contrib */</comment>
    <expr_stmt><expr><name>g_is_in_init_phase</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>HOLD_POOLER_RELOAD</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Initialize startup process environment if necessary. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>InitStandaloneProcess</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>InitProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Set default values for command-line options.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>InitializeGUCOptions</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Parse command-line options.
     */</comment>
    <expr_stmt><expr><call><name>process_postgres_switches</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Must have gotten a database name, or have a default (the username) */</comment>
    <if_stmt><if>if <condition>(<expr><name>dbname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>dbname</name> <operator>=</operator> <name>username</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>dbname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: no database nor user name specified"</literal></expr></argument>,
                            <argument><expr><name>progname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Acquire configuration parameters, unless inherited from postmaster */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SelectConfigFiles</name><argument_list>(<argument><expr><name>userDoption</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Set up signal handlers and masks.
     *
     * Note that postmaster blocked all signals before forking child process,
     * so there is no race condition whereby we might receive a signal before
     * we have set up the handler.
     *
     * Also note: it's best not to use any signals that are SIG_IGNored in the
     * postmaster.  If such a signal arrives before we are able to change the
     * handler to non-SIG_IGN, it'll get dropped.  Instead, make a dummy
     * handler in the postmaster to reserve the signal. (Of course, this isn't
     * an issue for signals that are locally generated, such as SIGALRM and
     * SIGPIPE.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>am_walsender</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>WalSndSignals</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>PostgresSigHupHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* set flag to read config
                                                     * file */</comment>
        <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>StatementCancelHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* cancel current query */</comment>
        <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* cancel current query and exit */</comment>

        <comment type="block">/*
         * In a standalone backend, SIGQUIT can be generated from the keyboard
         * easily, while SIGTERM cannot, so we make both signals do die()
         * rather than quickdie().
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>quickdie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* hard crash time */</comment>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* cancel current query and exit */</comment>
        <expr_stmt><expr><call><name>InitializeTimeouts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* establishes SIGALRM handler */</comment>

        <comment type="block">/*
         * Ignore failure to write to frontend. Note: if frontend closes
         * connection, we will notice it and exit cleanly when control next
         * returns to outer loop.  This seems safer than forcing exit in the
         * midst of output during who-knows-what operation...
         */</comment>
        <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>procsignal_sigusr1_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/* SIGUSR2 is registered for postgres in SetRemoteSubplan */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGFPE</name></expr></argument>, <argument><expr><name>FloatExceptionHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Reset some signals that are accepted by postmaster but not by
         * backend
         */</comment>
        <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* system() requires this on some
                                     * platforms */</comment>
    </block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>prctl</name><argument_list>(<argument><expr><name>PR_SET_PDEATHSIG</name></expr></argument>, <argument><expr><name>SIGKILL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pqinitmask</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We allow SIGQUIT (quickdie) at all times */</comment>
        <expr_stmt><expr><call><name>sigdelset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>, <argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* block everything except SIGQUIT */</comment>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Validate we have been given a reasonable-looking DataDir (if under
         * postmaster, assume postmaster did this already).
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ValidatePgVersion</name><argument_list>(<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Change into DataDir (if under postmaster, was done already) */</comment>
        <expr_stmt><expr><call><name>ChangeToDataDir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Create lockfile for data directory.
         */</comment>
        <expr_stmt><expr><call><name>CreateDataDirLockFile</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Initialize MaxBackends (if under postmaster, was done already) */</comment>
        <expr_stmt><expr><call><name>InitializeMaxBackends</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Early initialization */</comment>
    <expr_stmt><expr><call><name>BaseInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create a per-backend PGPROC struct in shared memory, except in the
     * EXEC_BACKEND case where this was done in SubPostmasterMain. We must do
     * this before we can use LWLocks (and in the EXEC_BACKEND case we already
     * had to do some stuff with LWLocks).
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>InitProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>InitProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* We need to allow SIGINT, etc during the initial transaction */</comment>
    <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * General initialization.
     *
     * NOTE: if you are tempted to add code in this vicinity, consider putting
     * it inside InitPostgres() instead.  In particular, anything that
     * involves database access should be there, not here.
     */</comment>
    <expr_stmt><expr><call><name>InitPostgres</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>username</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IsBackendPostgres</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>AuditLoggerQueueAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>    
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If the PostmasterContext is still around, recycle the space; we don't
     * need it anymore after InitPostgres completes.  Note this does not trash
     * *MyProcPort, because ConnCreate() allocated that space with malloc()
     * ... else we'd need to copy the Port data first.  Also, subsidiary data
     * such as the username isn't lost either; see ProcessStartupPacket().
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>PostmasterContext</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>PostmasterContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>PostmasterContext</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>NormalProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now all GUC states are fully set up.  Report them to client if
     * appropriate.
     */</comment>
    <expr_stmt><expr><call><name>BeginReportingGUCOptions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Also set up handler to log session end; we have to wait till now to be
     * sure Log_disconnections has its final value.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <name>Log_disconnections</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>on_proc_exit</name><argument_list>(<argument><expr><name>log_disconnections</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Perform initialization specific to a WAL sender process. */</comment>
    <if_stmt><if>if <condition>(<expr><name>am_walsender</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>InitWalSender</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * process any libraries that should be preloaded at backend start (this
     * likewise can't be done until GUC settings are complete)
     */</comment>
    <expr_stmt><expr><call><name>process_session_preload_libraries</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Send this backend's cancellation info to the frontend.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'K'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <name>MyProcPid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <name>MyCancelKey</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Need not flush since ReadyForQuery will do it. */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Welcome banner for standalone case */</comment>
    <if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestDebug</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nPostgreSQL stand-alone backend %s\n"</literal></expr></argument>, <argument><expr><name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Create the memory context we will use in the main loop.
     *
     * MessageContext is reset once per iteration of the main loop, ie, upon
     * completion of processing of each command message from the client.
     */</comment>
    <expr_stmt><expr><name>MessageContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                           <argument><expr><literal type="string">"MessageContext"</literal></expr></argument>,
                                           <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
    <expr_stmt><expr><name>AuditContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                           <argument><expr><literal type="string">"AuditContext"</literal></expr></argument>,
                                           <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Remember stand-alone backend startup time
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>PgStartTime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/*
     * Initialize key pair to be used as object id while using advisory lock
     * for backup
     */</comment>
    <expr_stmt><expr><name>xc_lockForBackupKey1</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>XC_LOCK_FOR_BACKUP_KEY_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>xc_lockForBackupKey1</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>XC_LOCK_FOR_BACKUP_KEY_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/*
     * Prepare to handle distributed requests. Do that after sending down
     * ReadyForQuery, to avoid pooler blocking.
     *
     * Also do this only when we can access the catalogs. For example, a
     * wal-sender can't do that since its not connected to a specific database
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>am_walsender</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>InitMultinodeExecutor</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_MODULE_MSGIDS</name></cpp:ifdef>
    <expr_stmt><expr><call><name>AtProcStart_MsgModule</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* if we exit, try to release cluster lock properly */</comment>
    <expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>PGXCCleanClusterLock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if we exit, try to release shared queues */</comment>
    <expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>SharedQueuesCleanup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If we exit, first try and clean connections and send to pool */</comment>
    <expr_stmt><expr><call><name>on_proc_exit</name><argument_list>(<argument><expr><name>PGXCNodeCleanAndRelease</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* If this postmaster is launched from another Coord, do not initialize handles. skip it */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsPoolHandle</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <call><name>ResourceOwnerCreate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"ForPGXCNodes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>InitMultinodeExecutor</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>pool_handle</name> <operator>=</operator> <call><name>GetPoolManagerHandle</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>pool_handle</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IO_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Can not connect to pool manager"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Pooler initialization has to be made before ressource is released */</comment>
        <expr_stmt><expr><call><name>PoolManagerConnect</name><argument_list>(<argument><expr><name>pool_handle</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>username</name></expr></argument>, <argument><expr><call><name>session_options</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>RESOURCE_RELEASE_BEFORE_LOCKS</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>RESOURCE_RELEASE_LOCKS</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>RESOURCE_RELEASE_AFTER_LOCKS</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <comment type="block">/* If we exit, first try and clean connections and send to pool */</comment>
        <expr_stmt><expr><call><name>on_proc_exit</name> <argument_list>(<argument><expr><name>PGXCNodeCleanAndRelease</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* XCP */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* If we exit, first try and clean connection to GTM */</comment>
        <expr_stmt><expr><call><name>on_proc_exit</name> <argument_list>(<argument><expr><name>DataNodeShutdown</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <comment type="block">/* free memory of g_TempKeyValueList */</comment>
    <expr_stmt><expr><call><name>on_proc_exit</name><argument_list>(<argument><expr><name>ReleaseSessionMemory</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * POSTGRES main processing loop begins here
     *
     * If an exception is encountered, processing resumes here so we abort the
     * current transaction and start a new one.
     *
     * You might wonder why this isn't coded as an infinite loop around a
     * PG_TRY construct.  The reason is that this is the bottom of the
     * exception stack, and so with PG_TRY there would be no exception handler
     * in force at all during the CATCH part.  By leaving the outermost setjmp
     * always active, we have at least some chance of recovering from an error
     * during error recovery.  (If we get into an infinite loop thereby, it
     * will soon be stopped by overflow of elog.c's internal state stack.)
     *
     * Note that we use sigsetjmp(..., 1), so that this function's signal mask
     * (to wit, UnBlockSig) will be restored when longjmp'ing to here.  This
     * is essential in case we longjmp'd out of a signal handler on a platform
     * where that leaves the signal blocked.  It's not redundant with the
     * unblock in AbortTransaction() because the latter is only called if we
     * were inside a transaction.
     */</comment>

    <if_stmt><if>if <condition>(<expr><call><name>sigsetjmp</name><argument_list>(<argument><expr><name>local_sigjmp_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * NOTE: if you are tempted to add more code in this if-block,
         * consider the high probability that it should be in
         * AbortTransaction() instead.  The only stuff done directly here
         * should be stuff that is guaranteed to apply *only* for outer-level
         * error recovery, such as adjusting the FE/BE protocol status.
         */</comment>

        <comment type="block">/* Since not using PG_TRY, must reset error stack by hand */</comment>
        <expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <comment type="block">/* Prevent interrupts while cleaning up */</comment>
        <expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Forget any pending QueryCancel request, since we're returning to
         * the idle loop anyway, and cancel any active timeout requests.  (In
         * future we might want to allow some timeout requests to survive, but
         * at minimum it'd be necessary to do reschedule_timeouts(), in case
         * we got here because of a query cancel interrupting the SIGALRM
         * interrupt handler.)    Note in particular that we must clear the
         * statement and lock timeout indicators, to prevent any future plain
         * query cancels from being misreported as timeouts in case we're
         * forgetting a timeout cancel.
         */</comment>
        <expr_stmt><expr><call><name>disable_all_timeouts</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* second to avoid race condition */</comment>

        <comment type="block">/* Not reading from the client anymore. */</comment>
        <expr_stmt><expr><name>DoingCommandRead</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <comment type="block">/* Make sure libpq is in a good state */</comment>
        <expr_stmt><expr><call><name>pq_comm_reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Report the error to the client and/or server log */</comment>
        <expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Make sure debug_query_string gets reset before we possibly clobber
         * the storage it points at.
         */</comment>
        <expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>groupOids</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>groupOids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>parallelExecutionError</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>end_query_requested</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>Executor_done</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>g_in_plpgsql_exec_fun</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ClearQueryAnalyzeInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
        <comment type="block">/* transaction will abort or rollback */</comment>
        <if_stmt><if>if <condition>(<expr><name>xact_started</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>AuditProcessResultInfo</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<comment type="block">/*
		 * Abort the current transaction in order to recover.
		 */</comment>
		<expr_stmt><expr><call><name>AbortCurrentTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>am_walsender</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>WalSndErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We can't release replication slots inside AbortTransaction() as we
		 * need to be able to start and abort transactions while having a slot
		 * acquired. But we never need to hold them across top level errors,
		 * so releasing here is fine. There's another cleanup in ProcKill()
		 * ensuring we'll correctly cleanup on FATAL errors as well.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>MyReplicationSlot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReplicationSlotRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* We also want to cleanup temporary slots on error. */</comment>
		<expr_stmt><expr><call><name>ReplicationSlotCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now return to normal top-level context and clear ErrorContext for
		 * next time.
		 */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we were handling an extended-query-protocol message, initiate
		 * skip till next Sync.  This also causes us not to issue
		 * ReadyForQuery (until we get Sync).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>doing_extended_query_message</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ignore_till_sync</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* We don't have a transaction command open anymore */</comment>
		<expr_stmt><expr><name>xact_started</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<comment type="block">/* Clear parallel DDL flag */</comment>
		<expr_stmt><expr><name>is_txn_has_parallel_ddl</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>leader_cn_executed_ddl</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * If an error occurred while we were reading a message from the
		 * client, we have potentially lost track of where the previous
		 * message ends and the next one begins.  Even though we have
		 * otherwise recovered from the error, we cannot safely read any more
		 * messages from the client, so there isn't much we can do with the
		 * connection anymore.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pq_is_reading_msg</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating connection because protocol synchronization was lost"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Now we can allow interrupts again */</comment>
		<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* for error code contrib */</comment>
    <expr_stmt><expr><name>g_is_in_init_phase</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* We can now handle ereport(ERROR) */</comment>
    <expr_stmt><expr><name>PG_exception_stack</name> <operator>=</operator> <operator>&amp;</operator><name>local_sigjmp_buf</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ignore_till_sync</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>send_ready_for_query</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* initially, or after error */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>am_walsender</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>IsNormalPostgres</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Non-error queries loop here.
     */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
        <expr_stmt><expr><call><name>mls_reset_command_tag</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>logicl_aply_rset_ignor_pk_conflict</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TbaseSubscriptionApplyWorkerReset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * At top of loop, reset extended-query-message flag, so that any
         * errors encountered in "idle" state don't provoke skip.
         */</comment>
        <expr_stmt><expr><name>doing_extended_query_message</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Release storage left over from prior query cycle, and create a new
         * query input buffer in the cleared MessageContext.
         */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>AuditContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<expr_stmt><expr><call><name>CheckInvalidateRemoteHandles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>AuditClearResultInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>ClearPrepareGID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>groupOids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>end_query_requested</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>Executor_done</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * Also consider releasing our catalog snapshot if any, so that it's
         * not preventing advance of global xmin while we wait for the client.
         */</comment>
        <expr_stmt><expr><call><name>InvalidateCatalogSnapshotConditionally</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * (1) If we've reached idle state, tell the frontend we're ready for
         * a new query.
         *
         * Note: this includes fflush()'ing the last of the prior output.
         *
         * This is also a good time to send collected statistics to the
         * collector, and to update the PS stats display.  We avoid doing
         * those every time through the message loop because it'd slow down
         * processing of batched messages, and because we don't want to report
         * uncommitted updates (that confuses autovacuum).  The notification
         * processor wants a call too, if we are not in a transaction block.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>send_ready_for_query</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"idle in transaction (aborted)"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_IDLEINTRANSACTION_ABORTED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Start the idle-in-transaction timer */</comment>
                <if_stmt><if>if <condition>(<expr><name>IdleInTransactionSessionTimeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>disable_idle_in_transaction_timeout</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>enable_timeout_after</name><argument_list>(<argument><expr><name>IDLE_IN_TRANSACTION_SESSION_TIMEOUT</name></expr></argument>,
                                         <argument><expr><name>IdleInTransactionSessionTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>IsTransactionOrTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"idle in transaction"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_IDLEINTRANSACTION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Start the idle-in-transaction timer */</comment>
                <if_stmt><if>if <condition>(<expr><name>IdleInTransactionSessionTimeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>disable_idle_in_transaction_timeout</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>enable_timeout_after</name><argument_list>(<argument><expr><name>IDLE_IN_TRANSACTION_SESSION_TIMEOUT</name></expr></argument>,
                                         <argument><expr><name>IdleInTransactionSessionTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ProcessCompletedNotifies</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pgstat_report_stat</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"idle"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_IDLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><call><name>ReadyForQuery</name><argument_list>(<argument><expr><name>whereToSendOutput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
            <comment type="block">/*
             * Before we read any new command we now should wait while all
             * already closed portals which are still producing finish their
             * work.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <call><name>IsConnFromDatanode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>cleanupClosedProducers</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
            <comment type="block">/*
             * Helps us catch any problems where we did not send down a snapshot
             * when it was expected. However if any deferred trigger is supposed
             * to be fired at commit time we need to preserve the snapshot sent previously
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>IS_PGXC_DATANODE</name> <operator>||</operator> <call><name>IsConnFromCoord</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsAnyAfterTriggerDeferred</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>UnsetGlobalSnapshotData</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <expr_stmt><expr><name>send_ready_for_query</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * (2) Allow asynchronous signals to be executed immediately if they
         * come in while we are waiting for client input. (This must be
         * conditional since we don't want, say, reads on behalf of COPY FROM
         * STDIN doing the same thing.)
         */</comment>
        <expr_stmt><expr><name>DoingCommandRead</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>RESUME_POOLER_RELOAD</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/*
         * (3) read a command (loop blocks here)
         */</comment>
        <expr_stmt><expr><name>firstchar</name> <operator>=</operator> <call><name>ReadCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>HOLD_POOLER_RELOAD</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/*
         * (4) disable async signal conditions again.
         *
         * Query cancel is supposed to be a no-op when there is no query in
         * progress, so if a query cancel arrived while we were idle, just
         * reset QueryCancelPending. ProcessInterrupts() has that effect when
         * it's called when DoingCommandRead is set, so check for interrupts
         * before resetting DoingCommandRead.
         */</comment>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>DoingCommandRead</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <comment type="block">/*
         * (5) turn off the idle-in-transaction timeout
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>disable_idle_in_transaction_timeout</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>disable_timeout</name><argument_list>(<argument><expr><name>IDLE_IN_TRANSACTION_SESSION_TIMEOUT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>disable_idle_in_transaction_timeout</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * (6) check for any other interesting events that happened while we
         * slept.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>ConfigReloadPending</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>ConfigReloadPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * (7) process the command.  But ignore it if we're skipping till
         * Sync.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>ignore_till_sync</name> <operator>&amp;&amp;</operator> <name>firstchar</name> <operator>!=</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <comment type="block">/*
         * Acquire the ClusterLock before starting query processing.
         *
         * If we are inside a transaction block, this lock will be already held
         * when the transaction began
         *
         * If the session has invoked a PAUSE CLUSTER earlier, then this lock
         * will be held already in exclusive mode. No need to lock in that case
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cluster_ex_lock_held</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cluster_lock_held</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type> <name>exclusive</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>AcquireClusterLock</name><argument_list>(<argument><expr><name>exclusive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cluster_lock_held</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* XCP */</comment>

        <switch>switch <condition>(<expr><name>firstchar</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'Q'</literal></expr>:</case>            <comment type="block">/* simple query */</comment>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl>;</decl_stmt>

                    <comment type="block">/* Set statement_timestamp() */</comment>
                    <expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>query_string</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>am_walsender</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_replication_command</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>exec_simple_query</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>exec_simple_query</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                    <expr_stmt><expr><name>send_ready_for_query</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

            <case>case <expr><literal type="char">'P'</literal></expr>:</case>            <comment type="block">/* parse */</comment>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type>            <name>numParams</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>paramTypes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier><modifier>*</modifier></type><name>paramTypeNames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name></type>		<name>need_rewrite</name> <init>= <expr><literal type="char">'N'</literal></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>forbidden_in_wal_sender</name><argument_list>(<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* Set statement_timestamp() */</comment>
                    <expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>stmt_name</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>query_string</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>numParams</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>paramTypes</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numParams</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>numParams</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
                        <if_stmt><if>if <condition>(<expr><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>paramTypeNames</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>numParams</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numParams</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                                <expr_stmt><expr><name><name>paramTypeNames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

							<expr_stmt><expr><name>need_rewrite</name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>
                        <block>{<block_content>
                            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numParams</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                                <expr_stmt><expr><name><name>paramTypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>exec_parse_message</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>stmt_name</name></expr></argument>,
									   <argument><expr><name>paramTypes</name></expr></argument>, <argument><expr><name>paramTypeNames</name></expr></argument>,
									   <argument><expr><name>numParams</name></expr></argument>, <argument><expr><name>need_rewrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
            <case>case <expr><literal type="char">'p'</literal></expr>:</case>            <comment type="block">/* plan */</comment>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>plan_string</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type>            <name>numParams</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier><modifier>*</modifier></type><name>paramTypes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>         <name>instrument_options</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                    <comment type="block">/* Set statement_timestamp() */</comment>
                    <expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>stmt_name</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>query_string</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>plan_string</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>numParams</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>paramTypes</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>numParams</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>numParams</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
                        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numParams</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>paramTypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator>
                                    <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                    </block_content>}</block></if></if_stmt>
					
					<expr_stmt><expr><name>instrument_options</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					
                    <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>exec_plan_message</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>plan_string</name></expr></argument>,
									  <argument><expr><name>paramTypes</name></expr></argument>, <argument><expr><name>numParams</name></expr></argument>,
									  <argument><expr><name>instrument_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <case>case <expr><literal type="char">'B'</literal></expr>:</case>            <comment type="block">/* bind */</comment>
                <expr_stmt><expr><call><name>forbidden_in_wal_sender</name><argument_list>(<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Set statement_timestamp() */</comment>
                <expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * this message is complex enough that it seems best to put
                 * the field extraction out-of-line
                 */</comment>
                <expr_stmt><expr><call><name>exec_bind_message</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'E'</literal></expr>:</case>            <comment type="block">/* execute */</comment>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portal_name</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type>            <name>max_rows</name></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>forbidden_in_wal_sender</name><argument_list>(<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* Set statement_timestamp() */</comment>
                    <expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>portal_name</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>max_rows</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>exec_execute_message</name><argument_list>(<argument><expr><name>portal_name</name></expr></argument>, <argument><expr><name>max_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

            <case>case <expr><literal type="char">'F'</literal></expr>:</case>            <comment type="block">/* fastpath function call */</comment>
                <expr_stmt><expr><call><name>forbidden_in_wal_sender</name><argument_list>(<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Set statement_timestamp() */</comment>
                <expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Report query to various monitoring facilities. */</comment>
                <expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_FASTPATH</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"&lt;FASTPATH&gt;"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* start an xact for this function invocation */</comment>
                <expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Note: we may at this point be inside an aborted
                 * transaction.  We can't throw error for that until we've
                 * finished reading the function-call message, so
                 * HandleFunctionRequest() must check for it after doing so.
                 * Be careful not to do anything that assumes we're inside a
                 * valid transaction here.
                 */</comment>

                <comment type="block">/* switch back to message context */</comment>
                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>HandleFunctionRequest</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* commit the function-invocation transaction */</comment>
                <expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>send_ready_for_query</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'C'</literal></expr>:</case>            <comment type="block">/* close */</comment>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type>            <name>close_type</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>close_target</name></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>forbidden_in_wal_sender</name><argument_list>(<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>close_type</name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>close_target</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"Received a 'C' (close) command for %s, type %c"</literal></expr></argument>,
                            <argument><expr><ternary><condition><expr><name><name>close_target</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><name>close_target</name></expr> </then><else>: <expr><literal type="string">"unnamed_stmt"</literal></expr></else></ternary></expr></argument>,
                            <argument><expr><name>close_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <switch>switch <condition>(<expr><name>close_type</name></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><literal type="char">'S'</literal></expr>:</case>
                            <if_stmt><if>if <condition>(<expr><name><name>close_target</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>DropPreparedStatement</name><argument_list>(<argument><expr><name>close_target</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                            <else>else
                            <block>{<block_content>
                                <comment type="block">/* special-case the unnamed statement */</comment>
                                <expr_stmt><expr><call><name>drop_unnamed_stmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>
                            <break>break;</break>
                        <case>case <expr><literal type="char">'P'</literal></expr>:</case>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>Portal</name></type>        <name>portal</name></decl>;</decl_stmt>

                                <expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>GetPortalByName</name><argument_list>(<argument><expr><name>close_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><call><name>PortalDrop</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            </block_content>}</block>
                            <break>break;</break>
                        <default>default:</default>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid CLOSE message subtype %d"</literal></expr></argument>,
                                            <argument><expr><name>close_type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                    </block_content>}</block></switch>

                    <if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'3'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* CloseComplete */</comment>
                </block_content>}</block>
                <break>break;</break>

            <case>case <expr><literal type="char">'D'</literal></expr>:</case>            <comment type="block">/* describe */</comment>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type>            <name>describe_type</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>describe_target</name></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>forbidden_in_wal_sender</name><argument_list>(<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* Set statement_timestamp() (needed for xact) */</comment>
                    <expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>describe_type</name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>describe_target</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <switch>switch <condition>(<expr><name>describe_type</name></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><literal type="char">'S'</literal></expr>:</case>
                            <expr_stmt><expr><call><name>exec_describe_statement_message</name><argument_list>(<argument><expr><name>describe_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><literal type="char">'P'</literal></expr>:</case>
                            <expr_stmt><expr><call><name>exec_describe_portal_message</name><argument_list>(<argument><expr><name>describe_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <default>default:</default>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid DESCRIBE message subtype %d"</literal></expr></argument>,
                                            <argument><expr><name>describe_type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                    </block_content>}</block></switch>
                </block_content>}</block>
                <break>break;</break>

            <case>case <expr><literal type="char">'H'</literal></expr>:</case>            <comment type="block">/* flush */</comment>
                <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>pq_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'S'</literal></expr>:</case>            <comment type="block">/* sync */</comment>
                <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>send_ready_for_query</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'L'</literal></expr>:</case>			<comment type="block">/* sync */</comment>
                <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>	
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <case>case <expr><literal type="char">'N'</literal></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type>    <name>cons</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cursor</name></decl>;</decl_stmt>
                    
                    <expr_stmt><expr><name>cursor</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>cons</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>SetDisConnectConsumer</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>cons</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    
                    <expr_stmt><expr><call><name>SharedQueueDisconnectConsumer</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>DropPreparedStatement</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>pq_putmessage</name><argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>pq_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block>
                <break>break;</break>
			<case>case <expr><literal type="char">'U'</literal></expr>:</case>			<comment type="block">/* coord info: coord_pid and coord_vxid */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type> <name>coord_pid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>TransactionId</name></type> <name>coord_vxid</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>coord_pid</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>coord_vxid</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name><operator>)</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>pgxc_set_coordinator_proc_pid</name><argument_list>(<argument><expr><name>coord_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pgxc_set_coordinator_proc_vxid</name><argument_list>(<argument><expr><name>coord_vxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"Received coord_pid: %d, coord_vxid: %u"</literal></expr></argument>, <argument><expr><name>coord_pid</name></expr></argument>, <argument><expr><name>coord_vxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>
			<case>case <expr><literal type="char">'o'</literal></expr>:</case>       <comment type="block">/* session id */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sessionid</name> <init>= <expr><call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>PGXCSessionId</name></expr></argument>, <argument><expr><name>sessionid</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/*
                 * 'X' means that the frontend is closing down the socket. EOF
                 * means unexpected loss of frontend connection. Either way,
                 * perform normal shutdown.
                 */</comment>
            <case>case <expr><literal type="char">'X'</literal></expr>:</case>
            <case>case <expr><name>EOF</name></expr>:</case>

                <comment type="block">/*
                 * Reset whereToSendOutput to prevent ereport from attempting
                 * to send any more messages to client.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * NOTE: if you are tempted to add more code here, DON'T!
                 * Whatever you had in mind to do should be set up as an
                 * on_proc_exit or on_shmem_exit callback, instead. Otherwise
                 * it will fail to be called during other backend-shutdown
                 * scenarios.
                 */</comment>
                <expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <case>case <expr><literal type="char">'d'</literal></expr>:</case>            <comment type="block">/* copy data */</comment>
            <case>case <expr><literal type="char">'c'</literal></expr>:</case>            <comment type="block">/* copy done */</comment>
            <case>case <expr><literal type="char">'f'</literal></expr>:</case>            <comment type="block">/* copy fail */</comment>

                <comment type="block">/*
                 * Accept but ignore these messages, per protocol spec; we
                 * probably got here because a COPY failed, and the frontend
                 * is still sending data.
                 */</comment>
                <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
            <case>case <expr><literal type="char">'M'</literal></expr>:</case>            <comment type="block">/* Command ID */</comment>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>CommandId</name></type> <name>cid</name> <init>= <expr><operator>(</operator><name>CommandId</name><operator>)</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Received cmd id %u"</literal></expr></argument>, <argument><expr><name>cid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>SaveReceivedCommandId</name><argument_list>(<argument><expr><name>cid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

            <case>case <expr><literal type="char">'g'</literal></expr>:</case>            <comment type="block">/* gxid */</comment>
                <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>globalXidString</name></decl>;</decl_stmt>
                    <expr_stmt><expr><name>globalXidString</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>StoreGlobalXid</name><argument_list>(<argument><expr><name>globalXidString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <comment type="block">/* Set the GXID we were passed down */</comment>
                    <decl_stmt><decl><type><name>TransactionId</name></type> <name>gxid</name></decl>;</decl_stmt>
                       <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gxid</name></expr></argument>, <argument><expr><call><name>pq_getmsgbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Received new gxid %u"</literal></expr></argument>, <argument><expr><name>gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>SetNextTransactionId</name><argument_list>(<argument><expr><name>gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block>
                <break>break;</break>

            <case>case <expr><literal type="char">'s'</literal></expr>:</case>            <comment type="block">/* snapshot */</comment>
                <comment type="block">/* Set the snapshot we were passed down */</comment>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gts</name></expr></argument>,
                    <argument><expr><call><name>pq_getmsgbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"receive snapshot gts "</literal> <name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>gts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SetGlobalTimestamp</name><argument_list>(<argument><expr><name>gts</name></expr></argument>, <argument><expr><name>SNAPSHOT_COORDINATOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
			<case>case <expr><literal type="char">'Z'</literal></expr>:</case>			<comment type="block">/* global prepare timestamp */</comment>
				<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <operator>(</operator><name>GlobalTimestamp</name><operator>)</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
				<comment type="block">/*
				 * Set Xact global prepare timestamp 
				 */</comment>
				<if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"set global prepare gts "</literal> <name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>SetGlobalPrepareTimestamp</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				
				<break>break;</break>

			<case>case <expr><literal type="char">'T'</literal></expr>:</case>			<comment type="block">/* global timestamp */</comment>
				<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <operator>(</operator><name>GlobalTimestamp</name><operator>)</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
				<comment type="block">/*
				 * Set Xact global commit timestamp 
				 */</comment>
				<if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"set global commit gts "</literal> <name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>SetGlobalCommitTimestamp</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'G'</literal></expr>:</case>   <comment type="block">/* Explicit prepared gid */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl>;</decl_stmt>
					<expr_stmt><expr><name>gid</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>remotePrepareGID</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"receive remote prepare gid %s"</literal></expr></argument>, <argument><expr><name>remotePrepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><literal type="char">'W'</literal></expr>:</case>	<comment type="block">/* Prefinish phase */</comment>
				<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <operator>(</operator><name>GlobalTimestamp</name><operator>)</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"get prefinish timestamp "</literal> <name>INT64_FORMAT</name> <literal type="string">"for gid %s"</literal></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>remotePrepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SetGlobalPrepareTimestamp</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>EndExplicitGlobalPrepare</name><argument_list>(<argument><expr><name>remotePrepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>remotePrepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>remotePrepareGID</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ReadyForCommit</name><argument_list>(<argument><expr><name>whereToSendOutput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <case>case <expr><literal type="char">'t'</literal></expr>:</case>            <comment type="block">/* timestamp */</comment>
                <expr_stmt><expr><name>timestamp</name> <operator>=</operator> <operator>(</operator><name>TimestampTz</name><operator>)</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Set in xact.x the static Timestamp difference value with GTM
                 * and the timestampreceivedvalues for Datanode reference
                 */</comment>
                <expr_stmt><expr><call><name>SetCurrentGTMDeltaTimestamp</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'b'</literal></expr>:</case>            <comment type="block">/* barrier */</comment>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type> <name>command</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>id</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <switch>switch <condition>(<expr><name>command</name></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><name>CREATE_BARRIER_PREPARE</name></expr>:</case>
                            <expr_stmt><expr><call><name>ProcessCreateBarrierPrepare</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>

                        <case>case <expr><name>CREATE_BARRIER_END</name></expr>:</case>
                            <expr_stmt><expr><call><name>ProcessCreateBarrierEnd</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>

                        <case>case <expr><name>CREATE_BARRIER_EXECUTE</name></expr>:</case>
                            <expr_stmt><expr><call><name>ProcessCreateBarrierExecute</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>

                        <default>default:</default>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid command received"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></switch>
                </block_content>}</block>
                <break>break;</break>    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
            <case>case <expr><literal type="char">'e'</literal></expr>:</case>       <comment type="block">/*start node of twophase transaction*/</comment>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>startnode</name></decl>;</decl_stmt>
                    <expr_stmt><expr><name>startnode</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>enable_distri_print</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"2pc recv startnode: %s"</literal></expr></argument>, <argument><expr><name>startnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>StoreStartNode</name><argument_list>(<argument><expr><name>startnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>
            <case>case <expr><literal type="char">'R'</literal></expr>:</case>            <comment type="block">/* participants of twophase transaction */</comment>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>partnodes</name></decl>;</decl_stmt>
                    <expr_stmt><expr><name>partnodes</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>enable_distri_print</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"2pc recv partnodes: %s"</literal></expr></argument>, <argument><expr><name>partnodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>StorePartNodes</name><argument_list>(<argument><expr><name>partnodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>
            <case>case <expr><literal type="char">'x'</literal></expr>:</case>           <comment type="block">/* xid in start node of twophase transaction */</comment>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>TransactionId</name></type> <name>startxid</name></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>enable_distri_print</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"2pc recv str_startxid:%s"</literal></expr></argument>, <argument><expr><name><name>input_message</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>startxid</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name><operator>)</operator><call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>enable_distri_print</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"2pc recv startxid:%u"</literal></expr></argument>, <argument><expr><name>startxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>StoreStartXid</name><argument_list>(<argument><expr><name>startxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>
            <case>case <expr><literal type="char">'n'</literal></expr>:</case>           <comment type="block">/* execute in pg_clean */</comment>
                <block>{<block_content>
                    <comment type="block">/* since g_twophase_state will be reinitialized in pg_clean */</comment>
                    <expr_stmt><expr><call><name>ClearLocalTwoPhaseState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>in_pg_clean</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>
            <case>case <expr><literal type="char">'r'</literal></expr>:</case>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>is_readonly</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>
            <case>case <expr><literal type="char">'A'</literal></expr>:</case>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>is_after_prepare</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>            

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
            <case>case <expr><literal type="char">'a'</literal></expr>:</case>            <comment type="block">/* logical apply : pgxc_node_send_apply */</comment>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <call><name>IsConnFromCoord</name><argument_list>()</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

                        <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'Y'</literal></expr>)</condition>
                        <block>{<block_content>
                        	<expr_stmt><expr><call><name>logicl_apply_set_ignor_pk_conflict</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'N'</literal></expr>)</condition>
                        <block>{<block_content>
                        	<expr_stmt><expr><call><name>logicl_apply_set_ignor_pk_conflict</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid logical apply value of ignore_pk_conflict %c"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>

                        <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'w'</literal></expr>)</condition>    <comment type="block">/* WalSndPrepareWrite */</comment>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>start_lsn</name></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>end_lsn</name></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>TimestampTz</name></type> <name>send_time</name></decl>;</decl_stmt>

                            <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

                            <expr_stmt><expr><name>start_lsn</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>end_lsn</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>send_time</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"receive logical apply start_lsn: %X/%X, end_lsn: %X/%X, send_time: "</literal> <name>INT64_FORMAT</name></expr></argument>,
                                         <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>start_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>start_lsn</name></expr></argument>,
                                         <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>end_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>end_lsn</name></expr></argument>,
                                         <argument><expr><name>send_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <comment type="block">/* do apply */</comment>
                            <expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><call><name>logical_apply_dispatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <comment type="block">/* Send ApplyDone message */</comment>
                            <expr_stmt><expr><call><name>pq_putmessage</name><argument_list>(<argument><expr><literal type="char">'4'</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>pq_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid frontend message type %d, %d"</literal></expr></argument>,
                                            <argument><expr><name>firstchar</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid frontend message type %d"</literal></expr></argument>,
                                        <argument><expr><name>firstchar</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <default>default:</default>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid frontend message type %d"</literal></expr></argument>,
                                <argument><expr><name>firstchar</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <comment type="block">/*
         * If the connection is going idle, release the cluster lock. However
         * if the session had invoked a PAUSE CLUSTER earlier, then wait for a
         * subsequent UNPAUSE to release this lock
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call>
            <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsTransactionOrTransactionBlock</name><argument_list>()</argument_list></call>
            <operator>&amp;&amp;</operator> <name>cluster_lock_held</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cluster_ex_lock_held</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type> <name>exclusive</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ReleaseClusterLock</name><argument_list>(<argument><expr><name>exclusive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cluster_lock_held</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* XCP */</comment>
    </block_content>}</block></for>                            <comment type="block">/* end of input-reading loop */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Throw an error if we're a WAL sender process.
 *
 * This is used to forbid anything else than simple query protocol messages
 * in a WAL sender process.  'firstchar' specifies what kind of a forbidden
 * message was received, and is used to construct the error message.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>forbidden_in_wal_sender</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>firstchar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>am_walsender</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>firstchar</name> <operator>==</operator> <literal type="char">'F'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fastpath function calls not supported in a replication connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extended query protocol not supported in a replication connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Obtain platform stack depth limit (in bytes)
 *
 * Return -1 if unknown
 */</comment>
<function><type><name>long</name></type>
<name>get_stack_depth_rlimit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETRLIMIT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>RLIMIT_STACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>val</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* This won't change after process launch, so check just once */</comment>
    <if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>rlimit</name></name></type> <name>rlim</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>getrlimit</name><argument_list>(<argument><expr><name>RLIMIT_STACK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rlim</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>rlim</name><operator>.</operator><name>rlim_cur</name></name> <operator>==</operator> <name>RLIM_INFINITY</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>val</name> <operator>=</operator> <name>LONG_MAX</name></expr>;</expr_stmt></block_content></block></if>
        <comment type="block">/* rlim_cur is probably of an unsigned type, so check for overflow */</comment>
        <if type="elseif">else if <condition>(<expr><name><name>rlim</name><operator>.</operator><name>rlim_cur</name></name> <operator>&gt;=</operator> <name>LONG_MAX</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>val</name> <operator>=</operator> <name>LONG_MAX</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>rlim</name><operator>.</operator><name>rlim_cur</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>val</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>                            <comment type="block">/* no getrlimit */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* On Windows we set the backend stack size in src/backend/Makefile */</comment>
    <return>return <expr><name>WIN32_STACK_RLIMIT</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>                            <comment type="block">/* not windows ... give up */</comment>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>rusage</name></name></type> <name>Save_r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>timeval</name></name></type> <name>Save_t</name></decl>;</decl_stmt>

<function><type><name>void</name></type>
<name>ResetUsageCommon</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rusage</name></name> <modifier>*</modifier></type><name>save_r</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>save_t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr><name>save_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><name>save_t</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ResetUsage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ResetUsageCommon</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Save_r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Save_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ShowUsageCommon</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>title</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rusage</name></name> <modifier>*</modifier></type><name>save_r</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>save_t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>user</name></decl>,
                <decl><type ref="prev"/><name>sys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>elapse_t</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>rusage</name></name></type> <name>r</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>elapse_t</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>user</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>r</name><operator>.</operator><name>ru_utime</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>sys</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>r</name><operator>.</operator><name>ru_stime</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sys</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>elapse_t</name><operator>.</operator><name>tv_usec</name></name> <operator>&lt;</operator> <name><name>save_t</name><operator>-&gt;</operator><name>tv_usec</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>elapse_t</name><operator>.</operator><name>tv_sec</name></name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>elapse_t</name><operator>.</operator><name>tv_usec</name></name> <operator>+=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>r</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_usec</name></name> <operator>&lt;</operator> <name><name>save_r</name><operator>-&gt;</operator><name>ru_utime</name><operator>.</operator><name>tv_usec</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>r</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_sec</name></name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_usec</name></name> <operator>+=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>r</name><operator>.</operator><name>ru_stime</name><operator>.</operator><name>tv_usec</name></name> <operator>&lt;</operator> <name><name>save_r</name><operator>-&gt;</operator><name>ru_stime</name><operator>.</operator><name>tv_usec</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>r</name><operator>.</operator><name>ru_stime</name><operator>.</operator><name>tv_sec</name></name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name><operator>.</operator><name>ru_stime</name><operator>.</operator><name>tv_usec</name></name> <operator>+=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * the only stats we don't show here are for memory usage -- i can't
     * figure out how to interpret the relevant fields in the rusage struct,
     * and they change names across o/s platforms, anyway. if you can figure
     * out what the entries mean, you can somehow extract resident set size,
     * shared text size, and unshared data and stack sizes.
     */</comment>
    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"! system usage stats:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
                     <argument><expr><literal type="string">"!\t%ld.%06ld s user, %ld.%06ld s system, %ld.%06ld s elapsed\n"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>r</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <name><name>save_r</name><operator>-&gt;</operator><name>ru_utime</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator></expr></argument>,
                     <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>r</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <name><name>save_r</name><operator>-&gt;</operator><name>ru_utime</name><operator>.</operator><name>tv_usec</name></name><operator>)</operator></expr></argument>,
                     <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>r</name><operator>.</operator><name>ru_stime</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <name><name>save_r</name><operator>-&gt;</operator><name>ru_stime</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator></expr></argument>,
                     <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>r</name><operator>.</operator><name>ru_stime</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <name><name>save_r</name><operator>-&gt;</operator><name>ru_stime</name><operator>.</operator><name>tv_usec</name></name><operator>)</operator></expr></argument>,
                     <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>elapse_t</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <name><name>save_t</name><operator>-&gt;</operator><name>tv_sec</name></name><operator>)</operator></expr></argument>,
                     <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>elapse_t</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <name><name>save_t</name><operator>-&gt;</operator><name>tv_usec</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
                     <argument><expr><literal type="string">"!\t[%ld.%06ld s user, %ld.%06ld s system total]\n"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>user</name><operator>.</operator><name>tv_sec</name></name></expr></argument>,
                     <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>user</name><operator>.</operator><name>tv_usec</name></name></expr></argument>,
                     <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>sys</name><operator>.</operator><name>tv_sec</name></name></expr></argument>,
                     <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>sys</name><operator>.</operator><name>tv_usec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETRUSAGE</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
                     <argument><expr><literal type="string">"!\t%ld/%ld [%ld/%ld] filesystem blocks in/out\n"</literal></expr></argument>,
                     <argument><expr><name><name>r</name><operator>.</operator><name>ru_inblock</name></name> <operator>-</operator> <name><name>save_r</name><operator>-&gt;</operator><name>ru_inblock</name></name></expr></argument>,
    <comment type="block">/* they only drink coffee at dec */</comment>
                     <argument><expr><name><name>r</name><operator>.</operator><name>ru_oublock</name></name> <operator>-</operator> <name><name>save_r</name><operator>-&gt;</operator><name>ru_oublock</name></name></expr></argument>,
                     <argument><expr><name><name>r</name><operator>.</operator><name>ru_inblock</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>.</operator><name>ru_oublock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
                       <argument><expr><literal type="string">"!\t%ld/%ld [%ld/%ld] page faults/reclaims, %ld [%ld] swaps\n"</literal></expr></argument>,
                     <argument><expr><name><name>r</name><operator>.</operator><name>ru_majflt</name></name> <operator>-</operator> <name><name>save_r</name><operator>-&gt;</operator><name>ru_majflt</name></name></expr></argument>,
                     <argument><expr><name><name>r</name><operator>.</operator><name>ru_minflt</name></name> <operator>-</operator> <name><name>save_r</name><operator>-&gt;</operator><name>ru_minflt</name></name></expr></argument>,
                     <argument><expr><name><name>r</name><operator>.</operator><name>ru_majflt</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>.</operator><name>ru_minflt</name></name></expr></argument>,
                     <argument><expr><name><name>r</name><operator>.</operator><name>ru_nswap</name></name> <operator>-</operator> <name><name>save_r</name><operator>-&gt;</operator><name>ru_nswap</name></name></expr></argument>,
                     <argument><expr><name><name>r</name><operator>.</operator><name>ru_nswap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
                      <argument><expr><literal type="string">"!\t%ld [%ld] signals rcvd, %ld/%ld [%ld/%ld] messages rcvd/sent\n"</literal></expr></argument>,
                     <argument><expr><name><name>r</name><operator>.</operator><name>ru_nsignals</name></name> <operator>-</operator> <name><name>save_r</name><operator>-&gt;</operator><name>ru_nsignals</name></name></expr></argument>,
                     <argument><expr><name><name>r</name><operator>.</operator><name>ru_nsignals</name></name></expr></argument>,
                     <argument><expr><name><name>r</name><operator>.</operator><name>ru_msgrcv</name></name> <operator>-</operator> <name><name>save_r</name><operator>-&gt;</operator><name>ru_msgrcv</name></name></expr></argument>,
                     <argument><expr><name><name>r</name><operator>.</operator><name>ru_msgsnd</name></name> <operator>-</operator> <name><name>save_r</name><operator>-&gt;</operator><name>ru_msgsnd</name></name></expr></argument>,
                     <argument><expr><name><name>r</name><operator>.</operator><name>ru_msgrcv</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>.</operator><name>ru_msgsnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
                      <argument><expr><literal type="string">"!\t%ld/%ld [%ld/%ld] voluntary/involuntary context switches\n"</literal></expr></argument>,
                     <argument><expr><name><name>r</name><operator>.</operator><name>ru_nvcsw</name></name> <operator>-</operator> <name><name>save_r</name><operator>-&gt;</operator><name>ru_nvcsw</name></name></expr></argument>,
                     <argument><expr><name><name>r</name><operator>.</operator><name>ru_nivcsw</name></name> <operator>-</operator> <name><name>save_r</name><operator>-&gt;</operator><name>ru_nivcsw</name></name></expr></argument>,
                     <argument><expr><name><name>r</name><operator>.</operator><name>ru_nvcsw</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>.</operator><name>ru_nivcsw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* HAVE_GETRUSAGE */</comment>

    <comment type="block">/* remove trailing newline */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>str</name><operator>.</operator><name>data</name><index>[<expr><name><name>str</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>str</name><operator>.</operator><name>data</name><index>[<expr><operator>--</operator><name><name>str</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ShowUsage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>title</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ShowUsageCommon</name><argument_list>(<argument><expr><name>title</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Save_r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Save_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * on_proc_exit handler to log end of session
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>log_disconnections</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Port</name>       <modifier>*</modifier></type><name>port</name> <init>= <expr><name>MyProcPort</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>secs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>usecs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>msecs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>hours</name></decl>,
                <decl><type ref="prev"/><name>minutes</name></decl>,
                <decl><type ref="prev"/><name>seconds</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>SessionStartTime</name></name></expr></argument>,
                        <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>msecs</name> <operator>=</operator> <name>usecs</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>hours</name> <operator>=</operator> <name>secs</name> <operator>/</operator> <name>SECS_PER_HOUR</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>secs</name> <operator>%=</operator> <name>SECS_PER_HOUR</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>minutes</name> <operator>=</operator> <name>secs</name> <operator>/</operator> <name>SECS_PER_MINUTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>seconds</name> <operator>=</operator> <name>secs</name> <operator>%</operator> <name>SECS_PER_MINUTE</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"disconnection: session time: %d:%02d:%02d.%03d "</literal>
                    <literal type="string">"user=%s database=%s host=%s%s%s"</literal></expr></argument>,
                    <argument><expr><name>hours</name></expr></argument>, <argument><expr><name>minutes</name></expr></argument>, <argument><expr><name>seconds</name></expr></argument>, <argument><expr><name>msecs</name></expr></argument>,
                    <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>remote_host</name></name></expr></argument>,
                    <argument><expr><ternary><condition><expr><name><name>port</name><operator>-&gt;</operator><name>remote_port</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><literal type="string">" port="</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>remote_port</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>replace_null_with_blank</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>NeedResourceOwner</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>stmt_name</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>INSERT_TRIGGER</name></expr></argument>, <argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>INSERT_TRIGGER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>strncmp</name><argument_list>(<argument><expr><name>UPDATE_TRIGGER</name></expr></argument>, <argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>UPDATE_TRIGGER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>strncmp</name><argument_list>(<argument><expr><name>DELETE_TRIGGER</name></expr></argument>, <argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>DELETE_TRIGGER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>


    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>IsStandbyPostgres</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><name>IsNormalPostgres</name> <operator>&amp;&amp;</operator> <name>false</name> <operator>==</operator> <name>IsPGXCMainCluster</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>IsExtendedQuery</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>doing_extended_query_message</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
