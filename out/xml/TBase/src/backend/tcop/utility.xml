<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/tcop/utility.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * utility.c
 *      Contains functions which control the execution of the POSTGRES utility
 *      commands.  At one time acted as an interface between the Lisp and C
 *      systems.
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 *
 * IDENTIFICATION
 *      src/backend/tcop/utility.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stdio.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/toasting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/alter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/cluster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/comment.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/collationcmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/conversioncmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/createas.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/discard.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/explain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/matview.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/lockcmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/portalcmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/proclang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/publicationcmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/schemacmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/seclabel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/subscriptioncmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/typecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/user.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/view.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_utilcmd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteDefine.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteRemove.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/barrier.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/locator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/poolutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/poolmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/nodemgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/groupmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/xc_maintenance_mode.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pause.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_shard_map.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/locator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/nodelock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"audit/audit.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/mls.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_key_values.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>DropSequenceGTM</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>GTM_SequenceKeyType</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecUtilityStmtOnNodes</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>parsetree</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>nodes</name></decl></parameter>,
                                   <parameter><decl><type><name>bool</name></type> <name>sentToRemote</name></decl></parameter>,
                                   <parameter><decl><type><name>bool</name></type> <name>force_autocommit</name></decl></parameter>,
                                   <parameter><decl><type><name>RemoteQueryExecType</name></type> <name>exec_type</name></decl></parameter>,
                                   <parameter><decl><type><name>bool</name></type> <name>is_temp</name></decl></parameter>,
                                   <parameter><decl><type><name>bool</name></type> <name>add_context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecUtilityStmtOnNodesInternal</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>parsetree</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
                                   <parameter><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>nodes</name></decl></parameter>,
                                   <parameter><decl><type><name>bool</name></type> <name>sentToRemote</name></decl></parameter>,
                                   <parameter><decl><type><name>bool</name></type> <name>force_autocommit</name></decl></parameter>,
                                   <parameter><decl><type><name>RemoteQueryExecType</name></type> <name>exec_type</name></decl></parameter>,
                                   <parameter><decl><type><name>bool</name></type> <name>is_temp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RemoteQueryExecType</name></type> <name>ExecUtilityFindNodes</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objectType</name></decl></parameter>,
                                                <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>,
                                                <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_temp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RemoteQueryExecType</name></type> <name>ExecUtilityFindNodesRelkind</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_temp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RemoteQueryExecType</name></type> <name>GetNodesForCommentUtility</name><parameter_list>(<parameter><decl><type><name>CommentStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_temp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RemoteQueryExecType</name></type> <name>GetNodesForRulesUtility</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_temp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DropStmtPreTreatment</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sentToRemote</name></decl></parameter>,
                                 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_temp</name></decl></parameter>, <parameter><decl><type><name>RemoteQueryExecType</name> <modifier>*</modifier></type><name>exec_type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsStmtAllowedInLockedMode</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecCreateKeyValuesStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveSequeceBarely</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>RegisterSeqDrop</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type>    <name>g_GTM_skip_catalog</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>is_txn_has_parallel_ddl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>enable_parallel_ddl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>leader_cn_executed_ddl</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>RemoteQueryExecType</name></type> <name>GetRenameExecType</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_temp</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Hook for plugins to get control in ProcessUtility() */</comment>
<decl_stmt><decl><type><name>ProcessUtility_hook_type</name></type> <name>ProcessUtility_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* local function declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessUtilitySlow</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
                   <parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
                   <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
                   <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
                   <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
                   <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
                   <parameter><decl><type><name>bool</name></type>    <name>sentToRemote</name></decl></parameter>,
                   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecDropStmt</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
                    <parameter><decl><type><name>bool</name></type> <name>sentToRemote</name></decl></parameter>,
                    <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecDropStmt</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * CommandIsReadOnly: is an executable query read-only?
 *
 * This is a much stricter test than we apply for XactReadOnly mode;
 * the query must be *in truth* read-only, because the caller wishes
 * not to do CommandCounterIncrement for it.
 *
 * Note: currently no need to support raw or analyzed queries here
 */</comment>
<function><type><name>bool</name></type>
<name>CommandIsReadOnly</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>CMD_SELECT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if>    <comment type="block">/* SELECT FOR [KEY] UPDATE/SHARE */</comment>
            <if type="elseif">else if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if>    <comment type="block">/* data-modifying CTE */</comment>
            <else>else<block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>
        <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
        <case>case <expr><name>CMD_INSERT</name></expr>:</case>
        <case>case <expr><name>CMD_DELETE</name></expr>:</case>
            <return>return <expr><name>false</name></expr>;</return>
        <case>case <expr><name>CMD_UTILITY</name></expr>:</case>
            <comment type="block">/* For now, treat all utility commands as read/write */</comment>
            <return>return <expr><name>false</name></expr>;</return>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized commandType: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check_xact_readonly: is a utility command read-only?
 *
 * Here we use the loose rules of XactReadOnly mode: no permanent effects
 * on the database are allowed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_xact_readonly</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* Only perform the check if we have a reason to do so. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>XactReadOnly</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>GTM_ReadOnly</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Note: Commands that need to do more complicated checking are handled
     * elsewhere, in particular COPY and plannable statements do their own
     * checking.  However they should all call PreventCommandIfReadOnly or
     * PreventCommandIfParallelMode to actually throw the error.
     */</comment>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_AlterDatabaseStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterDatabaseSetStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterDomainStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterFunctionStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterOperatorStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterTableMoveAllStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
        <case>case <expr><name>T_RenameStmt</name></expr>:</case>
        <case>case <expr><name>T_CommentStmt</name></expr>:</case>
        <case>case <expr><name>T_DefineStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateCastStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateEventTrigStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterEventTrigStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateConversionStmt</name></expr>:</case>
        <case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateDomainStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateFunctionStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
        <case>case <expr><name>T_IndexStmt</name></expr>:</case>
        <case>case <expr><name>T_CreatePLangStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateOpClassStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateOpFamilyStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterOpFamilyStmt</name></expr>:</case>
        <case>case <expr><name>T_RuleStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
        <case>case <expr><name>T_RefreshMatViewStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateTableSpaceStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateTransformStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
        <case>case <expr><name>T_CompositeTypeStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateEnumStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateRangeStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterEnumStmt</name></expr>:</case>
        <case>case <expr><name>T_ViewStmt</name></expr>:</case>
        <case>case <expr><name>T_DropStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_DropStmt</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>DropStmt</name>   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DropStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name> <operator>==</operator> <name>OBJECT_PUBLICATION</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>XactReadOnly</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsInParallelMode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>IS_PGXC_DATANODE</name></expr>)</condition>
                        <block>{<block_content>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_RenameStmt</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>RenameStmt</name>   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                    <comment type="block">/* alter replication_slot rename is allowed on datanode */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_REPLICATION_SLOT</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>XactReadOnly</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsInParallelMode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>IS_PGXC_DATANODE</name></expr>)</condition>
                        <block>{<block_content>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>T_DropdbStmt</name></expr>:</case>
        <case>case <expr><name>T_DropTableSpaceStmt</name></expr>:</case>
        <case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
        <case>case <expr><name>T_GrantStmt</name></expr>:</case>
        <case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>
        <case>case <expr><name>T_TruncateStmt</name></expr>:</case>
        <case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
        <case>case <expr><name>T_ReassignOwnedStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterTSDictionaryStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterTSConfigurationStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateExtensionStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterExtensionStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterExtensionContentsStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateFdwStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterFdwStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateForeignServerStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterForeignServerStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateUserMappingStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterUserMappingStmt</name></expr>:</case>
        <case>case <expr><name>T_DropUserMappingStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterTableSpaceOptionsStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
        <case>case <expr><name>T_ImportForeignSchemaStmt</name></expr>:</case>
        <case>case <expr><name>T_SecLabelStmt</name></expr>:</case>
        <case>case <expr><name>T_CreatePublicationStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterPublicationStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
        <case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_CreatePublicationStmt</name> <operator>||</operator>
                    <call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_CreateSubscriptionStmt</name> <operator>||</operator>
                    <call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_DropSubscriptionStmt</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>XactReadOnly</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsInParallelMode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>IS_PGXC_DATANODE</name></expr>)</condition>
                    <block>{<block_content>
                        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
                        <comment type="block">/* TBASE SUBSCRIPTION is not allowed on DATANODE */</comment>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTbaseSubscription</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <break>break;</break></block_content></block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
        <case>case <expr><name>T_AuditStmt</name></expr>:</case>
        <case>case <expr><name>T_CleanAuditStmt</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>PreventCommandIfReadOnly</name><argument_list>(<argument><expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PreventCommandIfParallelMode</name><argument_list>(<argument><expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <comment type="block">/* do nothing */</comment>
            <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * PreventCommandIfReadOnly: throw error if XactReadOnly or GTM_ReadOnly
 *
 * This is useful mainly to ensure consistency of the error message wording;
 * most callers have checked XactReadOnly for themselves.
 */</comment>
<function><type><name>void</name></type>
<name>PreventCommandIfReadOnly</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>XactReadOnly</name> <operator>||</operator> <name>GTM_ReadOnly</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_READ_ONLY_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/* translator: %s is name of a SQL command, eg CREATE */</comment>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute %s in a read-only %s"</literal></expr></argument>,
                        <argument><expr><name>cmdname</name></expr></argument>,<argument><expr><ternary><condition><expr><name>XactReadOnly</name></expr> ?</condition><then> <expr><literal type="string">"transaction"</literal></expr> </then><else>: <expr><literal type="string">"gtm"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PreventCommandIfParallelMode: throw error if current (sub)transaction is
 * in parallel mode.
 *
 * This is useful mainly to ensure consistency of the error message wording;
 * most callers have checked IsInParallelMode() for themselves.
 */</comment>
<function><type><name>void</name></type>
<name>PreventCommandIfParallelMode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/* translator: %s is name of a SQL command, eg CREATE */</comment>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute %s during a parallel operation"</literal></expr></argument>,
                        <argument><expr><name>cmdname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PreventCommandDuringRecovery: throw error if RecoveryInProgress
 *
 * The majority of operations that are unsafe in a Hot Standby
 * will be rejected by XactReadOnly tests.  However there are a few
 * commands that are allowed in "read-only" xacts but cannot be allowed
 * in Hot Standby mode.  Those commands should call this function.
 */</comment>
<function><type><name>void</name></type>
<name>PreventCommandDuringRecovery</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_READ_ONLY_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/* translator: %s is name of a SQL command, eg CREATE */</comment>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute %s during recovery"</literal></expr></argument>,
                        <argument><expr><name>cmdname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CheckRestrictedOperation: throw error for hazardous command if we're
 * inside a security restriction context.
 *
 * This is needed to protect session-local state for which there is not any
 * better-defined protection mechanism, such as ownership.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckRestrictedOperation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>InSecurityRestrictedOperation</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/* translator: %s is name of a SQL command, eg PREPARE */</comment>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute %s within security-restricted operation"</literal></expr></argument>,
                        <argument><expr><name>cmdname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ProcessUtility
 *        general utility function invoker
 *
 *    pstmt: PlannedStmt wrapper for the utility statement
 *    queryString: original source text of command
 *    context: identifies source of statement (toplevel client command,
 *        non-toplevel client command, subcommand of a larger utility command)
 *    params: parameters to use during execution
 *    queryEnv: environment for parse through execution (e.g., ephemeral named
 *        tables like trigger transition tables).  May be NULL.
 *    dest: where to send results
 *    completionTag: points to a buffer of size COMPLETION_TAG_BUFSIZE
 *        in which to store a command completion status string.
 *
 * Caller MUST supply a queryString; it is not allowed (anymore) to pass NULL.
 * If you really don't have source text, you can pass a constant string,
 * perhaps "(query not available)".
 *
 * completionTag is only set nonempty if we want to return a nondefault status.
 *
 * completionTag may be NULL if caller doesn't want a status string.
 *
 * Note for users of ProcessUtility_hook: the same queryString may be passed
 * to multiple invocations of ProcessUtility when processing a query string
 * containing multiple semicolon-separated statements.  One should use
 * pstmt-&gt;stmt_location and pstmt-&gt;stmt_len to identify the substring
 * containing the current statement.  Keep in mind also that some utility
 * statements (e.g., CREATE SCHEMA) will recurse to ProcessUtility to process
 * sub-statements, often passing down the same queryString, stmt_location,
 * and stmt_len that were given for the whole statement.
 */</comment>
<function><type><name>void</name></type>
<name>ProcessUtility</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
               <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
               <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
               <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
               <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
               <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
               <parameter><decl><type><name>bool</name></type> <name>sentToRemote</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
               <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryString</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* required as of 8.4 */</comment>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SetSendCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * We provide a function hook variable that lets loadable plugins get
     * control when ProcessUtility is called.  Such a plugin would normally
     * call standard_ProcessUtility().
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>ProcessUtility_hook</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call>(<modifier>*</modifier><name>ProcessUtility_hook</name>) <argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
                                <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
                                <argument><expr><name>dest</name></expr></argument>,
                                <argument><expr><name>sentToRemote</name></expr></argument>,
                                <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>standard_ProcessUtility</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
                                <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
                                <argument><expr><name>dest</name></expr></argument>,
                                <argument><expr><name>sentToRemote</name></expr></argument>,
                                <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Do the necessary processing before executing the utility command locally on
 * the coordinator.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ProcessUtilityPre</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
                        <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
                        <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>sentToRemote</name></decl></parameter>,
                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isTopLevel</name> <init>= <expr><operator>(</operator><name>context</name> <operator>==</operator> <name>PROCESS_UTILITY_TOPLEVEL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>all_done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_temp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>auto_commit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>add_context</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQueryExecType</name></type>    <name>exec_type</name> <init>= <expr><name>EXEC_ON_NONE</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * auto_commit and is_temp is initialised to false and changed if required.
     *
     * exec_type is initialised to EXEC_ON_NONE and updated iff the command
     * needs remote execution during the preprocessing step.
     */</comment>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
            <comment type="block">/*
             * ******************** transactions ********************
             */</comment>
        <case>case <expr><name>T_TransactionStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>TransactionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>TransactionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>TRANS_STMT_BEGIN</name></expr>:</case>
                    <case>case <expr><name>TRANS_STMT_START</name></expr>:</case>
                    <case>case <expr><name>TRANS_STMT_COMMIT</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <case>case <expr><name>TRANS_STMT_BEGIN_SUBTXN</name></expr>:</case>
                    <case>case <expr><name>TRANS_STMT_ROLLBACK_SUBTXN</name></expr>:</case>
                    <case>case <expr><name>TRANS_STMT_COMMIT_SUBTXN</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <break>break;</break>

                    <case>case <expr><name>TRANS_STMT_PREPARE</name></expr>:</case>
                        <expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"PREPARE TRANSACTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* Add check if xid is valid */</comment>
                        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>xc_maintenance_mode</name></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><call><name>IsXidImplicit</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>stmt</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid transaciton_id to prepare."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <break>break;</break>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                        <break>break;</break>

                    <case>case <expr><name>TRANS_STMT_COMMIT_PREPARED</name></expr>:</case>
                        <expr_stmt><expr><call><name>PreventTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"COMMIT PREPARED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"COMMIT PREPARED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/*
                         * Commit a transaction which was explicitely prepared
                         * before
                         */</comment>
                        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FinishRemotePreparedTransaction</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>xc_maintenance_mode</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>all_done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* No need to commit locally */</comment>
                        </block_content>}</block></if></if_stmt>
                        <break>break;</break>

                    <case>case <expr><name>TRANS_STMT_ROLLBACK_PREPARED</name></expr>:</case>
                        <expr_stmt><expr><call><name>PreventTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK PREPARED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"ROLLBACK PREPARED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FinishRemotePreparedTransaction</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>xc_maintenance_mode</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>all_done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                        <break>break;</break>

					<case>case <expr><name>TRANS_STMT_COMMIT_PREPARED_CHECK</name></expr>:</case>
						<expr_stmt><expr><call><name>PreventTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"COMMIT PREPARED CHECK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"COMMIT PREPARED CHECK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"COMMIT PREPARED %s FOR CHECK ONLY"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_ROLLBACK_PREPARED_CHECK</name></expr>:</case>
						<expr_stmt><expr><call><name>PreventTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK PREPARED CHECK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"ROLLBACK PREPARED CHECK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK PREPARED %s FOR CHECK ONLY"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

                    <case>case <expr><name>TRANS_STMT_ROLLBACK</name></expr>:</case>
                        <break>break;</break>

                    <case>case <expr><name>TRANS_STMT_SAVEPOINT</name></expr>:</case>
                        <break>break;</break>

                    <case>case <expr><name>TRANS_STMT_RELEASE</name></expr>:</case>
                        <break>break;</break>

                    <case>case <expr><name>TRANS_STMT_ROLLBACK_TO</name></expr>:</case>
                        <comment type="block">/*
                         * CommitTransactionCommand is in charge of
                         * re-defining the savepoint again
                         */</comment>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block>
            <break>break;</break>

            <comment type="block">/*
             * Portal (cursor) manipulation
             */</comment>
        <case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
        <case>case <expr><name>T_ClosePortalStmt</name></expr>:</case>
        <case>case <expr><name>T_FetchStmt</name></expr>:</case>
        <case>case <expr><name>T_DoStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateTableSpaceStmt</name></expr>:</case>
        <case>case <expr><name>T_DropTableSpaceStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterTableSpaceOptionsStmt</name></expr>:</case>
        <case>case <expr><name>T_TruncateStmt</name></expr>:</case>
        <case>case <expr><name>T_CopyStmt</name></expr>:</case>
        <case>case <expr><name>T_PrepareStmt</name></expr>:</case>
        <case>case <expr><name>T_ExecuteStmt</name></expr>:</case>
        <case>case <expr><name>T_DeallocateStmt</name></expr>:</case>
        <case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
        <case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterDatabaseStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterDatabaseSetStmt</name></expr>:</case>
            <break>break;</break>

        <case>case <expr><name>T_DropdbStmt</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>DropdbStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DropdbStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type> <name><name>query</name><index>[<expr><name>STRINGLENGTH</name></expr>]</index></name></decl>;</decl_stmt>

				<comment type="block">/* Clean connections before dropping a database on local node */</comment>
                <expr_stmt><expr><call><name>DropDBCleanConnection</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Clean also remote Coordinators */</comment>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>STRINGLENGTH</name></expr></argument>, <argument><expr><literal type="string">"CLEAN CONNECTION TO ALL FOR DATABASE %s;"</literal></expr></argument>,
                        <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                        <argument><expr><name>EXEC_ON_ALL_NODES</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * parallel ddl mode, we send drop db prepare in standard_ProcessUtility 
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>prepare</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_txn_has_parallel_ddl</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Lock database and check the constraints before we actually dropping */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>STRINGLENGTH</name></expr></argument>, <argument><expr><literal type="string">"DROP DATABASE PREPARE IF EXISTS %s;"</literal></expr></argument>,
						        <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>STRINGLENGTH</name></expr></argument>, <argument><expr><literal type="string">"DROP DATABASE PREPARE %s;"</literal></expr></argument>,
						        <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					                       <argument><expr><name>EXEC_ON_ALL_NODES</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>

            <comment type="block">/* Query-level asynchronous notification */</comment>
        <case>case <expr><name>T_NotifyStmt</name></expr>:</case>
        <case>case <expr><name>T_ListenStmt</name></expr>:</case>
        <case>case <expr><name>T_UnlistenStmt</name></expr>:</case>
        <case>case <expr><name>T_LoadStmt</name></expr>:</case>
        <case>case <expr><name>T_ClusterStmt</name></expr>:</case>
            <break>break;</break>

        <case>case <expr><name>T_VacuumStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>VacuumStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* we choose to allow this during "read only" transactions */</comment>
                <expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator></expr> ?</condition><then>
                                             <expr><literal type="string">"VACUUM"</literal></expr> </then><else>: <expr><literal type="string">"ANALYZE"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/*
                 * We have to run the command on nodes before Coordinator because
                 * vacuum() pops active snapshot and we can not send it to nodes
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_COORDINATOR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_DATANODES</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>auto_commit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <case>case <expr><name>T_VacuumShardStmt</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>T_ExplainStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterSystemStmt</name></expr>:</case>
        <case>case <expr><name>T_VariableSetStmt</name></expr>:</case>
        <case>case <expr><name>T_VariableShowStmt</name></expr>:</case>
        <case>case <expr><name>T_DiscardStmt</name></expr>:</case>
            <break>break;</break>

        <case>case <expr><name>T_CreateEventTrigStmt</name></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,            
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"EVENT TRIGGER not yet supported in Postgres-XL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterEventTrigStmt</name></expr>:</case>
            <break>break;</break>

            <comment type="block">/*
             * ******************************** ROLE statements ****
             */</comment>
        <case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
        <case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
        <case>case <expr><name>T_ReassignOwnedStmt</name></expr>:</case>
        <case>case <expr><name>T_LockStmt</name></expr>:</case>
        <case>case <expr><name>T_ConstraintsSetStmt</name></expr>:</case>
        <case>case <expr><name>T_CheckPointStmt</name></expr>:</case>
            <break>break;</break>

        <case>case <expr><name>T_BarrierStmt</name></expr>:</case>
            <expr_stmt><expr><call><name>RequestBarrier</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>BarrierStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>id</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_PauseClusterStmt</name></expr>:</case>
            <expr_stmt><expr><call><name>RequestClusterPause</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>PauseClusterStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>pause</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

            <comment type="block">/*
             * Node DDL is an operation local to Coordinator.
             * In case of a new node being created in the cluster,
             * it is necessary to create this node on all the Coordinators independently.
             */</comment>
        <case>case <expr><name>T_AlterNodeStmt</name></expr>:</case>
            <expr_stmt><expr><call><name>PgxcNodeAlter</name><argument_list>(<argument><expr><operator>(</operator><name>AlterNodeStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>AlterNodeStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>cluster</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>all_done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateNodeStmt</name></expr>:</case>
            <expr_stmt><expr><call><name>PgxcNodeCreate</name><argument_list>(<argument><expr><operator>(</operator><name>CreateNodeStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>all_done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DropNodeStmt</name></expr>:</case>
            <expr_stmt><expr><call><name>PgxcNodeRemove</name><argument_list>(<argument><expr><operator>(</operator><name>DropNodeStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>all_done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
            
        <comment type="block">/* group DDL should broad cast to all other coordinator */</comment>
        <case>case <expr><name>T_CreateGroupStmt</name></expr>:</case>
            <expr_stmt><expr><call><name>PgxcGroupCreate</name><argument_list>(<argument><expr><operator>(</operator><name>CreateGroupStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>isRestoreMode</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>                        
				<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>EXEC_ON_ALL_NODES</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>all_done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterGroupStmt</name></expr>:</case>
            <expr_stmt><expr><call><name>PgxcGroupAlter</name><argument_list>(<argument><expr><operator>(</operator><name>AlterGroupStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>IS_PGXC_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>                        
				<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>EXEC_ON_ALL_NODES</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>all_done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DropGroupStmt</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/* Check shard info on group */</comment>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>groupname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>   <name>groupoid</name>  <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>groupname</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>DropGroupStmt</name> <operator>*</operator><operator>)</operator><name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>group_name</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>groupoid</name> <operator>=</operator> <call><name>get_pgxc_groupoid</name><argument_list>(<argument><expr><name>groupname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>is_group_sharding_inited</name><argument_list>(<argument><expr><name>groupoid</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"shard info exist in group:%s groupoid:%d"</literal></expr></argument>, <argument><expr><name>groupname</name></expr></argument>, <argument><expr><name>groupoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                
                <expr_stmt><expr><call><name>PgxcGroupRemove</name><argument_list>(<argument><expr><operator>(</operator><name>DropGroupStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
                <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>IS_PGXC_COORDINATOR</name></expr>)</condition>
                <block>{<block_content>                        
					<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
											<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>EXEC_ON_ALL_NODES</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><name>all_done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
        <case>case <expr><name>T_CreateShardStmt</name></expr>:</case>
        <case>case <expr><name>T_CleanShardingStmt</name></expr>:</case>
        <case>case <expr><name>T_DropShardStmt</name></expr>:</case>
        <case>case <expr><name>T_MoveDataStmt</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
        <case>case <expr><name>T_CreateKeyValuesStmt</name></expr>:</case>
        <case>case <expr><name>T_CheckOverLapStmt</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <case>case <expr><name>T_LockNodeStmt</name></expr>:</case>
		<case>case <expr><name>T_SampleStmt</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>T_ReindexStmt</name></expr>:</case>
        <case>case <expr><name>T_GrantStmt</name></expr>:</case>
        <case>case <expr><name>T_DropStmt</name></expr>:</case>
            <break>break;</break>

        <case>case <expr><name>T_RenameStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
                <block>{<block_content>
					<expr_stmt><expr><name>exec_type</name> <operator>=</operator> <call><name>GetRenameExecType</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<if_stmt><if>if <condition>(<expr><name>LOCAL_PARALLEL_DDL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <comment type="block">/* clean connections of the old name first. */</comment>
                    <if_stmt><if>if <condition>(<expr><name>OBJECT_DATABASE</name> <operator>==</operator> <name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>char</name></type> <name><name>query</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name>DropDBCleanConnection</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* Clean also remote nodes */</comment>
                        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"CLEAN CONNECTION TO ALL FOR DATABASE %s;"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>EXEC_ON_ALL_NODES</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
            <break>break;</break>

        <case>case <expr><name>T_RemoteQuery</name></expr>:</case>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>IS_PGXC_COORDINATOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/*
             * Do not launch query on Other Datanodes if remote connection is a Coordinator one
             * it will cause a deadlock in the cluster at Datanode levels.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<if_stmt><if>if <condition>(<expr><name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PGXCNodeHandle</name><modifier>*</modifier></type> <name>leaderCnHandle</name> <init>= <expr><call><name>find_ddl_leader_cn</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>RemoteQueryExecType</name></type> <name>execType</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RemoteQuery</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>exec_type</name></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><operator>(</operator><name>execType</name> <operator>==</operator> <name>EXEC_ON_ALL_NODES</name> <operator>||</operator> <name>execType</name> <operator>==</operator> <name>EXEC_ON_COORDS</name><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_ddl_leader_cn</name><argument_list>(<argument><expr><name><name>leaderCnHandle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leader_cn_executed_ddl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>ExecRemoteUtility</name><argument_list>(<argument><expr><operator>(</operator><name>RemoteQuery</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
										<argument><expr><name>leaderCnHandle</name></expr></argument>, <argument><expr><name>EXCLUED_LEADER_DDL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecRemoteUtility</name><argument_list>(<argument><expr><operator>(</operator><name>RemoteQuery</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NON_PARALLEL_DDL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><call><name>ExecRemoteUtility</name><argument_list>(<argument><expr><operator>(</operator><name>RemoteQuery</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CleanConnStmt</name></expr>:</case>
            <comment type="block">/*
             * First send command to other nodes via probably existing
             * connections, then clean local pooler
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                        <argument><expr><name>EXEC_ON_ALL_NODES</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>CleanConnection</name><argument_list>(<argument><expr><operator>(</operator><name>CleanConnStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CommentStmt</name></expr>:</case>
        <case>case <expr><name>T_SecLabelStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterDomainStmt</name></expr>:</case>
        <case>case <expr><name>T_DefineStmt</name></expr>:</case>
            <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
        <case>case <expr><name>T_AuditStmt</name></expr>:</case>
        <case>case <expr><name>T_CleanAuditStmt</name></expr>:</case>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <case>case <expr><name>T_IndexStmt</name></expr>:</case>    <comment type="block">/* CREATE INDEX */</comment>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_concurrently_index</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* concurrent INDEX is permmitted now */</comment>
                    <decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC does not support concurrent INDEX yet"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The feature is not currently supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_CreateExtensionStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterExtensionStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterExtensionContentsStmt</name></expr>:</case>
            <break>break;</break>

        <case>case <expr><name>T_CreateFdwStmt</name></expr>:</case>
            <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterFdwStmt</name></expr>:</case>
            <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateForeignServerStmt</name></expr>:</case>
            <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterForeignServerStmt</name></expr>:</case>
            <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateUserMappingStmt</name></expr>:</case>
            <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterUserMappingStmt</name></expr>:</case>
        <case>case <expr><name>T_DropUserMappingStmt</name></expr>:</case>
            <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_ImportForeignSchemaStmt</name></expr>:</case>
            <break>break;</break>
        <case>case <expr><name>T_CompositeTypeStmt</name></expr>:</case>    <comment type="block">/* CREATE TYPE (composite) */</comment>
        <case>case <expr><name>T_CreateEnumStmt</name></expr>:</case>    <comment type="block">/* CREATE TYPE AS ENUM */</comment>
        <case>case <expr><name>T_CreateRangeStmt</name></expr>:</case> <comment type="block">/* CREATE TYPE AS RANGE */</comment>
        <case>case <expr><name>T_AlterEnumStmt</name></expr>:</case>    <comment type="block">/* ALTER TYPE (enum) */</comment>
        <case>case <expr><name>T_ViewStmt</name></expr>:</case>    <comment type="block">/* CREATE VIEW */</comment>
        <case>case <expr><name>T_CreateFunctionStmt</name></expr>:</case>    <comment type="block">/* CREATE FUNCTION */</comment>
        <case>case <expr><name>T_AlterFunctionStmt</name></expr>:</case>    <comment type="block">/* ALTER FUNCTION */</comment>
        <case>case <expr><name>T_RuleStmt</name></expr>:</case>    <comment type="block">/* CREATE RULE */</comment>
        <case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
            <break>break;</break>

        <case>case <expr><name>T_RefreshMatViewStmt</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RefreshMatViewStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>RefreshMatViewStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_COORDS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <block>{<block_content>
            <comment type="block">/* 
              * trigger is already supported on shard table, we do all DML/truncate with triggers on
              * coordinator instead of datanode.
                        */</comment>
            <decl_stmt><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CreateTrigStmt</name> <operator>*</operator><operator>)</operator><name>parsetree</name></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>relation_openrv_extended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>rel</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rd_locator_info</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name></name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>rd_locator_info</name> <operator>&amp;&amp;</operator> <name><name>rd_locator_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>rd_locator_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>whenClause</name></name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"constraint trigger or trigger with qual expression "</literal> 
                                            <literal type="string">"is not supported on interval partition table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"TRIGGER is not supported on cold/hot or key/value table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifndef>
                <if_stmt><if>if <condition>(<expr><name>rd_locator_info</name> <operator>&amp;&amp;</operator> <name><name>rd_locator_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_REPLICATED</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"TRIGGER is not supported on replication table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_datanode_row_triggers</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Postgres-XC does not support yet triggers */</comment>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Postgres-XL does not support TRIGGER yet"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The feature is not currently supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>CreateTrigStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>row</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"STATEMENT triggers not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Though enable_datanode_row_triggers "</literal>
                                 <literal type="string">"is ON, Postgres-XL only supports ROW "</literal>
                                 <literal type="string">"triggers"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Developer option "</literal>
                            <literal type="string">"enable_datanode_row_triggers is ON. "</literal>
                            <literal type="string">"Triggers will be executed on the datanodes "</literal>
                            <literal type="string">"and must not require access to other nodes. "</literal>
                            <literal type="string">"Use with caution"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <break>break;</break>

        <case>case <expr><name>T_CreatePLangStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateDomainStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateConversionStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateCastStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateOpClassStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateOpFamilyStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateTransformStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterOpFamilyStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterTSDictionaryStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterTSConfigurationStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterTableMoveAllStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterOperatorStmt</name></expr>:</case>
        <case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>
        <case>case <expr><name>T_CreatePolicyStmt</name></expr>:</case>    <comment type="block">/* CREATE POLICY */</comment>
        <case>case <expr><name>T_AlterPolicyStmt</name></expr>:</case> <comment type="block">/* ALTER POLICY */</comment>
        <case>case <expr><name>T_CreateAmStmt</name></expr>:</case>
            <break>break;</break>

        <case>case <expr><name>T_CreatePublicationStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COORDINATOR does not support CREATE PUBLICATION"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The feature is not currently supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <comment type="block">/* Postgres-XC does not support publications */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Postgres-XL does not support CREATE PUBLICATION"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The feature is not currently supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <break>break;</break>

        <case>case <expr><name>T_AlterPublicationStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>AlterPublicationStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>tableAction</name> <operator>!=</operator> <name>DEFELEM_ADD</name> <operator>&amp;&amp;</operator>
 				<operator>(</operator><operator>(</operator><name>AlterPublicationStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>tableAction</name> <operator>!=</operator> <name>DEFELEM_DROP</name></expr>)</condition>
 			<block>{<block_content>
 				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
 						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
 						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Postgres-XL only support ALTER PUBLICATION ... ADD/DROP TABLE "</literal></expr></argument>)</argument_list></call><operator>,</operator>
 						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The feature is not currently supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <break>break;</break>

        <case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTbaseSubscription</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COORDINATOR only supports CREATE TBASE SUBSCRIPTION"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The feature is not currently supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
            <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>IsTbaseSubscription</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DATANODE only supports CREATE SUBSCRIPTION"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The feature is not currently supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operation on SUBSCRIPTION is not allowed on this node"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <break>break;</break>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <comment type="block">/* Postgres-XC does not support subscriptions */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Postgres-XL does not support CREATE SUBSCRIPTION"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The feature is not currently supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <break>break;</break>

        <case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PUB_SUB_RELIABLE_</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ALTER_SUBSCRIPTION_CONNECTION</name> <operator>!=</operator> <operator>(</operator><operator>(</operator><name>AlterSubscriptionStmt</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>kind</name><operator>)</operator>
                <operator>&amp;&amp;</operator> <operator>(</operator><name>ALTER_SUBSCRIPTION_REFRESH</name> <operator>!=</operator> <operator>(</operator><operator>(</operator><name>AlterSubscriptionStmt</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>kind</name><operator>)</operator>
                <operator>&amp;&amp;</operator> <operator>(</operator><name>ALTER_SUBSCRIPTION_ENABLED</name> <operator>!=</operator> <operator>(</operator><operator>(</operator><name>AlterSubscriptionStmt</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>kind</name><operator>)</operator>
                <operator>&amp;&amp;</operator> <operator>(</operator><name>ALTER_SUBSCRIPTION_OPTIONS</name> <operator>!=</operator> <operator>(</operator><operator>(</operator><name>AlterSubscriptionStmt</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>kind</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TBase only supports ALTER [TBASE] SUBSCRIPTION XXX connection '...'; "</literal>
                     <literal type="string">"and ALTER [TBASE] SUBSCRIPTION XXX REFRESH PUBLICATION ...; "</literal>
                     <literal type="string">"and ALTER [TBASE] SUBSCRIPTION XXX DISABLE; "</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTbaseSubscription</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COORDINATOR only supports ALTER TBASE SUBSCRIPTION"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The feature is not currently supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>IsTbaseSubscription</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DATANODE only supports ALTER SUBSCRIPTION"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The feature is not currently supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operation on SUBSCRIPTION is not allowed on this node"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>            
            <break>break;</break>
        <case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTbaseSubscription</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COORDINATOR only supports DROP TBASE SUBSCRIPTION"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The feature is not currently supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>IsTbaseSubscription</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DATANODE only supports DROP SUBSCRIPTION"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The feature is not currently supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operation on SUBSCRIPTION is not allowed on this node"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>T_CreateStatsStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterCollationStmt</name></expr>:</case>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
    
    <comment type="block">/*
     * Send queryString to remote nodes, if needed.
     */</comment> 
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>auto_commit</name></expr></argument>,
                <argument><expr><name>exec_type</name></expr></argument>, <argument><expr><name>is_temp</name></expr></argument>, <argument><expr><name>add_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>all_done</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessUtilityPost</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
                        <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
                        <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>sentToRemote</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_temp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>auto_commit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>add_context</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQueryExecType</name></type>    <name>exec_type</name> <init>= <expr><name>EXEC_ON_NONE</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * auto_commit and is_temp is initialised to false and changed if required.
     *
     * exec_type is initialised to EXEC_ON_NONE and updated iff the command
     * needs remote execution during the preprocessing step.
     */</comment>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
            <comment type="block">/*
             * ******************** transactions ********************
             */</comment>
        <case>case <expr><name>T_TransactionStmt</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>TransactionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>TransactionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* execute savepoint on all nodes */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>TRANS_STMT_SAVEPOINT</name> <operator>||</operator>
                <name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>TRANS_STMT_RELEASE</name> <operator>||</operator>
                <name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>TRANS_STMT_ROLLBACK_TO</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>add_context</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
        <case>case <expr><name>T_ClosePortalStmt</name></expr>:</case>
        <case>case <expr><name>T_FetchStmt</name></expr>:</case>
        <case>case <expr><name>T_DoStmt</name></expr>:</case>
        <case>case <expr><name>T_CopyStmt</name></expr>:</case>
        <case>case <expr><name>T_PrepareStmt</name></expr>:</case>
        <case>case <expr><name>T_ExecuteStmt</name></expr>:</case>
        <case>case <expr><name>T_DeallocateStmt</name></expr>:</case>
        <case>case <expr><name>T_NotifyStmt</name></expr>:</case>
        <case>case <expr><name>T_ListenStmt</name></expr>:</case>
        <case>case <expr><name>T_UnlistenStmt</name></expr>:</case>
        <case>case <expr><name>T_VacuumStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <case>case <expr><name>T_VacuumShardStmt</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>T_ExplainStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterSystemStmt</name></expr>:</case>
        <case>case <expr><name>T_VariableSetStmt</name></expr>:</case>
        <case>case <expr><name>T_VariableShowStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateEventTrigStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterEventTrigStmt</name></expr>:</case>
        <case>case <expr><name>T_BarrierStmt</name></expr>:</case>
        <case>case <expr><name>T_PauseClusterStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterNodeStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateNodeStmt</name></expr>:</case>
        <case>case <expr><name>T_DropNodeStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateGroupStmt</name></expr>:</case>
        <case>case <expr><name>T_DropGroupStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterGroupStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
        <case>case <expr><name>T_CreateShardStmt</name></expr>:</case>
        <case>case <expr><name>T_CleanShardingStmt</name></expr>:</case>
        <case>case <expr><name>T_DropShardStmt</name></expr>:</case>
        <case>case <expr><name>T_MoveDataStmt</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
        <case>case <expr><name>T_CreateKeyValuesStmt</name></expr>:</case>
        <case>case <expr><name>T_CheckOverLapStmt</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <case>case <expr><name>T_LockNodeStmt</name></expr>:</case>
		<case>case <expr><name>T_SampleStmt</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>T_DropStmt</name></expr>:</case>
        <case>case <expr><name>T_RenameStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
        <case>case <expr><name>T_RemoteQuery</name></expr>:</case>
        <case>case <expr><name>T_CleanConnStmt</name></expr>:</case>
        <case>case <expr><name>T_SecLabelStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateFdwStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterFdwStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateForeignServerStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterForeignServerStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateUserMappingStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterUserMappingStmt</name></expr>:</case>
        <case>case <expr><name>T_DropUserMappingStmt</name></expr>:</case>
        <case>case <expr><name>T_ImportForeignSchemaStmt</name></expr>:</case>
        <case>case <expr><name>T_RefreshMatViewStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateTransformStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterOperatorStmt</name></expr>:</case>
        <case>case <expr><name>T_CreatePublicationStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterPublicationStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
        <case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterCollationStmt</name></expr>:</case>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
        <case>case <expr><name>T_AuditStmt</name></expr>:</case>
        <case>case <expr><name>T_CleanAuditStmt</name></expr>:</case>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>T_CreateTableSpaceStmt</name></expr>:</case>
        <case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
            <expr_stmt><expr><name>add_context</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt>
            <break>break;</break>
		<case>case <expr><name>T_DropdbStmt</name></expr>:</case>
		<case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
        <case>case <expr><name>T_DropTableSpaceStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>LOCAL_PARALLEL_DDL</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt>
			<break>break;</break>
        <case>case <expr><name>T_AlterTableSpaceOptionsStmt</name></expr>:</case>
        <case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterDatabaseSetStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
        <case>case <expr><name>T_ReassignOwnedStmt</name></expr>:</case>
        <case>case <expr><name>T_LockStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterDomainStmt</name></expr>:</case>
        <case>case <expr><name>T_DefineStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterExtensionStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterExtensionContentsStmt</name></expr>:</case>
        <case>case <expr><name>T_CompositeTypeStmt</name></expr>:</case>    <comment type="block">/* CREATE TYPE (composite) */</comment>
        <case>case <expr><name>T_CreateEnumStmt</name></expr>:</case>    <comment type="block">/* CREATE TYPE AS ENUM */</comment>
        <case>case <expr><name>T_CreateRangeStmt</name></expr>:</case> <comment type="block">/* CREATE TYPE AS RANGE */</comment>
        <case>case <expr><name>T_CreateFunctionStmt</name></expr>:</case>    <comment type="block">/* CREATE FUNCTION */</comment>
        <case>case <expr><name>T_AlterFunctionStmt</name></expr>:</case>    <comment type="block">/* ALTER FUNCTION */</comment>
        <case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
        <case>case <expr><name>T_CreatePLangStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateDomainStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateConversionStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateCastStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateOpClassStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateOpFamilyStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterOpFamilyStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterTSDictionaryStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterTSConfigurationStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterTableMoveAllStmt</name></expr>:</case>
        <case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>
        <case>case <expr><name>T_CreatePolicyStmt</name></expr>:</case>    <comment type="block">/* CREATE POLICY */</comment>
        <case>case <expr><name>T_AlterPolicyStmt</name></expr>:</case> <comment type="block">/* ALTER POLICY */</comment>
        <case>case <expr><name>T_CreateAmStmt</name></expr>:</case>
            <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt>
            <break>break;</break>
            
        <case>case <expr><name>T_CreateExtensionStmt</name></expr>:</case>
            <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_NONE</name></expr>;</expr_stmt>
            <break>break;</break>
            
        <case>case <expr><name>T_TruncateStmt</name></expr>:</case>
            <comment type="block">/*
             * Check details of the object being truncated.
             * If at least one temporary table is truncated truncate cannot use 2PC
             * at commit.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>TruncateStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>TruncateStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>stmt-&gt;relations</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>IsTempTable</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>is_temp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block>

				<comment type="block">/*
				 * Also truncate on coordinators which makes parallel ddl possible.
				 * temp table only exists on current coordinator
				 * which parallel ddl has no effect.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_temp</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
                <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_DATANODES</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

			</block_content>}</block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterDatabaseStmt</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * If this is not a SET TABLESPACE statement, just propogate the
                 * cmd as usual.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>IsSetTableSpace</name><argument_list>(<argument><expr><operator>(</operator><name>AlterDatabaseStmt</name><operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>add_context</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_LoadStmt</name></expr>:</case>
        <case>case <expr><name>T_ConstraintsSetStmt</name></expr>:</case>
            <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_DATANODES</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ClusterStmt</name></expr>:</case>
        <case>case <expr><name>T_CheckPointStmt</name></expr>:</case>
            <expr_stmt><expr><name>auto_commit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_DATANODES</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DiscardStmt</name></expr>:</case>
            <comment type="block">/*
             * Discard objects for all the sessions possible.
             * For example, temporary tables are created on all Datanodes
             * and Coordinators.
             */</comment>
            <expr_stmt><expr><name>auto_commit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ReindexStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ReindexStmt</name>         <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ReindexStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>                    <name>relid</name></decl>;</decl_stmt>

                <comment type="block">/* forbidden in parallel mode due to CommandIsReadOnly */</comment>
                <switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>REINDEX_OBJECT_INDEX</name></expr>:</case>
                    <case>case <expr><name>REINDEX_OBJECT_TABLE</name></expr>:</case>
                        <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <call><name>ExecUtilityFindNodesRelkind</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>REINDEX_OBJECT_SCHEMA</name></expr>:</case>
                    <case>case <expr><name>REINDEX_OBJECT_SYSTEM</name></expr>:</case>
                    <case>case <expr><name>REINDEX_OBJECT_DATABASE</name></expr>:</case>
                        <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_DATANODES</name></expr>;</expr_stmt>
                        <break>break;</break>
                    <default>default:</default>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized object type: %d"</literal></expr></argument>,
                             <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
                <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>auto_commit</name> <operator>=</operator> <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>REINDEX_OBJECT_DATABASE</name> <operator>||</operator>
                                       <name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>REINDEX_OBJECT_SCHEMA</name><operator>)</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_GrantStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>GrantStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>GrantStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>RemoteQueryExecType</name></type> <name>remoteExecType</name> <init>= <expr><name>EXEC_ON_ALL_NODES</name></expr></init></decl>;</decl_stmt>

                    <comment type="block">/* Launch GRANT on Coordinator if object is a sequence */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>==</operator> <name>ACL_OBJECT_RELATION</name> <operator>&amp;&amp;</operator>
                                <name><name>stmt</name><operator>-&gt;</operator><name>targtype</name></name> <operator>==</operator> <name>ACL_TARGET_OBJECT</name><operator>)</operator></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * In case object is a relation, differenciate the case
                         * of a sequence, a view and a table
                         */</comment>
                        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
                        <comment type="block">/* Check the list of objects */</comment>
                        <decl_stmt><decl><type><name>bool</name></type>        <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>RemoteQueryExecType</name></type> <name>type_local</name> <init>= <expr><name>remoteExecType</name></expr></init></decl>;</decl_stmt>

                        <macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>stmt-&gt;objects</argument>)</argument_list></macro>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>relvar</name> <init>= <expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relvar</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <comment type="block">/* Skip if object does not exist */</comment>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                <continue>continue;</continue></block_content></block></if></if_stmt>

                            <expr_stmt><expr><name>remoteExecType</name> <operator>=</operator> <call><name>ExecUtilityFindNodesRelkind</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <comment type="block">/* Check if object node type corresponds to the first one */</comment>
                            <if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>type_local</name> <operator>=</operator> <name>remoteExecType</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <if_stmt><if>if <condition>(<expr><name>type_local</name> <operator>!=</operator> <name>remoteExecType</name></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC does not support GRANT on multiple object types"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Grant VIEW/TABLE with separate queries"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>remoteExecType</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterObjectSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* Try to use the object relation if possible */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * When a relation is defined, it is possible that this object does
                     * not exist but an IF EXISTS clause might be used. So we do not do
                     * any error check here but block the access to remote nodes to
                     * this object as it does not exisy
                     */</comment>
                    <decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <call><name>ExecUtilityFindNodes</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>,
                                <argument><expr><name>relid</name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_NONE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <call><name>ExecUtilityFindNodes</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>,
                            <argument><expr><name>InvalidOid</name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CommentStmt</name></expr>:</case>
            <comment type="block">/* Comment objects depending on their object and temporary types */</comment>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>CommentStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CommentStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <call><name>GetNodesForCommentUtility</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_IndexStmt</name></expr>:</case>    <comment type="block">/* CREATE INDEX */</comment>
            <block>{<block_content>
                <decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>

                <comment type="block">/* INDEX on a temporary table cannot use 2PC at commit */</comment>
                <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <call><name>ExecUtilityFindNodes</name><argument_list>(<argument><expr><name>OBJECT_INDEX</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_NONE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <expr_stmt><expr><name>auto_commit</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>isconstraint</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				
				<if_stmt><if>if <condition>(<expr><name>exec_type</name> <operator>==</operator> <name>EXEC_ON_ALL_NODES</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_DATANODES</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_AlterEnumStmt</name></expr>:</case>    <comment type="block">/* ALTER TYPE (enum) */</comment>
            <comment type="block">/*
             * In this case force autocommit, this transaction cannot be launched
             * inside a transaction block.
             */</comment>
            <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ViewStmt</name></expr>:</case>    <comment type="block">/* CREATE VIEW */</comment>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ViewStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ViewStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>is_temp</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>view</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <ternary><condition><expr><name>is_temp</name></expr> ?</condition><then> <expr><name>EXEC_ON_DATANODES</name></expr> </then><else>: <expr><name>EXEC_ON_ALL_NODES</name></expr></else></ternary></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_RuleStmt</name></expr>:</case>    <comment type="block">/* CREATE RULE */</comment>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <call><name>GetNodesForRulesUtility</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RuleStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>relation</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>LOCAL_PARALLEL_DDL</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>CreateSeqStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CreateSeqStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* In case this query is related to a SERIAL execution, just bypass */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>is_serial</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>is_temp</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <ternary><condition><expr><name>is_temp</name></expr> ?</condition><then> <expr><name>EXEC_ON_DATANODES</name></expr> </then><else>: <expr><name>EXEC_ON_ALL_NODES</name></expr></else></ternary></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AlterSeqStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterSeqStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* In case this query is related to a SERIAL execution, just bypass */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>is_serial</name></name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Oid</name></type>                    <name>relid</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>sequence</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>

                    <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <call><name>ExecUtilityFindNodes</name><argument_list>(<argument><expr><name>OBJECT_SEQUENCE</name></expr></argument>,
                            <argument><expr><name>relid</name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>CreateTableAsStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CreateTableAsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/*
                 * CTAS for normal tables should have been rewritten as a
                 * CREATE TABLE + SELECT INTO
                 */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>OBJECT_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>is_temp</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <ternary><condition><expr><name>is_temp</name></expr> ?</condition><then> <expr><name>EXEC_ON_DATANODES</name></expr> </then><else>: <expr><name>EXEC_ON_ALL_NODES</name></expr></else></ternary></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateStatsStmt</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>CreateStatsStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CreateStatsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rln</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relations</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>relation_openrv</name><argument_list>(<argument><expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <name>rln</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="block">/*
                 * Get the target nodes to run the CREATE STATISTICS
                 * command. Since the grammar does not tell us about the
                 * underlying object type, we use the other variant to
                 * fetch the nodes. This is ok because the command must
                 * only be even used on some kind of relation.
                 */</comment> 
                <expr_stmt><expr><name>exec_type</name> <operator>=</operator>
                    <call><name>ExecUtilityFindNodesRelkind</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <name>g_GTM_skip_catalog</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skip_gtm_catalog can not be true on datanode."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>g_GTM_skip_catalog</name></expr>)</condition>
    <block>{<block_content>
        <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
            <case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_NONE</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

            <case>case <expr><name>T_DropStmt</name></expr>:</case>    
            <block>{<block_content>
                <decl_stmt><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DropStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>OBJECT_SEQUENCE</name> <operator>==</operator> <name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_NONE</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>
            
            <default>default:</default>
            <block>{<block_content>
                <break>break;</break>
            </block_content>}</block>
        </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>auto_commit</name></expr></argument>,
                <argument><expr><name>exec_type</name></expr></argument>, <argument><expr><name>is_temp</name></expr></argument>, <argument><expr><name>add_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		    <operator>(</operator><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>concurrent</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * When we get here, all DN have done with index creation, time to set index
			 * valid on CN.
			 */</comment>
			<decl_stmt><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>        <name>indexid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>   <name>rel</name> <init>= <expr><call><name>relation_openrv_extended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			
			<comment type="block">/* exec_type can't be EXEC_ON_ALL_NODES, as changed in "switch case" above */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>exec_type</name> <operator>!=</operator> <name>EXEC_ON_ALL_NODES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
			<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Failed to get enough message from stmt, have to guess a namespace.
				 * This should not happen but ...
				 */</comment>
				<expr_stmt><expr><name>indexid</name> <operator>=</operator> <call><name>RelnameGetRelid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>idxname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				
				<expr_stmt><expr><call><name>IndexCreateSetValid</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type> <name>namespace</name> <init>= <expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type> <name>nParts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type> <name>child_index</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type> <name>child_rel</name></decl>;</decl_stmt>
				
				<expr_stmt><expr><name>indexid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>idxname</name></name></expr></argument>, <argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				
				<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>nParts</name> <operator>=</operator> <call><name>RelationGetNParts</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				
				<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>IndexCreateSetValid</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				
				<comment type="block">/* if there are interval partitions, do the same thing */</comment>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nParts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><name>child_index</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>GetPartitionName</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>child_rel</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>GetPartitionName</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					
					<expr_stmt><expr><call><name>IndexCreateSetValid</name><argument_list>(<argument><expr><name>child_index</name></expr></argument>, <argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
				
				<comment type="block">/*
				 * Notice: community version of partition table is not allow to build
				 * index concurrently, so don't bother here.
				 */</comment>
			</block_content>}</block></else></if_stmt>
			
			<comment type="block">/* finally, tell other CN to create an index */</comment>
			<if_stmt><if>if <condition>(<expr><name>exec_type</name> <operator>!=</operator> <name>EXEC_ON_NONE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>auto_commit</name></expr></argument>,
				                       <argument><expr><name>EXEC_ON_COORDS</name></expr></argument>, <argument><expr><name>is_temp</name></expr></argument>, <argument><expr><name>add_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * Enable parallel ddl for specific query.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>parallel_ddl_process</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * set is_txn_has_parallel_ddl to be false in case of combination command
	 * that include some type support parallel ddl and some unsupport parallel
	 * ddl. eg: create extension which include T_CreateFunctionStmt and
	 * T_CreateOpClassStmt and so on.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_txn_has_parallel_ddl</name> <operator>&amp;&amp;</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>T_RemoteQuery</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>is_txn_has_parallel_ddl</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_parallel_ddl</name></expr>)</condition>
    <block>{<block_content>
        <return>return ;</return>
    </block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterDatabaseStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterDatabaseSetStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
			<break>break;</break>
		<case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AlterOwnerStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterOwnerStmt</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>OBJECT_DATABASE</name></expr>:</case>
					<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
					<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
					<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
					<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
						<break>break;</break>
					<default>default:</default>
						<return>return;</return>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterObjectSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
					<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
					<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
					<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
						<break>break;</break>
					<default>default:</default>
						<return>return;</return>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateTableSpaceStmt</name></expr>:</case>
		<case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
		<case>case <expr><name>T_CompositeTypeStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateEnumStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateRangeStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateFunctionStmt</name></expr>:</case>
		<case>case <expr><name>T_ViewStmt</name></expr>:</case>
		<case>case <expr><name>T_DropTableSpaceStmt</name></expr>:</case>
		<case>case <expr><name>T_DropdbStmt</name></expr>:</case>
		<case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
			<break>break;</break>
		<case>case <expr><name>T_DropStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DropStmt</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
				<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
					<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
					<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
					<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
					<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
					<case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
					<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
					<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
					<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
						<break>break;</break>
					<default>default:</default>
						<return>return;</return>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RenameStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
				<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>OBJECT_DATABASE</name></expr>:</case>
					<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
					<case>case <expr><name>OBJECT_ROLE</name></expr>:</case>
					<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
					<case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
					<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
					<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
					<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
						<break>break;</break>
					<default>default:</default>
						<return>return;</return>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_IndexStmt</name></expr>:</case>
    <comment type="block">/* CONCURRENT INDEX is not supported */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>,<argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>IndexStmt</name></expr></argument>,<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>concurrent</name></expr>)</condition>
    <block>{<block_content>
				<return>return ;</return>
    </block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TruncateStmt</name></expr>:</case>
		<case>case <expr><name>T_ReindexStmt</name></expr>:</case>
			<break>break;</break>
		<default>default:</default>
			<return>return ;</return>
    </block_content>}</block></switch>

    <comment type="block">/* Parallel ddl is enabled, set parallel ddl flag */</comment>
    <expr_stmt><expr><name>is_txn_has_parallel_ddl</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * standard_ProcessUtility itself deals only with utility commands for
 * which we do not provide event trigger support.  Commands that do have
 * such support are passed down to ProcessUtilitySlow, which contains the
 * necessary infrastructure for such triggers.
 *
 * This division is not just for performance: it's critical that the
 * event trigger code not be invoked when doing START TRANSACTION for
 * example, because we might need to refresh the event trigger cache,
 * which requires being in a valid transaction.
 */</comment>
<function><type><name>void</name></type>
<name>standard_ProcessUtility</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
                        <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
                        <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
                        <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
                        <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>sentToRemote</name></decl></parameter>,
                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isTopLevel</name> <init>= <expr><operator>(</operator><name>context</name> <operator>==</operator> <name>PROCESS_UTILITY_TOPLEVEL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	 <comment type="block">/* parallel enable check */</comment>
	 <expr_stmt><expr><call><name>parallel_ddl_process</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * For more detail see comments in function pgxc_lock_for_backup.
     *
     * Cosider the following scenario:
     * Imagine a two cordinator cluster CO1, CO2
     * Suppose a client connected to CO1 issues select pgxc_lock_for_backup()
     * Now assume that a client connected to CO2 issues a create table
     * select pgxc_lock_for_backup() would try to acquire the advisory lock
     * in exclusive mode, whereas create table would try to acquire the same
     * lock in shared mode. Both these requests will always try acquire the
     * lock in the same order i.e. they would both direct the request first to
     * CO1 and then to CO2. One of the two requests would therefore pass
     * and the other would fail.
     *
     * Consider another scenario:
     * Suppose we have a two cooridnator cluster CO1 and CO2
     * Assume one client connected to each coordinator
     * Further assume one client starts a transaction
     * and issues a DDL. This is an unfinished transaction.
     * Now assume the second client issues
     * select pgxc_lock_for_backup()
     * This request would fail because the unfinished transaction
     * would already hold the advisory lock.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name> <operator>&amp;&amp;</operator> <call><name>IsNormalProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Is the statement a prohibited one? */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsStmtAllowedInLockedMode</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* node number changes with ddl is not allowed */</comment>
			<if_stmt><if>if <condition>(<expr><name>HandlesInvalidatePending</name> <operator>&amp;&amp;</operator> <call><name>PrimaryNodeNumberChanged</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_QUERY_CANCELED</name></expr></argument>)</argument_list></call><operator>,</operator>
						        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling transaction due to cluster configuration reset by administrator command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>pgxc_lock_for_utility_stmt</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		</block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>check_xact_readonly</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>completionTag</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>completionTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>ProcessUtilityPre</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>,
                <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
            <comment type="block">/*
             * ******************** transactions ********************
             */</comment>
        <case>case <expr><name>T_TransactionStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>TransactionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>TransactionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
                <block>{<block_content>
                        <comment type="block">/*
                         * START TRANSACTION, as defined by SQL99: Identical
                         * to BEGIN.  Same code for both.
                         */</comment>
                    <case>case <expr><name>TRANS_STMT_BEGIN</name></expr>:</case>
                    <case>case <expr><name>TRANS_STMT_START</name></expr>:</case>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

                            <expr_stmt><expr><call><name>BeginTransactionBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_isolation"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><call><name>SetPGVariable</name><argument_list>(<argument><expr><literal type="string">"transaction_isolation"</literal></expr></argument>,
                                                  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                                  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                                <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_read_only"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><call><name>SetPGVariable</name><argument_list>(<argument><expr><literal type="string">"transaction_read_only"</literal></expr></argument>,
                                                  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                                  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                                <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_deferrable"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><call><name>SetPGVariable</name><argument_list>(<argument><expr><literal type="string">"transaction_deferrable"</literal></expr></argument>,
                                                  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                                  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            </block_content>}</block>
                        </block_content>}</block>
                        <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <case>case <expr><name>TRANS_STMT_BEGIN_SUBTXN</name></expr>:</case>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"[PLPGSQL] recv beginsubtxn cmd. pid:%d"</literal></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>BeginInternalSubTransaction</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>TRANS_STMT_ROLLBACK_SUBTXN</name></expr>:</case>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"[PLPGSQL] recv rollbacksubtxn cmd. pid:%d"</literal></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>RollbackAndReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>TRANS_STMT_COMMIT_SUBTXN</name></expr>:</case>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"[PLPGSQL] recv commitsubtxn cmd. pid:%d"</literal></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>ReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                    <case>case <expr><name>TRANS_STMT_COMMIT</name></expr>:</case>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EndTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/* report unsuccessful commit in completionTag */</comment>
                            <if_stmt><if>if <condition>(<expr><name>completionTag</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                        <break>break;</break>

                    <case>case <expr><name>TRANS_STMT_PREPARE</name></expr>:</case>
                        <expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"PREPARE TRANSACTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PrepareTransactionBlock</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/* report unsuccessful commit in completionTag */</comment>
                            <if_stmt><if>if <condition>(<expr><name>completionTag</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                        <break>break;</break>

                    <case>case <expr><name>TRANS_STMT_COMMIT_PREPARED</name></expr>:</case>
                        <expr_stmt><expr><call><name>PreventTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"COMMIT PREPARED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"COMMIT PREPARED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>FinishPreparedTransaction</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><name>TRANS_STMT_ROLLBACK_PREPARED</name></expr>:</case>
                        <expr_stmt><expr><call><name>PreventTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK PREPARED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"ROLLBACK PREPARED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>FinishPreparedTransaction</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>

					<case>case <expr><name>TRANS_STMT_COMMIT_PREPARED_CHECK</name></expr>:</case>
						<expr_stmt><expr><call><name>PreventTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"COMMIT PREPARED CHECK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"COMMIT PREPARED CHECK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>CheckPreparedTransactionLock</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_ROLLBACK_PREPARED_CHECK</name></expr>:</case>
						<expr_stmt><expr><call><name>PreventTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK PREPARED CHECK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"ROLLBACK PREPARED CHECK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>CheckPreparedTransactionLock</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

                    <case>case <expr><name>TRANS_STMT_ROLLBACK</name></expr>:</case>
                        <expr_stmt><expr><call><name>UserAbortTransactionBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><name>TRANS_STMT_SAVEPOINT</name></expr>:</case>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                            <expr_stmt><expr><call><name>RequireTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"SAVEPOINT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"savepoint_name"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            </block_content>}</block>

                            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><call><name>DefineSavepoint</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>
                        <break>break;</break>

                    <case>case <expr><name>TRANS_STMT_RELEASE</name></expr>:</case>
                        <expr_stmt><expr><call><name>RequireTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"RELEASE SAVEPOINT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>ReleaseSavepoint</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><name>TRANS_STMT_ROLLBACK_TO</name></expr>:</case>
                        <expr_stmt><expr><call><name>RequireTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK TO SAVEPOINT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>RollbackToSavepoint</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/*
                         * CommitTransactionCommand is in charge of
                         * re-defining the savepoint again
                         */</comment>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block>
            <break>break;</break>

            <comment type="block">/*
             * Portal (cursor) manipulation
             */</comment>
        <case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
            <expr_stmt><expr><call><name>PerformCursorOpen</name><argument_list>(<argument><expr><operator>(</operator><name>DeclareCursorStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>params</name></expr></argument>,
                              <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ClosePortalStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ClosePortalStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ClosePortalStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>CheckRestrictedOperation</name><argument_list>(<argument><expr><literal type="string">"CLOSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PerformPortalClose</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>portalname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_FetchStmt</name></expr>:</case>
            <expr_stmt><expr><call><name>PerformPortalFetch</name><argument_list>(<argument><expr><operator>(</operator><name>FetchStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>,
                               <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DoStmt</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecuteDoStmt</name><argument_list>(<argument><expr><operator>(</operator><name>DoStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateTableSpaceStmt</name></expr>:</case>
            <comment type="block">/* no event triggers for global objects */</comment>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PreventTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLESPACE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<comment type="block">/*
			 * If I am the main execute CN but not Leader CN,
			 * Notify the Leader CN to create firstly.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SendLeaderCNUtilityWithContext</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>CreateTableSpace</name><argument_list>(<argument><expr><operator>(</operator><name>CreateTableSpaceStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DropTableSpaceStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DropTableSpaceStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DropTableSpaceStmt</name> <operator>*</operator><operator>)</operator><name>parsetree</name></expr></init></decl>;</decl_stmt>
				<comment type="block">/* 
				 * no event triggers for global objects
				 * Allow this to be run inside transaction block on remote nodes
				 */</comment>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PreventTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"DROP TABLESPACE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<comment type="block">/*
				 * If I am the main execute CN but not Leader CN,
				 * Notify the Leader CN to create firstly.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PGXCNodeHandle</name>	<modifier>*</modifier></type><name>leaderCnHandle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name>leaderCnHandle</name> <operator>=</operator> <call><name>find_ddl_leader_cn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_ddl_leader_cn</name><argument_list>(<argument><expr><name><name>leaderCnHandle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>PreCheckforDropTableSpace</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>DropTableSpace</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
												<argument><expr><name>EXEC_ON_ALL_NODES</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
												<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><call><name>DropTableSpace</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
											<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
											<argument><expr><name>EXEC_ON_ALL_NODES</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<comment type="block">/* From remote cn */</comment>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><name>IS_PGXC_LOCAL_COORDINATOR</name> <operator>&amp;&amp;</operator> <name>is_txn_has_parallel_ddl</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>DropTableSpace</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<comment type="block">/* non parallel ddl mode */</comment>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>DropTableSpace</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<expr_stmt><expr><call><name>DropTableSpace</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_AlterTableSpaceOptionsStmt</name></expr>:</case>
            <comment type="block">/* no event triggers for global objects */</comment>
            <expr_stmt><expr><call><name>AlterTableSpaceOptions</name><argument_list>(<argument><expr><operator>(</operator><name>AlterTableSpaceOptionsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_TruncateStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<comment type="block">/*
			 * If I am the main execute CN but not Leader CN,
			 * Notify the Leader CN to create firstly.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>is_temp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>	<modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
				<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>((TruncateStmt *) parsetree)-&gt;relations</argument>)</argument_list></macro> 
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>RangeVar</name><modifier>*</modifier></type> <name>rel</name> <init>= <expr><operator>(</operator><name>RangeVar</name><operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>IsTempTable</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>is_temp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>ExecuteTruncate</name><argument_list>(<argument><expr><operator>(</operator><name>TruncateStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CopyStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>uint64</name></type>        <name>processed</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>DoCopy</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CopyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
                       <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr></argument>, <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr></argument>,
                       <argument><expr><operator>&amp;</operator><name>processed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>completionTag</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name>COMPLETION_TAG_BUFSIZE</name></expr></argument>,
                             <argument><expr><literal type="string">"COPY "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>processed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_PrepareStmt</name></expr>:</case>
            <expr_stmt><expr><call><name>CheckRestrictedOperation</name><argument_list>(<argument><expr><literal type="string">"PREPARE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PrepareQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PrepareStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
                         <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr></argument>, <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ExecuteStmt</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecuteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>ExecuteStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                         <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>params</name></expr></argument>,
                         <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DeallocateStmt</name></expr>:</case>
            <expr_stmt><expr><call><name>CheckRestrictedOperation</name><argument_list>(<argument><expr><literal type="string">"DEALLOCATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DeallocateQuery</name><argument_list>(<argument><expr><operator>(</operator><name>DeallocateStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
            <comment type="block">/* no event triggers for global objects */</comment>
            <expr_stmt><expr><call><name>GrantRole</name><argument_list>(<argument><expr><operator>(</operator><name>GrantRoleStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
            <comment type="block">/* no event triggers for global objects */</comment>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PreventTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"CREATE DATABASE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<comment type="block">/*
			 * If I am the main execute CN but not Leader CN,
			 * Notify the Leader CN to create firstly.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SendLeaderCNUtilityWithContext</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <expr_stmt><expr><call><name>createdb</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CreatedbStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterDatabaseStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<comment type="block">/*
			 * If I am the main execute CN but not Leader CN,
			 * Notify the Leader CN to create firstly.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If this is not a SET TABLESPACE statement, just propogate
				 * the cmd as usual.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsSetTableSpace</name><argument_list>(<argument><expr><operator>(</operator><name>AlterDatabaseStmt</name><operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>SendLeaderCNUtilityWithContext</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/* no event triggers for global objects */</comment>
            <expr_stmt><expr><call><name>AlterDatabase</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>AlterDatabaseStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterDatabaseSetStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<comment type="block">/*
			 * If I am the main execute CN but not Leader CN,
			 * Notify the Leader CN to create firstly.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>		
            <comment type="block">/* no event triggers for global objects */</comment>
            <expr_stmt><expr><call><name>AlterDatabaseSet</name><argument_list>(<argument><expr><operator>(</operator><name>AlterDatabaseSetStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DropdbStmt</name></expr>:</case>
            <block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type> <name><name>prepareQuery</name><index>[<expr><name>STRINGLENGTH</name></expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name></type> <name><name>cleanQuery</name><index>[<expr><name>STRINGLENGTH</name></expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>DropdbStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DropdbStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>prepare</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type> <name>missing_ok</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></init></decl>;</decl_stmt>
                <comment type="block">/* no event triggers for global objects */</comment>
                <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
					<block>{<block_content>
                    <expr_stmt><expr><call><name>PreventTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"DROP DATABASE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/*
					 * If I am the main execute CN but not Leader CN,
					 * Notify the Leader CN to drop firstly.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>PGXCNodeHandle</name>	<modifier>*</modifier></type><name>leaderCnHandle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Oid</name></type>				<name>db_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><name>leaderCnHandle</name> <operator>=</operator> <call><name>find_ddl_leader_cn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
						
						<expr_stmt><expr><name>db_oid</name> <operator>=</operator> <call><name>get_database_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>,	<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>db_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
                            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cleanQuery</name></expr></argument>, <argument><expr><name>STRINGLENGTH</name></expr></argument>, <argument><expr><literal type="string">"CLEAN CONNECTION TO ALL FOR DATABASE %s;"</literal></expr></argument>,
                                     <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>prepareQuery</name></expr></argument>, <argument><expr><name>STRINGLENGTH</name></expr></argument>, <argument><expr><literal type="string">"DROP DATABASE PREPARE %s;"</literal></expr></argument>,
						        			<argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_ddl_leader_cn</name><argument_list>(<argument><expr><name><name>leaderCnHandle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>cleanQuery</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>prepareQuery</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if>
							<else>else<block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>dropdb_prepare</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
							<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>prepareQuery</name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
												<argument><expr><name>EXEC_ON_ALL_NODES</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
												<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_ddl_leader_cn</name><argument_list>(<argument><expr><name><name>leaderCnHandle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></if>
						<else>else<block type="pseudo"><block_content>
							<break>break;</break></block_content></block></else></if_stmt>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* 
					 * In parallel ddl mode, we only send cmd to remote when
					 * database exists, so database can not miss when the cmd
					 * come from remote cn.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IS_PGXC_LOCAL_COORDINATOR</name> <operator>&amp;&amp;</operator> <name>is_txn_has_parallel_ddl</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>missing_ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>dropdb</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>	<name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
												<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
												<argument><expr><name>EXEC_ON_ALL_NODES</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
												<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>dropdb_prepare</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
            <break>break;</break>

            <comment type="block">/* Query-level asynchronous notification */</comment>
        <case>case <expr><name>T_NotifyStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>NotifyStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>NotifyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"NOTIFY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Async_Notify</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>conditionname</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>payload</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_ListenStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListenStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ListenStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"LISTEN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CheckRestrictedOperation</name><argument_list>(<argument><expr><literal type="string">"LISTEN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Async_Listen</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>conditionname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_UnlistenStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>UnlistenStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>UnlistenStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"UNLISTEN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CheckRestrictedOperation</name><argument_list>(<argument><expr><literal type="string">"UNLISTEN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>conditionname</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>Async_Unlisten</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>conditionname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>Async_UnlistenAll</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_LoadStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>LoadStmt</name>   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>LoadStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>closeAllVfds</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* probably not necessary... */</comment>
                <comment type="block">/* Allowed names are restricted if you're not superuser */</comment>
                <expr_stmt><expr><call><name>load_file</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_ClusterStmt</name></expr>:</case>
            <comment type="block">/* we choose to allow this during "read only" transactions */</comment>
            <expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"CLUSTER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* forbidden in parallel mode due to CommandIsReadOnly */</comment>
            <expr_stmt><expr><call><name>cluster</name><argument_list>(<argument><expr><operator>(</operator><name>ClusterStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_VacuumStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>VacuumStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* we choose to allow this during "read only" transactions */</comment>
                <expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator></expr> ?</condition><then>
                                             <expr><literal type="string">"VACUUM"</literal></expr> </then><else>: <expr><literal type="string">"ANALYZE"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* forbidden in parallel mode due to CommandIsReadOnly */</comment>
                <expr_stmt><expr><call><name>ExecVacuum</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <case>case <expr><name>T_VacuumShardStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>VacuumShardStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>VacuumShardStmt</name> <operator>*</operator><operator>)</operator><name>parsetree</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if<condition>(<expr><operator>!</operator><name>IS_PGXC_DATANODE</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"this operation can only be executed on datanode."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                
                <expr_stmt><expr><call><name>ExecVacuumShard</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>T_ExplainStmt</name></expr>:</case>
            <expr_stmt><expr><call><name>ExplainQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>ExplainStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>params</name></expr></argument>,
                         <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterSystemStmt</name></expr>:</case>
            <expr_stmt><expr><call><name>PreventTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"ALTER SYSTEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>AlterSystemSetConfigFile</name><argument_list>(<argument><expr><operator>(</operator><name>AlterSystemStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_VariableSetStmt</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecSetVariableStmt</name><argument_list>(<argument><expr><operator>(</operator><name>VariableSetStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
            <comment type="block">/* Let the pooler manage the statement */</comment>
            if (IS_PGXC_COORDINATOR &amp;&amp; !IsConnFromCoord())
            {
                VariableSetStmt *stmt = (VariableSetStmt *) parsetree;
                
                <comment type="block">/*
                 * If command is local and we are not in a transaction block do NOT
                 * send this query to backend nodes, it is just bypassed by the backend.
                 */</comment>
                if (stmt-&gt;is_local)
                {
                    if (IsTransactionBlock())
                    {
                        if (PoolManagerSetCommand(NULL, POOL_SET_COMMAND_ALL, POOL_CMD_LOCAL_SET, queryString) &lt; 0)
                            elog(ERROR, "TBase: ERROR local SET query:%s", queryString);
                    }
                }
                else
                {
                    if (PoolManagerSetCommand(NULL, POOL_SET_COMMAND_ALL, POOL_CMD_GLOBAL_SET, queryString) &lt; 0)
                        elog(ERROR, "TBase: ERROR global SET query:%s", queryString);
                }
            }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <break>break;</break>

        <case>case <expr><name>T_VariableShowStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>VariableShowStmt</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>VariableShowStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>GetPGVariable</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_DiscardStmt</name></expr>:</case>
            <comment type="block">/* should we allow DISCARD PLANS? */</comment>
            <expr_stmt><expr><call><name>CheckRestrictedOperation</name><argument_list>(<argument><expr><literal type="string">"DISCARD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DiscardCommand</name><argument_list>(<argument><expr><operator>(</operator><name>DiscardStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateEventTrigStmt</name></expr>:</case>
            <comment type="block">/* no event triggers on event triggers */</comment>
            <expr_stmt><expr><call><name>CreateEventTrigger</name><argument_list>(<argument><expr><operator>(</operator><name>CreateEventTrigStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterEventTrigStmt</name></expr>:</case>
            <comment type="block">/* no event triggers on event triggers */</comment>
            <expr_stmt><expr><call><name>AlterEventTrigger</name><argument_list>(<argument><expr><operator>(</operator><name>AlterEventTrigStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

            <comment type="block">/*
             * ******************************** ROLE statements ****
             */</comment>
        <case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<comment type="block">/*
			 * If I am the main execute CN but not Leader CN,
			 * Notify the Leader CN to create firstly.
			 */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/* no event triggers for global objects */</comment>
            <expr_stmt><expr><call><name>CreateRole</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CreateRoleStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
            <comment type="block">/* no event triggers for global objects */</comment>
            <expr_stmt><expr><call><name>AlterRole</name><argument_list>(<argument><expr><operator>(</operator><name>AlterRoleStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<comment type="block">/*
			 * If I am the main execute CN but not Leader CN,
			 * Notify the Leader CN to create firstly.
			 */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/* no event triggers for global objects */</comment>
            <expr_stmt><expr><call><name>AlterRoleSet</name><argument_list>(<argument><expr><operator>(</operator><name>AlterRoleSetStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
			<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<expr_stmt><expr><call><name>CheckAndDropRole</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <comment type="block">/* no event triggers for global objects */</comment>
				<expr_stmt><expr><call><name>DropRole</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_ReassignOwnedStmt</name></expr>:</case>
            <comment type="block">/* no event triggers for global objects */</comment>
            <expr_stmt><expr><call><name>ReassignOwnedObjects</name><argument_list>(<argument><expr><operator>(</operator><name>ReassignOwnedStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_LockStmt</name></expr>:</case>

            <comment type="block">/*
             * Since the lock would just get dropped immediately, LOCK TABLE
             * outside a transaction block is presumed to be user error.
             */</comment>
            <expr_stmt><expr><call><name>RequireTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"LOCK TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* forbidden in parallel mode due to CommandIsReadOnly */</comment>
            <expr_stmt><expr><call><name>LockTableCommand</name><argument_list>(<argument><expr><operator>(</operator><name>LockStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ConstraintsSetStmt</name></expr>:</case>
            <expr_stmt><expr><call><name>WarnNoTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"SET CONSTRAINTS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>AfterTriggerSetState</name><argument_list>(<argument><expr><operator>(</operator><name>ConstraintsSetStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CheckPointStmt</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to do CHECKPOINT"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * You might think we should have a PreventCommandDuringRecovery()
             * here, but we interpret a CHECKPOINT command during recovery as
             * a request for a restartpoint instead. We allow this since it
             * can be a useful way of reducing switchover time when using
             * various forms of replication.
             */</comment>
            <expr_stmt><expr><call><name>RequestCheckpoint</name><argument_list>(<argument><expr><name>CHECKPOINT_IMMEDIATE</name> <operator>|</operator> <name>CHECKPOINT_WAIT</name> <operator>|</operator>
                              <operator>(</operator><ternary><condition><expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>CHECKPOINT_FORCE</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ReindexStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ReindexStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ReindexStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* we choose to allow this during "read only" transactions */</comment>
                <expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"REINDEX"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* forbidden in parallel mode due to CommandIsReadOnly */</comment>
                <switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>REINDEX_OBJECT_INDEX</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>	
						<expr_stmt><expr><call><name>CheckAndSendLeaderCNReindex</name><argument_list>(<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>,
													<argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <expr_stmt><expr><call><name>ReindexIndex</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>REINDEX_OBJECT_TABLE</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>	
						<expr_stmt><expr><call><name>CheckAndSendLeaderCNReindex</name><argument_list>(<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>,
													<argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <expr_stmt><expr><call><name>ReindexTable</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>REINDEX_OBJECT_SCHEMA</name></expr>:</case>
                    <case>case <expr><name>REINDEX_OBJECT_SYSTEM</name></expr>:</case>
                    <case>case <expr><name>REINDEX_OBJECT_DATABASE</name></expr>:</case>

                        <comment type="block">/*
                         * This cannot run inside a user transaction block; if
                         * we were inside a transaction, then its commit- and
                         * start-transaction-command calls would not have the
                         * intended effect!
                         */</comment>
                        <expr_stmt><expr><call><name>PreventTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>,
                                                <argument><expr><ternary><condition><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>REINDEX_OBJECT_SCHEMA</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"REINDEX SCHEMA"</literal></expr> </then><else>:
                                                <expr><ternary><condition><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>REINDEX_OBJECT_SYSTEM</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"REINDEX SYSTEM"</literal></expr> </then><else>:
                                                <expr><literal type="string">"REINDEX DATABASE"</literal></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>ReindexMultipleTables</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <default>default:</default>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized object type: %d"</literal></expr></argument>,
                             <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block>
            <break>break;</break>

            <comment type="block">/*
             * The following statements are supported by Event Triggers only
             * in some cases, so we "fast path" them in the other cases.
             */</comment>

        <case>case <expr><name>T_GrantStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>GrantStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>GrantStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsGrantObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
                                       <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
                                       <argument><expr><name>dest</name></expr></argument>,
                                       <argument><expr><name>sentToRemote</name></expr></argument>,
                                       <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ExecuteGrantStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_DropStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>DropStmt</name>   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DropStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
                                       <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
                                       <argument><expr><name>dest</name></expr></argument>,
                                       <argument><expr><name>sentToRemote</name></expr></argument>,
                                       <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ExecDropStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_RenameStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
                    <expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
                                       <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
                                       <argument><expr><name>dest</name></expr></argument>,
                                       <argument><expr><name>sentToRemote</name></expr></argument>,
                                       <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<if type="elseif">else if <condition>(<expr><name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type> <name>is_temp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>PGXCNodeHandle</name>	<modifier>*</modifier></type><name>leaderCnHandle</name> <init>= <expr><call><name>find_ddl_leader_cn</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type> <name>is_leader_cn</name> <init>= <expr><call><name>is_ddl_leader_cn</name><argument_list>(<argument><expr><name><name>leaderCnHandle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>RemoteQueryExecType</name></type> <name>exec_type</name> <init>= <expr><call><name>GetRenameExecType</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<comment type="block">/*
					 * If I am the main execute CN but not Leader CN,
					 * Notify the Leader CN to create firstly.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_leader_cn</name></expr>)</condition>
					<block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>OBJECT_DATABASE</name> <operator>==</operator> <name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>char</name></type> <name><name>cleanQuery</name><index>[<expr><name>STRINGLENGTH</name></expr>]</index></name></decl>;</decl_stmt>
                            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cleanQuery</name></expr></argument>, <argument><expr><name>STRINGLENGTH</name></expr></argument>, <argument><expr><literal type="string">"CLEAN CONNECTION TO ALL FOR DATABASE %s;"</literal></expr></argument>,
                                     <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>cleanQuery</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>

						<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>ExecRenameStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
											<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>exec_type</name></expr></argument>,
											<argument><expr><name>is_temp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ExecRenameStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AlterObjectDependsStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterObjectDependsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
                                       <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
                                       <argument><expr><name>dest</name></expr></argument>,
                                       <argument><expr><name>sentToRemote</name></expr></argument>,
                                       <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ExecAlterObjectDependsStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterObjectSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
                                       <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
                                       <argument><expr><name>dest</name></expr></argument>,
                                       <argument><expr><name>sentToRemote</name></expr></argument>,
                                       <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ExecAlterObjectSchemaStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AlterOwnerStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterOwnerStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
                                       <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
                                       <argument><expr><name>dest</name></expr></argument>,
                                       <argument><expr><name>sentToRemote</name></expr></argument>,
                                       <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else
				<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<comment type="block">/*
					 * If I am the main execute CN but not Leader CN,
					 * Notify the Leader CN to create firstly.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><call><name>ExecAlterOwnerStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
			</block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_CommentStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>CommentStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CommentStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
                                       <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
                                       <argument><expr><name>dest</name></expr></argument>,
                                       <argument><expr><name>sentToRemote</name></expr></argument>,
                                       <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>CommentObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <break>break;</break>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_SecLabelStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>SecLabelStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>SecLabelStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
                                       <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
                                       <argument><expr><name>dest</name></expr></argument>,
                                       <argument><expr><name>sentToRemote</name></expr></argument>,
                                       <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ExecSecLabelStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <break>break;</break>
            </block_content>}</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
        <case>case <expr><name>T_CreateShardStmt</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>CreateShardStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CreateShardStmt</name> <operator>*</operator><operator>)</operator><name>parsetree</name></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CREATE_SHARD_MAX_LENGTH</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
            <decl_stmt><decl><type><name>int</name></type>         <name>i</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name></type>        <name>nodenum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>         <name>nodeGroup</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ExecNodes</name>    <modifier>*</modifier></type><name>execnodes</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name>        <modifier>*</modifier></type><name>nodeIndex</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>        
            <decl_stmt><decl><type><name>Oid</name>         <modifier>*</modifier></type><name>nodeOids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>isExtended</name></name> <operator>&amp;&amp;</operator> <call><name>MajorShardAlreadyExist</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"major shard map has initialized already, it can not be initialized again."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><call><name>GetDatanodeGlobalInfo</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodenum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodeIndex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodeOids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodeGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><call><name>is_group_sharding_inited</name><argument_list>(<argument><expr><name>nodeGroup</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"shard map of group:%u has initialized already, it can not be initialized again."</literal></expr></argument>, <argument><expr><name>nodeGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            
            <comment type="block">/* only if am the original session I will revoke other nodes to do the create sharding job */</comment>
            <if_stmt><if>if<condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>                        
				<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>EXEC_ON_COORDS</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
                <expr_stmt><expr><name>execnodes</name> <operator>=</operator> <operator>(</operator><name>ExecNodes</name> <operator>*</operator><operator>)</operator><call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nodenum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <comment type="block">/* generate ExecNodes*/</comment>                     
                    <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>=</operator> <name>RELATION_ACCESS_READ</name></expr>;</expr_stmt>  <comment type="block">/* not used */</comment>
                    <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name>LOCATOR_TYPE_SHARD</name></expr>;</expr_stmt>  <comment type="block">/* not used */</comment>
                    
                    <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>en_expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>en_relid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>primarynodelist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt> 

                    <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><name><name>nodeIndex</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    
                    <expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>execnodes</name></expr></argument>, 
											<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>EXEC_ON_DATANODES</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>execnodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* init local sharding map, here CN and DN all have the same shardmap info. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>isExtended</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* ordinary shard map group */</comment>
                <expr_stmt><expr><call><name>InitShardMap</name><argument_list>(<argument><expr><name>SHARD_MAP_GROUP_NUM</name></expr></argument>, <argument><expr><name>nodenum</name></expr></argument>, <argument><expr><name>nodeOids</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nodeGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* extension shard map group */</comment>
                <expr_stmt><expr><call><name>InitShardMap</name><argument_list>(<argument><expr><name>EXTENSION_SHARD_MAP_GROUP_NUM</name></expr></argument>, <argument><expr><name>nodenum</name></expr></argument>, <argument><expr><name>nodeOids</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nodeGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nodeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nodeOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <break>break;</break>
                    
        <case>case <expr><name>T_MoveDataStmt</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>reloids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
            
            <comment type="block">/* All cn and dn do the same thing to handle pgxc_shard_map items. */</comment>
            <expr_stmt><expr><call><name>PrepareMoveData</name><argument_list>(<argument><expr><operator>(</operator><name>MoveDataStmt</name><operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PgxcMoveData_Node</name><argument_list>(<argument><expr><operator>(</operator><name>MoveDataStmt</name><operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* When split one dn to two, should truncate new dn's all other tables except replicated table and shard table */</comment>
            <if_stmt><if>if<condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
            <block>{<block_content>                    
                <expr_stmt><expr><call><name>PgxcMoveData_DN</name><argument_list>(<argument><expr><operator>(</operator><name>MoveDataStmt</name><operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <if_stmt><if>if<condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>StringInfo</name></type> <name>qstring_tonode</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type> <name>execnodes</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>MoveDataStmt</name><modifier>*</modifier></type> <name>stmt</name> <init>= <expr><operator>(</operator><name>MoveDataStmt</name><operator>*</operator><operator>)</operator><name>parsetree</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>movecmd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name>     <modifier>*</modifier></type><name>dnoids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>      <name>group_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>      <name>ndns</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>      <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>      <name>nodeindex</name></decl>;</decl_stmt>
                
                <comment type="block">/* Send Move Data Command to All Coordinator,
                 *    BUT,it is necessary to add new node to all the Coordinators independently 
                 */</comment>
				<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>EXEC_ON_COORDS</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* generate new query string to datanode s*/</comment>
                <switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>MOVE_DATA_STRATEGY_NODE</name></expr>:</case>
                        <block>{<block_content>
                            <expr_stmt><expr><name>qstring_tonode</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><name>qstring_tonode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        
                            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>qstring_tonode</name></expr></argument>, 
                                            <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><name>movecmd</name> <operator>=</operator> <name><name>qstring_tonode</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"[MOVE_DATA_STRATEGY_NODE]movecmd=%s"</literal></expr></argument>, <argument><expr><name>movecmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>
                        <break>break;</break>
                    <case>case <expr><name>MOVE_DATA_STRATEGY_SHARD</name></expr>:</case>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>int</name></type> <name>si</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><name>qstring_tonode</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><name>qstring_tonode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        
                            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>qstring_tonode</name></expr></argument>, 
                                            <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"MOVE %s GROUP %s DATA FROM %s TO %s WITH ("</literal></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>isextension</name></name></expr> ?</condition><then> <expr><literal type="string">"EXTENSION"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                                            <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>group</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stmt</name><operator>-&gt;</operator><name>from_node</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stmt</name><operator>-&gt;</operator><name>to_node</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <for>for<control>(<init><expr><name>si</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>si</name> <operator>&lt;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>num_shard</name></name></expr>;</condition> <incr><expr><name>si</name><operator>++</operator></expr></incr>)</control>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>qstring_tonode</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>arr_shard</name><index>[<expr><name>si</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if_stmt><if>if<condition>(<expr><name>si</name> <operator>!=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>num_shard</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>qstring_tonode</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            </block_content>}</block></for>
                            <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>qstring_tonode</name></expr></argument>, <argument><expr><literal type="string">");"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            
                            <expr_stmt><expr><name>movecmd</name> <operator>=</operator> <name><name>qstring_tonode</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
                        </block_content>}</block>                            
                        <break>break;</break>
                    <case>case <expr><name>MOVE_DATA_STRATEGY_AT</name></expr>:</case>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Move Strategy MOVE_DATA_STRATEGY_AT is not supported in coordinator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <default>default:</default>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid Move Strategy: %d"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
                <comment type="block">/* generate ExecNodes*/</comment>
                <expr_stmt><expr><name>execnodes</name> <operator>=</operator> <operator>(</operator><name>ExecNodes</name> <operator>*</operator><operator>)</operator><call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>=</operator> <name>RELATION_ACCESS_READ</name></expr>;</expr_stmt>  <comment type="block">/* not used */</comment>
                <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name>LOCATOR_TYPE_SHARD</name></expr>;</expr_stmt>  <comment type="block">/* not used */</comment>
                <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>en_expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>en_relid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>primarynodelist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

                <comment type="block">/* For dn, move data cmd should send to all dns which belong to the move data group. */</comment>
                <expr_stmt><expr><name>group_oid</name> <operator>=</operator> <call><name>get_pgxc_groupoid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>group</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>group_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"group with name:%s not found"</literal></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>group</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* check if the group contains this two datanodes */</comment>
                <expr_stmt><expr><name>ndns</name> <operator>=</operator> <call><name>get_pgxc_groupmembers</name><argument_list>(<argument><expr><name>group_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dnoids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <comment type="block">/* get node index */</comment>
                    <decl_stmt><decl><type><name>char</name></type> <name>node_type</name> <init>= <expr><name>PGXC_NODE_DATANODE</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>nodeindex</name> <operator>=</operator> <call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name><name>dnoids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nodeindex</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nodeindex</name> <operator>&lt;</operator> <name>NumDataNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
    
                <comment type="block">/* Send Move Data Command to Data Node */</comment>
                <expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>movecmd</name></expr></argument>, <argument><expr><name>execnodes</name></expr></argument>, 
										<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>EXEC_ON_DATANODES</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>qstring_tonode</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>qstring_tonode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if<condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>UpdateReplicaRelNodes</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>MoveDataStmt</name><operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>toid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>reloids</name> <operator>=</operator> <call><name>GetShardRelations</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <macro><name>foreach</name><argument_list>(<argument>cell</argument>,<argument>reloids</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>,<argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,<argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
                        
        </block_content>}</block>
        <break>break;</break>
        
        <case>case <expr><name>T_DropShardStmt</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>DropShardStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DropShardStmt</name> <operator>*</operator><operator>)</operator><name>parsetree</name></expr></init></decl>;</decl_stmt>
            
            <decl_stmt><decl><type><name>Oid</name></type> <name>group</name> <init>= <expr><call><name>get_pgxc_groupoid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>group_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"node group %s not exist."</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>group_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>GroupHasRelations</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"node group %s still has relations inside, please remove them first."</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>group_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* first drop sharding map locally */</comment>
            <expr_stmt><expr><call><name>DropShardMap_Node</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
            <if_stmt><if>if<condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>   <name>i</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int32</name></type> <name><name>nodeIndex</name><index>[<expr><name>MAX_GROUP_NODE_NUMBER</name></expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int32</name></type> <name>nodenum</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>execnodes</name></decl>;</decl_stmt>
                
                <comment type="block">/* drop remote coord sharding map */</comment>
				<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>EXEC_ON_COORDS</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <comment type="block">/* drop datanodes sharding map */</comment>
                <expr_stmt><expr><call><name>GetGroupNodesByNameOrder</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>nodeIndex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>execnodes</name> <operator>=</operator> <operator>(</operator><name>ExecNodes</name> <operator>*</operator><operator>)</operator><call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <comment type="block">/* generate ExecNodes*/</comment>                     
                <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>=</operator> <name>RELATION_ACCESS_READ</name></expr>;</expr_stmt>  <comment type="block">/* not used */</comment>
                <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name>LOCATOR_TYPE_SHARD</name></expr>;</expr_stmt>  <comment type="block">/* not used */</comment>
                <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>en_expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>en_relid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>primarynodelist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt> 
                
                <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nodenum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><name><name>nodeIndex</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>execnodes</name></expr></argument>, 
										<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>EXEC_ON_DATANODES</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>execnodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                            
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        </block_content>}</block>
                
        <case>case <expr><name>T_CleanShardingStmt</name></expr>:</case>
        <block>{<block_content>
            <comment type="block">/*
             * Support two format of CleanShardingStmt.
             * 1. CLEAN SHARDING;
             * 2. CLEAN SHARDING GROUP groupname FROM from_node TO to_node;
             * For the first case, command will send to all cn and dn in cluster.
             * For the second case, command will send to all cn and all dn belong to the given group.
             */</comment>
            
            <decl_stmt><decl><type><name>CleanShardingStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CleanShardingStmt</name> <operator>*</operator><operator>)</operator><name>parsetree</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type> <name>groupid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>execnodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>fromidx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>fromoid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>toidx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>tooid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>dnoids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>ndns</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>nodeindex</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type> <name>node_type</name></decl>;</decl_stmt>
            
            <comment type="block">/* Case: CLEAN SHARDING */</comment>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>group_name</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Send cleansharding msg to all other cn and dn */</comment>
                <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
                <block>{<block_content>
					<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
											<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>EXEC_ON_ALL_NODES</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* Then cleansharding self */</comment>
                <expr_stmt><expr><call><name>ForceRefreshShardMap</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Case: CLEAN SHARDING GROUP groupname FROM from_node TO to_node */</comment>
            <expr_stmt><expr><name>groupid</name> <operator>=</operator> <call><name>get_pgxc_groupoid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>group_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>groupid</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"group name %s is not exist."</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>group_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>fromoid</name> <operator>=</operator> <call><name>get_pgxc_nodeoid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dn_from</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>fromoid</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"datanode %s is not exist."</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dn_from</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>tooid</name> <operator>=</operator> <call><name>get_pgxc_nodeoid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dn_to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>fromoid</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"datanode %s is not exist."</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dn_to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ForceRefreshShardMap</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <if_stmt><if>if<condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if<condition>(<expr><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call></expr>)</condition>
                <block>{<block_content>    
                    <expr_stmt><expr><call><name>ForceRefreshShardMap</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* 
                     * control clean flow 
                     * first, to node;
                     * second, all other cn and self;
                     * third, all other dn in the given group;
                     * last, from node;
                     */</comment>
                    <comment type="line">//first clean sharding at to datanode</comment>
                    <expr_stmt><expr><name>execnodes</name> <operator>=</operator> <operator>(</operator><name>ExecNodes</name> <operator>*</operator><operator>)</operator><call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>=</operator> <name>RELATION_ACCESS_READ</name></expr>;</expr_stmt>  <comment type="block">/* not used */</comment>
                    <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name>LOCATOR_TYPE_SHARD</name></expr>;</expr_stmt>  <comment type="block">/* not used */</comment>
                    <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>en_expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>en_relid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>primarynodelist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

                    <comment type="block">/* get node index */</comment>
                    <expr_stmt><expr><name>node_type</name> <operator>=</operator> <name>PGXC_NODE_DATANODE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>toidx</name> <operator>=</operator> <call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name>tooid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if<condition>(<expr><name>toidx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"innel error: datanode %d cannot be found."</literal></expr></argument>, <argument><expr><name>tooid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>,<argument><expr><name>toidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"CLEAN SHARDING;"</literal></expr></argument>, <argument><expr><name>execnodes</name></expr></argument>, 
											<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>EXEC_ON_DATANODES</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    
                    <comment type="line">//second clean sharding of all cooridnators</comment>
					<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
											<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>EXEC_ON_COORDS</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="line">//and self                        </comment>
                    <expr_stmt><expr><call><name>ForceRefreshShardMap</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">//third clean sharding at all other dns which belong to the given group.</comment>
                    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <comment type="block">/* check if the group contains this two datanodes */</comment>
                    <expr_stmt><expr><name>ndns</name> <operator>=</operator> <call><name>get_pgxc_groupmembers</name><argument_list>(<argument><expr><name>groupid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dnoids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>fromoid</name> <operator>==</operator> <name><name>dnoids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator>
                            <name>tooid</name>    <operator>==</operator> <name><name>dnoids</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"dnoids[%d]=%d, fromoid=%d, tooid=%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>dnoids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fromoid</name></expr></argument>, <argument><expr><name>tooid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        </block_content>}</block></if></if_stmt>
                        <comment type="block">/* get node index */</comment>
                        <expr_stmt><expr><name>node_type</name> <operator>=</operator> <name>PGXC_NODE_DATANODE</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>nodeindex</name> <operator>=</operator> <call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name><name>dnoids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nodeindex</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nodeindex</name> <operator>&lt;</operator> <name>NumDataNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                    <expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"CLEAN SHARDING;"</literal></expr></argument>, <argument><expr><name>execnodes</name></expr></argument>, 
											<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>EXEC_ON_DATANODES</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            

                    <comment type="line">//finally clean sharding at from datanode</comment>
                    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>node_type</name> <operator>=</operator> <name>PGXC_NODE_DATANODE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>fromidx</name> <operator>=</operator> <call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name>fromoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if<condition>(<expr><name>fromidx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"innel error: datanode %d cannot be found."</literal></expr></argument>, <argument><expr><name>fromidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>,<argument><expr><name>fromidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"CLEAN SHARDING;"</literal></expr></argument>, <argument><expr><name>execnodes</name></expr></argument>, 
											<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>EXEC_ON_DATANODES</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>execnodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>                    
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        </block_content>}</block>    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
        <case>case <expr><name>T_CreateKeyValuesStmt</name></expr>:</case>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>CREATE_KEY_VALUE_EXEC_ALL</name> <operator>==</operator> <name>g_create_key_value_mode</name><operator>)</operator>
                    <operator>||</operator> <operator>(</operator><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <name>CREATE_KEY_VALUE_EXEC_CN</name> <operator>==</operator> <name>g_create_key_value_mode</name><operator>)</operator>
                    <operator>||</operator> <operator>(</operator><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <name>CREATE_KEY_VALUE_EXEC_DN</name> <operator>==</operator> <name>g_create_key_value_mode</name><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ExecCreateKeyValuesStmt</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>IS_PGXC_COORDINATOR</name></expr>)</condition>
                <block>{<block_content>                    
                    <decl_stmt><decl><type><name>Oid</name></type>                    <name>group_oid</name>      <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Oid</name></type>                    <name>cold_group_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type>                    <name>i</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int32</name></type>                <name>nodenum</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int32</name></type>                <name><name>nodeIndex</name><index>[<expr><name>MAX_GROUP_NODE_NUMBER</name></expr>]</index></name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>ExecNodes</name>           <modifier>*</modifier></type><name>execnodes</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>char</name>                <modifier>*</modifier></type><name>checkoverlaps_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>List</name>                <modifier>*</modifier></type><name>stmts</name>             <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>CreateKeyValuesStmt</name> <modifier>*</modifier></type><name>stmt</name>              <init>= <expr><operator>(</operator><name>CreateKeyValuesStmt</name> <operator>*</operator><operator>)</operator><name>parsetree</name></expr></init></decl>;</decl_stmt>

                    <comment type="block">/* check key value overlaps */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>group</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>group_oid</name> <operator>=</operator> <call><name>get_pgxc_groupoid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>group</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>group_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC Group %s: group not defined"</literal></expr></argument>,
                                                <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>group</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>coldgroup</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>cold_group_oid</name> <operator>=</operator> <call><name>get_pgxc_groupoid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>coldgroup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>cold_group_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC Group %s: group not defined"</literal></expr></argument>,
                                            <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>coldgroup</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                    
                    <expr_stmt><expr><name>checkoverlaps_str</name> <operator>=</operator> <call><name>BuildKeyValueCheckoverlapsStr</name><argument_list>(<argument><expr><name>group_oid</name></expr></argument>, <argument><expr><name>cold_group_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>checkoverlaps_str</name></expr>)</condition>
                    <block>{<block_content>    
                        <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>wrapper</name></decl>;</decl_stmt>
                        
                        <expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>AddRemoteQueryNode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>checkoverlaps_str</name></expr></argument>, <argument><expr><name>EXEC_ON_DATANODES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    

                        <expr_stmt><expr><name>wrapper</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>stmts</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><call><name>list_nth</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                        <expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr>;</expr_stmt>
                            
                        <comment type="block">/* only one node here, just run it */</comment>
                        <expr_stmt><expr><call><name>ProcessUtility</name><argument_list>(<argument><expr><name>wrapper</name></expr></argument>,
                                       <argument><expr><name>queryString</name></expr></argument>,
                                       <argument><expr><name>PROCESS_UTILITY_SUBCOMMAND</name></expr></argument>,
                                       <argument><expr><name>params</name></expr></argument>,<argument><expr><name>queryEnv</name></expr></argument>,
                                       <argument><expr><name>None_Receiver</name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
                                       <argument><expr><name>true</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>
                                       <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* overlaps_string can not be freed here */</comment>                        
                    </block_content>}</block></if></if_stmt>

                    
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>CREATE_KEY_VALUE_EXEC_ALL</name> <operator>==</operator> <name>g_create_key_value_mode</name><operator>)</operator>
                        <operator>||</operator> <operator>(</operator><name>CREATE_KEY_VALUE_EXEC_CN</name> <operator>==</operator> <name>g_create_key_value_mode</name><operator>)</operator></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* first tell other coord node to create */</comment>
    					<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
												<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>EXEC_ON_COORDS</name></expr></argument>,
												<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>CREATE_KEY_VALUE_EXEC_ALL</name> <operator>==</operator> <name>g_create_key_value_mode</name><operator>)</operator>
                        <operator>||</operator> <operator>(</operator><name>CREATE_KEY_VALUE_EXEC_DN</name> <operator>==</operator> <name>g_create_key_value_mode</name><operator>)</operator></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* then tell the nodes of the key value group to create */</comment>                        
                        <expr_stmt><expr><call><name>GetGroupNodesByNameOrder</name><argument_list>(<argument><expr><name>group_oid</name></expr></argument>, <argument><expr><name>nodeIndex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>execnodes</name> <operator>=</operator> <operator>(</operator><name>ExecNodes</name> <operator>*</operator><operator>)</operator><call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nodenum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <comment type="block">/* generate ExecNodes*/</comment>                        
                            <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>=</operator> <name>RELATION_ACCESS_READ</name></expr>;</expr_stmt>  <comment type="block">/* not used */</comment>
                            <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name>LOCATOR_TYPE_SHARD</name></expr>;</expr_stmt>  <comment type="block">/* not used */</comment>
                            <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>en_expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>en_relid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>primarynodelist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt> 

                            <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><name><name>nodeIndex</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>execnodes</name></expr></argument>, 
    												<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>EXEC_ON_DATANODES</name></expr></argument>,
													<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
                        </block_content>}</block></for>
                        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>execnodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/* then tell the nodes of the key value cold group to create */</comment>    
                        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>coldgroup</name></name></expr>)</condition>
                        <block>{<block_content>                            
                            <expr_stmt><expr><call><name>GetGroupNodesByNameOrder</name><argument_list>(<argument><expr><name>cold_group_oid</name></expr></argument>, <argument><expr><name>nodeIndex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>execnodes</name> <operator>=</operator> <operator>(</operator><name>ExecNodes</name> <operator>*</operator><operator>)</operator><call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nodenum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                            <block>{<block_content>
                                <comment type="block">/* generate ExecNodes*/</comment>                        
                                <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>=</operator> <name>RELATION_ACCESS_READ</name></expr>;</expr_stmt>  <comment type="block">/* not used */</comment>
                                <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name>LOCATOR_TYPE_SHARD</name></expr>;</expr_stmt>  <comment type="block">/* not used */</comment>
                                <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>en_expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>en_relid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>primarynodelist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt> 

                                <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><name><name>nodeIndex</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>execnodes</name></expr></argument>, 
    													<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>EXEC_ON_DATANODES</name></expr></argument>,
														<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>execnodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
                            </block_content>}</block></for>
                            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>execnodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>                
                <break>break;</break>
            </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <case>case <expr><name>T_LockNodeStmt</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>LockNodeStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>LockNodeStmt</name> <operator>*</operator><operator>)</operator><name>parsetree</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* lock node */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>lock</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LockNode</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else <comment type="block">/* unlock node */</comment>
            <block>{<block_content>
                <expr_stmt><expr><call><name>UnLockNode</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            
            <break>break;</break>
        </block_content>}</block>
		<case>case <expr><name>T_SampleStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SampleStmt</name> <modifier>*</modifier></type> <name>stmt</name> <init>= <expr><operator>(</operator><name>SampleStmt</name> <operator>*</operator> <operator>)</operator><name>parsetree</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ExecSample</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>T_AlterNodeStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateNodeStmt</name></expr>:</case>
        <case>case <expr><name>T_DropNodeStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateGroupStmt</name></expr>:</case>
        <case>case <expr><name>T_DropGroupStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterGroupStmt</name></expr>:</case>
        <case>case <expr><name>T_RemoteQuery</name></expr>:</case>
        <case>case <expr><name>T_BarrierStmt</name></expr>:</case>
        <case>case <expr><name>T_PauseClusterStmt</name></expr>:</case>
        <case>case <expr><name>T_CleanConnStmt</name></expr>:</case>
            <break>break;</break>

        <default>default:</default>
            <comment type="block">/* All other statement types have event trigger support */</comment>
            <expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
                               <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
                               <argument><expr><name>dest</name></expr></argument>,
                               <argument><expr><name>sentToRemote</name></expr></argument>,
                               <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>ProcessUtilityPost</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The "Slow" variant of ProcessUtility should only receive statements
 * supported by the event triggers facility.  Therefore, we always
 * perform the trigger support calls if the context allows it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessUtilitySlow</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
                   <parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
                   <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
                   <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
                   <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
                   <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
                   <parameter><decl><type><name>bool</name></type> <name>sentToRemote</name></decl></parameter>,
                   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isTopLevel</name> <init>= <expr><operator>(</operator><name>context</name> <operator>==</operator> <name>PROCESS_UTILITY_TOPLEVEL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isCompleteQuery</name> <init>= <expr><operator>(</operator><name>context</name> <operator>&lt;=</operator> <name>PROCESS_UTILITY_QUERY</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>needCleanup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>commandCollected</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><name>InvalidObjectAddress</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>secondaryObject</name> <init>= <expr><name>InvalidObjectAddress</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* All event trigger calls are done only when isCompleteQuery is true */</comment>
    <expr_stmt><expr><name>needCleanup</name> <operator>=</operator> <name>isCompleteQuery</name> <operator>&amp;&amp;</operator> <call><name>EventTriggerBeginCompleteQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* PG_TRY block is to ensure we call EventTriggerEndCompleteQuery */</comment>
    <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>isCompleteQuery</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>EventTriggerDDLCommandStart</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
                <comment type="block">/*
                 * relation and attribute manipulation
                 */</comment>
            <case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<comment type="block">/*
                 * If I am the main execute CN but not Leader CN,
                 * Notify the Leader CN to create firstly.
                 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><call><name>CreateSchemaCommand</name><argument_list>(<argument><expr><operator>(</operator><name>CreateSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
                                    <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>,
                                    <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr></argument>,
                                    <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * EventTriggerCollectSimpleCommand called by
                 * CreateSchemaCommand
                 */</comment>
                <expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_CreateStmt</name></expr>:</case>
            <case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>stmts</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name></type>        <name>is_temp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name></type>        <name>is_local</name> <init>= <expr><operator>(</operator><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>islocal</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                    <decl_stmt><decl><type><name>DistributeBy</name> <modifier>*</modifier></type><name>distributeby</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                       <decl_stmt><decl><type><name>PGXCSubCluster</name> <modifier>*</modifier></type><name>subcluster</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<decl_stmt><decl><type><name>Oid</name></type> <name>nspaceid</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type> <name>exist_ok</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>is_txn_has_parallel_ddl</name> <operator>&amp;&amp;</operator> <call><name>IsConnFromCoord</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>exist_ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="block">/* Run parse analysis ... */</comment>
                    <comment type="block">/*
                     * If sentToRemote is set it is either EXECUTE DIRECT or part
                     * of extencion definition script, that is a kind of extension
                     * specific metadata table. So it makes sense do not distribute
                     * the relation. If someone sure he needs the table distributed
                     * it should explicitly specify distribution.
                     */</comment>
                    <expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>transformCreateStmt</name><argument_list>(<argument><expr><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
							<argument><expr><name>queryString</name></expr></argument>, <argument><expr><operator>!</operator><name>is_local</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>sentToRemote</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>nspaceid</name></expr></argument>, <argument><expr><name>exist_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>stmts</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
					<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>transformCreateStmt</name><argument_list>(<argument><expr><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
							<argument><expr><name>queryString</name></expr></argument>, <argument><expr><operator>!</operator><name>is_local</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>sentToRemote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * Scan the list of objects.
                         * Temporary tables are created on Datanodes only.
                         * Non-temporary objects are created on all nodes.
                         * In case temporary and non-temporary objects are mized return an error.
                         */</comment>
                        <decl_stmt><decl><type><name>bool</name></type>    <name>is_first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

                        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>stmts</argument>)</argument_list></macro>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>CreateStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>stmt_loc</name> <init>= <expr><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>
                                <decl_stmt><decl><type><name>bool</name></type> <name>is_object_temp</name> <init>= <expr><name><name>stmt_loc</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr></init></decl>;</decl_stmt>
                                
                                <comment type="block">/*make sure local coordinator always send create table command to remote cn and dn */</comment>
                                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_object_temp</name> <operator>&amp;&amp;</operator> <name><name>stmt_loc</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>OBJECT_TABLE</name> <operator>&amp;&amp;</operator> <name>sentToRemote</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Cannot support nondistribute table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ENABLE_ALL_TABLE_TYPE</name></cpp:ifndef>
                                <if_stmt><if>if<condition>(<expr><name><name>stmt_loc</name><operator>-&gt;</operator><name>distributeby</name></name> 
                                    <operator>&amp;&amp;</operator> <name><name>stmt_loc</name><operator>-&gt;</operator><name>distributeby</name><operator>-&gt;</operator><name>disttype</name></name> <operator>!=</operator> <name>DISTTYPE_SHARD</name>
                                    <operator>&amp;&amp;</operator> <name><name>stmt_loc</name><operator>-&gt;</operator><name>distributeby</name><operator>-&gt;</operator><name>disttype</name></name> <operator>!=</operator> <name>DISTTYPE_REPLICATION</name></expr>)</condition>
                                <block>{<block_content>
                                    
                                    <switch>switch<condition>(<expr><name><name>stmt_loc</name><operator>-&gt;</operator><name>distributeby</name><operator>-&gt;</operator><name>disttype</name></name></expr>)</condition>
                                    <block>{<block_content>
                                        <case>case <expr><name>DISTTYPE_HASH</name></expr>:</case>                                         
                                        <case>case <expr><name>DISTTYPE_MODULO</name></expr>:</case>
                                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Cannot support distribute type: Hash"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                            <break>break;</break>
                                        <case>case <expr><name>DISTTYPE_ROUNDROBIN</name></expr>:</case>
                                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Cannot support distribute type: RoundRobin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                            <break>break;</break>
                                        <default>default:</default>
											<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"Unknown distribute type."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                            <break>break;</break>
                                    </block_content>}</block></switch>
                                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

                                <if_stmt><if>if <condition>(<expr><name>is_first</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>is_first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                                    <if_stmt><if>if <condition>(<expr><name>is_object_temp</name></expr>)</condition><block type="pseudo"><block_content>
                                        <expr_stmt><expr><name>is_temp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                                </block_content>}</block></if>
                                <else>else
                                <block>{<block_content>
                                    <if_stmt><if>if <condition>(<expr><name>is_object_temp</name> <operator>!=</operator> <name>is_temp</name></expr>)</condition><block type="pseudo"><block_content>
                                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CREATE not supported for TEMP and non-TEMP objects"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                                                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"You should separate TEMP and non-TEMP objects"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                                </block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>                
                                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_object_temp</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>distributeby</name> <operator>=</operator> <name><name>stmt_loc</name><operator>-&gt;</operator><name>distributeby</name></name></expr>;</expr_stmt>
                                       <expr_stmt><expr><name>subcluster</name>   <operator>=</operator> <name><name>stmt_loc</name><operator>-&gt;</operator><name>subcluster</name></name></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            </block_content>}</block></if>
                            <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>CreateForeignTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <comment type="block">/* There are no temporary foreign tables */</comment>
                                <if_stmt><if>if <condition>(<expr><name>is_first</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>is_first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                                </block_content>}</block></if>
                                <else>else
                                <block>{<block_content>
                                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_temp</name></expr>)</condition><block type="pseudo"><block_content>
                                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CREATE not supported for TEMP and non-TEMP objects"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                                                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"You should separate TEMP and non-TEMP objects"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                                </block_content>}</block></else></if_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block>
                    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<comment type="block">/*
					 * If I am the main execute CN but not Leader CN,
					 * Notify the Leader CN to create firstly.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>leader_cn</name> <init>= <expr><call><name>find_ddl_leader_cn</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_ddl_leader_cn</name><argument_list>(<argument><expr><name><name>leader_cn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * Unlock namespace before send to Leader CN
							 * in case of concurrent drop schema and create
							 * schema.xxx dead lock.
							 */</comment>
							<expr_stmt><expr><call><name>UnlockDatabaseObject</name><argument_list>(<argument><expr><name>NamespaceRelationId</name></expr></argument>, <argument><expr><name>nspaceid</name></expr></argument>,
													<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>LockDatabaseObject</name><argument_list>(<argument><expr><name>NamespaceRelationId</name></expr></argument>, <argument><expr><name>nspaceid</name></expr></argument>,
													<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                    <comment type="block">/* Add check overlap remote query on top of query tree */</comment>
                    <if_stmt><if>if <condition>(<expr><name>subcluster</name> <operator>&amp;&amp;</operator> <name>distributeby</name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>overlaps_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name>overlaps_string</name> <operator>=</operator> <call><name>BuildRelationCheckoverlapsStr</name><argument_list>(<argument><expr><name>distributeby</name></expr></argument>, <argument><expr><name>subcluster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>overlaps_string</name></expr>)</condition>
                        <block>{<block_content>    
                            <expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>AddRemoteQueryNode</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><name>overlaps_string</name></expr></argument>, <argument><expr><name>EXEC_ON_DATANODES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <comment type="block">/* overlaps_string can not be freed here */</comment>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <comment type="block">/*
                     * Add a RemoteQuery node for a query at top level on a remote
                     * Coordinator, if not already done so
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>AddRemoteQueryNode</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><ternary><condition><expr><name>is_local</name></expr>
                                ?</condition><then> <expr><name>EXEC_ON_NONE</name></expr>
                                </then><else>: <expr><operator>(</operator><ternary><condition><expr><name>is_temp</name></expr> ?</condition><then> <expr><name>EXEC_ON_DATANODES</name></expr> </then><else>: <expr><name>EXEC_ON_ALL_NODES</name></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="block">/* ... and do it */</comment>
                    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>stmts</argument>)</argument_list></macro>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>CreateStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>Datum</name></type>        <name>toast_options</name></decl>;</decl_stmt>
                            <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>validnsps</name><index>[]</index></name> <init>= <expr><name>HEAP_RELOPT_NAMESPACES</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                            <decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>createStmt</name> <init>= <expr><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator><name>stmt</name></expr></init></decl>;</decl_stmt>

                            <comment type="block">/* Set temporary object object flag in pooler */</comment>
                            <if_stmt><if>if <condition>(<expr><name>is_temp</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>PoolManagerSetCommand</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>POOL_CMD_TEMP</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                            <comment type="block">/* Create the table itself */</comment>
                            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineRelation</name><argument_list>(<argument><expr><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
                                    <argument><expr><name>RELKIND_RELATION</name></expr></argument>,
                                    <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                    <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>EventTriggerCollectSimpleCommand</name><argument_list>(<argument><expr><name>address</name></expr></argument>,
                                    <argument><expr><name>secondaryObject</name></expr></argument>,
                                    <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <comment type="block">/*
                             * Let NewRelationCreateToastTable decide if this
                             * one needs a secondary relation too.
                             */</comment>
                            <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                            <comment type="block">/*
                             * parse and validate reloptions for the toast
                             * table
                             */</comment>
                            <expr_stmt><expr><name>toast_options</name> <operator>=</operator> <call><name>transformRelOptions</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
                                    <argument><expr><operator>(</operator><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name><operator>)</operator><operator>-&gt;</operator><name>options</name></expr></argument>,
                                    <argument><expr><literal type="string">"toast"</literal></expr></argument>,
                                    <argument><expr><name>validnsps</name></expr></argument>,
                                    <argument><expr><name>true</name></expr></argument>,
                                    <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>heap_reloptions</name><argument_list>(<argument><expr><name>RELKIND_TOASTVALUE</name></expr></argument>,
                                    <argument><expr><name>toast_options</name></expr></argument>,
                                    <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><call><name>NewRelationCreateToastTable</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>,
                                    <argument><expr><name>toast_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <comment type="block">/* 
                                  *  interval partition's parent table has been created, we need to create
                                  *  child tables.
                                                          */</comment>
                                <if_stmt><if>if <condition>(<expr><name><name>createStmt</name><operator>-&gt;</operator><name>partspec</name></name> <operator>&amp;&amp;</operator> 
                                    <call><name>strcmp</name><argument_list>(<argument><expr><name><name>createStmt</name><operator>-&gt;</operator><name>partspec</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>, <argument><expr><name>PARTITION_INTERVAL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                                <block>{<block_content>
                                    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                                    <decl_stmt><decl><type><name>PartitionBy</name> <modifier>*</modifier></type><name>interval</name> <init>= <expr><name><name>createStmt</name><operator>-&gt;</operator><name>partspec</name><operator>-&gt;</operator><name>interval</name></name></expr></init></decl>;</decl_stmt>

                                    <decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>createInterval</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>createStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                    <expr_stmt><expr><name><name>createInterval</name><operator>-&gt;</operator><name>interval_child</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                                    <expr_stmt><expr><name><name>createInterval</name><operator>-&gt;</operator><name>interval_parentId</name></name> <operator>=</operator> <name><name>address</name><operator>.</operator><name>objectId</name></name></expr>;</expr_stmt>
                                    <expr_stmt><expr><name><name>createInterval</name><operator>-&gt;</operator><name>partspec</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                                    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>interval</name><operator>-&gt;</operator><name>nPartitions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                                    <block>{<block_content>
                                        <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>addr</name></decl>;</decl_stmt>
                                        
                                        <expr_stmt><expr><name><name>createInterval</name><operator>-&gt;</operator><name>interval_child_idx</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

                                        <comment type="block">/* Create the table itself */</comment>
                                        <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>DefineRelation</name><argument_list>(<argument><expr><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>createInterval</name></expr></argument>,
                                                <argument><expr><name>RELKIND_RELATION</name></expr></argument>,
                                                <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                                <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        <comment type="block">/*
                                         * Let NewRelationCreateToastTable decide if this
                                         * one needs a secondary relation too.
                                         */</comment>
                                        <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                                        <expr_stmt><expr><call><name>NewRelationCreateToastTable</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>objectId</name></name></expr></argument>,
                                                                    <argument><expr><name>toast_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></for>
                                </block_content>}</block></if></if_stmt>

                                <comment type="block">/* 
                                 * If shard table created, replica identity for this table 
                                 * is also needed(used for logical replication). 
                                 */</comment>
                                <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
                                <block>{<block_content>
                                    <if_stmt><if>if <condition>(<expr><name><name>createStmt</name><operator>-&gt;</operator><name>distributeby</name></name> <operator>&amp;&amp;</operator> <name><name>createStmt</name><operator>-&gt;</operator><name>distributeby</name><operator>-&gt;</operator><name>disttype</name></name> <operator>==</operator> <name>DISTTYPE_SHARD</name>
                                        <operator>&amp;&amp;</operator> <operator>!</operator><name><name>createStmt</name><operator>-&gt;</operator><name>interval_child</name></name></expr>)</condition>
                                    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
                                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Replica identity is needed for shard table, please add to this table "</literal>
                                                     <literal type="string">"through \"alter table\" command."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Replica identity is needed for shard table, please add to this table "</literal>
                                                     <literal type="string">"through \"alter table\" command."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                    </block_content>}</block></if></if_stmt>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>CreateForeignTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/* Create the table itself */</comment>
                            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineRelation</name><argument_list>(<argument><expr><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
                                    <argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>,
                                    <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                    <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>CreateForeignTable</name><argument_list>(<argument><expr><operator>(</operator><name>CreateForeignTableStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
                                    <argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>EventTriggerCollectSimpleCommand</name><argument_list>(<argument><expr><name>address</name></expr></argument>,
                                    <argument><expr><name>secondaryObject</name></expr></argument>,
                                    <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <comment type="block">/*
                             * Recurse for anything else.  Note the recursive
                             * call will stash the objects so created into our
                             * event trigger context.
                             */</comment>
                            <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>wrapper</name></decl>;</decl_stmt>

                            <expr_stmt><expr><name>wrapper</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name>stmt</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr>;</expr_stmt>

                            <expr_stmt><expr><call><name>ProcessUtility</name><argument_list>(<argument><expr><name>wrapper</name></expr></argument>,
                                    <argument><expr><name>queryString</name></expr></argument>,
                                    <argument><expr><name>PROCESS_UTILITY_SUBCOMMAND</name></expr></argument>,
                                    <argument><expr><name>params</name></expr></argument>,
                                    <argument><expr><name>NULL</name></expr></argument>,
                                    <argument><expr><name>None_Receiver</name></expr></argument>,
                                    <argument><expr><name>true</name></expr></argument>,
                                    <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>

                        <comment type="block">/* Need CCI between commands */</comment>
                        <if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block>

                    <comment type="block">/*
                     * The multiple commands generated here are stashed
                     * individually, so disable collection below.
                     */</comment>
                    <expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
            <case>case <expr><name>T_AuditStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>auditString</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>AuditDefine</name><argument_list>(<argument><expr><operator>(</operator><name>AuditStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>auditString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>auditString</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
						<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>auditString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>EXEC_ON_ALL_NODES</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>auditString</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>auditString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>
            <case>case <expr><name>T_CleanAuditStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>cleanString</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>AuditClean</name><argument_list>(<argument><expr><operator>(</operator><name>CleanAuditStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cleanString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>cleanString</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
						<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>cleanString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,	<argument><expr><name>EXEC_ON_ALL_NODES</name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>cleanString</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cleanString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>atstmt</name> <init>= <expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>stmts</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>LOCKMODE</name></type>    <name>lockmode</name></decl>;</decl_stmt>

                    <comment type="block">/*
                     * Figure out lock mode, and acquire lock.  This also does
                     * basic permissions checks, so that we won't wait for a
                     * lock on (for example) a relation on which we have no
                     * permissions.
                     */</comment>
                    <expr_stmt><expr><name>lockmode</name> <operator>=</operator> <call><name>AlterTableGetLockLevel</name><argument_list>(<argument><expr><name><name>atstmt</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<comment type="block">/*
					 * If I am the main execute CN but not Leader CN,
					 * Notify the Leader CN to create firstly.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>bool</name></type> <name>is_temp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>PGXCNodeHandle</name>	<modifier>*</modifier></type><name>leaderCnHandle</name> <init>= <expr><call><name>find_ddl_leader_cn</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_ddl_leader_cn</name><argument_list>(<argument><expr><name><name>leaderCnHandle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>atstmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
															<argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>ExecUtilityFindNodes</name><argument_list>(<argument><expr><name><name>atstmt</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>,
													<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if>
							<else>else
							<block>{<block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist, skipping"</literal></expr></argument>,
											<argument><expr><name><name>atstmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>
							</block_content>}</block></else></if_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>AlterTableLookupRelation</name><argument_list>(<argument><expr><name>atstmt</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* Run parse analysis ... */</comment>
                        <expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>transformAlterTableStmt</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>atstmt</name></expr></argument>,
                                <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/*
                         * Add a RemoteQuery node for a query at top level on a remote
                         * Coordinator, if not already done so
                         */</comment>
                        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>sentToRemote</name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>bool</name></type> <name>is_temp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>RemoteQueryExecType</name></type> <name>exec_type</name></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>atstmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
                                    <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <call><name>ExecUtilityFindNodes</name><argument_list>(<argument><expr><name><name>atstmt</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>,
                                        <argument><expr><name>relid</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>AddRemoteQueryNode</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>exec_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>

                        <comment type="block">/* ... ensure we have an event trigger context ... */</comment>
                        <expr_stmt><expr><call><name>EventTriggerAlterTableStart</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>EventTriggerAlterTableRelid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/* ... and do it */</comment>
                        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>stmts</argument>)</argument_list></macro>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <comment type="block">/* Do the table alteration proper */</comment>
                                <expr_stmt><expr><call><name>AlterTable</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
                                        <argument><expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <comment type="block">/*
                                 * Recurse for anything else.  If we need to
                                 * do so, "close" the current complex-command
                                 * set, and start a new one at the bottom;
                                 * this is needed to ensure the ordering of
                                 * queued commands is consistent with the way
                                 * they are executed here.
                                 */</comment>
                                <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>wrapper</name></decl>;</decl_stmt>

                                <expr_stmt><expr><call><name>EventTriggerAlterTableEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name>wrapper</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name>stmt</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>ProcessUtility</name><argument_list>(<argument><expr><name>wrapper</name></expr></argument>,
                                        <argument><expr><name>queryString</name></expr></argument>,
                                        <argument><expr><name>PROCESS_UTILITY_SUBCOMMAND</name></expr></argument>,
                                        <argument><expr><name>params</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>,
                                        <argument><expr><name>None_Receiver</name></expr></argument>,
                                        <argument><expr><name>true</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>EventTriggerAlterTableStart</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>EventTriggerAlterTableRelid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>

                            <comment type="block">/* Need CCI between commands */</comment>
                            <if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        </block_content>}</block>

                        <comment type="block">/* done */</comment>
                        <expr_stmt><expr><call><name>EventTriggerAlterTableEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist, skipping"</literal></expr></argument>,
                                        <argument><expr><name><name>atstmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block>

                <break>break;</break>

            <case>case <expr><name>T_AlterDomainStmt</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>AlterDomainStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterDomainStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                    <comment type="block">/*
                     * Some or all of these functions are recursive to cover
                     * inherited things, so permission checks are done there.
                     */</comment>
                    <switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><literal type="char">'T'</literal></expr>:</case>    <comment type="block">/* ALTER DOMAIN DEFAULT */</comment>

                            <comment type="block">/*
                             * Recursively alter column default for table and,
                             * if requested, for descendants
                             */</comment>
                            <expr_stmt><expr><name>address</name> <operator>=</operator>
                                <call><name>AlterDomainDefault</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
                                                   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><literal type="char">'N'</literal></expr>:</case>    <comment type="block">/* ALTER DOMAIN DROP NOT NULL */</comment>
                            <expr_stmt><expr><name>address</name> <operator>=</operator>
                                <call><name>AlterDomainNotNull</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
                                                   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><literal type="char">'O'</literal></expr>:</case>    <comment type="block">/* ALTER DOMAIN SET NOT NULL */</comment>
                            <expr_stmt><expr><name>address</name> <operator>=</operator>
                                <call><name>AlterDomainNotNull</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
                                                   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><literal type="char">'C'</literal></expr>:</case>    <comment type="block">/* ADD CONSTRAINT */</comment>
                            <expr_stmt><expr><name>address</name> <operator>=</operator>
                                <call><name>AlterDomainAddConstraint</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
                                                         <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
                                                         <argument><expr><operator>&amp;</operator><name>secondaryObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><literal type="char">'X'</literal></expr>:</case>    <comment type="block">/* DROP CONSTRAINT */</comment>
                            <expr_stmt><expr><name>address</name> <operator>=</operator>
                                <call><name>AlterDomainDropConstraint</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
                                                          <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                                                          <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>,
                                                          <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><literal type="char">'V'</literal></expr>:</case>    <comment type="block">/* VALIDATE CONSTRAINT */</comment>
                            <expr_stmt><expr><name>address</name> <operator>=</operator>
                                <call><name>AlterDomainValidateConstraint</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
                                                              <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <default>default:</default>    <comment type="block">/* oops */</comment>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized alter domain type: %d"</literal></expr></argument>,
                                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                    </block_content>}</block></switch>
                </block_content>}</block>
                <break>break;</break>

                <comment type="block">/*
                 * ************* object creation / destruction **************
                 */</comment>
            <case>case <expr><name>T_DefineStmt</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>DefineStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DefineStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                    <switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
                            <expr_stmt><expr><name>address</name> <operator>=</operator>
                                <call><name>DefineAggregate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
                                                <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>oldstyle</name></name></expr></argument>,
                                                <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><name>OBJECT_OPERATOR</name></expr>:</case>
                            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineOperator</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>,
                                                     <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
                            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineType</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                                 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>,
                                                 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><name>OBJECT_TSPARSER</name></expr>:</case>
                            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineTSParser</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>,
                                                     <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><name>OBJECT_TSDICTIONARY</name></expr>:</case>
                            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineTSDictionary</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>,
                                                         <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><name>OBJECT_TSTEMPLATE</name></expr>:</case>
                            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineTSTemplate</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>,
                                                       <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><name>OBJECT_TSCONFIGURATION</name></expr>:</case>
                            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineTSConfiguration</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>,
                                                            <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>,
                                                            <argument><expr><operator>&amp;</operator><name>secondaryObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><name>OBJECT_COLLATION</name></expr>:</case>
                            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineCollation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                                      <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>,
                                                      <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>,
                                                      <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>if_not_exists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <default>default:</default>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized define stmt type: %d"</literal></expr></argument>,
                                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                    </block_content>}</block></switch>
                </block_content>}</block>
                <break>break;</break>

            <case>case <expr><name>T_IndexStmt</name></expr>:</case>    <comment type="block">/* CREATE INDEX */</comment>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>LOCKMODE</name></type>    <name>lockmode</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>inheritors</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <decl_stmt><decl><type><name>Relation</name></type>   <name>rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>istemp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>PreventTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>,
                                                <argument><expr><literal type="string">"CREATE INDEX CONCURRENTLY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>relid</name> <operator>=</operator>	<call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
														<argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
												 		<argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>RemoteQueryExecType</name></type> <name>exectype</name></decl>;</decl_stmt>
							<expr_stmt><expr><name>exectype</name> <operator>=</operator> <call><name>ExecUtilityFindNodes</name><argument_list>(<argument><expr><name>OBJECT_INDEX</name></expr></argument>,
															<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>istemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<comment type="block">/*
							 * If I am the main execute CN but not Leader CN,
							 * Notify the Leader CN to create firstly.
							 */</comment>
							<if_stmt><if>if <condition>(<expr><name>exectype</name> <operator>==</operator> <name>EXEC_ON_ALL_NODES</name> <operator>||</operator>
									<name>exectype</name> <operator>==</operator> <name>EXEC_ON_COORDS</name></expr>)</condition>
							<block>{<block_content>
								<decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>leaderCnHandle</name></decl>;</decl_stmt>
								<expr_stmt><expr><name>leaderCnHandle</name> <operator>=</operator> <call><name>find_ddl_leader_cn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
								<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_ddl_leader_cn</name><argument_list>(<argument><expr><name><name>leaderCnHandle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>)</condition>
								<block>{<block_content>
									<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>istemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								</block_content>}</block></if></if_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                    <comment type="block">/*
                     * Look up the relation OID just once, right here at the
                     * beginning, so that we don't end up repeating the name
                     * lookup later and latching onto a different relation
                     * partway through.  To avoid lock upgrade hazards, it's
                     * important that we take the strongest lock that will
                     * eventually be needed here, so the lockmode calculation
                     * needs to match what DefineIndex() does.
                     */</comment>
                    <expr_stmt><expr><name>lockmode</name> <operator>=</operator> <ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr> ?</condition><then> <expr><name>ShareUpdateExclusiveLock</name></expr>
                        </then><else>: <expr><name>ShareLock</name></expr></else></ternary></expr>;</expr_stmt>
                    <expr_stmt><expr><name>relid</name> <operator>=</operator>
                        <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
                                                 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                                 <argument><expr><name>RangeVarCallbackOwnsRelation</name></expr></argument>,
                                                 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
                    <comment type="block">/* could not create index on interval child table directly */</comment>
                    if (OidIsValid(relid))
                    {
                        Relation childRel = heap_open(relid, NoLock);

                        if (RELATION_IS_CHILD(childRel) &amp;&amp; !OidIsValid(stmt-&gt;parentIndexOid))
                        {
                            heap_close(childRel, NoLock);

                            elog(ERROR, "Create index on interval partition child is not permitted.");
                        }

                        heap_close(childRel, NoLock);
                    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

					<comment type="block">/*
					* CREATE INDEX on partitioned tables (but not regular
					* inherited tables) recurses to partitions, so we must
					* acquire locks early to avoid deadlocks.
					*/</comment>
					<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition>
					<block>{<block_content>
					   <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>

					   <comment type="block">/* already locked by RangeVarGetRelidExtended */</comment>
					   <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					   <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
					       <expr_stmt><expr><name>inheritors</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
					                                        <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					   <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

                    <comment type="block">/* Run parse analysis ... */</comment>
                    <expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>transformIndexStmt</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* ... and do it */</comment>
                    <expr_stmt><expr><call><name>EventTriggerAlterTableStart</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>address</name> <operator>=</operator>
                        <call><name>DefineIndex</name><argument_list>(<argument><expr><name>relid</name></expr></argument>,    <comment type="block">/* OID of heap relation */</comment>
                                    <argument><expr><name>stmt</name></expr></argument>,
                                    <argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* no predefined OID */</comment>
									<argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* no parent index */</comment>
									<argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* no parent constraint */</comment>
                                    <argument><expr><name>false</name></expr></argument>,    <comment type="block">/* is_alter_table */</comment>
                                    <argument><expr><name>true</name></expr></argument>,    <comment type="block">/* check_rights */</comment>
                                    <argument><expr><name>true</name></expr></argument>,    <comment type="block">/* check_not_in_use */</comment>
                                    <argument><expr><name>false</name></expr></argument>,    <comment type="block">/* skip_build */</comment>
                                    <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* quiet */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* for interval partition, create index on child tables. */</comment>
                        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>int</name></type> <name>nParts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>Oid</name></type> <name>indexOid</name>   <init>= <expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>partidxstmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>Oid</name></type> <name>relnamespace</name> <init>= <expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>MemoryContext</name></type> <name>temp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                            
                            <expr_stmt><expr><name>nParts</name> <operator>=</operator> <call><name>RelationGetNParts</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><call><name>StoreIntervalPartitionInfo</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>RELPARTKIND_PARENT</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name>rel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>

                            <expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                                          <argument><expr><literal type="string">"CreateIndexConcurrentlyContext"</literal></expr></argument>,
                                                          <argument><expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>,
                                                          <argument><expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>,
                                                          <argument><expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            
                            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nParts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>addr</name></decl>;</decl_stmt>
                                <decl_stmt><decl><type><name>Oid</name></type> <name>partOid</name></decl>;</decl_stmt>
                                <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>;</decl_stmt>
                                <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>referenced</name></decl>;</decl_stmt>
                                <decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name></decl>;</decl_stmt>

                                <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>

                                <expr_stmt><expr><name>old</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                
                                <expr_stmt><expr><name>partidxstmt</name> <operator>=</operator> <operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator><call><name>copyObject</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>partidxstmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <call><name>GetPartitionName</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>partidxstmt</name><operator>-&gt;</operator><name>idxname</name></name> <operator>=</operator> <call><name>GetPartitionName</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><name>partOid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>partidxstmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

								<if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>partOid</name></expr>)</condition>
								<block>{<block_content>
									<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<continue>continue;</continue>
								</block_content>}</block></if></if_stmt>

                                <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>DefineIndex</name><argument_list>(<argument><expr><name>partOid</name></expr></argument>,    <comment type="block">/* OID of heap relation */</comment>
                                                   <argument><expr><name>partidxstmt</name></expr></argument>,
                                                   <argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* no predefined OID */</comment>
												   <argument><expr><name>InvalidOid</name></expr></argument>,
												   <argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* no parent constraint */</comment>
                                                   <argument><expr><name>false</name></expr></argument>,    <comment type="block">/* is_alter_table */</comment>
                                                   <argument><expr><name>true</name></expr></argument>,    <comment type="block">/* check_rights */</comment>
                                                   <argument><expr><name>true</name></expr></argument>,    <comment type="block">/* check_not_in_use */</comment>
                                                   <argument><expr><name>false</name></expr></argument>,    <comment type="block">/* skip_build */</comment>
                                                   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* quiet */</comment>

                                <comment type="block">/* Make dependency entries */</comment>
                                <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>addr</name><operator>.</operator><name>objectId</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

                                <comment type="block">/* Dependency on relation */</comment>
                                <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>indexOid</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><call><name>StoreIntervalPartitionInfo</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>RELPARTKIND_CHILD</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></for>

                            <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><call><name>RELATION_IS_CHILD</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>referenced</name></decl>;</decl_stmt>

                            <comment type="block">/* Make dependency entries */</comment>
                            <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>address</name><operator>.</operator><name>objectId</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                                
                            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>parentIndexOid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <comment type="block">/* Dependency on relation */</comment>
                                <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>parentIndexOid</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><call><name>StoreIntervalPartitionInfo</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>RELPARTKIND_CHILD</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>parentIndexOid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>StoreIntervalPartitionInfo</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>RELPARTKIND_NONE</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>Oid</name></type> <name>indexOid</name>   <init>= <expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></init></decl>;</decl_stmt>

                            <expr_stmt><expr><call><name>StoreIntervalPartitionInfo</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>RELPARTKIND_NONE</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>

                        <if_stmt><if>if <condition>(<expr><name>rel</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>

                    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<comment type="block">/*
					 * Add the CREATE INDEX node itself to stash right away;
					 * if there were any commands stashed in the ALTER TABLE
					 * code, we need them to appear after this one.
					 */</comment>
					<expr_stmt><expr><call><name>EventTriggerCollectSimpleCommand</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>secondaryObject</name></expr></argument>,
													 <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>EventTriggerAlterTableEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>inheritors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>T_CreateExtensionStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>				
				<block>{<block_content>
					<decl_stmt><decl><type><name>CreateExtensionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CreateExtensionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>extension_query_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name> <operator>&amp;&amp;</operator> <name>CREATEEXT_CREATE</name> <operator>==</operator> <name><name>stmt</name><operator>-&gt;</operator><name>action</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>StringInfo</name></type> <name>qstring</name></decl>;</decl_stmt>
						<comment type="block">/* stage 1 */</comment>
						<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>PrepareExtension</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>ObjectAddressIsEqual</name><argument_list>(<argument><expr><name>InvalidObjectAddress</name></expr></argument>, <argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>

						<expr_stmt><expr><name>qstring</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><name>qstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>qstring</name></expr></argument>, 
										<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"PREPARE %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* Send prepare extension msg to all other cn and dn */</comment>
						<expr_stmt><expr><name>extension_query_string</name> <operator>=</operator> <name><name>qstring</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>,
												<argument><expr><name>extension_query_string</name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
												<argument><expr><name>EXEC_ON_ALL_NODES</name></expr></argument>,
												<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						
						<comment type="block">/* stage 2 */</comment>
						<expr_stmt><expr><call><name>ExecuteExtension</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CreateExtensionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>qstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>qstring</name></expr></argument>, 
										<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"EXECUTE %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* Send execute extension msg to all other cn and dn */</comment>
						<expr_stmt><expr><name>extension_query_string</name> <operator>=</operator> <name><name>qstring</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>,
												<argument><expr><name>extension_query_string</name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
												<argument><expr><name>EXEC_ON_ALL_NODES</name></expr></argument>,
												<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>qstring</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>qstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>CREATEEXT_PREPARE</name> <operator>==</operator> <name><name>stmt</name><operator>-&gt;</operator><name>action</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>PrepareExtension</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>CREATEEXT_EXECUTE</name> <operator>==</operator> <name><name>stmt</name><operator>-&gt;</operator><name>action</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ExecuteExtension</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateExtension</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CreateExtensionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					
					<break>break;</break>
				</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <case>case <expr><name>T_AlterExtensionStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ExecAlterExtensionStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>AlterExtensionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_AlterExtensionContentsStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ExecAlterExtensionContentsStmt</name><argument_list>(<argument><expr><operator>(</operator><name>AlterExtensionContentsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
                                                         <argument><expr><operator>&amp;</operator><name>secondaryObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_CreateFdwStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateForeignDataWrapper</name><argument_list>(<argument><expr><operator>(</operator><name>CreateFdwStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_AlterFdwStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterForeignDataWrapper</name><argument_list>(<argument><expr><operator>(</operator><name>AlterFdwStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_CreateForeignServerStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateForeignServer</name><argument_list>(<argument><expr><operator>(</operator><name>CreateForeignServerStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_AlterForeignServerStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterForeignServer</name><argument_list>(<argument><expr><operator>(</operator><name>AlterForeignServerStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_CreateUserMappingStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateUserMapping</name><argument_list>(<argument><expr><operator>(</operator><name>CreateUserMappingStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_AlterUserMappingStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterUserMapping</name><argument_list>(<argument><expr><operator>(</operator><name>AlterUserMappingStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_DropUserMappingStmt</name></expr>:</case>
                <expr_stmt><expr><call><name>RemoveUserMapping</name><argument_list>(<argument><expr><operator>(</operator><name>DropUserMappingStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* no commands stashed for DROP */</comment>
                <expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_ImportForeignSchemaStmt</name></expr>:</case>
                <expr_stmt><expr><call><name>ImportForeignSchema</name><argument_list>(<argument><expr><operator>(</operator><name>ImportForeignSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* commands are stashed inside ImportForeignSchema */</comment>
                <expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_CompositeTypeStmt</name></expr>:</case>    <comment type="block">/* CREATE TYPE (composite) */</comment>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>CompositeTypeStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CompositeTypeStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<comment type="block">/*
					 * If I am the main execute CN but not Leader CN,
					 * Notify the Leader CN to create firstly.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineCompositeType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typevar</name></name></expr></argument>,
                                                  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>coldeflist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

            <case>case <expr><name>T_CreateEnumStmt</name></expr>:</case>    <comment type="block">/* CREATE TYPE AS ENUM */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<comment type="block">/*
					 * If I am the main execute CN but not Leader CN,
					 * Notify the Leader CN to create firstly.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineEnum</name><argument_list>(<argument><expr><operator>(</operator><name>CreateEnumStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_CreateRangeStmt</name></expr>:</case> <comment type="block">/* CREATE TYPE AS RANGE */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<comment type="block">/*
					 * If I am the main execute CN but not Leader CN,
					 * Notify the Leader CN to create firstly.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineRange</name><argument_list>(<argument><expr><operator>(</operator><name>CreateRangeStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_AlterEnumStmt</name></expr>:</case>    <comment type="block">/* ALTER TYPE (enum) */</comment>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterEnum</name><argument_list>(<argument><expr><operator>(</operator><name>AlterEnumStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_ViewStmt</name></expr>:</case>    <comment type="block">/* CREATE VIEW */</comment>
                <expr_stmt><expr><call><name>EventTriggerAlterTableStart</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<comment type="block">/*
				 * If I am the main execute CN but not Leader CN,
				 * Notify the Leader CN to create firstly.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PGXCNodeHandle</name>	<modifier>*</modifier></type><name>leaderCnHandle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name>leaderCnHandle</name> <operator>=</operator> <call><name>find_ddl_leader_cn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_ddl_leader_cn</name><argument_list>(<argument><expr><name><name>leaderCnHandle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>List</name>		<modifier>*</modifier></type><name>relation_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>ListCell</name>	<modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>bool</name></type> <name>tmp</name> <init>= <expr><call><name>IsViewTemp</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ViewStmt</name><operator>*</operator><operator>)</operator><name>parsetree</name><operator>)</operator></expr></argument>,
												<argument><expr><name>queryString</name></expr></argument>,
												<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr></argument>,
												<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>relation_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<comment type="block">/* Unlock before we send to leander cn */</comment>
						<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>relation_list</argument>)</argument_list></macro>
						<block>{<block_content>
							<decl_stmt><decl><type><name>Oid</name></type> <name>reloid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
							<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineView</name><argument_list>(<argument><expr><operator>(</operator><name>ViewStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
                                     <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr></argument>, <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>EventTriggerCollectSimpleCommand</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>secondaryObject</name></expr></argument>,
                                                 <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* stashed internally */</comment>
                <expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>EventTriggerAlterTableEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_CreateFunctionStmt</name></expr>:</case>    <comment type="block">/* CREATE FUNCTION */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<comment type="block">/*
				 * If I am the main execute CN but not Leader CN,
				 * Notify the Leader CN to create firstly.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateFunction</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CreateFunctionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_AlterFunctionStmt</name></expr>:</case>    <comment type="block">/* ALTER FUNCTION */</comment>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterFunction</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>AlterFunctionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_RuleStmt</name></expr>:</case>    <comment type="block">/* CREATE RULE */</comment>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineRule</name><argument_list>(<argument><expr><operator>(</operator><name>RuleStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

			<case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type> <name>need_send</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type> <name>is_temp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type> <name>exist_ok</name> <init>= <expr><operator>!</operator><name>is_txn_has_parallel_ddl</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>CreateSeqStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CreateSeqStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>is_serial</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>is_temp</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>PGXCNodeHandle</name>	<modifier>*</modifier></type><name>leaderCnHandle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><name>need_send</name> <operator>=</operator> <call><name>PrecheckDefineSequence</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>leaderCnHandle</name> <operator>=</operator> <call><name>find_ddl_leader_cn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_send</name></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>

						<comment type="block">/*
						 * If I am the main execute CN but not Leader CN,
						 * Notify the Leader CN to create firstly.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_ddl_leader_cn</name><argument_list>(<argument><expr><name><name>leaderCnHandle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_temp</name> <operator>&amp;&amp;</operator> <name>need_send</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineSequence</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>exist_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>is_temp</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>PoolManagerSetCommand</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>POOL_CMD_TEMP</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>need_send</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>RemoteQueryExecType</name></type> <name>exec_type</name> <init>= 
							<expr><ternary><condition><expr><name>is_temp</name></expr> ?</condition><then> <expr><name>EXEC_ON_DATANODES</name></expr> </then><else>: <expr><name>EXEC_ON_ALL_NODES</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
												<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>exec_type</name></expr></argument>,
												<argument><expr><name>is_temp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineSequence</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CreateSeqStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<break>break;</break>

			<case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
                <block>{<block_content>
					<decl_stmt><decl><type><name>AlterSeqStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterSeqStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name></type> <name>is_temp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>PGXCNodeHandle</name>	<modifier>*</modifier></type><name>leaderCnHandle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name>leaderCnHandle</name> <operator>=</operator> <call><name>find_ddl_leader_cn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/*
					 * If I am the main execute CN but not Leader CN,
					 * Notify the Leader CN to create firstly.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_ddl_leader_cn</name><argument_list>(<argument><expr><name><name>leaderCnHandle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
						<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>sequence</name></name></expr></argument>,
													<argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>RemoteQueryExecType</name></type> <name>exec_type</name> <init>= <expr><name>EXEC_ON_NONE</name></expr></init></decl>;</decl_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<break>break;</break>
                    </block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>exec_type</name> <operator>=</operator> <call><name>ExecUtilityFindNodes</name><argument_list>(<argument><expr><name>OBJECT_SEQUENCE</name></expr></argument>,
															<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>exec_type</name> <operator>==</operator> <name>EXEC_ON_ALL_NODES</name> <operator>||</operator>
							<name>exec_type</name> <operator>==</operator> <name>EXEC_ON_COORDS</name></expr>)</condition>
                    <block>{<block_content>
							<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterSequence</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>AlterSeqStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>CreateTableAsStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CreateTableAsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>OBJECT_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>skipData</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <comment type="block">/*
                 * If I am the main execute CN but not Leader CN,
                 * Notify the Leader CN to create firstly.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ExecCreateTableAs</name><argument_list>(<argument><expr><operator>(</operator><name>CreateTableAsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
                                                <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
                                                <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

            <case>case <expr><name>T_RefreshMatViewStmt</name></expr>:</case>

                <comment type="block">/*
                 * REFRESH CONCURRENTLY executes some DDL commands internally.
                 * Inhibit DDL command collection here to avoid those commands
                 * from showing up in the deparsed command queue.  The refresh
                 * command itself is queued, which is enough.
                 */</comment>
                <expr_stmt><expr><call><name>EventTriggerInhibitCommandCollection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <block>{<block_content>
                    <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ExecRefreshMatView</name><argument_list>(<argument><expr><operator>(</operator><name>RefreshMatViewStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
                                                 <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>EventTriggerUndoInhibitCommandCollection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>EventTriggerUndoInhibitCommandCollection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateTrigger</name><argument_list>(<argument><expr><operator>(</operator><name>CreateTrigStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
                                        <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                                        <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <comment type="block">/* create trigger on interval partition */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>IsValidObjectAddress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>address</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>child_address</name></decl>;</decl_stmt>

                    <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
                    
                    <decl_stmt><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CreateTrigStmt</name> <operator>*</operator><operator>)</operator><name>parsetree</name></expr></init></decl>;</decl_stmt>
                    
                    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int</name></type> <name>child_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>int</name></type> <name>nParts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>child_stmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Oid</name></type> <name>child_reloid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><name>nParts</name> <operator>=</operator> <call><name>RelationGetNParts</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name>child_stmt</name> <operator>=</operator> <operator>(</operator><name>CreateTrigStmt</name> <operator>*</operator><operator>)</operator><call><name>copyObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <for>for <control>(<init><expr><name>child_idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>child_idx</name> <operator>&lt;</operator> <name>nParts</name></expr>;</condition> <incr><expr><name>child_idx</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>child_stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <call><name>GetPartitionName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>child_idx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><name>child_reloid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>child_stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>child_reloid</name></expr>)</condition>
							<block>{<block_content>
								<continue>continue;</continue>
							</block_content>}</block></if></if_stmt>

                            <expr_stmt><expr><name>child_address</name> <operator>=</operator> <call><name>CreateTrigger</name><argument_list>(<argument><expr><operator>(</operator><name>CreateTrigStmt</name> <operator>*</operator><operator>)</operator> <name>child_stmt</name></expr></argument>,
                                                          <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                                                          <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>child_address</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>address</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></for>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <break>break;</break>

            <case>case <expr><name>T_CreatePLangStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateProceduralLanguage</name><argument_list>(<argument><expr><operator>(</operator><name>CreatePLangStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_CreateDomainStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineDomain</name><argument_list>(<argument><expr><operator>(</operator><name>CreateDomainStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_CreateConversionStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateConversionCommand</name><argument_list>(<argument><expr><operator>(</operator><name>CreateConversionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
            <case>case <expr><name>T_CheckOverLapStmt</name></expr>:</case>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"CHECK OVERLAPS can't run on coordinators"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>ExecCheckOverLapStmt</name><argument_list>(<argument><expr><operator>(</operator><name>CheckOverLapStmt</name> <operator>*</operator><operator>)</operator><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <case>case <expr><name>T_CreateCastStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateCast</name><argument_list>(<argument><expr><operator>(</operator><name>CreateCastStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_CreateOpClassStmt</name></expr>:</case>
                <expr_stmt><expr><call><name>DefineOpClass</name><argument_list>(<argument><expr><operator>(</operator><name>CreateOpClassStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* command is stashed in DefineOpClass */</comment>
                <expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_CreateOpFamilyStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineOpFamily</name><argument_list>(<argument><expr><operator>(</operator><name>CreateOpFamilyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_CreateTransformStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateTransform</name><argument_list>(<argument><expr><operator>(</operator><name>CreateTransformStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_AlterOpFamilyStmt</name></expr>:</case>
                <expr_stmt><expr><call><name>AlterOpFamily</name><argument_list>(<argument><expr><operator>(</operator><name>AlterOpFamilyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* commands are stashed in AlterOpFamily */</comment>
                <expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_AlterTSDictionaryStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterTSDictionary</name><argument_list>(<argument><expr><operator>(</operator><name>AlterTSDictionaryStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_AlterTSConfigurationStmt</name></expr>:</case>
                <expr_stmt><expr><call><name>AlterTSConfiguration</name><argument_list>(<argument><expr><operator>(</operator><name>AlterTSConfigurationStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Commands are stashed in MakeConfigurationMapping and
                 * DropConfigurationMapping, which are called from
                 * AlterTSConfiguration
                 */</comment>
                <expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_AlterTableMoveAllStmt</name></expr>:</case>
                <expr_stmt><expr><call><name>AlterTableMoveAll</name><argument_list>(<argument><expr><operator>(</operator><name>AlterTableMoveAllStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* commands are stashed in AlterTableMoveAll */</comment>
                <expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_DropStmt</name></expr>:</case>
                <expr_stmt><expr><call><name>ExecDropStmt</name><argument_list>(<argument><expr><operator>(</operator><name>DropStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* no commands stashed for DROP */</comment>
                <expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_RenameStmt</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type> <name>stmt</name> <init>= <expr><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<if_stmt><if>if <condition>(<expr><name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>bool</name></type> <name>is_temp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>PGXCNodeHandle</name>	<modifier>*</modifier></type><name>leaderCnHandle</name> <init>= <expr><call><name>find_ddl_leader_cn</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>bool</name></type> <name>is_leader_cn</name> <init>= <expr><call><name>is_ddl_leader_cn</name><argument_list>(<argument><expr><name><name>leaderCnHandle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>RemoteQueryExecType</name></type> <name>exec_type</name> <init>= <expr><call><name>GetRenameExecType</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<comment type="block">/*
						 * If I am the main execute CN but not Leader CN,
						 * Notify the Leader CN to create firstly.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_leader_cn</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ExecRenameStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
												<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>exec_type</name></expr></argument>,
												<argument><expr><name>is_temp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
						<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ExecRenameStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block>
                <break>break;</break>

            <case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator>
                    <call><name>ExecAlterObjectDependsStmt</name><argument_list>(<argument><expr><operator>(</operator><name>AlterObjectDependsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
                                               <argument><expr><operator>&amp;</operator><name>secondaryObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<comment type="block">/*
				 * If I am the main execute CN but not Leader CN,
				 * Notify the Leader CN to create firstly.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>			
                <expr_stmt><expr><name>address</name> <operator>=</operator>
                    <call><name>ExecAlterObjectSchemaStmt</name><argument_list>(<argument><expr><operator>(</operator><name>AlterObjectSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
                                              <argument><expr><operator>&amp;</operator><name>secondaryObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<comment type="block">/*
				 * If I am the main execute CN but not Leader CN,
				 * Notify the Leader CN to create firstly.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ExecAlterOwnerStmt</name><argument_list>(<argument><expr><operator>(</operator><name>AlterOwnerStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_AlterOperatorStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterOperator</name><argument_list>(<argument><expr><operator>(</operator><name>AlterOperatorStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_CommentStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CommentObject</name><argument_list>(<argument><expr><operator>(</operator><name>CommentStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_GrantStmt</name></expr>:</case>
                <expr_stmt><expr><call><name>ExecuteGrantStmt</name><argument_list>(<argument><expr><operator>(</operator><name>GrantStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* commands are stashed in ExecGrantStmt_oids */</comment>
                <expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
                <expr_stmt><expr><call><name>DropOwnedObjects</name><argument_list>(<argument><expr><operator>(</operator><name>DropOwnedStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* no commands stashed for DROP */</comment>
                <expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>
                <expr_stmt><expr><call><name>ExecAlterDefaultPrivilegesStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>AlterDefaultPrivilegesStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>EventTriggerCollectAlterDefPrivs</name><argument_list>(<argument><expr><operator>(</operator><name>AlterDefaultPrivilegesStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_CreatePolicyStmt</name></expr>:</case>    <comment type="block">/* CREATE POLICY */</comment>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreatePolicy</name><argument_list>(<argument><expr><operator>(</operator><name>CreatePolicyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_AlterPolicyStmt</name></expr>:</case> <comment type="block">/* ALTER POLICY */</comment>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterPolicy</name><argument_list>(<argument><expr><operator>(</operator><name>AlterPolicyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_SecLabelStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ExecSecLabelStmt</name><argument_list>(<argument><expr><operator>(</operator><name>SecLabelStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_CreateAmStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateAccessMethod</name><argument_list>(<argument><expr><operator>(</operator><name>CreateAmStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_CreatePublicationStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreatePublication</name><argument_list>(<argument><expr><operator>(</operator><name>CreatePublicationStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_AlterPublicationStmt</name></expr>:</case>
                <expr_stmt><expr><call><name>AlterPublication</name><argument_list>(<argument><expr><operator>(</operator><name>AlterPublicationStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * AlterPublication calls EventTriggerCollectSimpleCommand
                 * directly
                 */</comment>
                <expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>CreateSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>istbase</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateTbaseSubscription</name><argument_list>(<argument><expr><operator>(</operator><name>CreateSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
                                                         <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateSubscription</name><argument_list>(<argument><expr><operator>(</operator><name>CreateSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
                                                 <argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateSubscription</name><argument_list>(<argument><expr><operator>(</operator><name>CreateSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
                                                 <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <break>break;</break>

            <case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>AlterSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>istbase</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>AlterTbaseSubscription</name><argument_list>(<argument><expr><operator>(</operator><name>AlterSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterSubscription</name><argument_list>(<argument><expr><operator>(</operator><name>AlterSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <break>break;</break>

            <case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>DropSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>istbase</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>DropTbaseSubscription</name><argument_list>(<argument><expr><operator>(</operator><name>DropSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><call><name>DropSubscription</name><argument_list>(<argument><expr><operator>(</operator><name>DropSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <comment type="block">/* no commands stashed for DROP */</comment>
                <expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_CreateStatsStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateStatistics</name><argument_list>(<argument><expr><operator>(</operator><name>CreateStatsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>T_AlterCollationStmt</name></expr>:</case>
                <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterCollation</name><argument_list>(<argument><expr><operator>(</operator><name>AlterCollationStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>

        <comment type="block">/*
         * Remember the object so that ddl_command_end event triggers have
         * access to it.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>commandCollected</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>EventTriggerCollectSimpleCommand</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>secondaryObject</name></expr></argument>,
                                             <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>isCompleteQuery</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>EventTriggerSQLDrop</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>EventTriggerDDLCommandEnd</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>needCleanup</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>EventTriggerEndCompleteQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>needCleanup</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>EventTriggerEndCompleteQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * SendLeaderCNUtility
 * For parallel ddl, we execute ddl in leader cn firstly
 * to avoid deadlock.
 */</comment>
<function><type><name>void</name></type> <name>SendLeaderCNUtility</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>temp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGXCNodeHandle</name>	<modifier>*</modifier></type><name>leaderCnHandle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RemoteQuery</name>		<modifier>*</modifier></type><name>step</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>leaderCnHandle</name> <operator>=</operator> <call><name>find_ddl_leader_cn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>is_ddl_leader_cn</name><argument_list>(<argument><expr><name><name>leaderCnHandle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <name>COMBINE_TYPE_SAME</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <ternary><condition><expr><name>temp</name></expr> ?</condition><then> <expr><name>EXEC_ON_NONE</name></expr> </then><else>: <expr><name>EXEC_ON_COORDS</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_nodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>is_temp</name></name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecRemoteUtility</name><argument_list>(<argument><expr><name>step</name></expr></argument>, <argument><expr><name>leaderCnHandle</name></expr></argument>, <argument><expr><name>ONLY_LEADER_DDL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>leader_cn_executed_ddl</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>SendLeaderCNUtilityWithContext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
									<parameter><decl><type><name>bool</name></type> <name>temp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
		<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>

        <comment type="block">/*
         * Some nodes failed. Add context about what all nodes the query
         * failed
         */</comment>
        <decl_stmt><decl><type><name>ExecNodes</name><modifier>*</modifier></type> <name>coord_success_nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExecNodes</name><modifier>*</modifier></type> <name>data_success_nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>msg_failed_nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>pgxc_all_success_nodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data_success_nodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>coord_success_nodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg_failed_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>msg_failed_nodes</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>msg_failed_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>CheckAndSendLeaderCNReindex</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>sentToRemote</name></decl></parameter>, <parameter><decl><type><name>ReindexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
									<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RemoteQueryExecType</name></type> <name>exec_type</name> <init>= <expr><name>EXEC_ON_NONE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGXCNodeHandle</name>	<modifier>*</modifier></type><name>leaderCnHandle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>sentToRemote</name> <operator>||</operator> <operator>!</operator><name>LOCAL_PARALLEL_DDL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If I am the main execute CN but not Leader CN, notify the Leader CN
	 * to reindex firstly.
	 */</comment>
	<expr_stmt><expr><name>leaderCnHandle</name> <operator>=</operator> <call><name>find_ddl_leader_cn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_ddl_leader_cn</name><argument_list>(<argument><expr><name><name>leaderCnHandle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_temp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>exec_type</name> <operator>=</operator> <call><name>ExecUtilityFindNodes</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>exec_type</name> <operator>==</operator> <name>EXEC_ON_ALL_NODES</name> <operator>||</operator> <name>exec_type</name> <operator>==</operator> <name>EXEC_ON_COORDS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>RemoteQueryExecType</name></type> <name>GetRenameExecType</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_temp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RemoteQueryExecType</name></type>	<name>exec_type</name> <init>= <expr><name>EXEC_ON_NONE</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/*
	 * Get the necessary details about the relation before we
	 * run ExecRenameStmt locally. Otherwise we may not be able
	 * to look-up using the old relation name.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
			* If the table does not exist, don't send the query to
			* the remote nodes. The local node will eventually
			* report an error, which is then sent back to the
			* client.
			*/</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
										<argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>exec_type</name> <operator>=</operator> <call><name>ExecUtilityFindNodes</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name></expr></argument>,
										<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_NONE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>exec_type</name> <operator>=</operator> <call><name>ExecUtilityFindNodes</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name></expr></argument>,
									<argument><expr><name>InvalidOid</name></expr></argument>,	<argument><expr><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>exec_type</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Dispatch function for DropStmt
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<name>ExecDropStmt</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
        <parameter><decl><type><name>bool</name></type> <name>sentToRemote</name></decl></parameter>,
        <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
ExecDropStmt<parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PreventTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>,
                                        <argument><expr><literal type="string">"DROP INDEX CONCURRENTLY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* fall through */</comment>
        <case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>g_GTM_skip_catalog</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_DATANODE</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skip_gtm_catalog can not be true on datanode."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>g_GTM_skip_catalog</name></expr>)</condition>
                <block>{<block_content>    
                    <expr_stmt><expr><call><name>RemoveSequeceBarely</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"NO CATALOG TOUCHED."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
        <case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
        <case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
        <case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
        <case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
            <block>{<block_content>
                <decl_stmt><decl><type><name>bool</name></type>        <name>is_temp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>RemoteQueryExecType</name></type> <name>exec_type</name> <init>= <expr><name>EXEC_ON_ALL_NODES</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>new_query_string</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>new_objects</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PGXCNodeHandle</name>	<modifier>*</modifier></type><name>leaderCnHandle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type> <name>need_sendto_leadercn</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <comment type="block">/* Check restrictions on objects dropped */</comment>
                <expr_stmt><expr><call><name>DropStmtPreTreatment</name><argument_list>(<argument><expr><operator>(</operator><name>DropStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>is_temp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exec_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>leaderCnHandle</name> <operator>=</operator> <call><name>find_ddl_leader_cn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_ddl_leader_cn</name><argument_list>(<argument><expr><name><name>leaderCnHandle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>need_sendto_leadercn</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>need_sendto_leadercn</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * For DROP TABLE/INDEX/VIEW/... IF EXISTS query, only 
					 * notice is emitted, if the referred objects are not
					 * found. In such case, the atomicity and consistency of
					 * the query or transaction among local CN and remote nodes
					 * can not be guaranteed against concurrent CREATE TABLE/
					 * INDEX/VIEW/... query.
					 *
					 * To ensure such atomicity and consistency, we only refer
					 * to local CN about the visibility of the objects to be
					 * deleted and rewrite the query into new_query_string 
					 * without the inivisible objects. Later, if the objects in
					 * new_query_string are not found on remote nodes, which
					 * should not happen, just ERROR.
					 */</comment>
					<decl_stmt><decl><type><name>bool</name></type> <name>need_drop</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>heap_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name>new_objects</name> <operator>=</operator> <call><name>PreCheckforRemoveRelation</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, 
															<argument><expr><name>new_query_string</name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>need_drop</name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>heap_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>need_drop</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * If I am the main execute CN but not Leader CN,
						 * Notify the Leader CN to create firstly.
						 */</comment>
						<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>new_query_string</name></expr></argument>, <argument><expr><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>RemoveRelationsParallelMode</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>new_objects</name></expr></argument>,
													<argument><expr><name>heap_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>new_objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>new_objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>RemoveRelations</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>new_query_string</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><call><name>RemoveRelations</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<comment type="block">/* DROP is done depending on the object type and its temporary type */</comment>
				<if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>new_query_string</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							<argument><expr><name>exec_type</name></expr></argument>, <argument><expr><name>is_temp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <comment type="block">/* DROP is done depending on the object type and its temporary type */</comment>
                <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                            <argument><expr><name>exec_type</name></expr></argument>, <argument><expr><name>is_temp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>				
            </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
		<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
		<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type> <name>is_temp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type> <name>need_drop</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>RemoteQueryExecType</name></type> <name>exec_type</name> <init>= <expr><name>EXEC_ON_ALL_NODES</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>new_objects</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PGXCNodeHandle</name>	<modifier>*</modifier></type><name>leaderCnHandle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type> <name>is_leader_cn</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_query_string</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Check restrictions on objects dropped */</comment>
				<expr_stmt><expr><call><name>DropStmtPreTreatment</name><argument_list>(<argument><expr><operator>(</operator><name>DropStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>is_temp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exec_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>leaderCnHandle</name> <operator>=</operator> <call><name>find_ddl_leader_cn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>is_leader_cn</name> <operator>=</operator> <call><name>is_ddl_leader_cn</name><argument_list>(<argument><expr><name><name>leaderCnHandle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_leader_cn</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * To ensure such atomicity and consistency, we only refer
						 * to local CN about the visibility of the objects to be
						 * deleted and rewrite the query into new_query_string 
						 * without the inivisible objects. Later, if the objects in
						 * new_query_string are not found on remote nodes, which
						 * should not happen, just ERROR.
						 */</comment>
						<expr_stmt><expr><name>new_objects</name> <operator>=</operator> <call><name>PreCheckforRemoveObjects</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,
															<argument><expr><name>true</name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>need_drop</name></expr></argument>,
															<argument><expr><name>new_query_string</name></expr></argument>,
															<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>need_drop</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							* If I am the main execute CN but not Leader CN,
							* Notify the Leader CN to create firstly.
							*/</comment>
							<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>new_query_string</name></expr></argument>, <argument><expr><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>RemoveObjectsParallelMode</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>new_objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>new_objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>new_objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></else></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>RemoveObjects</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>need_drop</name></expr></argument>,
										<argument><expr><name>new_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_drop</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>is_txn_has_parallel_ddl</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* parallel ddl mode, from remote cn, can't miss object */</comment>
					<expr_stmt><expr><call><name>RemoveObjects</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>need_drop</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* non parallel ddl mode */</comment>
					<expr_stmt><expr><call><name>RemoveObjects</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>need_drop</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>new_query_string</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
											<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>exec_type</name></expr></argument>,
											<argument><expr><name>is_temp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <default>default:</default>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
            <block>{<block_content>
                <decl_stmt><decl><type><name>bool</name></type>        <name>is_temp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>need_drop</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>RemoteQueryExecType</name></type> <name>exec_type</name> <init>= <expr><name>EXEC_ON_ALL_NODES</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* Check restrictions on objects dropped */</comment>
                <expr_stmt><expr><call><name>DropStmtPreTreatment</name><argument_list>(<argument><expr><operator>(</operator><name>DropStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>is_temp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exec_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><call><name>RemoveObjects</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>need_drop</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                            <argument><expr><name>exec_type</name></expr></argument>, <argument><expr><name>is_temp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>CheckAndDropRole</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sentToRemote</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DropRoleStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DropRoleStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_query_string</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>need_drop</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sentToRemote</name> <operator>&amp;&amp;</operator> <name>LOCAL_PARALLEL_DDL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGXCNodeHandle</name>	<modifier>*</modifier></type><name>leaderCnHandle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>leaderCnHandle</name> <operator>=</operator> <call><name>find_ddl_leader_cn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If I am the main execute CN but not Leader CN,
		 * Notify the Leader CN to create firstly.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_ddl_leader_cn</name><argument_list>(<argument><expr><name><name>leaderCnHandle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>role_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>need_drop</name> <operator>=</operator> <call><name>PreCheckDropRole</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>new_query_string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>role_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_drop</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>SendLeaderCNUtility</name><argument_list>(<argument><expr><name>new_query_string</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>DropRoleParallelMode</name><argument_list>(<argument><expr><name>role_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>new_query_string</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									<argument><expr><name>EXEC_ON_ALL_NODES</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DropRole</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>new_query_string</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>ExecUtilityStmtOnNodes</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>new_query_string</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									<argument><expr><name>sentToRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									<argument><expr><name>EXEC_ON_ALL_NODES</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<comment type="block">/* From remote cn */</comment>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>IS_PGXC_LOCAL_COORDINATOR</name> <operator>&amp;&amp;</operator> <name>is_txn_has_parallel_ddl</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* 
		 * In parallel ddl mode, we only send cmd to remote when
		 * database exists, so database can not miss when the cmd
		 * come from remote cn.
		 */</comment>
		<expr_stmt><expr><call><name>DropRole</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/* Non parallel ddl mode */</comment>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>DropRole</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * UtilityReturnsTuples
 *        Return "true" if this utility statement will send output to the
 *        destination.
 *
 * Generally, there should be a case here for each case in ProcessUtility
 * where "dest" is passed on.
 */</comment>
<function><type><name>bool</name></type>
<name>UtilityReturnsTuples</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_FetchStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>FetchStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>FetchStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Portal</name></type>        <name>portal</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>ismove</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>GetPortalByName</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>portalname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* not our business to raise error */</comment>
                <return>return <expr><ternary><condition><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>T_ExecuteStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ExecuteStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ExecuteStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* not our business to raise error */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>resultDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>T_ExplainStmt</name></expr>:</case>
            <return>return <expr><name>true</name></expr>;</return>

        <case>case <expr><name>T_VariableShowStmt</name></expr>:</case>
            <return>return <expr><name>true</name></expr>;</return>

        <default>default:</default>
            <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * UtilityTupleDescriptor
 *        Fetch the actual output tuple descriptor for a utility statement
 *        for which UtilityReturnsTuples() previously returned "true".
 *
 * The returned descriptor is created in (or copied into) the current memory
 * context.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>UtilityTupleDescriptor</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_FetchStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>FetchStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>FetchStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Portal</name></type>        <name>portal</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>ismove</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>GetPortalByName</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>portalname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* not our business to raise error */</comment>
                <return>return <expr><call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>T_ExecuteStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ExecuteStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ExecuteStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* not our business to raise error */</comment>
                <return>return <expr><call><name>FetchPreparedStatementResultDesc</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>T_ExplainStmt</name></expr>:</case>
            <return>return <expr><call><name>ExplainResultDesc</name><argument_list>(<argument><expr><operator>(</operator><name>ExplainStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</return>

        <case>case <expr><name>T_VariableShowStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>VariableShowStmt</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>VariableShowStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <return>return <expr><call><name>GetPGVariableResultDesc</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block>

        <default>default:</default>
            <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * QueryReturnsTuples
 *        Return "true" if this Query will send output to the destination.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
<function><type><name>bool</name></type>
<name>QueryReturnsTuples</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <switch>switch <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>CMD_SELECT</name></expr>:</case>
            <comment type="block">/* returns tuples */</comment>
            <return>return <expr><name>true</name></expr>;</return>
        <case>case <expr><name>CMD_INSERT</name></expr>:</case>
        <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
        <case>case <expr><name>CMD_DELETE</name></expr>:</case>
            <comment type="block">/* the forms with RETURNING return tuples */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>CMD_UTILITY</name></expr>:</case>
            <return>return <expr><call><name>UtilityReturnsTuples</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>CMD_UNKNOWN</name></expr>:</case>
        <case>case <expr><name>CMD_NOTHING</name></expr>:</case>
            <comment type="block">/* probably shouldn't get here */</comment>
            <break>break;</break>
    </block_content>}</block></switch>
    <return>return <expr><name>false</name></expr>;</return>                <comment type="block">/* default */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * UtilityContainsQuery
 *        Return the contained Query, or NULL if there is none
 *
 * Certain utility statements, such as EXPLAIN, contain a plannable Query.
 * This function encapsulates knowledge of exactly which ones do.
 * We assume it is invoked only on already-parse-analyzed statements
 * (else the contained parsetree isn't a Query yet).
 *
 * In some cases (currently, only EXPLAIN of CREATE TABLE AS/SELECT INTO and
 * CREATE MATERIALIZED VIEW), potentially Query-containing utility statements
 * can be nested.  This function will drill down to a non-utility Query, or
 * return NULL if none.
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>UtilityContainsQuery</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
            <expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>DeclareCursorStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>UtilityContainsQuery</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
            <return>return <expr><name>qry</name></expr>;</return>

        <case>case <expr><name>T_ExplainStmt</name></expr>:</case>
            <expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>ExplainStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>UtilityContainsQuery</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
            <return>return <expr><name>qry</name></expr>;</return>

        <case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
            <expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>CreateTableAsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>UtilityContainsQuery</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
            <return>return <expr><name>qry</name></expr>;</return>

        <default>default:</default>
            <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * AlterObjectTypeCommandTag
 *        helper function for CreateCommandTag
 *
 * This covers most cases where ALTER is used with an ObjectType enum.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>AlterObjectTypeCommandTag</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objtype</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>objtype</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER AGGREGATE"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_ATTRIBUTE</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TYPE"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_CAST</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER CAST"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_COLLATION</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER COLLATION"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_COLUMN</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TABLE"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_CONVERSION</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER CONVERSION"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_DATABASE</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER DATABASE"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_DOMAIN</name></expr>:</case>
        <case>case <expr><name>OBJECT_DOMCONSTRAINT</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER DOMAIN"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_EXTENSION</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER EXTENSION"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_FDW</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER FOREIGN DATA WRAPPER"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_FOREIGN_SERVER</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER SERVER"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER FOREIGN TABLE"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER FUNCTION"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER INDEX"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_LANGUAGE</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER LANGUAGE"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_LARGEOBJECT</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER LARGE OBJECT"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_OPCLASS</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER OPERATOR CLASS"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_OPERATOR</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER OPERATOR"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_OPFAMILY</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER OPERATOR FAMILY"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_POLICY</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER POLICY"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_ROLE</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER ROLE"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_RULE</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER RULE"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER SCHEMA"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER SEQUENCE"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
        <case>case <expr><name>OBJECT_TABCONSTRAINT</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TABLE"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_TABLESPACE</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TABLESPACE"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_TRIGGER</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TRIGGER"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_EVENT_TRIGGER</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER EVENT TRIGGER"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_TSCONFIGURATION</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TEXT SEARCH CONFIGURATION"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_TSDICTIONARY</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TEXT SEARCH DICTIONARY"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_TSPARSER</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TEXT SEARCH PARSER"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_TSTEMPLATE</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TEXT SEARCH TEMPLATE"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TYPE"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER VIEW"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER MATERIALIZED VIEW"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_PUBLICATION</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER PUBLICATION"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_SUBSCRIPTION</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER SUBSCRIPTION"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_STATISTIC_EXT</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER STATISTICS"</literal></expr>;</expr_stmt>
            <break>break;</break>
	    <case>case <expr><name>OBJECT_REPLICATION_SLOT</name></expr>:</case>
	        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER SLOT"</literal></expr>;</expr_stmt>
	        <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>tag</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CreateCommandTag
 *        utility to get a string representation of the command operation,
 *        given either a raw (un-analyzed) parsetree, an analyzed Query,
 *        or a PlannedStmt.
 *
 * This must handle all command types, but since the vast majority
 * of 'em are utility commands, it seems sensible to keep it here.
 *
 * NB: all result strings must be shorter than COMPLETION_TAG_BUFSIZE.
 * Also, the result must point at a true constant (permanent storage).
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>CreateCommandTag</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
            <comment type="block">/* recurse if we're given a RawStmt */</comment>
        <case>case <expr><name>T_RawStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>CreateCommandTag</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RawStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

            <comment type="block">/* raw plannable queries */</comment>
        <case>case <expr><name>T_InsertStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"INSERT"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DeleteStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DELETE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_UpdateStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"UPDATE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SelectStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT"</literal></expr>;</expr_stmt>
            <break>break;</break>

            <comment type="block">/* utility statements --- same whether raw or cooked */</comment>
        <case>case <expr><name>T_TransactionStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>TransactionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>TransactionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>TRANS_STMT_BEGIN</name></expr>:</case>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"BEGIN"</literal></expr>;</expr_stmt>
                        <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <case>case <expr><name>TRANS_STMT_BEGIN_SUBTXN</name></expr>:</case>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"BEGIN SUBTXN"</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>TRANS_STMT_ROLLBACK_SUBTXN</name></expr>:</case>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ROLLBACK SUBTXN"</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>TRANS_STMT_COMMIT_SUBTXN</name></expr>:</case>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"COMMIT SUBTXN"</literal></expr>;</expr_stmt>
                        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <case>case <expr><name>TRANS_STMT_START</name></expr>:</case>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"START TRANSACTION"</literal></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><name>TRANS_STMT_COMMIT</name></expr>:</case>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"COMMIT"</literal></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><name>TRANS_STMT_ROLLBACK</name></expr>:</case>
                    <case>case <expr><name>TRANS_STMT_ROLLBACK_TO</name></expr>:</case>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ROLLBACK"</literal></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><name>TRANS_STMT_SAVEPOINT</name></expr>:</case>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SAVEPOINT"</literal></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><name>TRANS_STMT_RELEASE</name></expr>:</case>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"RELEASE"</literal></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><name>TRANS_STMT_PREPARE</name></expr>:</case>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"PREPARE TRANSACTION"</literal></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><name>TRANS_STMT_COMMIT_PREPARED</name></expr>:</case>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"COMMIT PREPARED"</literal></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><name>TRANS_STMT_ROLLBACK_PREPARED</name></expr>:</case>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ROLLBACK PREPARED"</literal></expr>;</expr_stmt>
                        <break>break;</break>

					<case>case <expr><name>TRANS_STMT_COMMIT_PREPARED_CHECK</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"COMMIT PREPARED CHECK"</literal></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_ROLLBACK_PREPARED_CHECK</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ROLLBACK PREPARED CHECK"</literal></expr>;</expr_stmt>
						<break>break;</break>

                    <default>default:</default>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DECLARE CURSOR"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ClosePortalStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ClosePortalStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ClosePortalStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>portalname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CLOSE CURSOR ALL"</literal></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CLOSE CURSOR"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_FetchStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>FetchStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>FetchStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>tag</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>ismove</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"MOVE"</literal></expr> </then><else>: <expr><literal type="string">"FETCH"</literal></expr></else></ternary></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_CreateDomainStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE DOMAIN"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE SCHEMA"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TABLE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateTableSpaceStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TABLESPACE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DropTableSpaceStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP TABLESPACE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterTableSpaceOptionsStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TABLESPACE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateExtensionStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE EXTENSION"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterExtensionStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER EXTENSION"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterExtensionContentsStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER EXTENSION"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateFdwStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE FOREIGN DATA WRAPPER"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterFdwStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER FOREIGN DATA WRAPPER"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateForeignServerStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE SERVER"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterForeignServerStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER SERVER"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateUserMappingStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE USER MAPPING"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterUserMappingStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER USER MAPPING"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DropUserMappingStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP USER MAPPING"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE FOREIGN TABLE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ImportForeignSchemaStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"IMPORT FOREIGN SCHEMA"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DropStmt</name></expr>:</case>
            <switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>DropStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>removeType</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP TABLE"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP SEQUENCE"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP VIEW"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP MATERIALIZED VIEW"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP INDEX"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP TYPE"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_DOMAIN</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP DOMAIN"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_COLLATION</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP COLLATION"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_CONVERSION</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP CONVERSION"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP SCHEMA"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_TSPARSER</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP TEXT SEARCH PARSER"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_TSDICTIONARY</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP TEXT SEARCH DICTIONARY"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_TSTEMPLATE</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP TEXT SEARCH TEMPLATE"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_TSCONFIGURATION</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP TEXT SEARCH CONFIGURATION"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP FOREIGN TABLE"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_EXTENSION</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP EXTENSION"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP FUNCTION"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP AGGREGATE"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_OPERATOR</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP OPERATOR"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_LANGUAGE</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP LANGUAGE"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_CAST</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP CAST"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_TRIGGER</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP TRIGGER"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_EVENT_TRIGGER</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP EVENT TRIGGER"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_RULE</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP RULE"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_FDW</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP FOREIGN DATA WRAPPER"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_FOREIGN_SERVER</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP SERVER"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_OPCLASS</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP OPERATOR CLASS"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_OPFAMILY</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP OPERATOR FAMILY"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_POLICY</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP POLICY"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_TRANSFORM</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP TRANSFORM"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_ACCESS_METHOD</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP ACCESS METHOD"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_PUBLICATION</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP PUBLICATION"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_STATISTIC_EXT</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP STATISTICS"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <default>default:</default>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
            </block_content>}</block></switch>
            <break>break;</break>

        <case>case <expr><name>T_TruncateStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"TRUNCATE TABLE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CommentStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"COMMENT"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SecLabelStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SECURITY LABEL"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CopyStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"COPY"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_RenameStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>AlterObjectTypeCommandTag</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>renameType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>AlterObjectTypeCommandTag</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlterObjectDependsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>objectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>AlterObjectTypeCommandTag</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlterObjectSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>objectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>AlterObjectTypeCommandTag</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlterOwnerStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>objectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterTableMoveAllStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>AlterObjectTypeCommandTag</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlterTableMoveAllStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>AlterObjectTypeCommandTag</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>relkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterDomainStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER DOMAIN"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterFunctionStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER FUNCTION"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_GrantStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>GrantStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>GrantStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>tag</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>is_grant</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"GRANT"</literal></expr> </then><else>: <expr><literal type="string">"REVOKE"</literal></expr></else></ternary></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>GrantRoleStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>GrantRoleStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>tag</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>is_grant</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"GRANT ROLE"</literal></expr> </then><else>: <expr><literal type="string">"REVOKE ROLE"</literal></expr></else></ternary></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER DEFAULT PRIVILEGES"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DefineStmt</name></expr>:</case>
            <switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>DefineStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>kind</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE AGGREGATE"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_OPERATOR</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE OPERATOR"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TYPE"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_TSPARSER</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TEXT SEARCH PARSER"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_TSDICTIONARY</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TEXT SEARCH DICTIONARY"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_TSTEMPLATE</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TEXT SEARCH TEMPLATE"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_TSCONFIGURATION</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TEXT SEARCH CONFIGURATION"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_COLLATION</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE COLLATION"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_ACCESS_METHOD</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE ACCESS METHOD"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <default>default:</default>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
            </block_content>}</block></switch>
            <break>break;</break>

        <case>case <expr><name>T_CompositeTypeStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TYPE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateEnumStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TYPE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateRangeStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TYPE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterEnumStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TYPE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ViewStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE VIEW"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateFunctionStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE FUNCTION"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_IndexStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE INDEX"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_RuleStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE RULE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE SEQUENCE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER SEQUENCE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DoStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DO"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE DATABASE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterDatabaseStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER DATABASE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterDatabaseSetStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER DATABASE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DropdbStmt</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>DropdbStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>prepare</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP DATABASE PREPARE"</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP DATABASE"</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_NotifyStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"NOTIFY"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ListenStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"LISTEN"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_UnlistenStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"UNLISTEN"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_LoadStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"LOAD"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ClusterStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CLUSTER"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_VacuumStmt</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>VacuumStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"VACUUM"</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ANALYZE"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <case>case <expr><name>T_VacuumShardStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"VacuumShard"</literal></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>T_ExplainStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"EXPLAIN"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
            <switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>CreateTableAsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>relkind</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>CreateTableAsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>is_select_into</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT INTO"</literal></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TABLE AS"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    <break>break;</break>
                <case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE MATERIALIZED VIEW"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <default>default:</default>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
            </block_content>}</block></switch>
            <break>break;</break>

        <case>case <expr><name>T_RefreshMatViewStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"REFRESH MATERIALIZED VIEW"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterSystemStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER SYSTEM"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_VariableSetStmt</name></expr>:</case>
            <switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>VariableSetStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>kind</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>VAR_SET_VALUE</name></expr>:</case>
                <case>case <expr><name>VAR_SET_CURRENT</name></expr>:</case>
                <case>case <expr><name>VAR_SET_DEFAULT</name></expr>:</case>
                <case>case <expr><name>VAR_SET_MULTI</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SET"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>VAR_RESET</name></expr>:</case>
                <case>case <expr><name>VAR_RESET_ALL</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"RESET"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <default>default:</default>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
            </block_content>}</block></switch>
            <break>break;</break>

        <case>case <expr><name>T_VariableShowStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SHOW"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DiscardStmt</name></expr>:</case>
            <switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>DiscardStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>target</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>DISCARD_ALL</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DISCARD ALL"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>DISCARD_PLANS</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DISCARD PLANS"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>DISCARD_TEMP</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DISCARD TEMP"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>DISCARD_SEQUENCES</name></expr>:</case>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DISCARD SEQUENCES"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                <default>default:</default>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
            </block_content>}</block></switch>
            <break>break;</break>

        <case>case <expr><name>T_CreateTransformStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TRANSFORM"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TRIGGER"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateEventTrigStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE EVENT TRIGGER"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterEventTrigStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER EVENT TRIGGER"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreatePLangStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE LANGUAGE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE ROLE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER ROLE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER ROLE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP ROLE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP OWNED"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ReassignOwnedStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"REASSIGN OWNED"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_LockStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"LOCK TABLE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ConstraintsSetStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SET CONSTRAINTS"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CheckPointStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CHECKPOINT"</literal></expr>;</expr_stmt>
            <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <case>case <expr><name>T_BarrierStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"BARRIER"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterNodeStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER NODE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateNodeStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE NODE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DropNodeStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP NODE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateGroupStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE NODE GROUP"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterGroupStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER NODE GROUP"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DropGroupStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP NODE GROUP"</literal></expr>;</expr_stmt>
            <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <case>case <expr><name>T_PauseClusterStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"PAUSE/UNPAUSE CLUSTER"</literal></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <case>case <expr><name>T_ExecDirectStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"EXECUTE DIRECT"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_CleanConnStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CLEAN CONNECTION"</literal></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <case>case <expr><name>T_ReindexStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"REINDEX"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateConversionStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE CONVERSION"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateCastStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE CAST"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateOpClassStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE OPERATOR CLASS"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateOpFamilyStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE OPERATOR FAMILY"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterOpFamilyStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER OPERATOR FAMILY"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterOperatorStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER OPERATOR"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterTSDictionaryStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TEXT SEARCH DICTIONARY"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterTSConfigurationStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TEXT SEARCH CONFIGURATION"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreatePolicyStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE POLICY"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterPolicyStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER POLICY"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateAmStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE ACCESS METHOD"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreatePublicationStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE PUBLICATION"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterPublicationStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER PUBLICATION"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE SUBSCRIPTION"</literal></expr>;</expr_stmt>
            <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><call><name>IsTbaseSubscription</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TBASE SUBSCRIPTION"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <break>break;</break>

        <case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER SUBSCRIPTION"</literal></expr>;</expr_stmt>
            <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><call><name>IsTbaseSubscription</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TBASE SUBSCRIPTION"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <break>break;</break>

        <case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP SUBSCRIPTION"</literal></expr>;</expr_stmt>
            <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><call><name>IsTbaseSubscription</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP TBASE SUBSCRIPTION"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <break>break;</break>

        <case>case <expr><name>T_AlterCollationStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER COLLATION"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_PrepareStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"PREPARE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ExecuteStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"EXECUTE"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateStatsStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE STATISTICS"</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DeallocateStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>DeallocateStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DeallocateStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DEALLOCATE ALL"</literal></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DEALLOCATE"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block>
            <break>break;</break>

            <comment type="block">/* already-planned queries */</comment>
        <case>case <expr><name>T_PlannedStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>CMD_SELECT</name></expr>:</case>

                        <comment type="block">/*
                         * We take a little extra care here so that the result
                         * will be useful for complaints about read-only
                         * statements
                         */</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/* not 100% but probably close enough */</comment>
                            <switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>PlanRowMark</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>strength</name></expr>)</condition>
                            <block>{<block_content>
                                <case>case <expr><name>LCS_FORKEYSHARE</name></expr>:</case>
                                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT FOR KEY SHARE"</literal></expr>;</expr_stmt>
                                    <break>break;</break>
                                <case>case <expr><name>LCS_FORSHARE</name></expr>:</case>
                                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT FOR SHARE"</literal></expr>;</expr_stmt>
                                    <break>break;</break>
                                <case>case <expr><name>LCS_FORNOKEYUPDATE</name></expr>:</case>
                                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT FOR NO KEY UPDATE"</literal></expr>;</expr_stmt>
                                    <break>break;</break>
                                <case>case <expr><name>LCS_FORUPDATE</name></expr>:</case>
                                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT FOR UPDATE"</literal></expr>;</expr_stmt>
                                    <break>break;</break>
                                <default>default:</default>
                                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT"</literal></expr>;</expr_stmt>
                                    <break>break;</break>
                            </block_content>}</block></switch>
                        </block_content>}</block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
                        <break>break;</break>
                    <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"UPDATE"</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>CMD_INSERT</name></expr>:</case>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"INSERT"</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>CMD_DELETE</name></expr>:</case>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DELETE"</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>CMD_UTILITY</name></expr>:</case>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <default>default:</default>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized commandType: %d"</literal></expr></argument>,
                             <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block>
            <break>break;</break>

            <comment type="block">/* parsed-and-rewritten-but-not-planned queries */</comment>
        <case>case <expr><name>T_Query</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>CMD_SELECT</name></expr>:</case>

                        <comment type="block">/*
                         * We take a little extra care here so that the result
                         * will be useful for complaints about read-only
                         * statements
                         */</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/* not 100% but probably close enough */</comment>
                            <switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>RowMarkClause</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>strength</name></expr>)</condition>
                            <block>{<block_content>
                                <case>case <expr><name>LCS_FORKEYSHARE</name></expr>:</case>
                                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT FOR KEY SHARE"</literal></expr>;</expr_stmt>
                                    <break>break;</break>
                                <case>case <expr><name>LCS_FORSHARE</name></expr>:</case>
                                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT FOR SHARE"</literal></expr>;</expr_stmt>
                                    <break>break;</break>
                                <case>case <expr><name>LCS_FORNOKEYUPDATE</name></expr>:</case>
                                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT FOR NO KEY UPDATE"</literal></expr>;</expr_stmt>
                                    <break>break;</break>
                                <case>case <expr><name>LCS_FORUPDATE</name></expr>:</case>
                                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT FOR UPDATE"</literal></expr>;</expr_stmt>
                                    <break>break;</break>
                                <default>default:</default>
                                    <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
                                    <break>break;</break>
                            </block_content>}</block></switch>
                        </block_content>}</block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
                        <break>break;</break>
                    <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"UPDATE"</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>CMD_INSERT</name></expr>:</case>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"INSERT"</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>CMD_DELETE</name></expr>:</case>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DELETE"</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>CMD_UTILITY</name></expr>:</case>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <default>default:</default>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized commandType: %d"</literal></expr></argument>,
                             <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block>
            <break>break;</break>
            
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
        <case>case <expr><name>T_CleanShardingStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CLEAN SHARDING"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_CreateShardStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE SHARDING GROUP"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_DropShardStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP SHARDING GROUP"</literal></expr>;</expr_stmt>
            <break>break;</break>        
        <case>case <expr><name>T_MoveDataStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"MOVE DATA"</literal></expr>;</expr_stmt>
            <break>break;</break>    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
        <case>case <expr><name>T_CreateKeyValuesStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"Create KEY VALUE"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_CheckOverLapStmt</name></expr>:</case>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CHECK OVERLAPS"</literal></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <case>case <expr><name>T_LockNodeStmt</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>LockNodeStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>LockNodeStmt</name> <operator>*</operator><operator>)</operator><name>parsetree</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>lock</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"LOCK NODE"</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"UNLOCK NODE"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>
        </block_content>}</block>
		<case>case <expr><name>T_SampleStmt</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SAMPLE"</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
        <case>case <expr><name>T_AuditStmt</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>AuditStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AuditStmt</name> <operator>*</operator><operator>)</operator><name>parsetree</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>audit_ison</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"AUDIT"</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"NO AUDIT"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>T_CleanAuditStmt</name></expr>:</case>
        <block>{<block_content>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CLEAN AUDIT"</literal></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>T_RemoteQuery</name></expr>:</case>
        <block>{<block_content>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"REMOTE QUERY"</literal></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>tag</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetCommandLogLevel
 *        utility to get the minimum log_statement level for a command,
 *        given either a raw (un-analyzed) parsetree, an analyzed Query,
 *        or a PlannedStmt.
 *
 * This must handle all command types, but since the vast majority
 * of 'em are utility commands, it seems sensible to keep it here.
 */</comment>
<function><type><name>LogStmtLevel</name></type>
<name>GetCommandLogLevel</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>LogStmtLevel</name></type> <name>lev</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
            <comment type="block">/* recurse if we're given a RawStmt */</comment>
        <case>case <expr><name>T_RawStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RawStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

            <comment type="block">/* raw plannable queries */</comment>
        <case>case <expr><name>T_InsertStmt</name></expr>:</case>
        <case>case <expr><name>T_DeleteStmt</name></expr>:</case>
        <case>case <expr><name>T_UpdateStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_MOD</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SelectStmt</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>SelectStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>intoClause</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* SELECT INTO */</comment>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>

            <comment type="block">/* utility statements --- same whether raw or cooked */</comment>
        <case>case <expr><name>T_TransactionStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ClosePortalStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_FetchStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateTableSpaceStmt</name></expr>:</case>
        <case>case <expr><name>T_DropTableSpaceStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterTableSpaceOptionsStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateExtensionStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterExtensionStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterExtensionContentsStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateFdwStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterFdwStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateForeignServerStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterForeignServerStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateUserMappingStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterUserMappingStmt</name></expr>:</case>
        <case>case <expr><name>T_DropUserMappingStmt</name></expr>:</case>
        <case>case <expr><name>T_ImportForeignSchemaStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DropStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_TruncateStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_MOD</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CommentStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SecLabelStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CopyStmt</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>CopyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>is_from</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_MOD</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_PrepareStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PrepareStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>PrepareStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* Look through a PREPARE to the contained stmt */</comment>
                <expr_stmt><expr><name>lev</name> <operator>=</operator> <call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_ExecuteStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ExecuteStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ExecuteStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>ps</name></decl>;</decl_stmt>

                <comment type="block">/* Look through an EXECUTE to the referenced stmt */</comment>
                <expr_stmt><expr><name>ps</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>ps</name> <operator>&amp;&amp;</operator> <name><name>ps</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>raw_parse_tree</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>lev</name> <operator>=</operator> <call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>raw_parse_tree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_DeallocateStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_RenameStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterTableMoveAllStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterDomainStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_GrantStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DefineStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CompositeTypeStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateEnumStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateRangeStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterEnumStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ViewStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateFunctionStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterFunctionStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_IndexStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_RuleStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DoStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterDatabaseStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterDatabaseSetStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DropdbStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_NotifyStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ListenStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_UnlistenStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_LoadStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ClusterStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_VacuumStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <case>case <expr><name>T_VacuumShardStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>T_ExplainStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ExplainStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ExplainStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>        <name>analyze</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

                <comment type="block">/* Look through an EXPLAIN ANALYZE to the contained stmt */</comment>
                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>opt</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"analyze"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>analyze</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <comment type="block">/* don't "break", as explain.c will use the last value */</comment>
                </block_content>}</block>
                <if_stmt><if>if <condition>(<expr><name>analyze</name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

                <comment type="block">/* Plain EXPLAIN isn't so interesting */</comment>
                <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_RefreshMatViewStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterSystemStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_VariableSetStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_VariableShowStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DiscardStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateEventTrigStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterEventTrigStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreatePLangStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateDomainStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ReassignOwnedStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_LockStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ConstraintsSetStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CheckPointStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ReindexStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>    <comment type="block">/* should this be DDL? */</comment>
            <break>break;</break>

        <case>case <expr><name>T_CreateConversionStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateCastStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateOpClassStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateOpFamilyStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateTransformStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterOpFamilyStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreatePolicyStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterPolicyStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterTSDictionaryStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterTSConfigurationStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateAmStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreatePublicationStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterPublicationStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>

            <comment type="block">/* already-planned queries */</comment>
        <case>case <expr><name>T_PlannedStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>CMD_SELECT</name></expr>:</case>
                        <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
                    <case>case <expr><name>CMD_INSERT</name></expr>:</case>
                    <case>case <expr><name>CMD_DELETE</name></expr>:</case>
                        <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_MOD</name></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><name>CMD_UTILITY</name></expr>:</case>
                        <expr_stmt><expr><name>lev</name> <operator>=</operator> <call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>

                    <default>default:</default>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized commandType: %d"</literal></expr></argument>,
                             <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block>
            <break>break;</break>

            <comment type="block">/* parsed-and-rewritten-but-not-planned queries */</comment>
        <case>case <expr><name>T_Query</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

                <switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>CMD_SELECT</name></expr>:</case>
                        <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
                    <case>case <expr><name>CMD_INSERT</name></expr>:</case>
                    <case>case <expr><name>CMD_DELETE</name></expr>:</case>
                        <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_MOD</name></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><name>CMD_UTILITY</name></expr>:</case>
                        <expr_stmt><expr><name>lev</name> <operator>=</operator> <call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>

                    <default>default:</default>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized commandType: %d"</literal></expr></argument>,
                             <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>

            </block_content>}</block>
            <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <case>case <expr><name>T_CleanConnStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <case>case <expr><name>T_AlterNodeStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateNodeStmt</name></expr>:</case>
        <case>case <expr><name>T_DropNodeStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateGroupStmt</name></expr>:</case>
        <case>case <expr><name>T_DropGroupStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterGroupStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_ExecDirectStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
        <case>case <expr><name>T_CreateShardStmt</name></expr>:</case>
        <case>case <expr><name>T_DropShardStmt</name></expr>:</case>
        <case>case <expr><name>T_MoveDataStmt</name></expr>:</case>    
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_CleanShardingStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>        
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
        <case>case <expr><name>T_CreateKeyValuesStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_CheckOverLapStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <case>case <expr><name>T_LockNodeStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>
		<case>case <expr><name>T_SampleStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
        <case>case <expr><name>T_AuditStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_CleanAuditStmt</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_RemoteQuery</name></expr>:</case>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>lev</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecUtilityStmtOnNodesInternal</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>parsetree</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
								<parameter><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>nodes</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sentToRemote</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>force_autocommit</name></decl></parameter>,
								<parameter><decl><type><name>RemoteQueryExecType</name></type> <name>exec_type</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>is_temp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Return if query is launched on no nodes */</comment>
    <if_stmt><if>if <condition>(<expr><name>exec_type</name> <operator>==</operator> <name>EXEC_ON_NONE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Nothing to be done if this statement has been sent to the nodes */</comment>
    <if_stmt><if>if <condition>(<expr><name>sentToRemote</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If no Datanodes defined, the query cannot be launched */</comment>
    <if_stmt><if>if <condition>(<expr><name>NumDataNodes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"No Datanode defined in cluster"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You need to define at least 1 Datanode with "</literal>
                     <literal type="string">"CREATE NODE."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>step</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <name>COMBINE_TYPE_SAME</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_nodes</name></name> <operator>=</operator> <name>nodes</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>force_autocommit</name></name> <operator>=</operator> <name>force_autocommit</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>exec_type</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>parsetree</name></name> <operator>=</operator> <name>parsetree</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>LOCAL_PARALLEL_DDL</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>exec_type</name> <operator>==</operator> <name>EXEC_ON_COORDS</name> <operator>||</operator>	<name>exec_type</name> <operator>==</operator> <name>EXEC_ON_ALL_NODES</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGXCNodeHandle</name><modifier>*</modifier></type> <name>leaderCnHandle</name> <init>= <expr><call><name>find_ddl_leader_cn</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ExecRemoteUtility</name><argument_list>(<argument><expr><name>step</name></expr></argument>,	<argument><expr><name>leaderCnHandle</name></expr></argument>, <argument><expr><name>EXCLUED_LEADER_DDL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecRemoteUtility</name><argument_list>(<argument><expr><name>step</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NON_PARALLEL_DDL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>ExecRemoteUtility</name><argument_list>(<argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>sql_statement</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExecUtilityStmtOnNodes
 *
 * Execute the query on remote nodes
 * 
 *  queryString is the raw query to be executed.
 *     If nodes is NULL then the list of nodes is computed from exec_type.
 *     If auto_commit is true, then the query is executed without a transaction
 *       block and auto-committed on the remote node.
 *     exec_type is used to compute the list of remote nodes on which the query is
 *       executed.
 *     is_temp is set to true if the query involves a temporary database object.
 *  If add_context is true and if this fails on one of the nodes then add a
 *       context message containing the failed node names.
 *
 *  NB: parsetree is used to identify 3 subtransaction cmd: 
 *      savepoint, rollback to, release savepoint.
 *  Since these commands should not acquire xid
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecUtilityStmtOnNodes</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>parsetree</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>nodes</name></decl></parameter>,
        <parameter><decl><type><name>bool</name></type> <name>sentToRemote</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>auto_commit</name></decl></parameter>, <parameter><decl><type><name>RemoteQueryExecType</name></type> <name>exec_type</name></decl></parameter>,
        <parameter><decl><type><name>bool</name></type> <name>is_temp</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>add_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ExecUtilityStmtOnNodesInternal</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>sentToRemote</name></expr></argument>,
                <argument><expr><name>auto_commit</name></expr></argument>, <argument><expr><name>exec_type</name></expr></argument>, <argument><expr><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <comment type="block">/*
         * Some nodes failed. Add context about what all nodes the query
         * failed
         */</comment>
        <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>coord_success_nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>data_success_nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>msg_failed_nodes</name></decl>;</decl_stmt>

        <comment type="block">/*
         * If the caller has asked for context information, add that and
         * re-throw the error.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>add_context</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>pgxc_all_success_nodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data_success_nodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>coord_success_nodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg_failed_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>msg_failed_nodes</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>msg_failed_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


</block_content>}</block></function>

<comment type="block">/*
 * ExecUtilityFindNodes
 *
 * Determine the list of nodes to launch query on.
 * This depends on temporary nature of object and object type.
 * Return also a flag indicating if relation is temporary.
 *
 * If object is a RULE, the object id sent is that of the object to which the
 * rule is applicable.
 */</comment>
    <function><type><specifier>static</specifier> <name>RemoteQueryExecType</name></type>
<name>ExecUtilityFindNodes</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>object_type</name></decl></parameter>,
        <parameter><decl><type><name>Oid</name></type> <name>object_id</name></decl></parameter>,
        <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_temp</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>RemoteQueryExecType</name></type> <name>exec_type</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>object_type</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
            <expr_stmt><expr><operator>*</operator><name>is_temp</name> <operator>=</operator> <call><name>IsTempTable</name><argument_list>(<argument><expr><name>object_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>is_temp</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_DATANODES</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>

        <case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
        <case>case <expr><name>OBJECT_RULE</name></expr>:</case>
        <case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
        <case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
        <case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
            <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <call><name>ExecUtilityFindNodesRelkind</name><argument_list>(<argument><expr><name>object_id</name></expr></argument>, <argument><expr><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><operator>*</operator><name>is_temp</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>exec_type</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecUtilityFindNodesRelkind
 *
 * Get node execution and temporary type
 * for given relation depending on its relkind
 */</comment>
<function><type><specifier>static</specifier> <name>RemoteQueryExecType</name></type>
<name>ExecUtilityFindNodesRelkind</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_temp</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name></type> <name>relkind_str</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQueryExecType</name></type> <name>exec_type</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>relkind_str</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
        <case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>is_temp</name> <operator>=</operator> <call><name>IsTempTable</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>IsLocalTempTable</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_NONE</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_DATANODES</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>

        <case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>tuple</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type> <name>table_relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Form_pg_index</name></type> <name>index</name> <init>= <expr><operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>table_relid</name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indrelid</name></name></expr>;</expr_stmt>

                    <comment type="block">/* Release system cache BEFORE looking at the parent table */</comment>
                    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <call><name>ExecUtilityFindNodesRelkind</name><argument_list>(<argument><expr><name>table_relid</name></expr></argument>, <argument><expr><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_NONE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><operator>*</operator><name>is_temp</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
        <case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>
        <case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
            <comment type="block">/* Check if object is a temporary view */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>is_temp</name> <operator>=</operator> <call><name>IsTempTable</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_DATANODES</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><operator>*</operator><name>is_temp</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>exec_type</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<comment type="block">/*
 * IsStmtAllowedInLockedMode
 *
 * Allow/Disallow a utility command while cluster is locked
 * A statement will be disallowed if it makes such changes
 * in catalog that are backed up by pg_dump except
 * CREATE NODE that has to be allowed because
 * a new node has to be created while the cluster is still
 * locked for backup
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsStmtAllowedInLockedMode</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALLOW</name></cpp:macro>         <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISALLOW</name></cpp:macro>      <cpp:value>0</cpp:value></cpp:define>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* To allow creation of temp tables */</comment>
        <case>case <expr><name>T_CreateStmt</name></expr>:</case>                                      <comment type="block">/* CREATE TABLE */</comment>
            <block>{<block_content>
                <decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>ALLOW</name></expr>;</return></block_content></block></if></if_stmt>
                <return>return <expr><name>DISALLOW</name></expr>;</return>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_ExecuteStmt</name></expr>:</case>                                     <comment type="block">/*
                                                                 * Prepared statememts can only have
                                                                 * SELECT, INSERT, UPDATE, DELETE,
                                                                 * or VALUES statement, there is no
                                                                 * point stopping EXECUTE.
                                                                 */</comment>
        <case>case <expr><name>T_CreateNodeStmt</name></expr>:</case>                          <comment type="block">/*
                                                         * This has to be allowed so that the new node
                                                         * can be created, while the cluster is still
                                                         * locked for backup
                                                         */</comment>
        <case>case <expr><name>T_DropNodeStmt</name></expr>:</case>                            <comment type="block">/*
                                                         * This has to be allowed so that DROP NODE
                                                         * can be issued to drop a node that has crashed.
                                                         * Otherwise system would try to acquire a shared
                                                         * advisory lock on the crashed node.
                                                         */</comment>

        <case>case <expr><name>T_AlterNodeStmt</name></expr>:</case>                            <comment type="block">/*
                                                         * This has to be
                                                         * allowed so that
                                                         * ALTER NODE can be
                                                         * issued in case a
                                                         * datanode or
                                                         * coordinator failover
                                                         */</comment>  
        <case>case <expr><name>T_TransactionStmt</name></expr>:</case>
        <case>case <expr><name>T_PlannedStmt</name></expr>:</case>
        <case>case <expr><name>T_ClosePortalStmt</name></expr>:</case>
        <case>case <expr><name>T_FetchStmt</name></expr>:</case>
        <case>case <expr><name>T_TruncateStmt</name></expr>:</case>
        <case>case <expr><name>T_CopyStmt</name></expr>:</case>
        <case>case <expr><name>T_PrepareStmt</name></expr>:</case>                                     <comment type="block">/*
                                                                 * Prepared statememts can only have
                                                                 * SELECT, INSERT, UPDATE, DELETE,
                                                                 * or VALUES statement, there is no
                                                                 * point stopping PREPARE.
                                                                 */</comment>
        <case>case <expr><name>T_DeallocateStmt</name></expr>:</case>                          <comment type="block">/*
                                                         * If prepare is allowed the deallocate should
                                                         * be allowed also
                                                         */</comment>
        <case>case <expr><name>T_DoStmt</name></expr>:</case>
        <case>case <expr><name>T_NotifyStmt</name></expr>:</case>
        <case>case <expr><name>T_ListenStmt</name></expr>:</case>
        <case>case <expr><name>T_UnlistenStmt</name></expr>:</case>
        <case>case <expr><name>T_LoadStmt</name></expr>:</case>
        <case>case <expr><name>T_ClusterStmt</name></expr>:</case>
        <case>case <expr><name>T_VacuumStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <case>case <expr><name>T_VacuumShardStmt</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>T_ExplainStmt</name></expr>:</case>
        <case>case <expr><name>T_VariableSetStmt</name></expr>:</case>
        <case>case <expr><name>T_VariableShowStmt</name></expr>:</case>
        <case>case <expr><name>T_DiscardStmt</name></expr>:</case>
        <case>case <expr><name>T_LockStmt</name></expr>:</case>
        <case>case <expr><name>T_ConstraintsSetStmt</name></expr>:</case>
        <case>case <expr><name>T_CheckPointStmt</name></expr>:</case>
        <case>case <expr><name>T_BarrierStmt</name></expr>:</case>
        <case>case <expr><name>T_ReindexStmt</name></expr>:</case>
        <case>case <expr><name>T_RemoteQuery</name></expr>:</case>
        <case>case <expr><name>T_CleanConnStmt</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <case>case <expr><name>T_PauseClusterStmt</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<comment type="block">/* Node Lock/Unlock do not modify any data */</comment>
		<case>case <expr><name>T_LockNodeStmt</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<return>return <expr><name>ALLOW</name></expr>;</return>
        <case>case <expr><name>T_AlterSystemStmt</name></expr>:</case>
            <comment type="block">/* allow if it's main cluster slave */</comment>
            <return>return <expr><ternary><condition><expr><operator>(</operator><name>IS_PGXC_MAINCLUSTER_SLAVENODE</name><operator>)</operator></expr> ?</condition><then> <expr><name>ALLOW</name></expr> </then><else>: <expr><name>DISALLOW</name></expr></else></ternary></expr>;</return>
        <default>default:</default>
            <return>return <expr><name>DISALLOW</name></expr>;</return>
    </block_content>}</block></switch>
    <return>return <expr><name>DISALLOW</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetCommentObjectId
 * TODO Change to return the nodes to execute the utility on
 *
 * Return Object ID of object commented
 * Note: This function uses portions of the code of CommentObject,
 * even if this code is duplicated this is done like this to facilitate
 * merges with PostgreSQL head.
 */</comment>
<function><type><specifier>static</specifier> <name>RemoteQueryExecType</name></type>
<name>GetNodesForCommentUtility</name><parameter_list>(<parameter><decl><type><name>CommentStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_temp</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ObjectAddress</name></type>        <name>address</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>            <name>relation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQueryExecType</name></type>    <name>exec_type</name> <init>= <expr><name>EXEC_ON_ALL_NODES</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* By default execute on all nodes */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>                    <name>object_id</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>==</operator> <name>OBJECT_DATABASE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>database</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_database_oid</name><argument_list>(<argument><expr><name>database</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_DATABASE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>database</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* No clue, return the default one */</comment>
        <return>return <expr><name>exec_type</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>get_object_address</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name>relation</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>object_id</name> <operator>=</operator> <name><name>address</name><operator>.</operator><name>objectId</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * If the object being commented is a rule, the nodes are decided by the
     * object to which rule is applicable, so get the that object's oid
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>==</operator> <name>OBJECT_RULE</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>relation</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* This should not happen, but prepare for the worst */</comment>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rulename</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"can not find relation for rule \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>rulename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>object_id</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>object_id</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>relation</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Commented object may not have a valid object ID, so move to default */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>object_id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <call><name>ExecUtilityFindNodes</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>,
                <argument><expr><name>object_id</name></expr></argument>,
                <argument><expr><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>exec_type</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetNodesForRulesUtility
 * Get the nodes to execute this RULE related utility statement.
 * A rule is expanded on Coordinator itself, and does not need any
 * existence on Datanode. In fact, if it were to exist on Datanode,
 * there is a possibility that it would expand again
 */</comment>
<function><type><specifier>static</specifier> <name>RemoteQueryExecType</name></type>
<name>GetNodesForRulesUtility</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_temp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQueryExecType</name></type> <name>exec_type</name></decl>;</decl_stmt>

    <comment type="block">/* Skip if this Oid does not exist */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>EXEC_ON_NONE</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * PGXCTODO: See if it's a temporary object, do we really need
     * to care about temporary objects here? What about the
     * temporary objects defined inside the rule?
     */</comment>
    <expr_stmt><expr><name>exec_type</name> <operator>=</operator> <call><name>ExecUtilityFindNodes</name><argument_list>(<argument><expr><name>OBJECT_RULE</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>exec_type</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TreatDropStmtOnCoord
 * Do a pre-treatment of Drop statement on a remote Coordinator
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DropStmtPreTreatment</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sentToRemote</name></decl></parameter>,
        <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_temp</name></decl></parameter>, <parameter><decl><type><name>RemoteQueryExecType</name> <modifier>*</modifier></type><name>exec_type</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>res_is_temp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQueryExecType</name></type> <name>res_exec_type</name> <init>= <expr><name>EXEC_ON_ALL_NODES</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Nothing to do if not local Coordinator */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>||</operator> <call><name>IsConnFromCoord</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
        <case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
        <case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
        <case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
        <case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/*
                 * Check the list of objects going to be dropped.
                 * XC does not allow yet to mix drop of temporary and
                 * non-temporary objects because this involves to rewrite
                 * query to process for tables.
                 */</comment>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>        <name>is_first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><name>OBJECT_TABLE</name> <operator>==</operator> <name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name></expr>)</condition>
                <block>{<block_content>
                    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>stmt-&gt;objects</argument>)</argument_list></macro>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rangevar</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>Oid</name></type>         <name>relid</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>bool</name></type>        <name>schema_bound</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
                        
                        <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>rangevar</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <call><name>mls_check_relation_permission</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schema_bound</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>schema_bound</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not drop table:%s, cause mls poilcy is bound"</literal></expr></argument>, 
                                    <argument><expr><name><name>rangevar</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                            <comment type="block">/*
                             * if schema is crypted, table could be dropped directly.
                             * cause, table having the same name would be crypted when it was created again.
                             */</comment>
                        </block_content>}</block></if></if_stmt>          
                        
                        <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>FetchAllParitionList</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>NIL</name> <operator>!=</operator> <name>children</name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type>    <name>lc</name></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>Oid</name></type>         <name>partoid</name></decl>;</decl_stmt>

                            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>children</argument>)</argument_list></macro>
                            <block>{<block_content>
                                <expr_stmt><expr><name>partoid</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <call><name>mls_check_relation_permission</name><argument_list>(<argument><expr><name>partoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schema_bound</name></expr></argument>)</argument_list></call></expr>)</condition>
                                <block>{<block_content>
                                    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>schema_bound</name></expr>)</condition>
                                    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
                                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not drop table:%s, cause mls poilcy is bound"</literal></expr></argument>, 
                                            <argument><expr><name><name>rangevar</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not drop table:%s, partition oid:%u cause mls poilcy is bound"</literal></expr></argument>, 
                                            <argument><expr><name><name>rangevar</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>partoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                    </block_content>}</block></if></if_stmt>
                                </block_content>}</block></if></if_stmt> 
                            </block_content>}</block>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>stmt-&gt;objects</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Oid</name></type>         <name>relid</name></decl>;</decl_stmt>

                    <comment type="block">/*
                     * Do not print result at all, error is thrown
                     * after if necessary
                     */</comment>
                    <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * In case this relation ID is incorrect throw
                     * a correct DROP error.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>DropTableThrowErrorExternal</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
                                <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name></expr></argument>,
                                <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="block">/* In case of DROP ... IF EXISTS bypass */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <continue>continue;</continue></block_content></block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name>is_first</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>res_exec_type</name> <operator>=</operator> <call><name>ExecUtilityFindNodes</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name></expr></argument>,
                                <argument><expr><name>relid</name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name>res_is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>is_first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>RemoteQueryExecType</name></type> <name>exec_type_loc</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>bool</name></type> <name>is_temp_loc</name></decl>;</decl_stmt>
                        <expr_stmt><expr><name>exec_type_loc</name> <operator>=</operator> <call><name>ExecUtilityFindNodes</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name></expr></argument>,
                                <argument><expr><name>relid</name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name>is_temp_loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>exec_type_loc</name> <operator>!=</operator> <name>res_exec_type</name> <operator>||</operator>
                                <name>is_temp_loc</name> <operator>!=</operator> <name>res_is_temp</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DROP not supported for TEMP and non-TEMP objects"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"You should separate TEMP and non-TEMP objects"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>OBJECT_RULE</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/*
                 * In the case of a rule we need to find the object on
                 * which the rule is dependent and define if this rule
                 * has a dependency with a temporary object or not.
                 */</comment>
                <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>objname</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Relation</name></type>    <name>relation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>get_object_address</name><argument_list>(<argument><expr><name>OBJECT_RULE</name></expr></argument>,
                        <argument><expr><name>objname</name></expr></argument>, <comment type="block">/* XXX PG10MERGE: check if this is ok */</comment>
                        <argument><expr><operator>&amp;</operator><name>relation</name></expr></argument>,
                        <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
                        <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Do nothing if no relation */</comment>
                <if_stmt><if>if <condition>(<expr><name>relation</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>res_exec_type</name> <operator>=</operator> <call><name>ExecUtilityFindNodes</name><argument_list>(<argument><expr><name>OBJECT_RULE</name></expr></argument>,
                            <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>res_is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>res_exec_type</name> <operator>=</operator> <name>EXEC_ON_NONE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <comment type="block">/* Close relation if necessary */</comment>
                <if_stmt><if>if <condition>(<expr><name>relation</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><name>res_is_temp</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>res_exec_type</name> <operator>=</operator> <name>EXEC_ON_ALL_NODES</name></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/* Save results */</comment>
    <expr_stmt><expr><operator>*</operator><name>is_temp</name> <operator>=</operator> <name>res_is_temp</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>exec_type</name> <operator>=</operator> <name>res_exec_type</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
<comment type="block">/*
 * Create key values of relation
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ExecCreateKeyValuesStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int32</name></type>   <name>offset</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>   <name>nvalues</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                    
    <decl_stmt><decl><type><name>Oid</name></type>     <name>group_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>     <name>cold_group_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>     <name>db</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>     <name>nsp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>     <name>rel</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>    <modifier>*</modifier></type><name>search_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name>            <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>locator</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>     <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>    <name><name>tablename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CreateKeyValuesStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CreateKeyValuesStmt</name> <operator>*</operator><operator>)</operator><name>parsetree</name></expr></init></decl>;</decl_stmt>
    
    <comment type="line">//if (IS_PGXC_COORDINATOR)</comment>
    <block>{<block_content>
        <expr_stmt><expr><name>group_oid</name> <operator>=</operator> <call><name>get_pgxc_groupoid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>group</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>group_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC Group %s: group not defined"</literal></expr></argument>,
                            <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>group</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>coldgroup</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>cold_group_oid</name> <operator>=</operator> <call><name>get_pgxc_groupoid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>coldgroup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>cold_group_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC Group %s: group not defined"</literal></expr></argument>,
                                <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>coldgroup</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>cold_group_oid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    if (IS_PGXC_DATANODE)
    {
        group_oid        = InvalidOid;
        cold_group_oid = InvalidOid;
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <switch>switch <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relinfo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="number">1</literal></expr>:</case>
        <block>{<block_content>
            <comment type="block">/* only relation, loop through the namelist to find the relation */</comment>
            <expr_stmt><expr><name>search_path</name> <operator>=</operator> <call><name>fetch_search_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>db</name>  <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
            
            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>search_path</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>nsp</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nsp</name></expr></argument>)</argument_list></call></expr>)</condition>            
                <block>{<block_content>
                    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relinfo</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>                        
            <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>search_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tablename</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relinfo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><literal type="number">2</literal></expr>:</case>
        <block>{<block_content>
            <comment type="block">/* schema.relation */</comment>
            <expr_stmt><expr><name>db</name>  <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>        
            <comment type="block">/* schema */</comment>        
            <expr_stmt><expr><name>nsp</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relinfo</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
            <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>tablename</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relinfo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* relation */</comment>
            <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>lsecond</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relinfo</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>tablename</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>MAXPGPATH</name> <operator>-</operator> <name>offset</name></expr></argument>, <argument><expr><literal type="string">".%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>lsecond</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relinfo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><literal type="number">3</literal></expr>:</case>
        <block>{<block_content>
            <comment type="block">/* database.schema.relation */</comment>            
            <comment type="block">/* db */</comment>        
            <expr_stmt><expr><name>db</name>  <operator>=</operator> <call><name>get_database_oid</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relinfo</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>tablename</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relinfo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <comment type="block">/* schema */</comment>
            <expr_stmt><expr><name>nsp</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>lsecond</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relinfo</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>tablename</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>MAXPGPATH</name> <operator>-</operator> <name>offset</name></expr></argument>, <argument><expr><literal type="string">".%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>lsecond</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relinfo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <comment type="block">/* table */</comment>
            <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>lthird</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relinfo</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>tablename</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>MAXPGPATH</name> <operator>-</operator> <name>offset</name></expr></argument>, <argument><expr><literal type="string">".%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>lthird</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relinfo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>

        <default>default:</default>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table %s does not exist"</literal></expr></argument>,
                            <argument><expr><name>tablename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

    </block_content>}</block></switch>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table %s does not exist"</literal></expr></argument>,
                            <argument><expr><name>tablename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* check whether key values can be defined */</comment>
    <expr_stmt><expr><name>locator</name> <operator>=</operator> <call><name>GetRelationLocInfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>locator</name> <operator>||</operator> <name><name>locator</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>!=</operator> <name>LOCATOR_TYPE_SHARD</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table %s can not define key values, only shard table can have key values!"</literal></expr></argument>,
                            <argument><expr><name>tablename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>group_oid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>cold_group_oid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>group_oid</name> <operator>==</operator> <name>cold_group_oid</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"key value main group and cold group can not be the same one"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//if (IS_PGXC_COORDINATOR)</comment>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>cold_group_oid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"key value is supposed to have the same hot/cold strategy as main table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>CheckPgxcClassGroupValid</name><argument_list>(<argument><expr><name>group_oid</name></expr></argument>, <argument><expr><name>cold_group_oid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CheckKeyValueGroupValid</name><argument_list>(<argument><expr><name>group_oid</name></expr></argument>, <argument><expr><name>cold_group_oid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CheckPgxcClassGroupConfilct</name><argument_list>(<argument><expr><name>group_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <name>group_oid</name> <operator>||</operator> <name><name>locator</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <name>cold_group_oid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"key value group can not use main table's main group"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>coldGroupId</name></name> <operator>==</operator> <name>group_oid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"key value group can not use main table's cold group as main group"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>cold_group_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"key value must have a cold group when main table has one"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>    
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>nvalues</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>values</name>  <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>valuesLists</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;valuesLists</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>nvalues</name></expr>]</index></name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nvalues</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>CreateKeyValues</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>group_oid</name></expr></argument>, <argument><expr><name>cold_group_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveSequeceBarely</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell1</name></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    
    <macro><name>foreach</name><argument_list>(<argument>cell1</argument>, <argument>stmt-&gt;objects</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>object</name>   <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>sequence</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>         <name><name>seqname</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><name>sequence</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        
        <switch>switch <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>sequence</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="number">1</literal></expr>:</case>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>sequence</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">2</literal></expr>:</case>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>sequence</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name>sequence</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">3</literal></expr>:</case>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="string">"%s.%s.%s"</literal></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>sequence</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name>sequence</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lthird</name><argument_list>(<argument><expr><name>sequence</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"improper relation name (too many dotted names)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>    
        <expr_stmt><expr><call><name>DropSequenceGTM</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>, <argument><expr><name>GTM_SEQ_FULL_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
    </block_content>}</block>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
