<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/catalog/dependency.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * dependency.c
 *      Routines to support inter-object dependencies.
 *
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 * IDENTIFICATION
 *      src/backend/catalog/dependency.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_amop.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_amproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attrdef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_cast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_conversion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_conversion_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_default_acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_depend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_data_wrapper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_init_privs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_language.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_largeobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opfamily.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_publication.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_publication_rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_rewrite.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_subscription.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_transform.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_dict.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_template.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_user_mapping.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_group.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_c.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gtm.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/comment.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/proclang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/publicationcmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/schemacmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/seclabel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/typecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteRemove.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"audit/audit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_audit.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_publication_shard.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_subscription_shard.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_subscription_table.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcrypt.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/scansup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 * Deletion processing requires additional state for each ObjectAddress that
 * it's planning to delete.  For simplicity and code-sharing we make the
 * ObjectAddresses code support arrays with or without this extra state.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>int</name></type>            <name>flags</name></decl>;</decl_stmt>            <comment type="block">/* bitmask, see bit definitions below */</comment>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>dependee</name></decl>;</decl_stmt>        <comment type="block">/* object whose deletion forced this one */</comment>
}</block></struct></type> <name>ObjectAddressExtra</name>;</typedef>

<comment type="block">/* ObjectAddressExtra flag bits */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEPFLAG_ORIGINAL</name></cpp:macro>    <cpp:value>0x0001</cpp:value></cpp:define>    <comment type="block">/* an original deletion target */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEPFLAG_NORMAL</name></cpp:macro>        <cpp:value>0x0002</cpp:value></cpp:define>    <comment type="block">/* reached via normal dependency */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEPFLAG_AUTO</name></cpp:macro>        <cpp:value>0x0004</cpp:value></cpp:define>    <comment type="block">/* reached via auto dependency */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEPFLAG_INTERNAL</name></cpp:macro>    <cpp:value>0x0008</cpp:value></cpp:define>    <comment type="block">/* reached via internal dependency */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEPFLAG_EXTENSION</name></cpp:macro>    <cpp:value>0x0010</cpp:value></cpp:define>    <comment type="block">/* reached via extension dependency */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEPFLAG_REVERSE</name></cpp:macro>        <cpp:value>0x0020</cpp:value></cpp:define>    <comment type="block">/* reverse internal/extension link */</comment>

<comment type="block">/* expansible list of ObjectAddresses */</comment>
<struct>struct <name>ObjectAddresses</name>
<block>{
    <decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>refs</name></decl>;</decl_stmt>        <comment type="block">/* =&gt; palloc'd array */</comment>
    <decl_stmt><decl><type><name>ObjectAddressExtra</name> <modifier>*</modifier></type><name>extras</name></decl>;</decl_stmt> <comment type="block">/* =&gt; palloc'd array, or NULL if not used */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>numrefs</name></decl>;</decl_stmt>        <comment type="block">/* current number of references */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>maxrefs</name></decl>;</decl_stmt>        <comment type="block">/* current size of palloc'd array(s) */</comment>
}</block>;</struct>

<comment type="block">/* typedef ObjectAddresses appears in dependency.h */</comment>

<comment type="block">/* threaded list of ObjectAddresses, for recursion detection */</comment>
<typedef>typedef <type><struct>struct <name>ObjectAddressStack</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl>;</decl_stmt>    <comment type="block">/* object being visited */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>flags</name></decl>;</decl_stmt>            <comment type="block">/* its current flag bits */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>ObjectAddressStack</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>    <comment type="block">/* next outer stack level */</comment>
}</block></struct></type> <name>ObjectAddressStack</name>;</typedef>

<comment type="block">/* for find_expr_references_walker */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>addrs</name></decl>;</decl_stmt>        <comment type="block">/* addresses being accumulated */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>rtables</name></decl>;</decl_stmt>        <comment type="block">/* list of rangetables to resolve Vars */</comment>
}</block></struct></type> <name>find_expr_references_context</name>;</typedef>

<comment type="block">/*
 * This constant table maps ObjectClasses to the corresponding catalog OIDs.
 * See also getObjectClass().
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Oid</name></type> <name><name>object_classes</name><index>[]</index></name> <init>= <expr><block>{
    <expr><name>RelationRelationId</name></expr>,            <comment type="block">/* OCLASS_CLASS */</comment>
    <expr><name>ProcedureRelationId</name></expr>,        <comment type="block">/* OCLASS_PROC */</comment>
    <expr><name>TypeRelationId</name></expr>,                <comment type="block">/* OCLASS_TYPE */</comment>
    <expr><name>CastRelationId</name></expr>,                <comment type="block">/* OCLASS_CAST */</comment>
    <expr><name>CollationRelationId</name></expr>,        <comment type="block">/* OCLASS_COLLATION */</comment>
    <expr><name>ConstraintRelationId</name></expr>,        <comment type="block">/* OCLASS_CONSTRAINT */</comment>
    <expr><name>ConversionRelationId</name></expr>,        <comment type="block">/* OCLASS_CONVERSION */</comment>
    <expr><name>AttrDefaultRelationId</name></expr>,        <comment type="block">/* OCLASS_DEFAULT */</comment>
    <expr><name>LanguageRelationId</name></expr>,            <comment type="block">/* OCLASS_LANGUAGE */</comment>
    <expr><name>LargeObjectRelationId</name></expr>,        <comment type="block">/* OCLASS_LARGEOBJECT */</comment>
    <expr><name>OperatorRelationId</name></expr>,            <comment type="block">/* OCLASS_OPERATOR */</comment>
    <expr><name>OperatorClassRelationId</name></expr>,    <comment type="block">/* OCLASS_OPCLASS */</comment>
    <expr><name>OperatorFamilyRelationId</name></expr>,    <comment type="block">/* OCLASS_OPFAMILY */</comment>
    <expr><name>AccessMethodRelationId</name></expr>,        <comment type="block">/* OCLASS_AM */</comment>
    <expr><name>AccessMethodOperatorRelationId</name></expr>, <comment type="block">/* OCLASS_AMOP */</comment>
    <expr><name>AccessMethodProcedureRelationId</name></expr>,    <comment type="block">/* OCLASS_AMPROC */</comment>
    <expr><name>RewriteRelationId</name></expr>,            <comment type="block">/* OCLASS_REWRITE */</comment>
    <expr><name>TriggerRelationId</name></expr>,            <comment type="block">/* OCLASS_TRIGGER */</comment>
    <expr><name>NamespaceRelationId</name></expr>,        <comment type="block">/* OCLASS_SCHEMA */</comment>
    <expr><name>StatisticExtRelationId</name></expr>,        <comment type="block">/* OCLASS_STATISTIC_EXT */</comment>
    <expr><name>TSParserRelationId</name></expr>,            <comment type="block">/* OCLASS_TSPARSER */</comment>
    <expr><name>TSDictionaryRelationId</name></expr>,        <comment type="block">/* OCLASS_TSDICT */</comment>
    <expr><name>TSTemplateRelationId</name></expr>,        <comment type="block">/* OCLASS_TSTEMPLATE */</comment>
    <expr><name>TSConfigRelationId</name></expr>,            <comment type="block">/* OCLASS_TSCONFIG */</comment>
    <expr><name>AuthIdRelationId</name></expr>,            <comment type="block">/* OCLASS_ROLE */</comment>
    <expr><name>DatabaseRelationId</name></expr>,            <comment type="block">/* OCLASS_DATABASE */</comment>
    <expr><name>TableSpaceRelationId</name></expr>,        <comment type="block">/* OCLASS_TBLSPACE */</comment>
    <expr><name>ForeignDataWrapperRelationId</name></expr>,    <comment type="block">/* OCLASS_FDW */</comment>
    <expr><name>ForeignServerRelationId</name></expr>,    <comment type="block">/* OCLASS_FOREIGN_SERVER */</comment>
    <expr><name>UserMappingRelationId</name></expr>,        <comment type="block">/* OCLASS_USER_MAPPING */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <expr><name>PgxcClassRelationId</name></expr>,        <comment type="block">/* OCLASS_PGXCCLASS */</comment>
    <expr><name>PgxcNodeRelationId</name></expr>,            <comment type="block">/* OCLASS_PGXC_NODE */</comment>
    <expr><name>PgxcGroupRelationId</name></expr>,        <comment type="block">/* OCLASS_PGXC_GROUP */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr><name>PgPartitionIntervalRelationId</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
    <expr><name>PgAuditStmtConfRelationId</name></expr>,    <comment type="block">/* OCLASS_AUDIT_STMT */</comment>
    <expr><name>PgAuditUserConfRelationId</name></expr>,    <comment type="block">/* OCLASS_AUDIT_USER */</comment>
    <expr><name>PgAuditObjConfRelationId</name></expr>,    <comment type="block">/* OCLASS_AUDIT_OBJ */</comment>
    <expr><name>PgAuditObjDefOptsRelationId</name></expr>,<comment type="block">/* OCLASS_AUDIT_OBJDEFAULT */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
    <expr><name>PublicationShardRelationId</name></expr>, <comment type="block">/* OCLASS_PUBLICATION_SHARD */</comment>
    <expr><name>SubscriptionShardRelationId</name></expr>,<comment type="block">/* OCLASS_SUBSCRIPTION_SHARD */</comment>
    <expr><name>SubscriptionTableRelationId</name></expr>,<comment type="block">/* OCLASS_SUBSCRIPTION_TABLE */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><name>DefaultAclRelationId</name></expr>,        <comment type="block">/* OCLASS_DEFACL */</comment>
    <expr><name>ExtensionRelationId</name></expr>,        <comment type="block">/* OCLASS_EXTENSION */</comment>
    <expr><name>EventTriggerRelationId</name></expr>,        <comment type="block">/* OCLASS_EVENT_TRIGGER */</comment>
    <expr><name>PolicyRelationId</name></expr>,            <comment type="block">/* OCLASS_POLICY */</comment>
    <expr><name>PublicationRelationId</name></expr>,        <comment type="block">/* OCLASS_PUBLICATION */</comment>
    <expr><name>PublicationRelRelationId</name></expr>,    <comment type="block">/* OCLASS_PUBLICATION_REL */</comment>
    <expr><name>SubscriptionRelationId</name></expr>,        <comment type="block">/* OCLASS_SUBSCRIPTION */</comment>
    <expr><name>TransformRelationId</name></expr>            <comment type="block">/* OCLASS_TRANSFORM */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>findDependentObjects</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>,
                     <parameter><decl><type><name>int</name></type> <name>objflags</name></decl></parameter>,
                     <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
                     <parameter><decl><type><name>ObjectAddressStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
                     <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>targetObjects</name></decl></parameter>,
                     <parameter><decl><type><specifier>const</specifier> <name>ObjectAddresses</name> <modifier>*</modifier></type><name>pendingObjects</name></decl></parameter>,
                     <parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>depRel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>reportDependentObjects</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddresses</name> <modifier>*</modifier></type><name>targetObjects</name></decl></parameter>,
                       <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>,
                       <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>origObject</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deleteOneObject</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>,
                <parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>depRel</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>doDeletion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AcquireDeletionLock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReleaseDeletionLock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>find_expr_references_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                            <parameter><decl><type><name>find_expr_references_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>eliminate_duplicate_dependencies</name><parameter_list>(<parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>addrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>object_address_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_object_address</name><parameter_list>(<parameter><decl><type><name>ObjectClass</name></type> <name>oclass</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>subId</name></decl></parameter>,
                   <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>addrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_exact_object_address_extra</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>,
                               <parameter><decl><type><specifier>const</specifier> <name>ObjectAddressExtra</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>,
                               <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>addrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>object_address_present_add_flags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>,
                                 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
                                 <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>addrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>stack_address_present_add_flags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>,
                                <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
                                <parameter><decl><type><name>ObjectAddressStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DeleteInitPrivs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Go through the objects given running the final actions on them, and execute
 * the actual deletion.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deleteObjectsInList</name><parameter_list>(<parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>targetObjects</name></decl></parameter>, <parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>depRel</name></decl></parameter>,
                    <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Keep track of objects for event triggers, if necessary.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>trackDroppedObjectsNeeded</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>PERFORM_DELETION_INTERNAL</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>targetObjects</name><operator>-&gt;</operator><name>numrefs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>thisobj</name> <init>= <expr><operator>&amp;</operator><name><name>targetObjects</name><operator>-&gt;</operator><name>refs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ObjectAddressExtra</name> <modifier>*</modifier></type><name>extra</name> <init>= <expr><operator>&amp;</operator><name><name>targetObjects</name><operator>-&gt;</operator><name>extras</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>original</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>normal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>extra</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DEPFLAG_ORIGINAL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>original</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>extra</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DEPFLAG_NORMAL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>normal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>extra</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DEPFLAG_REVERSE</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>normal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectClass</name><argument_list>(<argument><expr><call><name>getObjectClass</name><argument_list>(<argument><expr><name>thisobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>EventTriggerSQLDropAddObject</name><argument_list>(<argument><expr><name>thisobj</name></expr></argument>, <argument><expr><name>original</name></expr></argument>, <argument><expr><name>normal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Delete all the objects in the proper order, except that if told to, we
     * should skip the original object(s).
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>targetObjects</name><operator>-&gt;</operator><name>numrefs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>thisobj</name> <init>= <expr><name><name>targetObjects</name><operator>-&gt;</operator><name>refs</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ObjectAddressExtra</name> <modifier>*</modifier></type><name>thisextra</name> <init>= <expr><name><name>targetObjects</name><operator>-&gt;</operator><name>extras</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>PERFORM_DELETION_SKIP_ORIGINAL</name><operator>)</operator> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>thisextra</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DEPFLAG_ORIGINAL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>deleteOneObject</name><argument_list>(<argument><expr><name>thisobj</name></expr></argument>, <argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * performDeletion: attempt to drop the specified object.  If CASCADE
 * behavior is specified, also drop any dependent objects (recursively).
 * If RESTRICT behavior is specified, error out if there are any dependent
 * objects, except for those that should be implicitly dropped anyway
 * according to the dependency type.
 *
 * This is the outer control routine for all forms of DROP that drop objects
 * that can participate in dependencies.  Note that performMultipleDeletions
 * is a variant on the same theme; if you change anything here you'll likely
 * need to fix that too.
 *
 * Bits in the flags argument can include:
 *
 * PERFORM_DELETION_INTERNAL: indicates that the drop operation is not the
 * direct result of a user-initiated action.  For example, when a temporary
 * schema is cleaned out so that a new backend can use it, or when a column
 * default is dropped as an intermediate step while adding a new one, that's
 * an internal operation.  On the other hand, when we drop something because
 * the user issued a DROP statement against it, that's not internal. Currently
 * this suppresses calling event triggers and making some permissions checks.
 *
 * PERFORM_DELETION_CONCURRENTLY: perform the drop concurrently.  This does
 * not currently work for anything except dropping indexes; don't set it for
 * other object types or you may get strange results.
 *
 * PERFORM_DELETION_QUIETLY: reduce message level from NOTICE to DEBUG2.
 *
 * PERFORM_DELETION_SKIP_ORIGINAL: do not delete the specified object(s),
 * but only what depends on it/them.
 *
 * PERFORM_DELETION_SKIP_EXTENSIONS: do not delete extensions, even when
 * deleting objects that are part of an extension.  This should generally
 * be used only when dropping temporary objects.
 */</comment>
<function><type><name>void</name></type>
<name>performDeletion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>,
                <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>depRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>targetObjects</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We save some cycles by opening pg_depend just once and passing the
     * Relation pointer down to all the recursive deletion steps.
     */</comment>
    <expr_stmt><expr><name>depRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Acquire deletion lock on the target object.  (Ideally the caller has
     * done this already, but many places are sloppy about it.)
     */</comment>
    <expr_stmt><expr><call><name>AcquireDeletionLock</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Construct a list of objects to delete (ie, the given object plus
     * everything directly or indirectly dependent on it).
     */</comment>
    <expr_stmt><expr><name>targetObjects</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>findDependentObjects</name><argument_list>(<argument><expr><name>object</name></expr></argument>,
                         <argument><expr><name>DEPFLAG_ORIGINAL</name></expr></argument>,
                         <argument><expr><name>flags</name></expr></argument>,
                         <argument><expr><name>NULL</name></expr></argument>,    <comment type="block">/* empty stack */</comment>
                         <argument><expr><name>targetObjects</name></expr></argument>,
                         <argument><expr><name>NULL</name></expr></argument>,    <comment type="block">/* no pendingObjects */</comment>
                         <argument><expr><operator>&amp;</operator><name>depRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check if deletion is allowed, and report about cascaded deletes.
     */</comment>
    <expr_stmt><expr><call><name>reportDependentObjects</name><argument_list>(<argument><expr><name>targetObjects</name></expr></argument>,
                           <argument><expr><name>behavior</name></expr></argument>,
                           <argument><expr><name>flags</name></expr></argument>,
                           <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* do the deed */</comment>
    <expr_stmt><expr><call><name>deleteObjectsInList</name><argument_list>(<argument><expr><name>targetObjects</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>depRel</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* And clean up */</comment>
    <expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>targetObjects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>

<comment type="block">/*
 * replace all invisible characters with ' ',
 * leave no spaces next to ',' or '.'
 */</comment>
<function><type><name>void</name></type>
<name>OmitqueryStringSpace</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>front</name> <init>= <expr><name>queryString</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>last</name> <init>= <expr><name>queryString</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>skip</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>queryString</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* omit space */</comment>
    <while>while <condition>(<expr><call><name>scanner_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>front</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>++</operator><name>front</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <while>while <condition>(<expr><operator>(</operator><operator>*</operator><name>front</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><call><name>scanner_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>front</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>skip</name> <operator>==</operator> <name>false</name></expr>)</condition>
        <block>{<block_content>
            <while>while<condition>(<expr><call><name>scanner_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>front</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>++</operator><name>front</name></expr>;</expr_stmt>
            </block_content>}</block></while>

            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>front</name><operator>)</operator> <operator>==</operator> <literal type="char">','</literal> <operator>||</operator> <operator>(</operator><operator>*</operator><name>front</name><operator>)</operator> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* no need space */</comment>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>last</name> <operator>!=</operator> <name>queryString</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>last</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">','</literal> <operator>||</operator> <operator>*</operator><operator>(</operator><name>last</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'.'</literal><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* no need space */</comment>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* replace all invisible characters with ' ' */</comment>
                <expr_stmt><expr><operator>*</operator><name>last</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
                <expr_stmt><expr><operator>++</operator><name>last</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>front</name><operator>)</operator> <operator>==</operator> <literal type="char">'\"'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>skip</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>skip</name> <operator>==</operator> <name>true</name><operator>)</operator></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>last</name> <operator>=</operator> <operator>*</operator><name>front</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>++</operator><name>front</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>last</name> <operator>=</operator> <operator>*</operator><name>front</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>++</operator><name>front</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><operator>++</operator><name>last</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><operator>*</operator><name>last</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * remove object name in query string (replace with ' ')
 */</comment>
<function><type><name>void</name></type>
<name>RemoveObjnameInQueryString</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>full_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmpStr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>start_ptr</name> <init>= <expr><name>queryString</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end_ptr</name> <init>= <expr><name>queryString</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>tmpStr</name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>full_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ptr</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>tmpStr</name></expr></argument>, <argument><expr><name>full_name</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* is not independent string, skip */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <name>start_ptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="char">','</literal><operator>)</operator><operator>)</operator> <operator>||</operator>
                    <operator>(</operator><operator>(</operator><name>ptr</name> <operator>+</operator> <name>len</name><operator>)</operator> <operator>&lt;=</operator> <name>end_ptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>ptr</name> <operator>+</operator> <name>len</name><operator>)</operator> <operator>!=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>ptr</name> <operator>+</operator> <name>len</name><operator>)</operator> <operator>!=</operator> <literal type="char">','</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>ptr</name> <operator>+</operator> <name>len</name><operator>)</operator> <operator>!=</operator> <literal type="char">';'</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <name>start_ptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'\"'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>len</name><operator>)</operator> <operator>&lt;=</operator> <name>end_ptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>ptr</name> <operator>+</operator> <name>len</name><operator>)</operator> <operator>==</operator> <literal type="char">'\"'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
                        <operator>(</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>&lt;</operator> <name>start_ptr</name> <operator>||</operator> <operator>*</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>!=</operator> <literal type="char">'.'</literal><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><operator>(</operator><name>ptr</name> <operator>+</operator> <name>len</name><operator>)</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>tmpStr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* replace obj name with ' ' */</comment>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* find the previous ',' */</comment>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>tmp</name> <operator>&gt;=</operator> <name>start_ptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>tmp</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>tmp</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></while>

        <if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>&gt;=</operator> <name>start_ptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>tmp</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>tmp</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* find the following ',' */</comment>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>tmp</name> <operator>&lt;=</operator> <name>end_ptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>tmp</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>tmp</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>

            <if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>&lt;=</operator> <name>end_ptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>tmp</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>tmp</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>tmpStr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Like RemoveRelations, implements drop relations. But the function
 * only be used for local cn in parallel ddl mode.
 */</comment>
<function><type><name>void</name></type>
<name>RemoveRelationsParallelMode</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>drop</name></decl></parameter>, <parameter><decl><type><name>ObjectAddresses</name><modifier>*</modifier></type> <name>objects</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>heap_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>		<name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	<name>relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> 	<modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>heap_oid</name></decl>;</decl_stmt>

	<comment type="block">/* Determine required relkind */</comment>
	<expr_stmt><expr><name>relkind</name> <operator>=</operator> <call><name>GetRemoveObjectRelkind</name><argument_list>(<argument><expr><name><name>drop</name><operator>-&gt;</operator><name>removeType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>drop</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>PERFORM_DELETION_CONCURRENTLY</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In DROP INDEX, attempt to acquire lock on the parent table before
	 * locking the index.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>heap_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>heap_oid</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>PERFORM_DELETION_CONCURRENTLY</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>heap_oid</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>heap_oid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>objects</name><operator>-&gt;</operator><name>numrefs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>ObjectAddress</name><modifier>*</modifier></type> <name>thisobj</name> <init>= <expr><name><name>objects</name><operator>-&gt;</operator><name>refs</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>		 <name>relOid</name> <init>= <expr><name><name>thisobj</name><operator>-&gt;</operator><name>objectId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type> <name>child_rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>AcquireDeletionLock</name><argument_list>(<argument><expr><name>thisobj</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* could not drop child interval partition or its index */</comment>
		<if_stmt><if>if <condition>(<expr><name>RELKIND_RELATION</name> <operator>==</operator> <name>relkind</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>report_error</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"drop table relOid: %u"</literal></expr></argument>, <argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>RELKIND_RELATION</name> <operator>==</operator> <name>relkind</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>child_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>child_rel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_CHILD</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>report_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>RELKIND_RELATION</name> <operator>==</operator> <name>relkind</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>report_error</name></expr>)</condition>
			<block>{<block_content>
				<empty_stmt>;</empty_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>performMultipleDeletions</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name><name>drop</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Implements drop one or more objects such as schema/function/type. 
 * The function only be used for local cn in parallel ddl mode.
 */</comment>
<function><type><name>void</name></type>
<name>RemoveObjectsParallelMode</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objects</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>objects</name><operator>-&gt;</operator><name>numrefs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>ObjectAddress</name><modifier>*</modifier></type> <name>thisobj</name> <init>= <expr><name><name>objects</name><operator>-&gt;</operator><name>refs</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsSharedRelation</name><argument_list>(<argument><expr><name><name>thisobj</name><operator>-&gt;</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockSharedObject</name><argument_list>(<argument><expr><name><name>thisobj</name><operator>-&gt;</operator><name>classId</name></name></expr></argument>, <argument><expr><name><name>thisobj</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>,
								<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockDatabaseObject</name><argument_list>(<argument><expr><name><name>thisobj</name><operator>-&gt;</operator><name>classId</name></name></expr></argument>, <argument><expr><name><name>thisobj</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>,
								<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>
	<comment type="block">/* Here we really delete them. */</comment>
    <expr_stmt><expr><call><name>performMultipleDeletions</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * performMultipleDeletions: Similar to performDeletion, but act on multiple
 * objects at once.
 *
 * The main difference from issuing multiple performDeletion calls is that the
 * list of objects that would be implicitly dropped, for each object to be
 * dropped, is the union of the implicit-object list for all objects.  This
 * makes each check be more relaxed.
 */</comment>
<function><type><name>void</name></type>
<name>performMultipleDeletions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddresses</name> <modifier>*</modifier></type><name>objects</name></decl></parameter>,
                         <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>depRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>targetObjects</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* No work if no objects... */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>objects</name><operator>-&gt;</operator><name>numrefs</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We save some cycles by opening pg_depend just once and passing the
     * Relation pointer down to all the recursive deletion steps.
     */</comment>
    <expr_stmt><expr><name>depRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Construct a list of objects to delete (ie, the given objects plus
     * everything directly or indirectly dependent on them).  Note that
     * because we pass the whole objects list as pendingObjects context, we
     * won't get a failure from trying to delete an object that is internally
     * dependent on another one in the list; we'll just skip that object and
     * delete it when we reach its owner.
     */</comment>
    <expr_stmt><expr><name>targetObjects</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>objects</name><operator>-&gt;</operator><name>numrefs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>thisobj</name> <init>= <expr><name><name>objects</name><operator>-&gt;</operator><name>refs</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Acquire deletion lock on each target object.  (Ideally the caller
         * has done this already, but many places are sloppy about it.)
         */</comment>
        <expr_stmt><expr><call><name>AcquireDeletionLock</name><argument_list>(<argument><expr><name>thisobj</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>findDependentObjects</name><argument_list>(<argument><expr><name>thisobj</name></expr></argument>,
                             <argument><expr><name>DEPFLAG_ORIGINAL</name></expr></argument>,
                             <argument><expr><name>flags</name></expr></argument>,
                             <argument><expr><name>NULL</name></expr></argument>,    <comment type="block">/* empty stack */</comment>
                             <argument><expr><name>targetObjects</name></expr></argument>,
                             <argument><expr><name>objects</name></expr></argument>,
                             <argument><expr><operator>&amp;</operator><name>depRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Check if deletion is allowed, and report about cascaded deletes.
     *
     * If there's exactly one object being deleted, report it the same way as
     * in performDeletion(), else we have to be vaguer.
     */</comment>
    <expr_stmt><expr><call><name>reportDependentObjects</name><argument_list>(<argument><expr><name>targetObjects</name></expr></argument>,
                           <argument><expr><name>behavior</name></expr></argument>,
                           <argument><expr><name>flags</name></expr></argument>,
                           <argument><expr><operator>(</operator><ternary><condition><expr><name><name>objects</name><operator>-&gt;</operator><name>numrefs</name></name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>objects</name><operator>-&gt;</operator><name>refs</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* do the deed */</comment>
    <expr_stmt><expr><call><name>deleteObjectsInList</name><argument_list>(<argument><expr><name>targetObjects</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>depRel</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* And clean up */</comment>
    <expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>targetObjects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<comment type="block">/*
 * Check type and class of the given object and rename it properly on GTM
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>doRename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><call><name>getObjectClass</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>OCLASS_CLASS</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type>        <name>relKind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * If we are here, a schema is being renamed, a sequence depends on it.
             * as sequences' global name use the schema name, this sequence
             * has also to be renamed on GTM.
             * An operation with GTM can just be done from a remote Coordinator.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_SEQUENCE</name> <operator>&amp;&amp;</operator>
                <name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Relation</name></type> <name>relseq</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>seqname</name> <init>= <expr><call><name>GetGlobalSeqName</name><argument_list>(<argument><expr><name>relseq</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>oldname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newseqname</name> <init>= <expr><call><name>GetGlobalSeqName</name><argument_list>(<argument><expr><name>relseq</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="block">/* We also need to rename this sequence on GTM, it has a global name ! */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>RenameSequenceGTM</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>, <argument><expr><name>newseqname</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"GTM error, could not rename sequence"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newseqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relseq</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <default>default:</default>
            <comment type="block">/* Nothing to do, this object has not to be renamed, end of the story... */</comment>
            <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * performRename: used to rename objects
 * on GTM depending on another object(s)
 */</comment>
<function><type><name>void</name></type>
<name>performRename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>depRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>targetObjects</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Check the dependencies on this object
     * And rename object dependent if necessary
     */</comment>

    <expr_stmt><expr><name>depRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>targetObjects</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>findDependentObjects</name><argument_list>(<argument><expr><name>object</name></expr></argument>,
                         <argument><expr><name>DEPFLAG_ORIGINAL</name></expr></argument>,
                         <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* XXX seems like flags are only used while
                               dropping objects */</comment>
                         <argument><expr><name>NULL</name></expr></argument>,      <comment type="block">/* empty stack */</comment>
                         <argument><expr><name>targetObjects</name></expr></argument>,
                         <argument><expr><name>NULL</name></expr></argument>,
                         <argument><expr><operator>&amp;</operator><name>depRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check Objects one by one to see if some of them have to be renamed on GTM */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>targetObjects</name><operator>-&gt;</operator><name>numrefs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>thisobj</name> <init>= <expr><name><name>targetObjects</name><operator>-&gt;</operator><name>refs</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>doRename</name><argument_list>(<argument><expr><name>thisobj</name></expr></argument>, <argument><expr><name>oldname</name></expr></argument>, <argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* And clean up */</comment>
    <expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>targetObjects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * findDependentObjects - find all objects that depend on 'object'
 *
 * For every object that depends on the starting object, acquire a deletion
 * lock on the object, add it to targetObjects (if not already there),
 * and recursively find objects that depend on it.  An object's dependencies
 * will be placed into targetObjects before the object itself; this means
 * that the finished list's order represents a safe deletion order.
 *
 * The caller must already have a deletion lock on 'object' itself,
 * but must not have added it to targetObjects.  (Note: there are corner
 * cases where we won't add the object either, and will also release the
 * caller-taken lock.  This is a bit ugly, but the API is set up this way
 * to allow easy rechecking of an object's liveness after we lock it.  See
 * notes within the function.)
 *
 * When dropping a whole object (subId = 0), we find dependencies for
 * its sub-objects too.
 *
 *    object: the object to add to targetObjects and find dependencies on
 *    objflags: flags to be ORed into the object's targetObjects entry
 *    flags: PERFORM_DELETION_xxx flags for the deletion operation as a whole
 *    stack: list of objects being visited in current recursion; topmost item
 *            is the object that we recursed from (NULL for external callers)
 *    targetObjects: list of objects that are scheduled to be deleted
 *    pendingObjects: list of other objects slated for destruction, but
 *            not necessarily in targetObjects yet (can be NULL if none)
 *    *depRel: already opened pg_depend relation
 *
 * Note: objflags describes the reason for visiting this particular object
 * at this time, and is not passed down when recursing.  The flags argument
 * is passed down, since it describes what we're doing overall.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>findDependentObjects</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>,
                     <parameter><decl><type><name>int</name></type> <name>objflags</name></decl></parameter>,
                     <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
                     <parameter><decl><type><name>ObjectAddressStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
                     <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>targetObjects</name></decl></parameter>,
                     <parameter><decl><type><specifier>const</specifier> <name>ObjectAddresses</name> <modifier>*</modifier></type><name>pendingObjects</name></decl></parameter>,
                     <parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>depRel</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>otherObject</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddressStack</name></type> <name>mystack</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddressExtra</name></type> <name>extra</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If the target object is already being visited in an outer recursion
     * level, just report the current objflags back to that level and exit.
     * This is needed to avoid infinite recursion in the face of circular
     * dependencies.
     *
     * The stack check alone would result in dependency loops being broken at
     * an arbitrary point, ie, the first member object of the loop to be
     * visited is the last one to be deleted.  This is obviously unworkable.
     * However, the check for internal dependency below guarantees that we
     * will not break a loop at an internal dependency: if we enter the loop
     * at an "owned" object we will switch and start at the "owning" object
     * instead.  We could probably hack something up to avoid breaking at an
     * auto dependency, too, if we had to.  However there are no known cases
     * where that would be necessary.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>stack_address_present_add_flags</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>objflags</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * It's also possible that the target object has already been completely
     * processed and put into targetObjects.  If so, again we just add the
     * specified objflags to its entry and return.
     *
     * (Note: in these early-exit cases we could release the caller-taken
     * lock, since the object is presumably now locked multiple times; but it
     * seems not worth the cycles.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>object_address_present_add_flags</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>objflags</name></expr></argument>, <argument><expr><name>targetObjects</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * The target object might be internally dependent on some other object
     * (its "owner"), and/or be a member of an extension (also considered its
     * owner).  If so, and if we aren't recursing from the owning object, we
     * have to transform this deletion request into a deletion request of the
     * owning object.  (We'll eventually recurse back to this object, but the
     * owning object has to be visited first so it will be deleted after.) The
     * way to find out about this is to scan the pg_depend entries that show
     * what this object depends on.
     */</comment>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_classid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_objid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
		<comment type="block">/* Consider only dependencies of this sub-object */</comment>
        <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>Anum_pg_depend_objsubid</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
                    <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectSubId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nkeys</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
	<block>{<block_content>
		<comment type="block">/* Consider dependencies of this object and any sub-objects it has */</comment>
        <expr_stmt><expr><name>nkeys</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><operator>*</operator><name>depRel</name></expr></argument>, <argument><expr><name>DependDependerIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>foundDep</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>otherObject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name><name>foundDep</name><operator>-&gt;</operator><name>refclassid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>otherObject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>foundDep</name><operator>-&gt;</operator><name>refobjid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>otherObject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name><name>foundDep</name><operator>-&gt;</operator><name>refobjsubid</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * When scanning dependencies of a whole object, we may find rows
		 * linking sub-objects of the object to the object itself.  (Normally,
		 * such a dependency is implicit, but we must make explicit ones in
		 * some cases involving partitioning.)  We must ignore such rows to
		 * avoid infinite recursion.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>otherObject</name><operator>.</operator><name>classId</name></name> <operator>==</operator> <name><name>object</name><operator>-&gt;</operator><name>classId</name></name> <operator>&amp;&amp;</operator>
			<name><name>otherObject</name><operator>.</operator><name>objectId</name></name> <operator>==</operator> <name><name>object</name><operator>-&gt;</operator><name>objectId</name></name> <operator>&amp;&amp;</operator>
			<name><name>object</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

        <switch>switch <condition>(<expr><name><name>foundDep</name><operator>-&gt;</operator><name>deptype</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>DEPENDENCY_NORMAL</name></expr>:</case>
            <case>case <expr><name>DEPENDENCY_AUTO</name></expr>:</case>
            <case>case <expr><name>DEPENDENCY_AUTO_EXTENSION</name></expr>:</case>
                <comment type="block">/* no problem */</comment>
                <break>break;</break>

            <case>case <expr><name>DEPENDENCY_EXTENSION</name></expr>:</case>

                <comment type="block">/*
                 * If told to, ignore EXTENSION dependencies altogether.  This
                 * flag is normally used to prevent dropping extensions during
                 * temporary-object cleanup, even if a temp object was created
                 * during an extension script.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>PERFORM_DELETION_SKIP_EXTENSIONS</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * If the other object is the extension currently being
                 * created/altered, ignore this dependency and continue with
                 * the deletion.  This allows dropping of an extension's
                 * objects within the extension's scripts, as well as corner
                 * cases such as dropping a transient object created within
                 * such a script.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>creating_extension</name> <operator>&amp;&amp;</operator>
                    <name><name>otherObject</name><operator>.</operator><name>classId</name></name> <operator>==</operator> <name>ExtensionRelationId</name> <operator>&amp;&amp;</operator>
                    <name><name>otherObject</name><operator>.</operator><name>objectId</name></name> <operator>==</operator> <name>CurrentExtensionObject</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>

                <comment type="block">/* Otherwise, treat this like an internal dependency */</comment>
                <comment type="block">/* FALL THRU */</comment>

            <case>case <expr><name>DEPENDENCY_INTERNAL</name></expr>:</case>
			<case>case <expr><name>DEPENDENCY_INTERNAL_AUTO</name></expr>:</case>

                <comment type="block">/*
                 * This object is part of the internal implementation of
                 * another object, or is part of the extension that is the
                 * other object.  We have three cases:
                 *
                 * 1. At the outermost recursion level, disallow the DROP. (We
                 * just ereport here, rather than proceeding, since no other
                 * dependencies are likely to be interesting.)    However, if
                 * the owning object is listed in pendingObjects, just release
                 * the caller's lock and return; we'll eventually complete the
                 * DROP when we reach that entry in the pending list.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>stack</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>otherObjDesc</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>pendingObjects</name> <operator>&amp;&amp;</operator>
                        <call><name>object_address_present</name><argument_list>(<argument><expr><operator>&amp;</operator><name>otherObject</name></expr></argument>, <argument><expr><name>pendingObjects</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* need to release caller's lock; see notes below */</comment>
                        <expr_stmt><expr><call><name>ReleaseDeletionLock</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return;</return>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>otherObjDesc</name> <operator>=</operator> <call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>otherObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DEPENDENT_OBJECTS_STILL_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop %s because %s requires it"</literal></expr></argument>,
                                    <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name>otherObjDesc</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You can drop %s instead."</literal></expr></argument>,
                                     <argument><expr><name>otherObjDesc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * 2. When recursing from the other end of this dependency,
                 * it's okay to continue with the deletion.  This holds when
                 * recursing from a whole object that includes the nominal
                 * other end as a component, too.  Since there can be more
                 * than one "owning" object, we have to allow matches that are
                 * more than one level down in the stack.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>stack_address_present_add_flags</name><argument_list>(<argument><expr><operator>&amp;</operator><name>otherObject</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * 3. Not all the owning objects have been visited, so
                 * transform this deletion request into a delete of this
                 * owning object.
                 *
				 * For INTERNAL_AUTO dependencies, we don't enforce this;
				 * in other words, we don't follow the links back to the
				 * owning object.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>foundDep</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_INTERNAL_AUTO</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>

				<comment type="block">/*
                 * First, release caller's lock on this object and get
                 * deletion lock on the owning object.  (We must release
                 * caller's lock to avoid deadlock against a concurrent
                 * deletion of the owning object.)
                 */</comment>
                <expr_stmt><expr><call><name>ReleaseDeletionLock</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>AcquireDeletionLock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>otherObject</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * The owning object might have been deleted while we waited
                 * to lock it; if so, neither it nor the current object are
                 * interesting anymore.  We test this by checking the
                 * pg_depend entry (see notes below).
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>systable_recheck_tuple</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ReleaseDeletionLock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>otherObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * Okay, recurse to the owning object instead of proceeding.
                 *
                 * We do not need to stack the current object; we want the
                 * traversal order to be as if the original reference had
                 * linked to the owning object instead of this one.
                 *
                 * The dependency type is a "reverse" dependency: we need to
                 * delete the owning object if this one is to be deleted, but
                 * this linkage is never a reason for an automatic deletion.
                 */</comment>
                <expr_stmt><expr><call><name>findDependentObjects</name><argument_list>(<argument><expr><operator>&amp;</operator><name>otherObject</name></expr></argument>,
                                     <argument><expr><name>DEPFLAG_REVERSE</name></expr></argument>,
                                     <argument><expr><name>flags</name></expr></argument>,
                                     <argument><expr><name>stack</name></expr></argument>,
                                     <argument><expr><name>targetObjects</name></expr></argument>,
                                     <argument><expr><name>pendingObjects</name></expr></argument>,
                                     <argument><expr><name>depRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* And we're done here. */</comment>
                <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>

            <case>case <expr><name>DEPENDENCY_PIN</name></expr>:</case>

                <comment type="block">/*
                 * Should not happen; PIN dependencies should have zeroes in
                 * the depender fields...
                 */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"incorrect use of PIN dependency with %s"</literal></expr></argument>,
                     <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized dependency type '%c' for %s"</literal></expr></argument>,
                     <argument><expr><name><name>foundDep</name><operator>-&gt;</operator><name>deptype</name></name></expr></argument>, <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now recurse to any dependent objects.  We must visit them first since
     * they have to be deleted before the current object.
     */</comment>
    <expr_stmt><expr><name><name>mystack</name><operator>.</operator><name>object</name></name> <operator>=</operator> <name>object</name></expr>;</expr_stmt>    <comment type="block">/* set up a new stack level */</comment>
    <expr_stmt><expr><name><name>mystack</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>objflags</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mystack</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>stack</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_refclassid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_refobjid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>Anum_pg_depend_refobjsubid</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
                    <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectSubId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nkeys</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>nkeys</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><operator>*</operator><name>depRel</name></expr></argument>, <argument><expr><name>DependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>foundDep</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>subflags</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>otherObject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name><name>foundDep</name><operator>-&gt;</operator><name>classid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>otherObject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>foundDep</name><operator>-&gt;</operator><name>objid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>otherObject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name><name>foundDep</name><operator>-&gt;</operator><name>objsubid</name></name></expr>;</expr_stmt>

        <comment type="block">/*
		 * If what we found is a sub-object of the current object, just ignore
		 * it.  (Normally, such a dependency is implicit, but we must make
		 * explicit ones in some cases involving partitioning.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>otherObject</name><operator>.</operator><name>classId</name></name> <operator>==</operator> <name><name>object</name><operator>-&gt;</operator><name>classId</name></name> <operator>&amp;&amp;</operator>
			<name><name>otherObject</name><operator>.</operator><name>objectId</name></name> <operator>==</operator> <name><name>object</name><operator>-&gt;</operator><name>objectId</name></name> <operator>&amp;&amp;</operator>
			<name><name>object</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
         * Must lock the dependent object before recursing to it.
         */</comment>
        <expr_stmt><expr><call><name>AcquireDeletionLock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>otherObject</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * The dependent object might have been deleted while we waited to
         * lock it; if so, we don't need to do anything more with it. We can
         * test this cheaply and independently of the object's type by seeing
         * if the pg_depend tuple we are looking at is still live. (If the
         * object got deleted, the tuple would have been deleted too.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>systable_recheck_tuple</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* release the now-useless lock */</comment>
            <expr_stmt><expr><call><name>ReleaseDeletionLock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>otherObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* and continue scanning for dependencies */</comment>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Recurse, passing objflags indicating the dependency type */</comment>
        <switch>switch <condition>(<expr><name><name>foundDep</name><operator>-&gt;</operator><name>deptype</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>DEPENDENCY_NORMAL</name></expr>:</case>
                <expr_stmt><expr><name>subflags</name> <operator>=</operator> <name>DEPFLAG_NORMAL</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>DEPENDENCY_AUTO</name></expr>:</case>
            <case>case <expr><name>DEPENDENCY_AUTO_EXTENSION</name></expr>:</case>
                <expr_stmt><expr><name>subflags</name> <operator>=</operator> <name>DEPFLAG_AUTO</name></expr>;</expr_stmt>
                <break>break;</break>
			<case>case <expr><name>DEPENDENCY_INTERNAL_AUTO</name></expr>:</case>
            <case>case <expr><name>DEPENDENCY_INTERNAL</name></expr>:</case>
                <expr_stmt><expr><name>subflags</name> <operator>=</operator> <name>DEPFLAG_INTERNAL</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>DEPENDENCY_EXTENSION</name></expr>:</case>
                <expr_stmt><expr><name>subflags</name> <operator>=</operator> <name>DEPFLAG_EXTENSION</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>DEPENDENCY_PIN</name></expr>:</case>

                <comment type="block">/*
                 * For a PIN dependency we just ereport immediately; there
                 * won't be any others to report.
                 */</comment>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DEPENDENT_OBJECTS_STILL_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop %s because it is required by the database system"</literal></expr></argument>,
                                <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>subflags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <comment type="block">/* keep compiler quiet */</comment>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized dependency type '%c' for %s"</literal></expr></argument>,
                     <argument><expr><name><name>foundDep</name><operator>-&gt;</operator><name>deptype</name></name></expr></argument>, <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>subflags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <comment type="block">/* keep compiler quiet */</comment>
                <break>break;</break>
        </block_content>}</block></switch>

        <expr_stmt><expr><call><name>findDependentObjects</name><argument_list>(<argument><expr><operator>&amp;</operator><name>otherObject</name></expr></argument>,
                             <argument><expr><name>subflags</name></expr></argument>,
                             <argument><expr><name>flags</name></expr></argument>,
                             <argument><expr><operator>&amp;</operator><name>mystack</name></expr></argument>,
                             <argument><expr><name>targetObjects</name></expr></argument>,
                             <argument><expr><name>pendingObjects</name></expr></argument>,
                             <argument><expr><name>depRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Finally, we can add the target object to targetObjects.  Be careful to
     * include any flags that were passed back down to us from inner recursion
     * levels.
     */</comment>
    <expr_stmt><expr><name><name>extra</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name><name>mystack</name><operator>.</operator><name>flags</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>stack</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>extra</name><operator>.</operator><name>dependee</name></name> <operator>=</operator> <operator>*</operator><name><name>stack</name><operator>-&gt;</operator><name>object</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extra</name><operator>.</operator><name>dependee</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>extra</name><operator>.</operator><name>dependee</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>add_exact_object_address_extra</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extra</name></expr></argument>, <argument><expr><name>targetObjects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * reportDependentObjects - report about dependencies, and fail if RESTRICT
 *
 * Tell the user about dependent objects that we are going to delete
 * (or would need to delete, but are prevented by RESTRICT mode);
 * then error out if there are any and it's not CASCADE mode.
 *
 *    targetObjects: list of objects that are scheduled to be deleted
 *    behavior: RESTRICT or CASCADE
 *    flags: other flags for the deletion operation
 *    origObject: base object of deletion, or NULL if not available
 *        (the latter case occurs in DROP OWNED)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reportDependentObjects</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddresses</name> <modifier>*</modifier></type><name>targetObjects</name></decl></parameter>,
                       <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>,
                       <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>origObject</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>msglevel</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>PERFORM_DELETION_QUIETLY</name><operator>)</operator></expr> ?</condition><then> <expr><name>DEBUG2</name></expr> </then><else>: <expr><name>NOTICE</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>ok</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>clientdetail</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>logdetail</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numReportedClient</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numNotReportedClient</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If no error is to be thrown, and the msglevel is too low to be shown to
     * either client or server log, there's no need to do any of the work.
     *
     * Note: this code doesn't know all there is to be known about elog
     * levels, but it works for NOTICE and DEBUG2, which are the only values
     * msglevel can currently have.  We also assume we are running in a normal
     * operating environment.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>behavior</name> <operator>==</operator> <name>DROP_CASCADE</name> <operator>&amp;&amp;</operator>
        <name>msglevel</name> <operator>&lt;</operator> <name>client_min_messages</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>msglevel</name> <operator>&lt;</operator> <name>log_min_messages</name> <operator>||</operator> <name>log_min_messages</name> <operator>==</operator> <name>LOG</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We limit the number of dependencies reported to the client to
     * MAX_REPORTED_DEPS, since client software may not deal well with
     * enormous error strings.  The server log always gets a full report.
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_REPORTED_DEPS</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>clientdetail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logdetail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We process the list back to front (ie, in dependency order not deletion
     * order), since this makes for a more understandable display.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>targetObjects</name><operator>-&gt;</operator><name>numrefs</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><operator>&amp;</operator><name><name>targetObjects</name><operator>-&gt;</operator><name>refs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>ObjectAddressExtra</name> <modifier>*</modifier></type><name>extra</name> <init>= <expr><operator>&amp;</operator><name><name>targetObjects</name><operator>-&gt;</operator><name>extras</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>objDesc</name></decl>;</decl_stmt>

        <comment type="block">/* Ignore the original deletion target(s) */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>extra</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DEPFLAG_ORIGINAL</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>objDesc</name> <operator>=</operator> <call><name>getObjectDescription</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If, at any stage of the recursive search, we reached the object via
         * an AUTO, INTERNAL, or EXTENSION dependency, then it's okay to
         * delete it even in RESTRICT mode.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>extra</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>DEPFLAG_AUTO</name> <operator>|</operator>
                            <name>DEPFLAG_INTERNAL</name> <operator>|</operator>
                            <name>DEPFLAG_EXTENSION</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * auto-cascades are reported at DEBUG2, not msglevel.  We don't
             * try to combine them with the regular message because the
             * results are too confusing when client_min_messages and
             * log_min_messages are different.
             */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"drop auto-cascades to %s"</literal></expr></argument>,
                            <argument><expr><name>objDesc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>behavior</name> <operator>==</operator> <name>DROP_RESTRICT</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>otherDesc</name> <init>= <expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extra</name><operator>-&gt;</operator><name>dependee</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>numReportedClient</name> <operator>&lt;</operator> <name>MAX_REPORTED_DEPS</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* separate entries with a newline */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>clientdetail</name><operator>.</operator><name>len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>clientdetail</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>clientdetail</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s depends on %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>objDesc</name></expr></argument>, <argument><expr><name>otherDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>numReportedClient</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>numNotReportedClient</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <comment type="block">/* separate entries with a newline */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>logdetail</name><operator>.</operator><name>len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logdetail</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logdetail</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s depends on %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>objDesc</name></expr></argument>, <argument><expr><name>otherDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>otherDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>numReportedClient</name> <operator>&lt;</operator> <name>MAX_REPORTED_DEPS</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* separate entries with a newline */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>clientdetail</name><operator>.</operator><name>len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>clientdetail</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>clientdetail</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"drop cascades to %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>objDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>numReportedClient</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>numNotReportedClient</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <comment type="block">/* separate entries with a newline */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>logdetail</name><operator>.</operator><name>len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logdetail</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logdetail</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"drop cascades to %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>objDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>objDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>numNotReportedClient</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>clientdetail</name></expr></argument>, <argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"\nand %d other object "</literal>
                                                 <literal type="string">"(see server log for list)"</literal></expr></argument>,
                                                 <argument><expr><literal type="string">"\nand %d other objects "</literal>
                                                 <literal type="string">"(see server log for list)"</literal></expr></argument>,
                                                 <argument><expr><name>numNotReportedClient</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>numNotReportedClient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>origObject</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DEPENDENT_OBJECTS_STILL_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop %s because other objects depend on it"</literal></expr></argument>,
                            <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><name>origObject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>clientdetail</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail_log</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>logdetail</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use DROP ... CASCADE to drop the dependent objects too."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DEPENDENT_OBJECTS_STILL_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop desired object(s) because other objects depend on them"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>clientdetail</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail_log</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>logdetail</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use DROP ... CASCADE to drop the dependent objects too."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>numReportedClient</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>msglevel</name></expr></argument>,
        <comment type="block">/* translator: %d always has a value larger than 1 */</comment>
                <argument><expr><operator>(</operator><call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"drop cascades to %d other object"</literal></expr></argument>,
                               <argument><expr><literal type="string">"drop cascades to %d other objects"</literal></expr></argument>,
                               <argument><expr><name>numReportedClient</name> <operator>+</operator> <name>numNotReportedClient</name></expr></argument>,
                               <argument><expr><name>numReportedClient</name> <operator>+</operator> <name>numNotReportedClient</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>clientdetail</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail_log</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>logdetail</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>numReportedClient</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* we just use the single item as-is */</comment>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>msglevel</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>clientdetail</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>clientdetail</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>logdetail</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * deleteOneObject: delete a single object for performDeletion.
 *
 * *depRel is the already-open pg_depend relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deleteOneObject</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>, <parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>depRel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>

    <comment type="block">/* DROP hook of the objects being removed */</comment>
    <expr_stmt><expr><call><name>InvokeObjectDropHookArg</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>classId</name></name></expr></argument>, <argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>,
                            <argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectSubId</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Close depRel if we are doing a drop concurrently.  The object deletion
     * subroutine will commit the current transaction, so we can't keep the
     * relation open across doDeletion().
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>PERFORM_DELETION_CONCURRENTLY</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><operator>*</operator><name>depRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Delete the object itself, in an object-type-dependent way.
     *
     * We used to do this after removing the outgoing dependency links, but it
     * seems just as reasonable to do it beforehand.  In the concurrent case
     * we *must* do it in this order, because we can't make any transactional
     * updates before calling doDeletion() --- they'd get committed right
     * away, which is not cool if the deletion then fails.
     */</comment>
    <expr_stmt><expr><call><name>doDeletion</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Reopen depRel if we closed it above
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>PERFORM_DELETION_CONCURRENTLY</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>depRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Now remove any pg_depend records that link from this object to others.
     * (Any records linking to this object should be gone already.)
     *
     * When dropping a whole object (subId = 0), remove all pg_depend records
     * for its sub-objects too.
     */</comment>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_classid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_objid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>Anum_pg_depend_objsubid</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
                    <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectSubId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nkeys</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>nkeys</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><operator>*</operator><name>depRel</name></expr></argument>, <argument><expr><name>DependDependerIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><operator>*</operator><name>depRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Delete shared dependency references related to this object.  Again, if
     * subId = 0, remove records for sub-objects too.
     */</comment>
    <expr_stmt><expr><call><name>deleteSharedDependencyRecordsFor</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>classId</name></name></expr></argument>, <argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>,
                                     <argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectSubId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <comment type="block">/*
     * Delete any comments, security labels, or initial privileges associated
     * with this object.  (This is a convenient place to do these things,
     * rather than having every object type know to do it.)
     */</comment>
    <expr_stmt><expr><call><name>DeleteComments</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>, <argument><expr><name><name>object</name><operator>-&gt;</operator><name>classId</name></name></expr></argument>, <argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectSubId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DeleteSecurityLabel</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DeleteInitPrivs</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <expr_stmt><expr><call><name>DeleteCryptPolicy</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * CommandCounterIncrement here to ensure that preceding changes are all
     * visible to the next deletion step.
     */</comment>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * And we're done!
     */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * doDeletion: actually delete a single object
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>doDeletion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <switch>switch <condition>(<expr><call><name>getObjectClass</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>OCLASS_CLASS</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name></type>        <name>relKind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
					<name>relKind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>bool</name></type>        <name>concurrent</name> <init>= <expr><operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>PERFORM_DELETION_CONCURRENTLY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>index_drop</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>concurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>RemoveAttributeById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>,
                                            <argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectSubId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>heap_drop_with_catalog</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></else></if_stmt>

                <comment type="block">/*
                 * for a sequence, in addition to dropping the heap, also
                 * delete pg_sequence tuple
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>DeleteSequenceTuple</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
                <comment type="block">/*
                 * Do not do extra process if this session is connected to a remote
                 * Coordinator.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * This session is connected directly to application, so extra
                 * process related to remote nodes and GTM is needed.
                 */</comment>
                <switch>switch <condition>(<expr><name>relKind</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>
                        <comment type="block">/*
                         * Drop the sequence on GTM.
                         * Sequence is dropped on GTM by a remote Coordinator only
                         * for a non temporary sequence.
                         */</comment>
                        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/*
                             * The sequence has already been removed from Coordinator,
                             * finish the stuff on GTM too
                             */</comment>

                            <decl_stmt><decl><type><name>Relation</name></type> <name>relseq</name></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>seqname</name></decl>;</decl_stmt>
                            <comment type="block">/*
                             * A relation is opened to get the schema and database name as
                             * such data is not available before when dropping a function.
                             */</comment>
                            <expr_stmt><expr><name>relseq</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>seqname</name> <operator>=</operator> <call><name>GetGlobalSeqName</name><argument_list>(<argument><expr><name>relseq</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>            
                            <expr_stmt><expr><call><name>RegisterSeqDrop</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>, <argument><expr><name>GTM_SEQ_FULL_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                            <expr_stmt><expr><call><name>DropSequenceGTM</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>, <argument><expr><name>GTM_SEQ_FULL_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <comment type="block">/* Then close the relation opened previously */</comment>
                            <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relseq</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <break>break;</break>
                    <case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
                    <case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
                        <break>break;</break>
                    <default>default:</default>
                        <break>break;</break>
                </block_content>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>OCLASS_PROC</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveFunctionById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_TYPE</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveTypeById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_CAST</name></expr>:</case>
            <expr_stmt><expr><call><name>DropCastById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_COLLATION</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveCollationById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_CONSTRAINT</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveConstraintById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_CONVERSION</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveConversionById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_DEFAULT</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveAttrDefaultById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_LANGUAGE</name></expr>:</case>
            <expr_stmt><expr><call><name>DropProceduralLanguageById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_LARGEOBJECT</name></expr>:</case>
            <expr_stmt><expr><call><name>LargeObjectDrop</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_OPERATOR</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveOperatorById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_OPCLASS</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveOpClassById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_OPFAMILY</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveOpFamilyById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_AM</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveAccessMethodById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_AMOP</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveAmOpEntryById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_AMPROC</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveAmProcEntryById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_REWRITE</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveRewriteRuleById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_TRIGGER</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveTriggerById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_SCHEMA</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveSchemaById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_STATISTIC_EXT</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveStatisticsById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_TSPARSER</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveTSParserById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_TSDICT</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveTSDictionaryById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_TSTEMPLATE</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveTSTemplateById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_TSCONFIG</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveTSConfigurationById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

            <comment type="block">/*
             * OCLASS_ROLE, OCLASS_DATABASE, OCLASS_TBLSPACE intentionally not
             * handled here
             */</comment>

        <case>case <expr><name>OCLASS_FDW</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveForeignDataWrapperById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_FOREIGN_SERVER</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveForeignServerById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_USER_MAPPING</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveUserMappingById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_DEFACL</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveDefaultACLById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <case>case <expr><name>OCLASS_PGXC_CLASS</name></expr>:</case>
            <expr_stmt><expr><call><name>RemovePgxcClass</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <case>case <expr><name>OCLASS_PG_PARTITION_INTERVAL</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveIntervalPartition</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <case>case <expr><name>OCLASS_EXTENSION</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveExtensionById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_EVENT_TRIGGER</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveEventTriggerById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_POLICY</name></expr>:</case>
            <expr_stmt><expr><call><name>RemovePolicyById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_PUBLICATION</name></expr>:</case>
            <expr_stmt><expr><call><name>RemovePublicationById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_PUBLICATION_REL</name></expr>:</case>
            <expr_stmt><expr><call><name>RemovePublicationRelById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OCLASS_TRANSFORM</name></expr>:</case>
            <expr_stmt><expr><call><name>DropTransformById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
        <case>case <expr><name>OCLASS_AUDIT_STMT</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveStmtAuditById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OCLASS_AUDIT_USER</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveUserAuditById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OCLASS_AUDIT_OBJ</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveObjectAuditById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OCLASS_AUDIT_OBJDEFAULT</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveObjectDefaultAuditById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
        <case>case <expr><name>OCLASS_PUBLICATION_SHARD</name></expr>:</case>
            <expr_stmt><expr><call><name>RemovePublicationShardById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OCLASS_SUBSCRIPTION_SHARD</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveSubscriptionShardById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OCLASS_SUBSCRIPTION_TABLE</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoveSubscriptionTableById</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/*
             * These global object types are not supported here.
             */</comment>
        <case>case <expr><name>OCLASS_ROLE</name></expr>:</case>
        <case>case <expr><name>OCLASS_DATABASE</name></expr>:</case>
        <case>case <expr><name>OCLASS_TBLSPACE</name></expr>:</case>
        <case>case <expr><name>OCLASS_SUBSCRIPTION</name></expr>:</case>
        <case>case <expr><name>OCLASS_PGXC_NODE</name></expr>:</case>
        <case>case <expr><name>OCLASS_PGXC_GROUP</name></expr>:</case>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"global objects cannot be deleted by doDeletion"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

            <comment type="block">/*
             * There's intentionally no default: case here; we want the
             * compiler to warn if a new OCLASS hasn't been handled above.
             */</comment>

    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * AcquireDeletionLock - acquire a suitable lock for deleting an object
 *
 * We use LockRelation for relations, LockDatabaseObject for everything
 * else.  Note that dependency.c is not concerned with deleting any kind of
 * shared-across-databases object, so we have no need for LockSharedObject.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AcquireDeletionLock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>classId</name></name> <operator>==</operator> <name>RelationRelationId</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * In DROP INDEX CONCURRENTLY, take only ShareUpdateExclusiveLock on
         * the index for the moment.  index_drop() will promote the lock once
         * it's safe to do so.  In all other cases we need full exclusive
         * lock.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>PERFORM_DELETION_CONCURRENTLY</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* assume we should lock the whole object not a sub-object */</comment>
        <expr_stmt><expr><call><name>LockDatabaseObject</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>classId</name></name></expr></argument>, <argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ReleaseDeletionLock - release an object deletion lock
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReleaseDeletionLock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>classId</name></name> <operator>==</operator> <name>RelationRelationId</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <comment type="block">/* assume we should lock the whole object not a sub-object */</comment>
        <expr_stmt><expr><call><name>UnlockDatabaseObject</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>classId</name></name></expr></argument>, <argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                             <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * recordDependencyOnExpr - find expression dependencies
 *
 * This is used to find the dependencies of rules, constraint expressions,
 * etc.
 *
 * Given an expression or query in node-tree form, find all the objects
 * it refers to (tables, columns, operators, functions, etc).  Record
 * a dependency of the specified type from the given depender object
 * to each object mentioned in the expression.
 *
 * rtable is the rangetable to be used to interpret Vars with varlevelsup=0.
 * It can be NIL if no such variables are expected.
 */</comment>
<function><type><name>void</name></type>
<name>recordDependencyOnExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>depender</name></decl></parameter>,
                       <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>,
                       <parameter><decl><type><name>DependencyType</name></type> <name>behavior</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>find_expr_references_context</name></type> <name>context</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>addrs</name></name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set up interpretation for Vars at varlevelsup = 0 */</comment>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>rtables</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Scan the expression tree for referenceable objects */</comment>
    <expr_stmt><expr><call><name>find_expr_references_walker</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Remove any duplicates */</comment>
    <expr_stmt><expr><call><name>eliminate_duplicate_dependencies</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* And record 'em */</comment>
    <expr_stmt><expr><call><name>recordMultipleDependencies</name><argument_list>(<argument><expr><name>depender</name></expr></argument>,
                               <argument><expr><name><name>context</name><operator>.</operator><name>addrs</name><operator>-&gt;</operator><name>refs</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>addrs</name><operator>-&gt;</operator><name>numrefs</name></name></expr></argument>,
                               <argument><expr><name>behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * recordDependencyOnSingleRelExpr - find expression dependencies
 *
 * As above, but only one relation is expected to be referenced (with
 * varno = 1 and varlevelsup = 0).  Pass the relation OID instead of a
 * range table.  An additional frammish is that dependencies on that
 * relation's component columns will be marked with 'self_behavior',
 * whereas 'behavior' is used for everything else; also, if 'reverse_self'
 * is true, those dependencies are reversed so that the columns are made
 * to depend on the table not vice versa.
 *
 * NOTE: the caller should ensure that a whole-table dependency on the
 * specified relation is created separately, if one is needed.  In particular,
 * a whole-row Var "relation.*" will not cause this routine to emit any
 * dependency item.  This is appropriate behavior for subexpressions of an
 * ordinary query, so other cases need to cope as necessary.
 */</comment>
<function><type><name>void</name></type>
<name>recordDependencyOnSingleRelExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>depender</name></decl></parameter>,
                                <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relId</name></decl></parameter>,
                                <parameter><decl><type><name>DependencyType</name></type> <name>behavior</name></decl></parameter>,
                                <parameter><decl><type><name>DependencyType</name></type> <name>self_behavior</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>reverse_self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>find_expr_references_context</name></type> <name>context</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name></type> <name>rte</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>addrs</name></name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We gin up a rather bogus rangetable list to handle Vars */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rte</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rte</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_RangeTblEntry</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rte</name><operator>.</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_RELATION</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rte</name><operator>.</operator><name>relid</name></name> <operator>=</operator> <name>relId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rte</name><operator>.</operator><name>relkind</name></name> <operator>=</operator> <name>RELKIND_RELATION</name></expr>;</expr_stmt> <comment type="block">/* no need for exactness here */</comment>

    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>rtables</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rte</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Scan the expression tree for referenceable objects */</comment>
    <expr_stmt><expr><call><name>find_expr_references_walker</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Remove any duplicates */</comment>
    <expr_stmt><expr><call><name>eliminate_duplicate_dependencies</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Separate self-dependencies if necessary */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>behavior</name> <operator>!=</operator> <name>self_behavior</name> <operator>||</operator> <name>reverse_self</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>context</name><operator>.</operator><name>addrs</name><operator>-&gt;</operator><name>numrefs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>self_addrs</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>outobj</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>oldref</name></decl>,
                    <decl><type ref="prev"/><name>outrefs</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>self_addrs</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>outobj</name> <operator>=</operator> <name><name>context</name><operator>.</operator><name>addrs</name><operator>-&gt;</operator><name>refs</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>outrefs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>oldref</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>oldref</name> <operator>&lt;</operator> <name><name>context</name><operator>.</operator><name>addrs</name><operator>-&gt;</operator><name>numrefs</name></name></expr>;</condition> <incr><expr><name>oldref</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>thisobj</name> <init>= <expr><name><name>context</name><operator>.</operator><name>addrs</name><operator>-&gt;</operator><name>refs</name></name> <operator>+</operator> <name>oldref</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>thisobj</name><operator>-&gt;</operator><name>classId</name></name> <operator>==</operator> <name>RelationRelationId</name> <operator>&amp;&amp;</operator>
                <name><name>thisobj</name><operator>-&gt;</operator><name>objectId</name></name> <operator>==</operator> <name>relId</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Move this ref into self_addrs */</comment>
                <expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><name>thisobj</name></expr></argument>, <argument><expr><name>self_addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Keep it in context.addrs */</comment>
                <expr_stmt><expr><operator>*</operator><name>outobj</name> <operator>=</operator> <operator>*</operator><name>thisobj</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>outobj</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>outrefs</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>context</name><operator>.</operator><name>addrs</name><operator>-&gt;</operator><name>numrefs</name></name> <operator>=</operator> <name>outrefs</name></expr>;</expr_stmt>

		<comment type="block">/* Record the self-dependencies with the appropriate direction */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reverse_self</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>recordMultipleDependencies</name><argument_list>(<argument><expr><name>depender</name></expr></argument>,
                                       <argument><expr><name><name>self_addrs</name><operator>-&gt;</operator><name>refs</name></name></expr></argument>, <argument><expr><name><name>self_addrs</name><operator>-&gt;</operator><name>numrefs</name></name></expr></argument>,
                                       <argument><expr><name>self_behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Can't use recordMultipleDependencies, so do it the hard way */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>selfref</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>selfref</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>selfref</name> <operator>&lt;</operator> <name><name>self_addrs</name><operator>-&gt;</operator><name>numrefs</name></name></expr>;</condition> <incr><expr><name>selfref</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>thisobj</name> <init>= <expr><name><name>self_addrs</name><operator>-&gt;</operator><name>refs</name></name> <operator>+</operator> <name>selfref</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><name>thisobj</name></expr></argument>, <argument><expr><name>depender</name></expr></argument>, <argument><expr><name>self_behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>self_addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Record the external dependencies */</comment>
    <expr_stmt><expr><call><name>recordMultipleDependencies</name><argument_list>(<argument><expr><name>depender</name></expr></argument>,
                               <argument><expr><name><name>context</name><operator>.</operator><name>addrs</name><operator>-&gt;</operator><name>refs</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>addrs</name><operator>-&gt;</operator><name>numrefs</name></name></expr></argument>,
                               <argument><expr><name>behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Recursively search an expression tree for object references.
 *
 * Note: we avoid creating references to columns of tables that participate
 * in an SQL JOIN construct, but are not actually used anywhere in the query.
 * To do so, we do not scan the joinaliasvars list of a join RTE while
 * scanning the query rangetable, but instead scan each individual entry
 * of the alias list when we find a reference to it.
 *
 * Note: in many cases we do not need to create dependencies on the datatypes
 * involved in an expression, because we'll have an indirect dependency via
 * some other object.  For instance Var nodes depend on a column which depends
 * on the datatype, and OpExpr nodes depend on the operator which depends on
 * the datatype.  However we do need a type dependency if there is no such
 * indirect dependency, as for example in Const and CoerceToDomain nodes.
 *
 * Similarly, we don't need to create dependencies on collations except where
 * the collation is being freshly introduced to the expression.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>find_expr_references_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                            <parameter><decl><type><name>find_expr_references_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Var</name>           <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>rtable</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

        <comment type="block">/* Find matching rtable entry, or complain if not found */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>&gt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>rtables</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid varlevelsup %d"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>rtable</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>rtables</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid varno %d"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * A whole-row Var references no specific columns, so adds no new
         * dependency.  (We assume that there is a whole-table dependency
         * arising from each underlying rangetable entry.  While we could
         * record such a dependency when finding a whole-row Var that
         * references a relation directly, it's quite unclear how to extend
         * that to whole-row Vars for JOINs, so it seems better to leave the
         * responsibility with the range table.  Note that this poses some
         * risks for identifying dependencies of stand-alone expressions:
         * whole-table references may need to be created separately.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* If it's a plain relation, reference this column */</comment>
            <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_CLASS</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>,
                               <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Scan join output column to add references to join inputs */</comment>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>save_rtables</name></decl>;</decl_stmt>

            <comment type="block">/* We must make the context appropriate for join's level */</comment>
            <expr_stmt><expr><name>save_rtables</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>rtables</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>rtables</name></name> <operator>=</operator> <call><name>list_copy_tail</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>rtables</name></name></expr></argument>,
                                              <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
                <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid varattno %d"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>find_expr_references_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>,
                                                          <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>rtables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>rtables</name></name> <operator>=</operator> <name>save_rtables</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Const</name>       <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>objoid</name></decl>;</decl_stmt>

        <comment type="block">/* A constant must depend on the constant's datatype */</comment>
        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_TYPE</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We must also depend on the constant's collation: it could be
         * different from the datatype's, if a CollateExpr was const-folded to
         * a simple constant.  However we can save work in the most common
         * case where the collation is "default", since we know that's pinned.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constcollid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <name><name>con</name><operator>-&gt;</operator><name>constcollid</name></name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_COLLATION</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>constcollid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                               <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * If it's a regclass or similar literal referring to an existing
         * object, add a reference to that object.  (Currently, only the
         * regclass and regconfig cases have any likely use, but we may as
         * well handle all the OID-alias datatypes consistently.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
        <block>{<block_content>
            <switch>switch <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>consttype</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>REGPROCOID</name></expr>:</case>
                <case>case <expr><name>REGPROCEDUREOID</name></expr>:</case>
                    <expr_stmt><expr><name>objoid</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>,
                                              <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_PROC</name></expr></argument>, <argument><expr><name>objoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <break>break;</break>
                <case>case <expr><name>REGOPEROID</name></expr>:</case>
                <case>case <expr><name>REGOPERATOROID</name></expr>:</case>
                    <expr_stmt><expr><name>objoid</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>,
                                              <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_OPERATOR</name></expr></argument>, <argument><expr><name>objoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <break>break;</break>
                <case>case <expr><name>REGCLASSOID</name></expr>:</case>
                    <expr_stmt><expr><name>objoid</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>,
                                              <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_CLASS</name></expr></argument>, <argument><expr><name>objoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <break>break;</break>
                <case>case <expr><name>REGTYPEOID</name></expr>:</case>
                    <expr_stmt><expr><name>objoid</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>,
                                              <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_TYPE</name></expr></argument>, <argument><expr><name>objoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <break>break;</break>
                <case>case <expr><name>REGCONFIGOID</name></expr>:</case>
                    <expr_stmt><expr><name>objoid</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>TSCONFIGOID</name></expr></argument>,
                                              <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_TSCONFIG</name></expr></argument>, <argument><expr><name>objoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <break>break;</break>
                <case>case <expr><name>REGDICTIONARYOID</name></expr>:</case>
                    <expr_stmt><expr><name>objoid</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>TSDICTOID</name></expr></argument>,
                                              <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_TSDICT</name></expr></argument>, <argument><expr><name>objoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <break>break;</break>

                <case>case <expr><name>REGNAMESPACEOID</name></expr>:</case>
                    <expr_stmt><expr><name>objoid</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>NAMESPACEOID</name></expr></argument>,
                                              <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_SCHEMA</name></expr></argument>, <argument><expr><name>objoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <break>break;</break>

                    <comment type="block">/*
                     * Dependencies for regrole should be shared among all
                     * databases, so explicitly inhibit to have dependencies.
                     */</comment>
                <case>case <expr><name>REGROLEOID</name></expr>:</case>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constant of the type %s cannot be used here"</literal></expr></argument>,
                                    <argument><expr><literal type="string">"regrole"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Param</name>       <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* A parameter must depend on the parameter's datatype */</comment>
        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_TYPE</name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* and its collation, just as for Consts */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramcollid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <name><name>param</name><operator>-&gt;</operator><name>paramcollid</name></name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_COLLATION</name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramcollid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                               <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>funcexpr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_PROC</name></expr></argument>, <argument><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* fall through to examine arguments */</comment>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>OpExpr</name>       <modifier>*</modifier></type><name>opexpr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_OPERATOR</name></expr></argument>, <argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* fall through to examine arguments */</comment>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>DistinctExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>DistinctExpr</name> <modifier>*</modifier></type><name>distinctexpr</name> <init>= <expr><operator>(</operator><name>DistinctExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_OPERATOR</name></expr></argument>, <argument><expr><name><name>distinctexpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* fall through to examine arguments */</comment>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NullIfExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>NullIfExpr</name> <modifier>*</modifier></type><name>nullifexpr</name> <init>= <expr><operator>(</operator><name>NullIfExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_OPERATOR</name></expr></argument>, <argument><expr><name><name>nullifexpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* fall through to examine arguments */</comment>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>opexpr</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_OPERATOR</name></expr></argument>, <argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* fall through to examine arguments */</comment>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Aggref</name>       <modifier>*</modifier></type><name>aggref</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_PROC</name></expr></argument>, <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* fall through to examine arguments */</comment>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>wfunc</name> <init>= <expr><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_PROC</name></expr></argument>, <argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winfnoid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* fall through to examine arguments */</comment>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Extra work needed here if we ever need this case */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"already-planned subqueries not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>relab</name> <init>= <expr><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* since there is no function dependency, need to depend on type */</comment>
        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_TYPE</name></expr></argument>, <argument><expr><name><name>relab</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* the collation might not be referenced anywhere else, either */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>relab</name><operator>-&gt;</operator><name>resultcollid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <name><name>relab</name><operator>-&gt;</operator><name>resultcollid</name></name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_COLLATION</name></expr></argument>, <argument><expr><name><name>relab</name><operator>-&gt;</operator><name>resultcollid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                               <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CoerceViaIO</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>iocoerce</name> <init>= <expr><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* since there is no exposed function, need to depend on type */</comment>
        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_TYPE</name></expr></argument>, <argument><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ArrayCoerceExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>acoerce</name> <init>= <expr><operator>(</operator><name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>acoerce</name><operator>-&gt;</operator><name>elemfuncid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_PROC</name></expr></argument>, <argument><expr><name><name>acoerce</name><operator>-&gt;</operator><name>elemfuncid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                               <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_TYPE</name></expr></argument>, <argument><expr><name><name>acoerce</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* fall through to examine arguments */</comment>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ConvertRowtypeExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>cvt</name> <init>= <expr><operator>(</operator><name>ConvertRowtypeExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* since there is no function dependency, need to depend on type */</comment>
        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_TYPE</name></expr></argument>, <argument><expr><name><name>cvt</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>coll</name> <init>= <expr><operator>(</operator><name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_COLLATION</name></expr></argument>, <argument><expr><name><name>coll</name><operator>-&gt;</operator><name>collOid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>rowexpr</name> <init>= <expr><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_TYPE</name></expr></argument>, <argument><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_typeid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RowCompareExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>rcexpr</name> <init>= <expr><operator>(</operator><name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>rcexpr-&gt;opnos</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_OPERATOR</name></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                               <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>rcexpr-&gt;opfamilies</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_OPFAMILY</name></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                               <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <comment type="block">/* fall through to examine arguments */</comment>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_TYPE</name></expr></argument>, <argument><expr><name><name>cd</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NextValueExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>NextValueExpr</name> <modifier>*</modifier></type><name>nve</name> <init>= <expr><operator>(</operator><name>NextValueExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_CLASS</name></expr></argument>, <argument><expr><name><name>nve</name><operator>-&gt;</operator><name>seqid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OnConflictExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>OnConflictExpr</name> <modifier>*</modifier></type><name>onconflict</name> <init>= <expr><operator>(</operator><name>OnConflictExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>onconflict</name><operator>-&gt;</operator><name>constraint</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_CONSTRAINT</name></expr></argument>, <argument><expr><name><name>onconflict</name><operator>-&gt;</operator><name>constraint</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                               <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* fall through to examine arguments */</comment>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_OPERATOR</name></expr></argument>, <argument><expr><name><name>sgc</name><operator>-&gt;</operator><name>eqop</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>sgc</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_OPERATOR</name></expr></argument>, <argument><expr><name><name>sgc</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                               <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Recurse into RTE subquery or not-yet-planned sublink subquery */</comment>
        <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Add whole-relation refs for each plain relation mentioned in the
         * subquery's rtable.
         *
         * Note: query_tree_walker takes care of recursing into RTE_FUNCTION
         * RTEs, subqueries, etc, so no need to do that here.  But keep it
         * from looking at join alias lists.
         *
         * Note: we don't need to worry about collations mentioned in
         * RTE_VALUES or RTE_CTE RTEs, because those must just duplicate
         * collations referenced in other parts of the Query.  We do have to
         * worry about collations mentioned in RTE_FUNCTION, but we take care
         * of those when we recurse to the RangeTblFunction node(s).
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>query-&gt;rtable</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>RTE_RELATION</name></expr>:</case>
                    <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_CLASS</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                       <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                <default>default:</default>
                    <break>break;</break>
            </block_content>}</block></switch>
        </block_content>}</block>

        <comment type="block">/*
         * If the query is an INSERT or UPDATE, we should create a dependency
         * on each target column, to prevent the specific target column from
         * being dropped.  Although we will visit the TargetEntry nodes again
         * during query_tree_walker, we won't have enough context to do this
         * conveniently, so do it here.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>||</operator>
            <name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
                <name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid resultRelation %d"</literal></expr></argument>,
                     <argument><expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
            <block>{<block_content>
                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>query-&gt;targetList</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <continue>continue;</continue></block_content></block></if></if_stmt>    <comment type="block">/* ignore junk tlist items */</comment>
                    <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_CLASS</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
                                       <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Add dependencies on constraints listed in query's constraintDeps
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>query-&gt;constraintDeps</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_CONSTRAINT</name></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                               <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <comment type="block">/* query_tree_walker ignores ORDER BY etc, but we need those opers */</comment>
        <expr_stmt><expr><call><name>find_expr_references_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>find_expr_references_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>find_expr_references_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>windowClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>find_expr_references_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Examine substructure of query */</comment>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>rtables</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>rtables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
                                   <argument><expr><name>find_expr_references_walker</name></expr></argument>,
                                   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>,
                                   <argument><expr><name>QTW_IGNORE_JOINALIASES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>rtables</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>rtables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>setop</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* we need to look at the groupClauses for operator references */</comment>
        <expr_stmt><expr><call><name>find_expr_references_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>setop</name><operator>-&gt;</operator><name>groupClauses</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* fall through to examine child nodes */</comment>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblFunction</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Add refs for any datatypes and collations used in a column
         * definition list for a RECORD function.  (For other cases, it should
         * be enough to depend on the function itself.)
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>ct</argument>, <argument>rtfunc-&gt;funccoltypes</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_TYPE</name></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                               <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <macro><name>foreach</name><argument_list>(<argument>ct</argument>, <argument>rtfunc-&gt;funccolcollations</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>collid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>collid</name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_COLLATION</name></expr></argument>, <argument><expr><name>collid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>TableSampleClause</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TableSampleClause</name> <modifier>*</modifier></type><name>tsc</name> <init>= <expr><operator>(</operator><name>TableSampleClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>add_object_address</name><argument_list>(<argument><expr><name>OCLASS_PROC</name></expr></argument>, <argument><expr><name><name>tsc</name><operator>-&gt;</operator><name>tsmhandler</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><name><name>context</name><operator>-&gt;</operator><name>addrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* fall through to examine arguments */</comment>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>find_expr_references_walker</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given an array of dependency references, eliminate any duplicates.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>eliminate_duplicate_dependencies</name><parameter_list>(<parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>addrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>priorobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>oldref</name></decl>,
                <decl><type ref="prev"/><name>newrefs</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We can't sort if the array has "extra" data, because there's no way to
     * keep it in sync.  Fortunately that combination of features is not
     * needed.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>addrs</name><operator>-&gt;</operator><name>extras</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>addrs</name><operator>-&gt;</operator><name>numrefs</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>                    <comment type="block">/* nothing to do */</comment>

    <comment type="block">/* Sort the refs so that duplicates are adjacent */</comment>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>addrs</name><operator>-&gt;</operator><name>refs</name></name></expr></argument>, <argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>numrefs</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>,
          <argument><expr><name>object_address_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Remove dups */</comment>
    <expr_stmt><expr><name>priorobj</name> <operator>=</operator> <name><name>addrs</name><operator>-&gt;</operator><name>refs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>newrefs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>oldref</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>oldref</name> <operator>&lt;</operator> <name><name>addrs</name><operator>-&gt;</operator><name>numrefs</name></name></expr>;</condition> <incr><expr><name>oldref</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>thisobj</name> <init>= <expr><name><name>addrs</name><operator>-&gt;</operator><name>refs</name></name> <operator>+</operator> <name>oldref</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>priorobj</name><operator>-&gt;</operator><name>classId</name></name> <operator>==</operator> <name><name>thisobj</name><operator>-&gt;</operator><name>classId</name></name> <operator>&amp;&amp;</operator>
            <name><name>priorobj</name><operator>-&gt;</operator><name>objectId</name></name> <operator>==</operator> <name><name>thisobj</name><operator>-&gt;</operator><name>objectId</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>priorobj</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>==</operator> <name><name>thisobj</name><operator>-&gt;</operator><name>objectSubId</name></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>        <comment type="block">/* identical, so drop thisobj */</comment>

            <comment type="block">/*
             * If we have a whole-object reference and a reference to a part
             * of the same object, we don't need the whole-object reference
             * (for example, we don't need to reference both table foo and
             * column foo.bar).  The whole-object reference will always appear
             * first in the sorted list.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>priorobj</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* replace whole ref with partial */</comment>
                <expr_stmt><expr><name><name>priorobj</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>=</operator> <name><name>thisobj</name><operator>-&gt;</operator><name>objectSubId</name></name></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Not identical, so add thisobj to output set */</comment>
        <expr_stmt><expr><name>priorobj</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>priorobj</name> <operator>=</operator> <operator>*</operator><name>thisobj</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>newrefs</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>addrs</name><operator>-&gt;</operator><name>numrefs</name></name> <operator>=</operator> <name>newrefs</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * qsort comparator for ObjectAddress items
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>object_address_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>obja</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ObjectAddress</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>objb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ObjectAddress</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>obja</name><operator>-&gt;</operator><name>classId</name></name> <operator>&lt;</operator> <name><name>objb</name><operator>-&gt;</operator><name>classId</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>obja</name><operator>-&gt;</operator><name>classId</name></name> <operator>&gt;</operator> <name><name>objb</name><operator>-&gt;</operator><name>classId</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>obja</name><operator>-&gt;</operator><name>objectId</name></name> <operator>&lt;</operator> <name><name>objb</name><operator>-&gt;</operator><name>objectId</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>obja</name><operator>-&gt;</operator><name>objectId</name></name> <operator>&gt;</operator> <name><name>objb</name><operator>-&gt;</operator><name>objectId</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We sort the subId as an unsigned int so that 0 will come first. See
     * logic in eliminate_duplicate_dependencies.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>obja</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>objb</name><operator>-&gt;</operator><name>objectSubId</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>obja</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>&gt;</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>objb</name><operator>-&gt;</operator><name>objectSubId</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Routines for handling an expansible array of ObjectAddress items.
 *
 * new_object_addresses: create a new ObjectAddresses array.
 */</comment>
<function><type><name>ObjectAddresses</name> <modifier>*</modifier></type>
<name>new_object_addresses</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>addrs</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>addrs</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddresses</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>addrs</name><operator>-&gt;</operator><name>numrefs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addrs</name><operator>-&gt;</operator><name>maxrefs</name></name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addrs</name><operator>-&gt;</operator><name>refs</name></name> <operator>=</operator> <operator>(</operator><name>ObjectAddress</name> <operator>*</operator><operator>)</operator>
        <call><name>palloc</name><argument_list>(<argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>maxrefs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addrs</name><operator>-&gt;</operator><name>extras</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>        <comment type="block">/* until/unless needed */</comment>

    <return>return <expr><name>addrs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add an entry to an ObjectAddresses array.
 *
 * It is convenient to specify the class by ObjectClass rather than directly
 * by catalog OID.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_object_address</name><parameter_list>(<parameter><decl><type><name>ObjectClass</name></type> <name>oclass</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>subId</name></decl></parameter>,
                   <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>addrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Make sure object_classes is kept up to date with the ObjectClass enum.
     */</comment>
    <expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>object_classes</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LAST_OCLASS</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                     <argument><expr><literal type="string">"object_classes[] must cover all ObjectClasses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* enlarge array if needed */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>addrs</name><operator>-&gt;</operator><name>numrefs</name></name> <operator>&gt;=</operator> <name><name>addrs</name><operator>-&gt;</operator><name>maxrefs</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>addrs</name><operator>-&gt;</operator><name>maxrefs</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>addrs</name><operator>-&gt;</operator><name>refs</name></name> <operator>=</operator> <operator>(</operator><name>ObjectAddress</name> <operator>*</operator><operator>)</operator>
            <call><name>repalloc</name><argument_list>(<argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>refs</name></name></expr></argument>, <argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>maxrefs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>addrs</name><operator>-&gt;</operator><name>extras</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* record this item */</comment>
    <expr_stmt><expr><name>item</name> <operator>=</operator> <name><name>addrs</name><operator>-&gt;</operator><name>refs</name></name> <operator>+</operator> <name><name>addrs</name><operator>-&gt;</operator><name>numrefs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>classId</name></name> <operator>=</operator> <name><name>object_classes</name><index>[<expr><name>oclass</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>objectId</name></name> <operator>=</operator> <name>objectId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>=</operator> <name>subId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addrs</name><operator>-&gt;</operator><name>numrefs</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add an entry to an ObjectAddresses array.
 *
 * As above, but specify entry exactly.
 */</comment>
<function><type><name>void</name></type>
<name>add_exact_object_address</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>,
                         <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>addrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

    <comment type="block">/* enlarge array if needed */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>addrs</name><operator>-&gt;</operator><name>numrefs</name></name> <operator>&gt;=</operator> <name><name>addrs</name><operator>-&gt;</operator><name>maxrefs</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>addrs</name><operator>-&gt;</operator><name>maxrefs</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>addrs</name><operator>-&gt;</operator><name>refs</name></name> <operator>=</operator> <operator>(</operator><name>ObjectAddress</name> <operator>*</operator><operator>)</operator>
            <call><name>repalloc</name><argument_list>(<argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>refs</name></name></expr></argument>, <argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>maxrefs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>addrs</name><operator>-&gt;</operator><name>extras</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* record this item */</comment>
    <expr_stmt><expr><name>item</name> <operator>=</operator> <name><name>addrs</name><operator>-&gt;</operator><name>refs</name></name> <operator>+</operator> <name><name>addrs</name><operator>-&gt;</operator><name>numrefs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>item</name> <operator>=</operator> <operator>*</operator><name>object</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addrs</name><operator>-&gt;</operator><name>numrefs</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add an entry to an ObjectAddresses array.
 *
 * As above, but specify entry exactly and provide some "extra" data too.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_exact_object_address_extra</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>,
                               <parameter><decl><type><specifier>const</specifier> <name>ObjectAddressExtra</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>,
                               <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>addrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddressExtra</name> <modifier>*</modifier></type><name>itemextra</name></decl>;</decl_stmt>

    <comment type="block">/* allocate extra space if first time */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>addrs</name><operator>-&gt;</operator><name>extras</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>addrs</name><operator>-&gt;</operator><name>extras</name></name> <operator>=</operator> <operator>(</operator><name>ObjectAddressExtra</name> <operator>*</operator><operator>)</operator>
            <call><name>palloc</name><argument_list>(<argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>maxrefs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddressExtra</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* enlarge array if needed */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>addrs</name><operator>-&gt;</operator><name>numrefs</name></name> <operator>&gt;=</operator> <name><name>addrs</name><operator>-&gt;</operator><name>maxrefs</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>addrs</name><operator>-&gt;</operator><name>maxrefs</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>addrs</name><operator>-&gt;</operator><name>refs</name></name> <operator>=</operator> <operator>(</operator><name>ObjectAddress</name> <operator>*</operator><operator>)</operator>
            <call><name>repalloc</name><argument_list>(<argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>refs</name></name></expr></argument>, <argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>maxrefs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>addrs</name><operator>-&gt;</operator><name>extras</name></name> <operator>=</operator> <operator>(</operator><name>ObjectAddressExtra</name> <operator>*</operator><operator>)</operator>
            <call><name>repalloc</name><argument_list>(<argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>extras</name></name></expr></argument>, <argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>maxrefs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddressExtra</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* record this item */</comment>
    <expr_stmt><expr><name>item</name> <operator>=</operator> <name><name>addrs</name><operator>-&gt;</operator><name>refs</name></name> <operator>+</operator> <name><name>addrs</name><operator>-&gt;</operator><name>numrefs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>item</name> <operator>=</operator> <operator>*</operator><name>object</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>itemextra</name> <operator>=</operator> <name><name>addrs</name><operator>-&gt;</operator><name>extras</name></name> <operator>+</operator> <name><name>addrs</name><operator>-&gt;</operator><name>numrefs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>itemextra</name> <operator>=</operator> <operator>*</operator><name>extra</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addrs</name><operator>-&gt;</operator><name>numrefs</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Test whether an object is present in an ObjectAddresses array.
 *
 * We return "true" if object is a subobject of something in the array, too.
 */</comment>
<function><type><name>bool</name></type>
<name>object_address_present</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name>ObjectAddresses</name> <modifier>*</modifier></type><name>addrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>addrs</name><operator>-&gt;</operator><name>numrefs</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>thisobj</name> <init>= <expr><name><name>addrs</name><operator>-&gt;</operator><name>refs</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>classId</name></name> <operator>==</operator> <name><name>thisobj</name><operator>-&gt;</operator><name>classId</name></name> <operator>&amp;&amp;</operator>
            <name><name>object</name><operator>-&gt;</operator><name>objectId</name></name> <operator>==</operator> <name><name>thisobj</name><operator>-&gt;</operator><name>objectId</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>==</operator> <name><name>thisobj</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>||</operator>
                <name><name>thisobj</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * As above, except that if the object is present then also OR the given
 * flags into its associated extra data (which must exist).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>object_address_present_add_flags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>,
                                 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
                                 <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>addrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>addrs</name><operator>-&gt;</operator><name>numrefs</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>thisobj</name> <init>= <expr><name><name>addrs</name><operator>-&gt;</operator><name>refs</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>classId</name></name> <operator>==</operator> <name><name>thisobj</name><operator>-&gt;</operator><name>classId</name></name> <operator>&amp;&amp;</operator>
            <name><name>object</name><operator>-&gt;</operator><name>objectId</name></name> <operator>==</operator> <name><name>thisobj</name><operator>-&gt;</operator><name>objectId</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>==</operator> <name><name>thisobj</name><operator>-&gt;</operator><name>objectSubId</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ObjectAddressExtra</name> <modifier>*</modifier></type><name>thisextra</name> <init>= <expr><name><name>addrs</name><operator>-&gt;</operator><name>extras</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>thisextra</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>flags</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>thisobj</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * We get here if we find a need to delete a column after
                 * having already decided to drop its whole table.  Obviously
                 * we no longer need to drop the subobject, so report that we
                 * found the subobject in the array.  But don't plaster its
                 * flags on the whole object.
                 */</comment>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * We get here if we find a need to delete a whole table after
                 * having already decided to drop one of its columns.  We
                 * can't report that the whole object is in the array, but we
                 * should mark the subobject with the whole object's flags.
                 *
                 * It might seem attractive to physically delete the column's
                 * array entry, or at least mark it as no longer needing
                 * separate deletion.  But that could lead to, e.g., dropping
                 * the column's datatype before we drop the table, which does
                 * not seem like a good idea.  This is a very rare situation
                 * in practice, so we just take the hit of doing a separate
                 * DROP COLUMN action even though we know we're gonna delete
                 * the table later.
                 *
                 * Because there could be other subobjects of this object in
                 * the array, this case means we always have to loop through
                 * the whole array; we cannot exit early on a match.
                 */</comment>
                <decl_stmt><decl><type><name>ObjectAddressExtra</name> <modifier>*</modifier></type><name>thisextra</name> <init>= <expr><name><name>addrs</name><operator>-&gt;</operator><name>extras</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>thisextra</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>flags</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Similar to above, except we search an ObjectAddressStack.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>stack_address_present_add_flags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>,
                                <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
                                <parameter><decl><type><name>ObjectAddressStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddressStack</name> <modifier>*</modifier></type><name>stackptr</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>stackptr</name> <operator>=</operator> <name>stack</name></expr>;</init> <condition><expr><name>stackptr</name></expr>;</condition> <incr><expr><name>stackptr</name> <operator>=</operator> <name><name>stackptr</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>thisobj</name> <init>= <expr><name><name>stackptr</name><operator>-&gt;</operator><name>object</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>classId</name></name> <operator>==</operator> <name><name>thisobj</name><operator>-&gt;</operator><name>classId</name></name> <operator>&amp;&amp;</operator>
            <name><name>object</name><operator>-&gt;</operator><name>objectId</name></name> <operator>==</operator> <name><name>thisobj</name><operator>-&gt;</operator><name>objectId</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>==</operator> <name><name>thisobj</name><operator>-&gt;</operator><name>objectSubId</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>stackptr</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>flags</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>thisobj</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * We're visiting a column with whole table already on stack.
                 * As in object_address_present_add_flags(), we can skip
                 * further processing of the subobject, but we don't want to
                 * propagate flags for the subobject to the whole object.
                 */</comment>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * We're visiting a table with column already on stack.  As in
                 * object_address_present_add_flags(), we should propagate
                 * flags for the whole object to each of its subobjects.
                 */</comment>
                <expr_stmt><expr><name><name>stackptr</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>flags</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Record multiple dependencies from an ObjectAddresses array, after first
 * removing any duplicates.
 */</comment>
<function><type><name>void</name></type>
<name>record_object_address_dependencies</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>depender</name></decl></parameter>,
                                   <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>referenced</name></decl></parameter>,
                                   <parameter><decl><type><name>DependencyType</name></type> <name>behavior</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>eliminate_duplicate_dependencies</name><argument_list>(<argument><expr><name>referenced</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>recordMultipleDependencies</name><argument_list>(<argument><expr><name>depender</name></expr></argument>,
                               <argument><expr><name><name>referenced</name><operator>-&gt;</operator><name>refs</name></name></expr></argument>, <argument><expr><name><name>referenced</name><operator>-&gt;</operator><name>numrefs</name></name></expr></argument>,
                               <argument><expr><name>behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Clean up when done with an ObjectAddresses array.
 */</comment>
<function><type><name>void</name></type>
<name>free_object_addresses</name><parameter_list>(<parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>addrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>refs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>addrs</name><operator>-&gt;</operator><name>extras</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>extras</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Determine the class of a given object identified by objectAddress.
 *
 * This function is essentially the reverse mapping for the object_classes[]
 * table.  We implement it as a function because the OIDs aren't consecutive.
 */</comment>
<function><type><name>ObjectClass</name></type>
<name>getObjectClass</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* only pg_class entries can have nonzero objectSubId */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>classId</name></name> <operator>!=</operator> <name>RelationRelationId</name> <operator>&amp;&amp;</operator>
        <name><name>object</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid non-zero objectSubId for object class %u"</literal></expr></argument>,
             <argument><expr><name><name>object</name><operator>-&gt;</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <switch>switch <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>classId</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>RelationRelationId</name></expr>:</case>
            <comment type="block">/* caller must check objectSubId */</comment>
            <return>return <expr><name>OCLASS_CLASS</name></expr>;</return>

        <case>case <expr><name>ProcedureRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_PROC</name></expr>;</return>

        <case>case <expr><name>TypeRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_TYPE</name></expr>;</return>

        <case>case <expr><name>CastRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_CAST</name></expr>;</return>

        <case>case <expr><name>CollationRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_COLLATION</name></expr>;</return>

        <case>case <expr><name>ConstraintRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_CONSTRAINT</name></expr>;</return>

        <case>case <expr><name>ConversionRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_CONVERSION</name></expr>;</return>

        <case>case <expr><name>AttrDefaultRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_DEFAULT</name></expr>;</return>

        <case>case <expr><name>LanguageRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_LANGUAGE</name></expr>;</return>

        <case>case <expr><name>LargeObjectRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_LARGEOBJECT</name></expr>;</return>

        <case>case <expr><name>OperatorRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_OPERATOR</name></expr>;</return>

        <case>case <expr><name>OperatorClassRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_OPCLASS</name></expr>;</return>

        <case>case <expr><name>OperatorFamilyRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_OPFAMILY</name></expr>;</return>

        <case>case <expr><name>AccessMethodRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_AM</name></expr>;</return>

        <case>case <expr><name>AccessMethodOperatorRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_AMOP</name></expr>;</return>

        <case>case <expr><name>AccessMethodProcedureRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_AMPROC</name></expr>;</return>

        <case>case <expr><name>RewriteRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_REWRITE</name></expr>;</return>

        <case>case <expr><name>TriggerRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_TRIGGER</name></expr>;</return>

        <case>case <expr><name>NamespaceRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_SCHEMA</name></expr>;</return>

        <case>case <expr><name>StatisticExtRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_STATISTIC_EXT</name></expr>;</return>

        <case>case <expr><name>TSParserRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_TSPARSER</name></expr>;</return>

        <case>case <expr><name>TSDictionaryRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_TSDICT</name></expr>;</return>

        <case>case <expr><name>TSTemplateRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_TSTEMPLATE</name></expr>;</return>

        <case>case <expr><name>TSConfigRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_TSCONFIG</name></expr>;</return>

        <case>case <expr><name>AuthIdRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_ROLE</name></expr>;</return>

        <case>case <expr><name>DatabaseRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_DATABASE</name></expr>;</return>

        <case>case <expr><name>TableSpaceRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_TBLSPACE</name></expr>;</return>

        <case>case <expr><name>ForeignDataWrapperRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_FDW</name></expr>;</return>

        <case>case <expr><name>ForeignServerRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_FOREIGN_SERVER</name></expr>;</return>

        <case>case <expr><name>UserMappingRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_USER_MAPPING</name></expr>;</return>

        <case>case <expr><name>DefaultAclRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_DEFACL</name></expr>;</return>

        <case>case <expr><name>ExtensionRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_EXTENSION</name></expr>;</return>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <case>case <expr><name>PgxcClassRelationId</name></expr>:</case>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>OCLASS_PGXC_CLASS</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>EventTriggerRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_EVENT_TRIGGER</name></expr>;</return>

        <case>case <expr><name>PolicyRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_POLICY</name></expr>;</return>

        <case>case <expr><name>PublicationRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_PUBLICATION</name></expr>;</return>

        <case>case <expr><name>PublicationRelRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_PUBLICATION_REL</name></expr>;</return>

        <case>case <expr><name>SubscriptionRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_SUBSCRIPTION</name></expr>;</return>

        <case>case <expr><name>TransformRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_TRANSFORM</name></expr>;</return>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <case>case <expr><name>PgPartitionIntervalRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_PG_PARTITION_INTERVAL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
        <case>case <expr><name>PgAuditStmtConfRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_AUDIT_STMT</name></expr>;</return>
        <case>case <expr><name>PgAuditUserConfRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_AUDIT_USER</name></expr>;</return>
        <case>case <expr><name>PgAuditObjConfRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_AUDIT_OBJ</name></expr>;</return>
        <case>case <expr><name>PgAuditObjDefOptsRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_AUDIT_OBJDEFAULT</name></expr>;</return>    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
        <case>case <expr><name>PublicationShardRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_PUBLICATION_SHARD</name></expr>;</return>    
        <case>case <expr><name>SubscriptionShardRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_SUBSCRIPTION_SHARD</name></expr>;</return>
        <case>case <expr><name>SubscriptionTableRelationId</name></expr>:</case>
            <return>return <expr><name>OCLASS_SUBSCRIPTION_TABLE</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </block_content>}</block></switch>

    <comment type="block">/* shouldn't get here */</comment>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized object class: %u"</literal></expr></argument>, <argument><expr><name><name>object</name><operator>-&gt;</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>OCLASS_CLASS</name></expr>;</return>        <comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * delete initial ACL for extension objects
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DeleteInitPrivs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>relation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>oldtuple</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>InitPrivsRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_init_privs_objoid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_init_privs_classoid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_init_privs_objsubid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
                <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectSubId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>InitPrivsObjIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>oldtuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oldtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
