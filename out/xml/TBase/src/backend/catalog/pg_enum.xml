<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/catalog/pg_enum.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_enum.c
 *      routines to support manipulation of the pg_enum relation
 *
 * Copyright (c) 2006-2017, PostgreSQL Global Development Group
 *
 *
 * IDENTIFICATION
 *      src/backend/catalog/pg_enum.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/binary_upgrade.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_enum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/value.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/catcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>


<comment type="block">/* Potentially set by pg_upgrade_support functions */</comment>
<decl_stmt><decl><type><name>Oid</name></type>            <name>binary_upgrade_next_pg_enum_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RenumberEnumType</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pg_enum</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>existing</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nelems</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>sort_order_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * EnumValuesCreate
 *        Create an entry in pg_enum for each of the supplied enum values.
 *
 * vals is a list of Value strings.
 */</comment>
<function><type><name>void</name></type>
<name>EnumValuesCreate</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>enumTypeOid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>vals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>pg_enum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NameData</name></type>    <name>enumlabel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>oids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>elemno</name></decl>,
                <decl><type ref="prev"/><name>num_elems</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>Natts_pg_enum</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>Natts_pg_enum</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>num_elems</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We do not bother to check the list of values for duplicates --- if you
     * have any, you'll get a less-than-friendly unique-index violation. It is
     * probably not worth trying harder.
     */</comment>

    <expr_stmt><expr><name>pg_enum</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>EnumRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Allocate OIDs for the enum's members.
     *
     * While this method does not absolutely guarantee that we generate no
     * duplicate OIDs (since we haven't entered each oid into the table before
     * allocating the next), trouble could only occur if the OID counter wraps
     * all the way around before we finish. Which seems unlikely.
     */</comment>
    <expr_stmt><expr><name>oids</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_elems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>elemno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>elemno</name> <operator>&lt;</operator> <name>num_elems</name></expr>;</condition> <incr><expr><name>elemno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * We assign even-numbered OIDs to all the new enum labels.  This
         * tells the comparison functions the OIDs are in the correct sort
         * order and can be compared directly.
         */</comment>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>new_oid</name></decl>;</decl_stmt>

        <do>do
        <block>{<block_content>
            <expr_stmt><expr><name>new_oid</name> <operator>=</operator> <call><name>GetNewOid</name><argument_list>(<argument><expr><name>pg_enum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> while <condition>(<expr><name>new_oid</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition>;</do>
        <expr_stmt><expr><name><name>oids</name><index>[<expr><name>elemno</name></expr>]</index></name> <operator>=</operator> <name>new_oid</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* sort them, just in case OID counter wrapped from high to low */</comment>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name>num_elems</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>oid_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* and make the entries */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>elemno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>vals</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>lab</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * labels are stored in a name field, for easier syscache lookup, so
         * check the length to make sure it's within range.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>lab</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <operator>(</operator><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid enum label \"%s\""</literal></expr></argument>, <argument><expr><name>lab</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Labels must be %d characters or less."</literal></expr></argument>,
                               <argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_enum_enumtypid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>enumTypeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_enum_enumsortorder</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Float4GetDatum</name><argument_list>(<argument><expr><name>elemno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>enumlabel</name></expr></argument>, <argument><expr><name>lab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_enum_enumlabel</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>enumlabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_enum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HeapTupleSetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name><name>oids</name><index>[<expr><name>elemno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>pg_enum</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>elemno</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* clean up */</comment>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_enum</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnumValuesDelete
 *        Remove all the pg_enum entries for the specified enum type.
 */</comment>
<function><type><name>void</name></type>
<name>EnumValuesDelete</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>enumTypeOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>pg_enum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pg_enum</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>EnumRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_enum_enumtypid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>enumTypeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_enum</name></expr></argument>, <argument><expr><name>EnumTypIdLabelIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>pg_enum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_enum</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AddEnumLabel
 *        Add a new label to the enum set. By default it goes at
 *        the end, but the user can choose to place it before or
 *        after any existing set member.
 */</comment>
<function><type><name>void</name></type>
<name>AddEnumLabel</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>enumTypeOid</name></decl></parameter>,
             <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newVal</name></decl></parameter>,
             <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>neighbor</name></decl></parameter>,
             <parameter><decl><type><name>bool</name></type> <name>newValIsAfter</name></decl></parameter>,
             <parameter><decl><type><name>bool</name></type> <name>skipIfExists</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>pg_enum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>newOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>Natts_pg_enum</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>Natts_pg_enum</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NameData</name></type>    <name>enumlabel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>enum_tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float4</name></type>        <name>newelemorder</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name>  <modifier>*</modifier></type><name>existing</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nelems</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* check length of new label is ok */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <operator>(</operator><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid enum label \"%s\""</literal></expr></argument>, <argument><expr><name>newVal</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Labels must be %d characters or less."</literal></expr></argument>,
                           <argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Acquire a lock on the enum type, which we won't release until commit.
     * This ensures that two backends aren't concurrently modifying the same
     * enum type.  Without that, we couldn't be sure to get a consistent view
     * of the enum members via the syscache.  Note that this does not block
     * other backends from inspecting the type; see comments for
     * RenumberEnumType.
     */</comment>
    <expr_stmt><expr><call><name>LockDatabaseObject</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>enumTypeOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check if label is already in use.  The unique index on pg_enum would
     * catch this anyway, but we prefer a friendlier error message, and
     * besides we need a check to support IF NOT EXISTS.
     */</comment>
    <expr_stmt><expr><name>enum_tup</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ENUMTYPOIDNAME</name></expr></argument>,
                               <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>enumTypeOid</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>enum_tup</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>enum_tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>skipIfExists</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"enum label \"%s\" already exists, skipping"</literal></expr></argument>,
                            <argument><expr><name>newVal</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"enum label \"%s\" already exists"</literal></expr></argument>,
                            <argument><expr><name>newVal</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>pg_enum</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>EnumRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If we have to renumber the existing members, we restart from here */</comment>
<label><name>restart</name>:</label>

    <comment type="block">/* Get the list of existing members of the enum */</comment>
    <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>ENUMTYPOIDNAME</name></expr></argument>,
                               <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>enumTypeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nelems</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</expr_stmt>

    <comment type="block">/* Sort the existing members by enumsortorder */</comment>
    <expr_stmt><expr><name>existing</name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nelems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>existing</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>list</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name><operator>)</operator></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>existing</name></expr></argument>, <argument><expr><name>nelems</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HeapTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>sort_order_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>neighbor</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Put the new label at the end of the list. No change to existing
         * tuples is required.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>nelems</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Form_pg_enum</name></type> <name>en</name> <init>= <expr><operator>(</operator><name>Form_pg_enum</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>existing</name><index>[<expr><name>nelems</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>newelemorder</name> <operator>=</operator> <name><name>en</name><operator>-&gt;</operator><name>enumsortorder</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>newelemorder</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* BEFORE or AFTER was specified */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>nbr_index</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>other_nbr_index</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_enum</name></type> <name>nbr_en</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_enum</name></type> <name>other_nbr_en</name></decl>;</decl_stmt>

        <comment type="block">/* Locate the neighbor element */</comment>
        <for>for <control>(<init><expr><name>nbr_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>nbr_index</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>nbr_index</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Form_pg_enum</name></type> <name>en</name> <init>= <expr><operator>(</operator><name>Form_pg_enum</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>existing</name><index>[<expr><name>nbr_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>enumlabel</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>neighbor</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>nbr_index</name> <operator>&gt;=</operator> <name>nelems</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an existing enum label"</literal></expr></argument>,
                            <argument><expr><name>neighbor</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>nbr_en</name> <operator>=</operator> <operator>(</operator><name>Form_pg_enum</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>existing</name><index>[<expr><name>nbr_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Attempt to assign an appropriate enumsortorder value: one less than
         * the smallest member, one more than the largest member, or halfway
         * between two existing members.
         *
         * In the "halfway" case, because of the finite precision of float4,
         * we might compute a value that's actually equal to one or the other
         * of its neighbors.  In that case we renumber the existing members
         * and try again.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>newValIsAfter</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>other_nbr_index</name> <operator>=</operator> <name>nbr_index</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>other_nbr_index</name> <operator>=</operator> <name>nbr_index</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>other_nbr_index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>newelemorder</name> <operator>=</operator> <name><name>nbr_en</name><operator>-&gt;</operator><name>enumsortorder</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>other_nbr_index</name> <operator>&gt;=</operator> <name>nelems</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>newelemorder</name> <operator>=</operator> <name><name>nbr_en</name><operator>-&gt;</operator><name>enumsortorder</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * The midpoint value computed here has to be rounded to float4
             * precision, else our equality comparisons against the adjacent
             * values are meaningless.  The most portable way of forcing that
             * to happen with non-C-standard-compliant compilers is to store
             * it into a volatile variable.
             */</comment>
            <decl_stmt><decl><type><specifier>volatile</specifier> <name>float4</name></type> <name>midpoint</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>other_nbr_en</name> <operator>=</operator> <operator>(</operator><name>Form_pg_enum</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>existing</name><index>[<expr><name>other_nbr_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>midpoint</name> <operator>=</operator> <operator>(</operator><name><name>nbr_en</name><operator>-&gt;</operator><name>enumsortorder</name></name> <operator>+</operator>
                        <name><name>other_nbr_en</name><operator>-&gt;</operator><name>enumsortorder</name></name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>midpoint</name> <operator>==</operator> <name><name>nbr_en</name><operator>-&gt;</operator><name>enumsortorder</name></name> <operator>||</operator>
                <name>midpoint</name> <operator>==</operator> <name><name>other_nbr_en</name><operator>-&gt;</operator><name>enumsortorder</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>RenumberEnumType</name><argument_list>(<argument><expr><name>pg_enum</name></expr></argument>, <argument><expr><name>existing</name></expr></argument>, <argument><expr><name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Clean up and start over */</comment>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>existing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ReleaseCatCacheList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>restart</name>;</goto>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>newelemorder</name> <operator>=</operator> <name>midpoint</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Get a new OID for the new label */</comment>
    <if_stmt><if>if <condition>(<expr><name>IsBinaryUpgrade</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>binary_upgrade_next_pg_enum_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_enum OID value not set when in binary upgrade mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Use binary-upgrade override for pg_enum.oid, if supplied. During
         * binary upgrade, all pg_enum.oid's are set this way so they are
         * guaranteed to be consistent.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>neighbor</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ALTER TYPE ADD BEFORE/AFTER is incompatible with binary upgrade"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>newOid</name> <operator>=</operator> <name>binary_upgrade_next_pg_enum_oid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>binary_upgrade_next_pg_enum_oid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Normal case: we need to allocate a new Oid for the value.
         *
         * We want to give the new element an even-numbered Oid if it's safe,
         * which is to say it compares correctly to all pre-existing even
         * numbered Oids in the enum.  Otherwise, we must give it an odd Oid.
         */</comment>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type>        <name>sorts_ok</name></decl>;</decl_stmt>

            <comment type="block">/* Get a new OID (different from all existing pg_enum tuples) */</comment>
            <expr_stmt><expr><name>newOid</name> <operator>=</operator> <call><name>GetNewOid</name><argument_list>(<argument><expr><name>pg_enum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Detect whether it sorts correctly relative to existing
             * even-numbered labels of the enum.  We can ignore existing
             * labels with odd Oids, since a comparison involving one of those
             * will not take the fast path anyway.
             */</comment>
            <expr_stmt><expr><name>sorts_ok</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>exists_tup</name> <init>= <expr><name><name>existing</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Form_pg_enum</name></type> <name>exists_en</name> <init>= <expr><operator>(</operator><name>Form_pg_enum</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>exists_tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>exists_oid</name> <init>= <expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>exists_tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>exists_oid</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>    <comment type="block">/* ignore odd Oids */</comment>

                <if_stmt><if>if <condition>(<expr><name><name>exists_en</name><operator>-&gt;</operator><name>enumsortorder</name></name> <operator>&lt;</operator> <name>newelemorder</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* should sort before */</comment>
                    <if_stmt><if>if <condition>(<expr><name>exists_oid</name> <operator>&gt;=</operator> <name>newOid</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>sorts_ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* should sort after */</comment>
                    <if_stmt><if>if <condition>(<expr><name>exists_oid</name> <operator>&lt;=</operator> <name>newOid</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>sorts_ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>

            <if_stmt><if>if <condition>(<expr><name>sorts_ok</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* If it's even and sorts OK, we're done. */</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>newOid</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * If it's odd, and sorts OK, loop back to get another OID and
                 * try again.  Probably, the next available even OID will sort
                 * correctly too, so it's worth trying.
                 */</comment>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * If it's odd, and does not sort correctly, we're done.
                 * (Probably, the next available even OID would sort
                 * incorrectly too, so no point in trying again.)
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>newOid</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * If it's even, and does not sort correctly, loop back to get
                 * another OID and try again.  (We *must* reject this case.)
                 */</comment>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Done with info about existing members */</comment>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>existing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseCatCacheList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create the new pg_enum entry */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_enum_enumtypid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>enumTypeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_enum_enumsortorder</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Float4GetDatum</name><argument_list>(<argument><expr><name>newelemorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>enumlabel</name></expr></argument>, <argument><expr><name>newVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_enum_enumlabel</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>enumlabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>enum_tup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_enum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HeapTupleSetOid</name><argument_list>(<argument><expr><name>enum_tup</name></expr></argument>, <argument><expr><name>newOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>pg_enum</name></expr></argument>, <argument><expr><name>enum_tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>enum_tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_enum</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RenameEnumLabel
 *        Rename a label in an enum set.
 */</comment>
<function><type><name>void</name></type>
<name>RenameEnumLabel</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>enumTypeOid</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldVal</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newVal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>pg_enum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>enum_tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_enum</name></type> <name>en</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nelems</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>old_tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found_new</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* check length of new label is ok */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <operator>(</operator><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid enum label \"%s\""</literal></expr></argument>, <argument><expr><name>newVal</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Labels must be %d characters or less."</literal></expr></argument>,
                           <argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Acquire a lock on the enum type, which we won't release until commit.
     * This ensures that two backends aren't concurrently modifying the same
     * enum type.  Since we are not changing the type's sort order, this is
     * probably not really necessary, but there seems no reason not to take
     * the lock to be sure.
     */</comment>
    <expr_stmt><expr><call><name>LockDatabaseObject</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>enumTypeOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pg_enum</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>EnumRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get the list of existing members of the enum */</comment>
    <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>ENUMTYPOIDNAME</name></expr></argument>,
                               <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>enumTypeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nelems</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Locate the element to rename and check if the new label is already in
     * use.  (The unique index on pg_enum would catch that anyway, but we
     * prefer a friendlier error message.)
     */</comment>
    <expr_stmt><expr><name>old_tup</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>found_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>enum_tup</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>list</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>en</name> <operator>=</operator> <operator>(</operator><name>Form_pg_enum</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>enum_tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>enumlabel</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>oldVal</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>old_tup</name> <operator>=</operator> <name>enum_tup</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>enumlabel</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newVal</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>found_new</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>old_tup</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an existing enum label"</literal></expr></argument>,
                        <argument><expr><name>oldVal</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>found_new</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"enum label \"%s\" already exists"</literal></expr></argument>,
                        <argument><expr><name>newVal</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* OK, make a writable copy of old tuple */</comment>
    <expr_stmt><expr><name>enum_tup</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>old_tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>en</name> <operator>=</operator> <operator>(</operator><name>Form_pg_enum</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>enum_tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseCatCacheList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Update the pg_enum entry */</comment>
    <expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>en</name><operator>-&gt;</operator><name>enumlabel</name></name></expr></argument>, <argument><expr><name>newVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_enum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>enum_tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>enum_tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>enum_tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_enum</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RenumberEnumType
 *        Renumber existing enum elements to have sort positions 1..n.
 *
 * We avoid doing this unless absolutely necessary; in most installations
 * it will never happen.  The reason is that updating existing pg_enum
 * entries creates hazards for other backends that are concurrently reading
 * pg_enum.  Although system catalog scans now use MVCC semantics, the
 * syscache machinery might read different pg_enum entries under different
 * snapshots, so some other backend might get confused about the proper
 * ordering if a concurrent renumbering occurs.
 *
 * We therefore make the following choices:
 *
 * 1. Any code that is interested in the enumsortorder values MUST read
 * all the relevant pg_enum entries with a single MVCC snapshot, or else
 * acquire lock on the enum type to prevent concurrent execution of
 * AddEnumLabel().
 *
 * 2. Code that is not examining enumsortorder can use a syscache
 * (for example, enum_in and enum_out do so).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RenumberEnumType</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pg_enum</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>existing</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nelems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We should only need to increase existing elements' enumsortorders,
     * never decrease them.  Therefore, work from the end backwards, to avoid
     * unwanted uniqueness violations.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>nelems</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>newtup</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_enum</name></type> <name>en</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>float4</name></type>        <name>newsortorder</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name><name>existing</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>en</name> <operator>=</operator> <operator>(</operator><name>Form_pg_enum</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>newsortorder</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>en</name><operator>-&gt;</operator><name>enumsortorder</name></name> <operator>!=</operator> <name>newsortorder</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>en</name><operator>-&gt;</operator><name>enumsortorder</name></name> <operator>=</operator> <name>newsortorder</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_enum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Make the updates visible */</comment>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* qsort comparison function for tuples by sort order */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>sort_order_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>v1</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>HeapTuple</name> <operator>*</operator><operator>)</operator> <name>p1</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>v2</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>HeapTuple</name> <operator>*</operator><operator>)</operator> <name>p2</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_enum</name></type> <name>en1</name> <init>= <expr><operator>(</operator><name>Form_pg_enum</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_enum</name></type> <name>en2</name> <init>= <expr><operator>(</operator><name>Form_pg_enum</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>en1</name><operator>-&gt;</operator><name>enumsortorder</name></name> <operator>&lt;</operator> <name><name>en2</name><operator>-&gt;</operator><name>enumsortorder</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>en1</name><operator>-&gt;</operator><name>enumsortorder</name></name> <operator>&gt;</operator> <name><name>en2</name><operator>-&gt;</operator><name>enumsortorder</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
