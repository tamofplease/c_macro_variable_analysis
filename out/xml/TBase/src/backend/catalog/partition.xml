<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/catalog/partition.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * partition.c
 *          Partitioning related data structures and functions.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *          src/backend/catalog/partition.c
 *
 *-------------------------------------------------------------------------
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaddress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_partitioned_table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partbounds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hashutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>get_partition_parent_worker</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>inhRel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_partition_ancestors_worker</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>inhRel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>,
                               <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>ancestors</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>qsort_partition_hbound_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>qsort_partition_list_value_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
                               <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>qsort_partition_rbound_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
                           <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>get_partition_operator</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>,
                       <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>need_relabel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>make_partition_op_expr</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keynum</name></decl></parameter>,
                       <parameter><decl><type><name>uint16</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_range_key_properties</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keynum</name></decl></parameter>,
                         <parameter><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>ldatum</name></decl></parameter>,
                         <parameter><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>udatum</name></decl></parameter>,
                         <parameter><decl><type><name>ListCell</name> <modifier>*</modifier><modifier>*</modifier></type><name>partexprs_item</name></decl></parameter>,
                         <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>keyCol</name></decl></parameter>,
                         <parameter><decl><type><name>Const</name> <modifier>*</modifier><modifier>*</modifier></type><name>lower_val</name></decl></parameter>, <parameter><decl><type><name>Const</name> <modifier>*</modifier><modifier>*</modifier></type><name>upper_val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_qual_for_hash</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_qual_for_list</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_qual_for_range</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>for_default</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_range_nulltest</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>generate_partition_qual</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>PartitionRangeBound</name> <modifier>*</modifier></type><name>make_one_range_bound</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>,
                     <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>datums</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lower</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>partition_hbound_cmp</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>modulus1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>remainder1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>modulus2</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>remainder2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>partition_rbound_cmp</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>datums1</name></decl></parameter>,
					 <parameter><decl><type><name>PartitionRangeDatumKind</name> <modifier>*</modifier></type><name>kind1</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lower1</name></decl></parameter>,
					 <parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>b2</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>get_partition_bound_num_indexes</name><parameter_list>(<parameter><decl><type><name>PartitionBoundInfo</name></type> <name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* SQL-callable function for use in hash partition CHECK constraints */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>satisfies_hash_partition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * RelationBuildPartitionDesc
 *        Form rel's partition descriptor
 *
 * Not flushed from the cache by RelationClearRelation() unless changed because
 * of addition or removal of partition.
 */</comment>
<function><type><name>void</name></type>
<name>RelationBuildPartitionDesc</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>inhoids</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>partoids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>oids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>boundspecs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>nparts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PartitionDesc</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type>            <name>ndatums</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>default_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Hash partitioning specific */</comment>
	<decl_stmt><decl><type><name>PartitionHashBound</name> <modifier>*</modifier><modifier>*</modifier></type><name>hbounds</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* List partitioning specific */</comment>
    <decl_stmt><decl><type><name>PartitionListValue</name> <modifier>*</modifier><modifier>*</modifier></type><name>all_values</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>null_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Range partitioning specific */</comment>
    <decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier><modifier>*</modifier></type><name>rbounds</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type> <name>old_portable_output</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * The following could happen in situations where rel has a pg_class entry
     * but not the pg_partitioned_table entry yet.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>key</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Get partition oids from pg_inherits */</comment>
    <expr_stmt><expr><name>inhoids</name> <operator>=</operator> <call><name>find_inheritance_children</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Collect bound spec nodes in a list */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>partoids</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>inhoids</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>inhrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>datum</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>boundspec</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>inhrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>inhrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * It is possible that the pg_class tuple of a partition has not been
         * updated yet to set its relpartbound field.  The only case where
         * this happens is when we open the parent relation to check using its
         * partition descriptor that a new partition's bound does not overlap
         * some existing partition.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relispartition</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
                                <argument><expr><name>Anum_pg_class_relpartbound</name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/*
          * partition bound stored as string transformed without portable_output
          * in catalog, so we need to read bound without portable_input.
                 */</comment>
        <expr_stmt><expr><name>old_portable_output</name> <operator>=</operator> <call><name>set_portable_input</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>boundspec</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		* Sanity check: If the PartitionBoundSpec says this is the default
		* partition, its OID should correspond to whatever's stored in
		* pg_partitioned_table.partdefid; if not, the catalog is corrupt.
		*/</comment>
		<if_stmt><if>if <condition>(<expr><call><name>castNode</name><argument_list>(<argument><expr><name>PartitionBoundSpec</name></expr></argument>, <argument><expr><name>boundspec</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>is_default</name></expr>)</condition>
		<block>{<block_content>
		   <decl_stmt><decl><type><name>Oid</name></type>         <name>partdefid</name></decl>;</decl_stmt>

		   <expr_stmt><expr><name>partdefid</name> <operator>=</operator> <call><name>get_default_partition_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		   <if_stmt><if>if <condition>(<expr><name>partdefid</name> <operator>!=</operator> <name>inhrelid</name></expr>)</condition><block type="pseudo"><block_content>
		       <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected partdefid %u, but got %u"</literal></expr></argument>,
		            <argument><expr><name>inhrelid</name></expr></argument>, <argument><expr><name>partdefid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>set_portable_input</name><argument_list>(<argument><expr><name>old_portable_output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>boundspecs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>boundspecs</name></expr></argument>, <argument><expr><name>boundspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>partoids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>partoids</name></expr></argument>, <argument><expr><name>inhrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name>nparts</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>partoids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>nparts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>oids</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nparts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>partoids</argument>)</argument_list></macro>
            <expr_stmt><expr><name><name>oids</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Convert from node to the internal representation */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ndatums</name> <operator>=</operator> <name>nparts</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>hbounds</name> <operator>=</operator> <operator>(</operator><name>PartitionHashBound</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>palloc</name><argument_list>(<argument><expr><name>nparts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionHashBound</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>boundspecs</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>PartitionBoundSpec</name></expr></argument>,
													<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid strategy in partition bound spec"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PartitionHashBound</name> <operator>*</operator><operator>)</operator>
					<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionHashBound</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>modulus</name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>remainder</name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>

			<comment type="block">/* Sort all the bounds in ascending order */</comment>
			<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>hbounds</name></expr></argument>, <argument><expr><name>nparts</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionHashBound</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
				  <argument><expr><name>qsort_partition_hbound_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>non_null_values</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * Create a unified list of non-null values across all partitions.
             */</comment>
            <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>null_index</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>boundspecs</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>PartitionBoundSpec</name></expr></argument>,
                                                    <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_LIST</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid strategy in partition bound spec"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Note the index of the partition bound spec for the default
				 * partition. There's no datum to add to the list of non-null
				 * datums for this partition.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>default_index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

                <macro><name>foreach</name><argument_list>(<argument>c</argument>, <argument>spec-&gt;listdatums</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Const</name>       <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>PartitionListValue</name> <modifier>*</modifier></type><name>list_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>val</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>list_value</name> <operator>=</operator> <operator>(</operator><name>PartitionListValue</name> <operator>*</operator><operator>)</operator>
                            <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionListValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>list_value</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>list_value</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>val</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="block">/*
                         * Never put a null into the values array, flag
                         * instead for the code further down below where we
                         * construct the actual relcache struct.
                         */</comment>
                        <if_stmt><if>if <condition>(<expr><name>null_index</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"found null more than once"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <expr_stmt><expr><name>null_index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name>list_value</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>non_null_values</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>non_null_values</name></expr></argument>,
                                                  <argument><expr><name>list_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block>

                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block>

            <expr_stmt><expr><name>ndatums</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>non_null_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Collect all list values in one array. Alongside the value, we
             * also save the index of partition the value comes from.
             */</comment>
            <expr_stmt><expr><name>all_values</name> <operator>=</operator> <operator>(</operator><name>PartitionListValue</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ndatums</name> <operator>*</operator>
                                                        <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionListValue</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>non_null_values</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PartitionListValue</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>all_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PartitionListValue</name> <operator>*</operator><operator>)</operator>
                    <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionListValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>all_values</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>value</name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>all_values</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block>

            <expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><name>all_values</name></expr></argument>, <argument><expr><name>ndatums</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionListValue</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
                      <argument><expr><name>qsort_partition_list_value_cmp</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name></expr>)</condition>
        <block>{<block_content>
		    <decl_stmt><decl><type><name>int</name></type>         <name>k</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier><modifier>*</modifier></type><name>all_bounds</name></decl>,
                       <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>all_bounds</name> <operator>=</operator> <operator>(</operator><name>PartitionRangeBound</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <name>nparts</name> <operator>*</operator>
                                                          <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeBound</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Create a unified list of range bounds across all the
             * partitions.
             */</comment>
		    <expr_stmt><expr><name>i</name> <operator>=</operator> <name>ndatums</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>boundspecs</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>PartitionBoundSpec</name></expr></argument>,
                                                    <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>lower</name></decl>,
                           <decl><type ref="prev"><modifier>*</modifier></type><name>upper</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_RANGE</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid strategy in partition bound spec"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Note the index of the partition bound spec for the default
				 * partition. There's no datum to add to the allbounds array
				 * for this partition.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>default_index</name> <operator>=</operator> <name>i</name><operator>++</operator></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>lower</name> <operator>=</operator> <call><name>make_one_range_bound</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>,
                                             <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>upper</name> <operator>=</operator> <call><name>make_one_range_bound</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>,
                                             <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		        <expr_stmt><expr><name><name>all_bounds</name><index>[<expr><name>ndatums</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>lower</name></expr>;</expr_stmt>
		        <expr_stmt><expr><name><name>all_bounds</name><index>[<expr><name>ndatums</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>upper</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block>

		    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ndatums</name> <operator>==</operator> <name>nparts</name> <operator>*</operator> <literal type="number">2</literal> <operator>||</operator>
		           <operator>(</operator><name>default_index</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>ndatums</name> <operator>==</operator> <operator>(</operator><name>nparts</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Sort all the bounds in ascending order */</comment>
		    <expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><name>all_bounds</name></expr></argument>, <argument><expr><name>ndatums</name></expr></argument>,
                      <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeBound</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
                      <argument><expr><name>qsort_partition_rbound_cmp</name></expr></argument>,
                      <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		    <comment type="block">/* Save distinct bounds from all_bounds into rbounds. */</comment>
		    <expr_stmt><expr><name>rbounds</name> <operator>=</operator> <operator>(</operator><name>PartitionRangeBound</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		        <call><name>palloc</name><argument_list>(<argument><expr><name>ndatums</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeBound</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><name><name>all_bounds</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>        <name>is_distinct</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

                <comment type="block">/* Is the current bound distinct from the previous one? */</comment>
                <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Datum</name></type>        <name>cmpval</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>prev</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>cur</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name><name>prev</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>is_distinct</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/*
                     * If the bounds are both MINVALUE or MAXVALUE, stop now
                     * and treat them as equal, since any values after this
                     * point must be ignored.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>

                    <expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
                                               <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
                                               <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
                                               <argument><expr><name><name>prev</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>cmpval</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>is_distinct</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>

                <comment type="block">/*
		         * Only if the bound is distinct save it into a temporary
		         * array i.e. rbounds which is later copied into boundinfo
		         * datums array.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>is_distinct</name></expr>)</condition><block type="pseudo"><block_content>
		            <expr_stmt><expr><name><name>rbounds</name><index>[<expr><name>k</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>all_bounds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>prev</name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt>
            </block_content>}</block></for>

		    <comment type="block">/* Update ndatums to hold the count of distinct datums. */</comment>
		    <expr_stmt><expr><name>ndatums</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected partition strategy: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Now build the actual relcache partition descriptor */</comment>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_pdcxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>,
                                          <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_pdcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PartitionDescData</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nparts</name></name> <operator>=</operator> <name>nparts</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nparts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>mapping</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>next_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>oids</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nparts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>boundinfo</name> <operator>=</operator> <operator>(</operator><name>PartitionBoundInfoData</name> <operator>*</operator><operator>)</operator>
            <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionBoundInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>default_index</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>=</operator> <name>ndatums</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>null_index</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>ndatums</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Initialize mapping array with invalid values */</comment>
        <expr_stmt><expr><name>mapping</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>mapping</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

        <switch>switch <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
        <block>{<block_content>
			<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
				<block>{<block_content>
					<comment type="block">/* Modulus are stored in ascending order */</comment>
					<decl_stmt><decl><type><name>int</name></type>			<name>greatest_modulus</name> <init>= <expr><name><name>hbounds</name><index>[<expr><name>ndatums</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>modulus</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>greatest_modulus</name> <operator>*</operator>
														<sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>greatest_modulus</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type>			<name>modulus</name> <init>= <expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>modulus</name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>int</name></type>			<name>remainder</name> <init>= <expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>remainder</name></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator>
																<sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>modulus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<while>while <condition>(<expr><name>remainder</name> <operator>&lt;</operator> <name>greatest_modulus</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* overlap? */</comment>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>remainder</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>remainder</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>remainder</name> <operator>+=</operator> <name>modulus</name></expr>;</expr_stmt>
						</block_content>}</block></while>

						<expr_stmt><expr><name><name>mapping</name><index>[<expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></for>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hbounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

            <case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ndatums</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Copy values.  Indexes of individual values are mapped
                     * to canonical values so that they match for any two list
                     * partitioned tables with same number of partitions and
                     * same lists per partition.  One way to canonicalize is
                     * to assign the index in all_values[] of the smallest
                     * value of each partition, as the index of all of the
                     * partition's values.
                     */</comment>
                    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>all_values</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>value</name></expr></argument>,
                                                            <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypbyval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                                                            <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttyplen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/* If the old index has no mapping, assign one */</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>mapping</name><index>[<expr><name><name>all_values</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>mapping</name><index>[<expr><name><name>all_values</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name></expr>]</index></name> <operator>=</operator> <name>next_index</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

                        <expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>mapping</name><index>[<expr><name><name>all_values</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name></expr>]</index></name></expr>;</expr_stmt>
                    </block_content>}</block></for>

                    <comment type="block">/*
                     * If null-accepting partition has no mapped index yet,
                     * assign one.  This could happen if such partition
                     * accepts only null and hence not covered in the above
                     * loop which only handled non-null values.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name>null_index</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>null_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name><name>mapping</name><index>[<expr><name>null_index</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>mapping</name><index>[<expr><name>null_index</name></expr>]</index></name> <operator>=</operator> <name>next_index</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>null_index</name></name> <operator>=</operator> <name><name>mapping</name><index>[<expr><name>null_index</name></expr>]</index></name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

					<comment type="block">/* Assign mapped index for the default partition. */</comment>
					<if_stmt><if>if <condition>(<expr><name>default_index</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * The default partition accepts any value not
						 * specified in the lists of other partitions, hence
						 * it should not get mapped index while assigning
						 * those for non-null datums.
						 */</comment>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>default_index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
							   <name><name>mapping</name><index>[<expr><name>default_index</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>mapping</name><index>[<expr><name>default_index</name></expr>]</index></name> <operator>=</operator> <name>next_index</name><operator>++</operator></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>default_index</name></name> <operator>=</operator> <name><name>mapping</name><index>[<expr><name>default_index</name></expr>]</index></name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

                    <comment type="block">/* All partition must now have a valid mapping */</comment>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>next_index</name> <operator>==</operator> <name>nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block>

            <case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <operator>(</operator><name>PartitionRangeDatumKind</name> <operator>*</operator><operator>*</operator><operator>)</operator>
                        <call><name>palloc</name><argument_list>(<argument><expr><name>ndatums</name> <operator>*</operator>
                               <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeDatumKind</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>ndatums</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator>
                                                        <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

                        <expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator>
                                                                <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PartitionRangeDatumKind</name> <operator>*</operator><operator>)</operator>
                            <call><name>palloc</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator>
                                   <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeDatumKind</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name><name>rbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>kind</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator>
                                    <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>rbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>datums</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
                                              <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypbyval</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
                                              <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttyplen</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            <expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>rbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>kind</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
                        </block_content>}</block></for>

                        <comment type="block">/*
                         * There is no mapping for invalid indexes.
                         *
                         * Any lower bounds in the rbounds array have invalid
                         * indexes assigned, because the values between the
                         * previous bound (if there is one) and this (lower)
                         * bound are not part of the range of any existing
                         * partition.
                         */</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>rbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>lower</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
                        <else>else
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>int</name></type>            <name>orig_index</name> <init>= <expr><name><name>rbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name></expr></init></decl>;</decl_stmt>

                            <comment type="block">/* If the old index has no mapping, assign one */</comment>
                            <if_stmt><if>if <condition>(<expr><name><name>mapping</name><index>[<expr><name>orig_index</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name><name>mapping</name><index>[<expr><name>orig_index</name></expr>]</index></name> <operator>=</operator> <name>next_index</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

                            <expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>mapping</name><index>[<expr><name>orig_index</name></expr>]</index></name></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></for>

					<comment type="block">/* Assign mapped index for the default partition. */</comment>
					<if_stmt><if>if <condition>(<expr><name>default_index</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>default_index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>mapping</name><index>[<expr><name>default_index</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>mapping</name><index>[<expr><name>default_index</name></expr>]</index></name> <operator>=</operator> <name>next_index</name><operator>++</operator></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>default_index</name></name> <operator>=</operator> <name><name>mapping</name><index>[<expr><name>default_index</name></expr>]</index></name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block>

            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected partition strategy: %d"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>

        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>boundinfo</name></name> <operator>=</operator> <name>boundinfo</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Now assign OIDs from the original array into mapped indexes of the
         * result array.  Order of OIDs in the former is defined by the
         * catalog scan that retrieved them, whereas that in the latter is
		 * defined by canonicalized representation of the partition bounds.
         */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name><name>mapping</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name><name>oids</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>mapping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partdesc</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Are two partition bound collections logically equal?
 *
 * Used in the keep logic of relcache.c (ie, in RelationClearRelation()).
 * This is also useful when b1 and b2 are bound collections of two separate
 * relations, respectively, because PartitionBoundInfo is a canonical
 * representation of partition bounds.
 */</comment>
<function><type><name>bool</name></type>
<name>partition_bounds_equal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>parttyplen</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>parttypbyval</name></decl></parameter>,
                       <parameter><decl><type><name>PartitionBoundInfo</name></type> <name>b1</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundInfo</name></type> <name>b2</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>ndatums</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>null_index</name></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>null_index</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>default_index</name></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>default_index</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>greatest_modulus</name> <init>= <expr><call><name>get_hash_partition_greatest_modulus</name><argument_list>(<argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If two hash partitioned tables have different greatest moduli,
		 * their partition schemes don't match.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>greatest_modulus</name> <operator>!=</operator> <call><name>get_hash_partition_greatest_modulus</name><argument_list>(<argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We arrange the partitions in the ascending order of their modulus
		 * and remainders.  Also every modulus is factor of next larger
		 * modulus.  Therefore we can safely store index of a given partition
		 * in indexes array at remainder of that partition.  Also entries at
		 * (remainder + N * modulus) positions in indexes array are all same
		 * for (modulus, remainder) specification for any partition.  Thus
		 * datums array from both the given bounds are same, if and only if
		 * their indexes array will be same.  So, it suffices to compare
		 * indexes array.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>greatest_modulus</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>

		<comment type="block">/*
		 * Nonetheless make sure that the bounds are indeed same when the
		 * indexes match.  Hash partition bound stores modulus and remainder
		 * at b1-&gt;datums[i][0] and b1-&gt;datums[i][1] position respectively.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>b1</name><operator>-&gt;</operator><name>ndatums</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>b1</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>b2</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
					<name><name>b1</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>b2</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>b1</name><operator>-&gt;</operator><name>ndatums</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/* For range partitions, the bounds might not be finite. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* The different kinds of bound all differ from each other */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * Non-finite bounds are equal without further
					 * examination.
					 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
				 * Compare the actual values. Note that it would be both
				 * incorrect and unsafe to invoke the comparison operator
				 * derived from the partitioning specification here.  It would
				 * be incorrect because we want the relcache entry to be
				 * updated for ANY change to the partition bounds, not just
				 * those that the partitioning operator thinks are
				 * significant.  It would be unsafe because we might reach
				 * this code in the context of an aborted transaction, and an
				 * arbitrary partitioning operator might not be safe in that
				 * context.  datumIsEqual() should be simple enough to be
				 * safe.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>datumIsEqual</name><argument_list>(<argument><expr><name><name>b1</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>b2</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
							  <argument><expr><name><name>parttypbyval</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>parttyplen</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* There are ndatums+1 indexes in case of range partitions */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name> <operator>&amp;&amp;</operator>
        <name><name>b1</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a copy of given PartitionBoundInfo structure. The data types of bounds
 * are described by given partition key specificiation.
 */</comment>
<function><type><specifier>extern</specifier> <name>PartitionBoundInfo</name></type>
<name>partition_bounds_copy</name><parameter_list>(<parameter><decl><type><name>PartitionBoundInfo</name></type> <name>src</name></decl></parameter>,
					  <parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>dest</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>ndatums</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>partnatts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>num_indexes</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dest</name> <operator>=</operator> <operator>(</operator><name>PartitionBoundInfo</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionBoundInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>strategy</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ndatums</name> <operator>=</operator> <name><name>dest</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>ndatums</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>partnatts</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</expr_stmt>

	<comment type="block">/* Range partitioned table has an extra index. */</comment>
	<expr_stmt><expr><name>num_indexes</name> <operator>=</operator> <call><name>get_partition_bound_num_indexes</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* List partitioned tables have only a single partition key. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_LIST</name> <operator>||</operator> <name>partnatts</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>datums</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <operator>(</operator><name>PartitionRangeDatumKind</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ndatums</name> <operator>*</operator>
												<sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeDatumKind</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PartitionRangeDatumKind</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>partnatts</name> <operator>*</operator>
												<sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeDatumKind</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dest</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeDatumKind</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>         <name>j</name></decl>;</decl_stmt>

		<comment type="block">/*
		* For a corresponding to hash partition, datums array will have two
		* elements - modulus and remainder.
		*/</comment>
		<decl_stmt><decl><type><name>bool</name></type>        <name>hash_part</name> <init>= <expr><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>         <name>natts</name> <init>= <expr><ternary><condition><expr><name>hash_part</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><name>partnatts</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
		    <decl_stmt><decl><type><name>bool</name></type>        <name>byval</name></decl>;</decl_stmt>
		    <decl_stmt><decl><type><name>int</name></type>         <name>typlen</name></decl>;</decl_stmt>

		    <if_stmt><if>if <condition>(<expr><name>hash_part</name></expr>)</condition>
		    <block>{<block_content>
		        <expr_stmt><expr><name>typlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt> <comment type="block">/* Always int4 */</comment>
		        <expr_stmt><expr><name>byval</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>   <comment type="block">/* int4 is pass-by-value */</comment>
		    </block_content>}</block></if>
		    <else>else
		    <block>{<block_content>
		        <expr_stmt><expr><name>byval</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>parttypbyval</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		        <expr_stmt><expr><name>typlen</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>parttyplen</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		    </block_content>}</block></else></if_stmt>

		    <if_stmt><if>if <condition>(<expr><name><name>dest</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
				<name><name>dest</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
						                       <argument><expr><name>byval</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		</block_content>}</block></for>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>indexes</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dest</name><operator>-&gt;</operator><name>indexes</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>indexes</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>null_index</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>null_index</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>default_index</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>default_index</name></name></expr>;</expr_stmt>

	<return>return <expr><name>dest</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check_new_partition_bound
 *
 * Checks if the new partition's bound overlaps any of the existing partitions
 * of parent.  Also performs additional checks as necessary per strategy.
 */</comment>
<function><type><name>void</name></type>
<name>check_new_partition_bound</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>,
                          <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name> <init>= <expr><name><name>partdesc</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>with</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>overlap</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The default partition bound never conflicts with any other
		 * partition's; if that's what we're attaching, the only possible
		 * problem is that one already exists, so check for that and we're
		 * done.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>boundinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Default partition already exists, error out. */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition \"%s\" conflicts with existing default partition \"%s\""</literal></expr></argument>,
						<argument><expr><name>relname</name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>default_index</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <switch>switch <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
    <block>{<block_content>
		<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name> <operator>&lt;</operator> <name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name> <init>= <expr><name><name>partdesc</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Datum</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>datums</name> <init>= <expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>ndatums</name> <init>= <expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>greatest_modulus</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>remainder</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>offset</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>valid_modulus</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>prev_modulus</name></decl>,	<comment type="block">/* Previous largest modulus */</comment>
								<decl><type ref="prev"/><name>next_modulus</name></decl>;</decl_stmt>	<comment type="block">/* Next largest modulus */</comment>

					<comment type="block">/*
					 * Check rule that every modulus must be a factor of the
					 * next larger modulus.  For example, if you have a bunch
					 * of partitions that all have modulus 5, you can add a
					 * new partition with modulus 10 or a new partition with
					 * modulus 15, but you cannot add both a partition with
					 * modulus 10 and a partition with modulus 15, because 10
					 * is not a factor of 15.
					 *
					 * Get the greatest (modulus, remainder) pair contained in
					 * boundinfo-&gt;datums that is less than or equal to the
					 * (spec-&gt;modulus, spec-&gt;remainder) pair.
					 */</comment>
					<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>partition_hash_bsearch</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>,
													<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name></expr></argument>,
													<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>next_modulus</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>datums</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>valid_modulus</name> <operator>=</operator> <operator>(</operator><name>next_modulus</name> <operator>%</operator> <name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>prev_modulus</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>datums</name><index>[<expr><name>offset</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>valid_modulus</name> <operator>=</operator> <operator>(</operator><name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name> <operator>%</operator> <name>prev_modulus</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>valid_modulus</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>offset</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name>ndatums</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>next_modulus</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>datums</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>valid_modulus</name> <operator>=</operator> <operator>(</operator><name>next_modulus</name> <operator>%</operator> <name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></else></if_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>valid_modulus</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"every hash partition modulus must be a factor of the next larger modulus"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>greatest_modulus</name> <operator>=</operator> <call><name>get_hash_partition_greatest_modulus</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>remainder</name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name></expr>;</expr_stmt>

					<comment type="block">/*
					 * Normally, the lowest remainder that could conflict with
					 * the new partition is equal to the remainder specified
					 * for the new partition, but when the new partition has a
					 * modulus higher than any used so far, we need to adjust.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>remainder</name> <operator>&gt;=</operator> <name>greatest_modulus</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>remainder</name> <operator>=</operator> <name>remainder</name> <operator>%</operator> <name>greatest_modulus</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* Check every potentially-conflicting remainder. */</comment>
					<do>do
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>remainder</name></expr>]</index></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>overlap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>with</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>remainder</name></expr>]</index></name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>remainder</name> <operator>+=</operator> <name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name></expr>;</expr_stmt>
					</block_content>}</block> while <condition>(<expr><name>remainder</name> <operator>&lt;</operator> <name>greatest_modulus</name></expr>)</condition>;</do>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>

        <case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>boundinfo</name> <operator>&amp;&amp;</operator>
                           <name><name>boundinfo</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name> <operator>&amp;&amp;</operator>
                           <operator>(</operator><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
							<call><name>partition_bound_accepts_nulls</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call> <operator>||</operator>
							<call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>spec-&gt;listdatums</argument>)</argument_list></macro>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>Const</name>       <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>val</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>int</name></type>            <name>offset</name></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>bool</name></type>        <name>equal</name></decl>;</decl_stmt>

							<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>partition_list_bsearch</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
														<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>,
															<argument><expr><name>boundinfo</name></expr></argument>,
															<argument><expr><name><name>val</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>equal</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>overlap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>with</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
                                <break>break;</break>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><call><name>partition_bound_accepts_nulls</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>overlap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>with</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>null_index</name></name></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block>
                </block_content>}</block></if></if_stmt>

                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>lower</name></decl>,
                           <decl><type ref="prev"><modifier>*</modifier></type><name>upper</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lower</name> <operator>=</operator> <call><name>make_one_range_bound</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>upper</name> <operator>=</operator> <call><name>make_one_range_bound</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * First check if the resulting range would be empty with
                 * specified lower and upper bounds
                 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>partition_rbound_cmp</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
										 <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>, <argument><expr><name><name>lower</name><operator>-&gt;</operator><name>datums</name></name></expr></argument>,
										 <argument><expr><name><name>lower</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>upper</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"empty range bound specified for partition \"%s\""</literal></expr></argument>,
                                    <argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Specified lower bound %s is greater than or equal to upper bound %s."</literal></expr></argument>,
                                       <argument><expr><call><name>get_range_partbound_string</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><call><name>get_range_partbound_string</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name> <init>= <expr><name><name>partdesc</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type>            <name>offset</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name></type>        <name>equal</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>boundinfo</name> <operator>&amp;&amp;</operator>
						   <name><name>boundinfo</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name> <operator>&amp;&amp;</operator>
						   <operator>(</operator><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
							<call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Test whether the new lower bound (which is treated
                     * inclusively as part of the new partition) lies inside
                     * an existing partition, or in a gap.
                     *
                     * If it's inside an existing partition, the bound at
                     * offset + 1 will be the upper bound of that partition,
                     * and its index will be &gt;= 0.
                     *
                     * If it's in a gap, the bound at offset + 1 will be the
                     * lower bound of the next partition, and its index will
                     * be -1. This is also true if there is no next partition,
                     * since the index array is initialised with an extra -1
                     * at the end.
                     */</comment>
					<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>partition_range_bsearch</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>,
													 <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
													 <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>,
													 <argument><expr><name>boundinfo</name></expr></argument>, <argument><expr><name>lower</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * Check that the new partition will fit in the gap.
                         * For it to fit, the new upper bound must be less
                         * than or equal to the lower bound of the next
                         * partition, if there is one.
                         */</comment>
                        <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>int32</name></type>        <name>cmpval</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>Datum</name> 	   <modifier>*</modifier></type><name>datums</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>PartitionRangeDatumKind</name> <modifier>*</modifier></type><name>kind</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>bool</name></type>		<name>is_lower</name></decl>;</decl_stmt>

							<expr_stmt><expr><name>datums</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
							<expr_stmt><expr><name>kind</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
							<expr_stmt><expr><name>is_lower</name> <operator>=</operator> <operator>(</operator><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

							<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>partition_rbound_cmp</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>,
														  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
														  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>,
														  <argument><expr><name>datums</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>,
														  <argument><expr><name>is_lower</name></expr></argument>, <argument><expr><name>upper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
                            <block>{<block_content>
                                <comment type="block">/*
                                 * The new partition overlaps with the
                                 * existing partition between offset + 1 and
                                 * offset + 2.
                                 */</comment>
                                <expr_stmt><expr><name>overlap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>with</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="block">/*
                         * The new partition overlaps with the existing
                         * partition between offset and offset + 1.
                         */</comment>
                        <expr_stmt><expr><name>overlap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>with</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>

                <break>break;</break>
            </block_content>}</block>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected partition strategy: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><name>overlap</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>with</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition \"%s\" would overlap partition \"%s\""</literal></expr></argument>,
                        <argument><expr><name>relname</name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>with</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check_default_allows_bound
 *
 * This function checks if there exists a row in the default partition that
 * would properly belong to the new partition being added.  If it finds one,
 * it throws an error.
 */</comment>
<function><type><name>void</name></type>
<name>check_default_allows_bound</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>default_rel</name></decl></parameter>,
						   <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>new_spec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_part_constraints</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>def_part_constraints</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>all_parts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>new_part_constraints</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>new_spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name><operator>)</operator></expr>
		?</condition><then> <expr><call><name>get_qual_for_list</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>new_spec</name></expr></argument>)</argument_list></call></expr>
		</then><else>: <expr><call><name>get_qual_for_range</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>new_spec</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>def_part_constraints</name> <operator>=</operator>
		<call><name>get_proposed_default_constraint</name><argument_list>(<argument><expr><name>new_part_constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the existing constraints on the default partition imply that it will
	 * not contain any row that would belong to the new partition, we can
	 * avoid scanning the default partition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PartConstraintImpliedByRelConstraint</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>, <argument><expr><name>def_part_constraints</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition constraint for table \"%s\" is implied by existing constraints"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Scan the default partition and its subpartitions, and check for rows
	 * that do not satisfy the revised partition constraints.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>default_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>all_parts</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>all_parts</name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>all_parts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>part_relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>part_rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>constr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>partition_constraint</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>partqualstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCxt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tupslot</name></decl>;</decl_stmt>

		<comment type="block">/* Lock already taken above. */</comment>
		<if_stmt><if>if <condition>(<expr><name>part_relid</name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>part_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>part_relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the partition constraints on default partition child imply
			 * that it will not contain any row that would belong to the new
			 * partition, we can avoid scanning the child table.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PartConstraintImpliedByRelConstraint</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>,
													 <argument><expr><name>def_part_constraints</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition constraint for table \"%s\" is implied by existing constraints"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>part_rel</name> <operator>=</operator> <name>default_rel</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Only RELKIND_RELATION relations (i.e. leaf partitions) need to be
		 * scanned.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>part_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>part_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipped scanning foreign table \"%s\" which is a partition of default partition \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>constr</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>def_part_constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>partition_constraint</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
			<call><name>map_partition_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>constr</name></expr></argument>,
									<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>part_rel</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Build expression execution states for partition check quals */</comment>
		<expr_stmt><expr><name>partqualstate</name> <operator>=</operator> <call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><name>partition_constraint</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupslot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Switch to per-tuple memory context and reset it for each tuple
		 * produced, so we don't leak memory.
		 */</comment>
		<expr_stmt><expr><name>oldCxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupslot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>tupslot</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecCheck</name><argument_list>(<argument><expr><name>partqualstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"updated partition constraint for default partition \"%s\" would be violated by some row"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* keep the lock until commit */</comment>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * get_partition_parent
 *
 * Returns inheritance parent of a partition by scanning pg_inherits
 *
 * Note: Because this function assumes that the relation whose OID is passed
 * as an argument will have precisely one parent, it should only be called
 * when it is known that the relation is a partition.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_partition_parent</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>catalogRelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>catalogRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_partition_parent_worker</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for parent of relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_partition_parent_worker
 *     Scan the pg_inherits relation to return the OID of the parent of the
 *     given relation
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>get_partition_parent_worker</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>inhRel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>Oid</name></type>         <name>result</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>tuple</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_inherits_inhrelid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_inherits_inhseqno</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
                <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>inhRel</name></expr></argument>, <argument><expr><name>InheritsRelidSeqnoIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
   <block>{<block_content>
       <decl_stmt><decl><type><name>Form_pg_inherits</name></type> <name>form</name> <init>= <expr><operator>(</operator><name>Form_pg_inherits</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>form</name><operator>-&gt;</operator><name>inhparent</name></name></expr>;</expr_stmt>
   </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_partition_ancestors
 *     Obtain ancestors of given relation
 *
 * Returns a list of ancestors of the given relation.
 *
 * Note: Because this function assumes that the relation whose OID is passed
 * as an argument and each ancestor will have precisely one parent, it should
 * only be called when it is known that the relation is a partition.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>get_partition_ancestors</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>Relation</name></type>    <name>inhRel</name></decl>;</decl_stmt>

   <expr_stmt><expr><name>inhRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <expr_stmt><expr><call><name>get_partition_ancestors_worker</name><argument_list>(<argument><expr><name>inhRel</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>inhRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_partition_ancestors_worker
 *     recursive worker for get_partition_ancestors
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_partition_ancestors_worker</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>inhRel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>ancestors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <decl_stmt><decl><type><name>Oid</name></type>         <name>parentOid</name></decl>;</decl_stmt>

   <comment type="block">/* Recursion ends at the topmost level, ie., when there's no parent */</comment>
   <expr_stmt><expr><name>parentOid</name> <operator>=</operator> <call><name>get_partition_parent_worker</name><argument_list>(<argument><expr><name>inhRel</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <if_stmt><if>if <condition>(<expr><name>parentOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
       <return>return;</return></block_content></block></if></if_stmt>

   <expr_stmt><expr><operator>*</operator><name>ancestors</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><operator>*</operator><name>ancestors</name></expr></argument>, <argument><expr><name>parentOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>get_partition_ancestors_worker</name><argument_list>(<argument><expr><name>inhRel</name></expr></argument>, <argument><expr><name>parentOid</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_qual_from_partbound
 *        Given a parser node for partition bound, return the list of executable
 *        expressions as partition constraint
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>get_qual_from_partbound</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>,
                        <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>my_qual</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
    <block>{<block_content>
		<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>my_qual</name> <operator>=</operator> <call><name>get_qual_for_hash</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

        <case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>my_qual</name> <operator>=</operator> <call><name>get_qual_for_list</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>my_qual</name> <operator>=</operator> <call><name>get_qual_for_range</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>spec</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected partition strategy: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <return>return <expr><name>my_qual</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * map_partition_varattnos - maps varattno of any Vars in expr from the
 * attno's of 'from_rel' to the attno's of 'to_rel' partition, each of which
 * may be either a leaf partition or a partitioned table, but both of which
 * must be from the same partitioning hierarchy.
 *
 * Even though all of the same column names must be present in all relations
 * in the hierarchy, and they must also have the same types, the attnos may
 * be different.
 *
 * If found_whole_row is not NULL, *found_whole_row returns whether a
 * whole-row variable was found in the input expression.
 *
 * Note: this will work on any node tree, so really the argument and result
 * should be declared "Node *".  But a substantial majority of the callers
 * are working on Lists, so it's less messy to do the casts internally.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>map_partition_varattnos</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fromrel_varno</name></decl></parameter>,
						<parameter><decl><type><name>Relation</name></type> <name>to_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>from_rel</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>found_whole_row</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>my_found_whole_row</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>part_attnos</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>part_attnos</name> <operator>=</operator> <call><name>convert_tuples_by_name_map</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>to_rel</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>from_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>map_variable_attnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
											<argument><expr><name>fromrel_varno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                        <argument><expr><name>part_attnos</name></expr></argument>,
											<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>from_rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>,
											<argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>to_rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reltype</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>my_found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>found_whole_row</name> <operator>=</operator> <name>my_found_whole_row</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>expr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RelationGetPartitionQual
 *
 * Returns a list of partition quals
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>RelationGetPartitionQual</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Quick exit */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name>generate_partition_qual</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_partition_qual_relid
 *
 * Returns an expression tree describing the passed-in relation's partition
 * constraint.
 *
 * If the relation is not found, or is not a partition, or there is no
 * partition constraint, return NULL.  We must guard against the first two
 * cases because this supports a SQL function that could be passed any OID.
 * The last case can happen even if relispartition is true, when a default
 * partition is the only partition.
 */</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type>
<name>get_partition_qual_relid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Do the work only if this relation exists and is a partition. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>get_rel_relispartition</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    	<decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>and_args</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>and_args</name> <operator>=</operator> <call><name>generate_partition_qual</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Convert implicit-AND list format to boolean expression */</comment>
		<if_stmt><if>if <condition>(<expr><name>and_args</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>and_args</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>and_args</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>and_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Keep the lock, to allow safe deparsing against the rel by caller. */</comment>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_partition_operator
 *
 * Return oid of the operator of given strategy for a given partition key
 * column.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>get_partition_operator</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>, <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>,
                       <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>need_relabel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>operoid</name></decl>;</decl_stmt>

    <comment type="block">/*
     * First check if there exists an operator of the given strategy, with
     * this column's type as both its lefttype and righttype, in the
     * partitioning operator family specified for the column.
     */</comment>
    <expr_stmt><expr><name>operoid</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopfamily</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>,
                                  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>,
                                  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>,
                                  <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If one doesn't exist, we must resort to using an operator in the same
     * operator family but with the operator class declared input type.  It is
     * OK to do so, because the column's type is known to be binary-coercible
     * with the operator class input type (otherwise, the operator class in
     * question would not have been accepted as the partitioning operator
     * class).  We must however inform the caller to wrap the non-Const
     * expression with a RelabelType node to denote the implicit coercion. It
     * ensures that the resulting expression structurally matches similarly
     * processed expressions within the optimizer.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>operoid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>operoid</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopfamily</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>,
                                      <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>,
                                      <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>,
                                      <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>operoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing operator %d(%u,%u) in opfamily %u"</literal></expr></argument>,
                 <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>,
                 <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopfamily</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>need_relabel</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>need_relabel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <return>return <expr><name>operoid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_partition_op_expr
 *        Returns an Expr for the given partition key column with arg1 and
 *        arg2 as its leftop and rightop, respectively
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>make_partition_op_expr</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keynum</name></decl></parameter>,
                       <parameter><decl><type><name>uint16</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>operoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>need_relabel</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Get the correct btree operator for this partitioning column */</comment>
    <expr_stmt><expr><name>operoid</name> <operator>=</operator> <call><name>get_partition_operator</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>keynum</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>need_relabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Chosen operator may be such that the non-Const operand needs to be
     * coerced, so apply the same; see the comment in
     * get_partition_operator().
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>need_relabel</name> <operator>||</operator>
         <name><name>key</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><name>keynum</name></expr>]</index></name> <operator>!=</operator> <name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><name>keynum</name></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>arg1</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeRelabelType</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>,
                                        <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>,
                                        <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                                        <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>,
                                        <argument><expr><name>COERCE_EXPLICIT_CAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Generate the actual expression */</comment>
    <switch>switch <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>saopexpr</name></decl>;</decl_stmt>

                <comment type="block">/* Build leftop = ANY (rightop) */</comment>
                <expr_stmt><expr><name>saopexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>saopexpr</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name>operoid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>saopexpr</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>operoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>saopexpr</name><operator>-&gt;</operator><name>useOr</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>saopexpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><name>keynum</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>saopexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>saopexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>saopexpr</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>make_opclause</name><argument_list>(<argument><expr><name>operoid</name></expr></argument>,
                                   <argument><expr><name>BOOLOID</name></expr></argument>,
                                   <argument><expr><name>false</name></expr></argument>,
                                   <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>,
                                   <argument><expr><name>InvalidOid</name></expr></argument>,
                                   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid partitioning strategy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_qual_for_hash
 *
 * Given a list of partition columns, modulus and remainder corresponding to a
 * partition, this function returns CHECK constraint expression Node for that
 * partition.
 *
 * The partition constraint for a hash partition is always a call to the
 * built-in function satisfies_hash_partition().  The first two arguments are
 * the modulus and remainder for the partition; the remaining arguments are the
 * values to be hashed.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_qual_for_hash</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>relidConst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>modulusConst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>remainderConst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>partexprs_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Fixed arguments. */</comment>
	<expr_stmt><expr><name>relidConst</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>OIDOID</name></expr></argument>,
									<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									<argument><expr><name>InvalidOid</name></expr></argument>,
									<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>,
									<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>false</name></expr></argument>,
									<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>modulusConst</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
									  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									  <argument><expr><name>InvalidOid</name></expr></argument>,
									  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
									  <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>remainderConst</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
										<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										<argument><expr><name>InvalidOid</name></expr></argument>,
										<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
										<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>false</name></expr></argument>,
										<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make3</name><argument_list>(<argument><expr><name>relidConst</name></expr></argument>, <argument><expr><name>modulusConst</name></expr></argument>, <argument><expr><name>remainderConst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partexprs_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add an argument for each key column. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>keyCol</name></decl>;</decl_stmt>

		<comment type="block">/* Left operand */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>keyCol</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypmod</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>keyCol</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>partexprs_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partexprs_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>partexprs_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>keyCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>fexpr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>F_SATISFIES_HASH_PARTITION</name></expr></argument>,
						 <argument><expr><name>BOOLOID</name></expr></argument>,
						 <argument><expr><name>args</name></expr></argument>,
						 <argument><expr><name>InvalidOid</name></expr></argument>,
						 <argument><expr><name>InvalidOid</name></expr></argument>,
						 <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>fexpr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_qual_for_list
 *
 * Returns an implicit-AND list of expressions to use as a list partition's
 * constraint, given the partition key and bound structures.
 *
 * The function returns NIL for a default partition when it's the only
 * partition since in that case there is no constraint.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_qual_for_list</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>keyCol</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArrayExpr</name>  <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>opexpr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>nulltest</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>arrelems</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>list_has_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Only single-column list partitioning is supported, so we are worried
     * only about the partition key with index 0.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Construct Var or expression representing the partition column */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>keyCol</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
                                  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                                  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                                  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypmod</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                                  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                                  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>keyCol</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * For default list partition, collect datums for all the partitions. The
	 * default partition constraint should check that the partition key is
	 * equal to none of those.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ndatums</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>pdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name> <init>= <expr><name><name>pdesc</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>boundinfo</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ndatums</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>partition_bound_accepts_nulls</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>list_has_null</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If default is the only partition, there need not be any partition
		 * constraint on it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ndatums</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>list_has_null</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

			<comment type="block">/* Construct const from datum */</comment>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
							<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypmod</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
							<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
							<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttyplen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
							<argument><expr><operator>*</operator><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>,	<comment type="block">/* isnull */</comment>
							<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypbyval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>arrelems</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>arrelems</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Create list of Consts for the allowed values, excluding any nulls.
		 */</comment>
    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>spec-&gt;listdatums</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Const</name>       <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>list_has_null</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>arrelems</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>arrelems</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block>
	</block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>arrelems</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Construct an ArrayExpr for the non-null partition values */</comment>
        <expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arr</name><operator>-&gt;</operator><name>array_typeid</name></name> <operator>=</operator> <ternary><condition><expr><operator>!</operator><call><name>type_is_array</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>
            ?</condition><then> <expr><call><name>get_array_type</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>
            </then><else>: <expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arr</name><operator>-&gt;</operator><name>array_collid</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arr</name><operator>-&gt;</operator><name>element_typeid</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arr</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <name>arrelems</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arr</name><operator>-&gt;</operator><name>multidims</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

        <comment type="block">/* Generate the main expression, i.e., keyCol = ANY (arr) */</comment>
        <expr_stmt><expr><name>opexpr</name> <operator>=</operator> <call><name>make_partition_op_expr</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
                                        <argument><expr><name>keyCol</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* If there are no partition values, we don't need an = ANY expr */</comment>
        <expr_stmt><expr><name>opexpr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>list_has_null</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Gin up a "col IS NOT NULL" test that will be AND'd with the main
         * expression.  This might seem redundant, but the partition routing
         * machinery needs it.
         */</comment>
        <expr_stmt><expr><name>nulltest</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>keyCol</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NOT_NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><name>opexpr</name></expr> ?</condition><then> <expr><call><name>list_make2</name><argument_list>(<argument><expr><name>nulltest</name></expr></argument>, <argument><expr><name>opexpr</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>nulltest</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Gin up a "col IS NULL" test that will be OR'd with the main
         * expression.
         */</comment>
        <expr_stmt><expr><name>nulltest</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>keyCol</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>opexpr</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>or</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>or</name> <operator>=</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>nulltest</name></expr></argument>, <argument><expr><name>opexpr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>or</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>nulltest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Note that, in general, applying NOT to a constraint expression doesn't
	 * necessarily invert the set of rows it accepts, because NOT (NULL) is
	 * NULL.  However, the partition constraints we construct here never
	 * evaluate to NULL, so applying NOT works as intended.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>make_ands_explicit</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>NOT_EXPR</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_range_key_properties
 *        Returns range partition key information for a given column
 *
 * This is a subroutine for get_qual_for_range, and its API is pretty
 * specialized to that caller.
 *
 * Constructs an Expr for the key column (returned in *keyCol) and Consts
 * for the lower and upper range limits (returned in *lower_val and
 * *upper_val).  For MINVALUE/MAXVALUE limits, NULL is returned instead of
 * a Const.  All of these structures are freshly palloc'd.
 *
 * *partexprs_item points to the cell containing the next expression in
 * the key-&gt;partexprs list, or NULL.  It may be advanced upon return.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_range_key_properties</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keynum</name></decl></parameter>,
                         <parameter><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>ldatum</name></decl></parameter>,
                         <parameter><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>udatum</name></decl></parameter>,
                         <parameter><decl><type><name>ListCell</name> <modifier>*</modifier><modifier>*</modifier></type><name>partexprs_item</name></decl></parameter>,
                         <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>keyCol</name></decl></parameter>,
                         <parameter><decl><type><name>Const</name> <modifier>*</modifier><modifier>*</modifier></type><name>lower_val</name></decl></parameter>, <parameter><decl><type><name>Const</name> <modifier>*</modifier><modifier>*</modifier></type><name>upper_val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Get partition key expression for this column */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>keynum</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>keyCol</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
                                   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>,
                                   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>,
                                   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypmod</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>,
                                   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>,
                                   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>partexprs_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of partition key expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>keyCol</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><operator>*</operator><name>partexprs_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>partexprs_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><operator>*</operator><name>partexprs_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Get appropriate Const nodes for the bounds */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>ldatum</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>lower_val</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>ldatum</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>lower_val</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>udatum</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>upper_val</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>udatum</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>upper_val</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
  * get_range_nulltest
  *
  * A non-default range partition table does not currently allow partition
  * keys to be null, so emit an IS NOT NULL expression for each key column.
  */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_range_nulltest</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>nulltest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>partexprs_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>partexprs_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>keyCol</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>keyCol</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypmod</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>partexprs_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of partition key expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>keyCol</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>partexprs_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partexprs_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>partexprs_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>nulltest</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>keyCol</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NOT_NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>nulltest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_qual_for_range
 *
 * Returns an implicit-AND list of expressions to use as a range partition's
 * constraint, given the partition key and bound structures.
 *
 * For a multi-column range partition key, say (a, b, c), with (al, bl, cl)
 * as the lower bound tuple and (au, bu, cu) as the upper bound tuple, we
 * generate an expression tree of the following form:
 *
 *    (a IS NOT NULL) and (b IS NOT NULL) and (c IS NOT NULL)
 *        AND
 *    (a &gt; al OR (a = al AND b &gt; bl) OR (a = al AND b = bl AND c &gt;= cl))
 *        AND
 *    (a &lt; au OR (a = au AND b &lt; bu) OR (a = au AND b = bu AND c &lt; cu))
 *
 * It is often the case that a prefix of lower and upper bound tuples contains
 * the same values, for example, (al = au), in which case, we will emit an
 * expression tree of the following form:
 *
 *    (a IS NOT NULL) and (b IS NOT NULL) and (c IS NOT NULL)
 *        AND
 *    (a = al)
 *        AND
 *    (b &gt; bl OR (b = bl AND c &gt;= cl))
 *        AND
 *    (b &lt; bu) OR (b = bu AND c &lt; cu))
 *
 * If a bound datum is either MINVALUE or MAXVALUE, these expressions are
 * simplified using the fact that any value is greater than MINVALUE and less
 * than MAXVALUE. So, for example, if cu = MAXVALUE, c &lt; cu is automatically
 * true, and we need not emit any expression for it, and the last line becomes
 *
 *    (b &lt; bu) OR (b = bu), which is simplified to (b &lt;= bu)
 *
 * In most common cases with only one partition column, say a, the following
 * expression tree will be generated: a IS NOT NULL AND a &gt;= al AND a &lt; au
 *
 * For default partition, it returns the negation of the constraints of all
 * the other partitions.
 *
 * External callers should pass for_default as false; we set it to true only
 * when recursing.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_qual_for_range</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>for_default</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell1</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>cell2</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>partexprs_item</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>partexprs_item_saved</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>ldatum</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>udatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>keyCol</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Const</name>       <modifier>*</modifier></type><name>lower_val</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>upper_val</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>lower_or_arms</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>upper_or_arms</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_or_arms</name></decl>,
                <decl><type ref="prev"/><name>current_or_arm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lower_or_start_datum</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>upper_or_start_datum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>need_next_lower_arm</name></decl>,
                <decl><type ref="prev"/><name>need_next_upper_arm</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>or_expr_args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>pdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>inhoids</name> <init>= <expr><name><name>pdesc</name><operator>-&gt;</operator><name>oids</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nparts</name> <init>= <expr><name><name>pdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr></init></decl>,
					<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>inhrelid</name> <init>= <expr><name><name>inhoids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>bspec</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>inhrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>inhrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
									<argument><expr><name>Anum_pg_class_relpartbound</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bspec</name> <operator>=</operator> <operator>(</operator><name>PartitionBoundSpec</name> <operator>*</operator><operator>)</operator>
				<call><name>stringToNode</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>bspec</name></expr></argument>, <argument><expr><name>PartitionBoundSpec</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected PartitionBoundSpec"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bspec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
        <block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>part_qual</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>part_qual</name> <operator>=</operator> <call><name>get_qual_for_range</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>bspec</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * AND the constraints of the partition and add to
				 * or_expr_args
				 */</comment>
				<expr_stmt><expr><name>or_expr_args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>or_expr_args</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>list_length</name><argument_list>(<argument><expr><name>part_qual</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>
									   ?</condition><then> <expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>part_qual</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
									   </then><else>: <expr><call><name>linitial</name><argument_list>(<argument><expr><name>part_qual</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>or_expr_args</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
        <block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>   <modifier>*</modifier></type><name>other_parts_constr</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Combine the constraints obtained for non-default partitions
			 * using OR.  As requested, each of the OR's args doesn't include
			 * the NOT NULL test for partition keys (which is to avoid its
			 * useless repetition).  Add the same now.
			 */</comment>
			<expr_stmt><expr><name>other_parts_constr</name> <operator>=</operator>
						<call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>,
							<argument><expr><call><name>lappend</name><argument_list>(<argument><expr><call><name>get_range_nulltest</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><ternary><condition><expr><call><name>list_length</name><argument_list>(<argument><expr><name>or_expr_args</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>
										?</condition><then> <expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><name>or_expr_args</name></expr></argument>,
													   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
										</then><else>: <expr><call><name>linitial</name><argument_list>(<argument><expr><name>or_expr_args</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Finally, the default partition contains everything *NOT*
			 * contained in the non-default partitions.
			 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>NOT_EXPR</name></expr></argument>,
										<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>other_parts_constr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

		<return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>lower_or_start_datum</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>upper_or_start_datum</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_or_arms</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it is the recursive call for default, we skip the get_range_nulltest
	 * to avoid accumulating the NullTest on the same keys for each partition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>for_default</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_range_nulltest</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Iterate over the key columns and check if the corresponding lower and
     * upper datums are equal using the btree equality operator for the
     * column's type.  If equal, we emit single keyCol = common_value
     * expression.  Starting from the first column for which the corresponding
     * lower and upper bound datums are not equal, we generate OR expressions
     * as shown in the function's header comment.
     */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>partexprs_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>partexprs_item_saved</name> <operator>=</operator> <name>partexprs_item</name></expr>;</expr_stmt>    <comment type="block">/* placate compiler */</comment>
    <macro><name>forboth</name><argument_list>(<argument>cell1</argument>, <argument>spec-&gt;lowerdatums</argument>, <argument>cell2</argument>, <argument>spec-&gt;upperdatums</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>EState</name>       <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>test_expr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>test_exprstate</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>test_result</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isNull</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>ldatum</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>udatum</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Since get_range_key_properties() modifies partexprs_item, and we
         * might need to start over from the previous expression in the later
         * part of this function, save away the current value.
         */</comment>
        <expr_stmt><expr><name>partexprs_item_saved</name> <operator>=</operator> <name>partexprs_item</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>get_range_key_properties</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>ldatum</name></expr></argument>, <argument><expr><name>udatum</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>partexprs_item</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>keyCol</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>lower_val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If either value is NULL, the corresponding partition bound is
         * either MINVALUE or MAXVALUE, and we treat them as unequal, because
         * even if they're the same, there is no common value to equate the
         * key column with.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lower_val</name> <operator>||</operator> <operator>!</operator><name>upper_val</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/* Create the test expression */</comment>
        <expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>test_expr</name> <operator>=</operator> <call><name>make_partition_op_expr</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
                                           <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>lower_val</name></expr></argument>,
                                           <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>upper_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fix_opfuncids</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>test_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>test_exprstate</name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>test_expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>test_result</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name>test_exprstate</name></expr></argument>,
                                                <argument><expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>,
                                                <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If not equal, go generate the OR expressions */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>test_result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/*
         * The bounds for the last key column can't be equal, because such a
         * range partition would never be allowed to be defined (it would have
         * an empty range otherwise).
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid range bound specification"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Equal, so generate keyCol = lower_val expression */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
                         <argument><expr><call><name>make_partition_op_expr</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
                                                <argument><expr><name>keyCol</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>lower_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* First pair of lower_val and upper_val that are not equal. */</comment>
    <expr_stmt><expr><name>lower_or_start_datum</name> <operator>=</operator> <name>cell1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>upper_or_start_datum</name> <operator>=</operator> <name>cell2</name></expr>;</expr_stmt>

    <comment type="block">/* OR will have as many arms as there are key columns left. */</comment>
    <expr_stmt><expr><name>num_or_arms</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>-</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>current_or_arm</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>lower_or_arms</name> <operator>=</operator> <name>upper_or_arms</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>need_next_lower_arm</name> <operator>=</operator> <name>need_next_upper_arm</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>current_or_arm</name> <operator>&lt;</operator> <name>num_or_arms</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>lower_or_arm_args</name> <init>= <expr><name>NIL</name></expr></init></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>upper_or_arm_args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Restart scan of columns from the i'th one */</comment>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>partexprs_item</name> <operator>=</operator> <name>partexprs_item_saved</name></expr>;</expr_stmt>

        <macro><name>for_both_cell</name><argument_list>(<argument>cell1</argument>, <argument>lower_or_start_datum</argument>, <argument>cell2</argument>, <argument>upper_or_start_datum</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>ldatum_next</name> <init>= <expr><name>NULL</name></expr></init></decl>,
                       <decl><type ref="prev"><modifier>*</modifier></type><name>udatum_next</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>ldatum</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>cell1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>ldatum_next</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>,
                                       <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><call><name>lnext</name><argument_list>(<argument><expr><name>cell1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>udatum</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>cell2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>udatum_next</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>,
                                       <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><call><name>lnext</name><argument_list>(<argument><expr><name>cell2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>get_range_key_properties</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>ldatum</name></expr></argument>, <argument><expr><name>udatum</name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>partexprs_item</name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>keyCol</name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>lower_val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>need_next_lower_arm</name> <operator>&amp;&amp;</operator> <name>lower_val</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>uint16</name></type>        <name>strategy</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * For the non-last columns of this arm, use the EQ operator.
                 * For the last column of this arm, use GT, unless this is the
                 * last column of the whole bound check, or the next bound
                 * datum is MINVALUE, in which case use GE.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>j</name> <operator>-</operator> <name>i</name> <operator>&lt;</operator> <name>current_or_arm</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>strategy</name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name>j</name> <operator>==</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>||</operator>
                         <operator>(</operator><name>ldatum_next</name> <operator>&amp;&amp;</operator>
                          <name><name>ldatum_next</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_MINVALUE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>strategy</name> <operator>=</operator> <name>BTGreaterEqualStrategyNumber</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>strategy</name> <operator>=</operator> <name>BTGreaterStrategyNumber</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <expr_stmt><expr><name>lower_or_arm_args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>lower_or_arm_args</name></expr></argument>,
                                            <argument><expr><call><name>make_partition_op_expr</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
                                                                   <argument><expr><name>strategy</name></expr></argument>,
                                                                   <argument><expr><name>keyCol</name></expr></argument>,
                                                                   <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>lower_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>need_next_upper_arm</name> <operator>&amp;&amp;</operator> <name>upper_val</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>uint16</name></type>        <name>strategy</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * For the non-last columns of this arm, use the EQ operator.
                 * For the last column of this arm, use LT, unless the next
                 * bound datum is MAXVALUE, in which case use LE.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>j</name> <operator>-</operator> <name>i</name> <operator>&lt;</operator> <name>current_or_arm</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>strategy</name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name>udatum_next</name> <operator>&amp;&amp;</operator>
                         <name><name>udatum_next</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_MAXVALUE</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>strategy</name> <operator>=</operator> <name>BTLessEqualStrategyNumber</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>strategy</name> <operator>=</operator> <name>BTLessStrategyNumber</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <expr_stmt><expr><name>upper_or_arm_args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>upper_or_arm_args</name></expr></argument>,
                                            <argument><expr><call><name>make_partition_op_expr</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
                                                                   <argument><expr><name>strategy</name></expr></argument>,
                                                                   <argument><expr><name>keyCol</name></expr></argument>,
                                                                   <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>upper_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Did we generate enough of OR's arguments?  First arm considers
             * the first of the remaining columns, second arm considers first
             * two of the remaining columns, and so on.
             */</comment>
            <expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>j</name> <operator>-</operator> <name>i</name> <operator>&gt;</operator> <name>current_or_arm</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * We must not emit any more arms if the new column that will
                 * be considered is unbounded, or this one was.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lower_val</name> <operator>||</operator> <operator>!</operator><name>ldatum_next</name> <operator>||</operator>
                    <name><name>ldatum_next</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>need_next_lower_arm</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>upper_val</name> <operator>||</operator> <operator>!</operator><name>udatum_next</name> <operator>||</operator>
                    <name><name>udatum_next</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>need_next_upper_arm</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <if_stmt><if>if <condition>(<expr><name>lower_or_arm_args</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>lower_or_arms</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>lower_or_arms</name></expr></argument>,
                                    <argument><expr><ternary><condition><expr><call><name>list_length</name><argument_list>(<argument><expr><name>lower_or_arm_args</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>
                                    ?</condition><then> <expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>lower_or_arm_args</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
                                    </then><else>: <expr><call><name>linitial</name><argument_list>(<argument><expr><name>lower_or_arm_args</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>upper_or_arm_args</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>upper_or_arms</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>upper_or_arms</name></expr></argument>,
                                    <argument><expr><ternary><condition><expr><call><name>list_length</name><argument_list>(<argument><expr><name>upper_or_arm_args</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>
                                    ?</condition><then> <expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>upper_or_arm_args</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
                                    </then><else>: <expr><call><name>linitial</name><argument_list>(<argument><expr><name>upper_or_arm_args</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* If no work to do in the next iteration, break away. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_next_lower_arm</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>need_next_upper_arm</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><operator>++</operator><name>current_or_arm</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * Generate the OR expressions for each of lower and upper bounds (if
     * required), and append to the list of implicitly ANDed list of
     * expressions.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>lower_or_arms</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
                         <argument><expr><ternary><condition><expr><call><name>list_length</name><argument_list>(<argument><expr><name>lower_or_arms</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>
                         ?</condition><then> <expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><name>lower_or_arms</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
                         </then><else>: <expr><call><name>linitial</name><argument_list>(<argument><expr><name>lower_or_arms</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>upper_or_arms</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
                         <argument><expr><ternary><condition><expr><call><name>list_length</name><argument_list>(<argument><expr><name>upper_or_arms</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>
                         ?</condition><then> <expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><name>upper_or_arms</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
                         </then><else>: <expr><call><name>linitial</name><argument_list>(<argument><expr><name>upper_or_arms</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * As noted above, for non-default, we return list with constant TRUE. If
	 * the result is NIL during the recursive call for default, it implies
	 * this is the only other partition which can hold every value of the key
	 * except NULL. Hence we return the NullTest result skipped earlier.
	 */</comment>
    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><name>for_default</name></expr>
			?</condition><then> <expr><call><name>get_range_nulltest</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>
			</then><else>: <expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_partition_qual
 *
 * Generate partition predicate from rel's partition bound expression. The
 * function returns a NIL list if there is no predicate.
 *
 * Result expression tree is stored CacheMemoryContext to ensure it survives
 * as long as the relcache entry. But we should be running in a less long-lived
 * working context. To avoid leaking cache memory if this routine fails partway
 * through, we build in working memory and then copy the completed structure
 * into cache memory.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>generate_partition_qual</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>boundDatum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>my_qual</name> <init>= <expr><name>NIL</name></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>parent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found_whole_row</name></decl>;</decl_stmt>

    <comment type="block">/* Guard against stack overflow due to overly deep partition tree */</comment>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Quick copy */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partcheck</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partcheck</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Grab at least an AccessShareLock on the parent table */</comment>
	<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><call><name>get_partition_parent</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get pg_class.relpartbound */</comment>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>,
             <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>boundDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
                                 <argument><expr><name>Anum_pg_class_relpartbound</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
	<block>{<block_content>
	    <decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>bound</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bound</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>PartitionBoundSpec</name></expr></argument>,
                     <argument><expr><call><name>stringToNode</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>boundDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>my_qual</name> <operator>=</operator> <call><name>get_qual_from_partbound</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <comment type="block">/* Add the parent's quals to the list (if any) */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>generate_partition_qual</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>my_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>my_qual</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Change Vars to have partition's attnos instead of the parent's. We do
     * this after we concatenate the parent's quals, because we want every Var
     * in it to bear this relation's attnos. It's safe to assume varno = 1
     * here.
     */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>map_partition_varattnos</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* There can never be a whole-row reference here */</comment>
    <if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected whole-row reference found in partition key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Save a copy in the relcache */</comment>
    <expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partcheck</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Keep the parent locked until commit */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_partition_for_tuple
 *      Finds partition of relation which accepts the partition key specified
 *      in values and isnull
 *
 * Return value is index of the partition (&gt;= 0 and &lt; partdesc-&gt;nparts) if one
 * found or -1 if none found.
 */</comment>
<function><type><name>int</name></type>
<name>get_partition_for_tuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>     <name>bound_offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>part_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PartitionKey</name></type>  <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Route as appropriate based on partitioning strategy. */</comment>
		<switch>switch <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
        <block>{<block_content>
			<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name> <init>= <expr><name><name>partdesc</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>greatest_modulus</name> <init>= <expr><call><name>get_hash_partition_greatest_modulus</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>uint64</name></type>		<name>rowHash</name> <init>= <expr><call><name>compute_hash_value</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>,
														 <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
														 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>part_index</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>rowHash</name> <operator>%</operator> <name>greatest_modulus</name></expr>]</index></name></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>partition_bound_accepts_nulls</name><argument_list>(<argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>part_index</name> <operator>=</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>boundinfo</name><operator>-&gt;</operator><name>null_index</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type>		<name>equal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>bound_offset</name> <operator>=</operator> <call><name>partition_list_bsearch</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
													  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>,
														 <argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>,
													  <argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>bound_offset</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>equal</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>part_index</name> <operator>=</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>bound_offset</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type>		<name>equal</name> <init>= <expr><name>false</name></expr></init></decl>,
								<decl><type ref="prev"/><name>range_partkey_has_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * No range includes NULL, so this will be accepted by the
					 * default partition if there is one, and otherwise
					 * rejected.
					 */</comment>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>range_partkey_has_null</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>range_partkey_has_null</name></expr>)</condition>
                <block>{<block_content>
					<expr_stmt><expr><name>bound_offset</name> <operator>=</operator> <call><name>partition_range_datum_bsearch</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
																 <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>,
														 <argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>,
														<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>,
														 <argument><expr><name>values</name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name>equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * The bound at bound_offset is less than or equal to the
                     * tuple value, so the bound at offset+1 is the upper
                     * bound of the partition we're looking for, if there
                     * actually exists one.
                     */</comment>
                    <expr_stmt><expr><name>part_index</name> <operator>=</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>bound_offset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
				</block_content>}</block>
                    <break>break;</break>

                <default>default:</default>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected partition strategy: %d"</literal></expr></argument>,
                         <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></switch>

        <comment type="block">/*
     * part_index &lt; 0 means we failed to find a partition of this parent.
		 * Use the default partition, if there is one.
		 */</comment>
    <if_stmt><if>if <condition>(<expr><name>part_index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>part_index</name> <operator>=</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>boundinfo</name><operator>-&gt;</operator><name>default_index</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>part_index</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Checks if any of the 'attnums' is a partition key attribute for rel
 *
 * Sets *used_in_expr if any of the 'attnums' is found to be referenced in some
 * partition key expression.  It's possible for a column to be both used
 * directly and as part of an expression; if that happens, *used_in_expr may
 * end up as either true or false.  That's OK for current uses of this
 * function, because *used_in_expr is only used to tailor the error message
 * text.
 */</comment>
<function><type><name>bool</name></type>
<name>has_partition_attrs</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>,
					<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>used_in_expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>partnatts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partexprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>partexprs_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>attnums</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partnatts</name> <operator>=</operator> <call><name>get_partition_natts</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partexprs</name> <operator>=</operator> <call><name>get_partition_exprs</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>partexprs_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>partexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>partattno</name> <init>= <expr><call><name>get_partition_col_attnum</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>partattno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>partattno</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
							  <argument><expr><name>attnums</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>used_in_expr</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>used_in_expr</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Arbitrary expression */</comment>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>partexprs_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>expr_attrs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Find all attributes referenced */</comment>
			<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>expr_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partexprs_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>partexprs_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>, <argument><expr><name>expr_attrs</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>used_in_expr</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>used_in_expr</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort_partition_hbound_cmp
 *
 * We sort hash bounds by modulus, then by remainder.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>qsort_partition_hbound_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionHashBound</name> <modifier>*</modifier></type><name>h1</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>PartitionHashBound</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionHashBound</name> <modifier>*</modifier></type><name>h2</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>PartitionHashBound</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>partition_hbound_cmp</name><argument_list>(<argument><expr><name><name>h1</name><operator>-&gt;</operator><name>modulus</name></name></expr></argument>, <argument><expr><name><name>h1</name><operator>-&gt;</operator><name>remainder</name></name></expr></argument>,
								<argument><expr><name><name>h2</name><operator>-&gt;</operator><name>modulus</name></name></expr></argument>, <argument><expr><name><name>h2</name><operator>-&gt;</operator><name>remainder</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partition_hbound_cmp
 *
 * Compares modulus first, then remainder if modulus are equal.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>partition_hbound_cmp</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>modulus1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>remainder1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>modulus2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>remainder2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>modulus1</name> <operator>&lt;</operator> <name>modulus2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>modulus1</name> <operator>&gt;</operator> <name>modulus2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>modulus1</name> <operator>==</operator> <name>modulus2</name> <operator>&amp;&amp;</operator> <name>remainder1</name> <operator>!=</operator> <name>remainder2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><operator>(</operator><name>remainder1</name> <operator>&gt;</operator> <name>remainder2</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort_partition_list_value_cmp
 *
 * Compare two list partition bound datums
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>qsort_partition_list_value_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>val1</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>PartitionListValue</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator><operator>-&gt;</operator><name>value</name></expr></init></decl>,
                <decl><type ref="prev"/><name>val2</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>PartitionListValue</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator><operator>-&gt;</operator><name>value</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><operator>(</operator><name>PartitionKey</name><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                                           <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                                           <argument><expr><name>val1</name></expr></argument>, <argument><expr><name>val2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_one_range_bound
 *
 * Return a PartitionRangeBound given a list of PartitionRangeDatum elements
 * and a flag telling whether the bound is lower or not.  Made into a function
 * because there are multiple sites that want to use this facility.
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionRangeBound</name> <modifier>*</modifier></type>
<name>make_one_range_bound</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>datums</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lower</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>bound</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>datums</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>bound</name> <operator>=</operator> <operator>(</operator><name>PartitionRangeBound</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeBound</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>datums</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <operator>(</operator><name>PartitionRangeDatumKind</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator>
                                                      <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeDatumKind</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>lower</name></name> <operator>=</operator> <name>lower</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>datums</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>datum</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* What's contained in this range datum? */</comment>
        <expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>datum</name><operator>-&gt;</operator><name>kind</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Const</name>       <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name><name>datum</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid range bound datum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>val</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>bound</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Used when sorting range bounds across all range partitions */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>qsort_partition_rbound_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>b1</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>PartitionRangeBound</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>b2</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>PartitionRangeBound</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><operator>(</operator><name>PartitionKey</name><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>partition_rbound_cmp</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
								<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>, <argument><expr><name><name>b1</name><operator>-&gt;</operator><name>datums</name></name></expr></argument>, <argument><expr><name><name>b1</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>,
								<argument><expr><name><name>b1</name><operator>-&gt;</operator><name>lower</name></name></expr></argument>, <argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partition_rbound_cmp
 *
 * Return for two range bounds whether the 1st one (specified in datum1,
 * kind1, and lower1) is &lt;, =, or &gt; the bound specified in *b2.
 *
 * partnatts, partsupfunc and partcollation give the number of attributes in the
 * bounds to be compared, comparison function to be used and the collations of
 * attributes, respectively.
 *
 * Note that if the values of the two range bounds compare equal, then we take
 * into account whether they are upper or lower bounds, and an upper bound is
 * considered to be smaller than a lower bound. This is important to the way
 * that RelationBuildPartitionDesc() builds the PartitionBoundInfoData
 * structure, which only stores the upper bound of a common boundary between
 * two contiguous partitions.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>partition_rbound_cmp</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>,
                     <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>datums1</name></decl></parameter>, <parameter><decl><type><name>PartitionRangeDatumKind</name> <modifier>*</modifier></type><name>kind1</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name></type> <name>lower1</name></decl></parameter>, <parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>b2</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int32</name></type>        <name>cmpval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* placate compiler */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>datums2</name> <init>= <expr><name><name>b2</name><operator>-&gt;</operator><name>datums</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PartitionRangeDatumKind</name> <modifier>*</modifier></type><name>kind2</name> <init>= <expr><name><name>b2</name><operator>-&gt;</operator><name>kind</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>lower2</name> <init>= <expr><name><name>b2</name><operator>-&gt;</operator><name>lower</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * First, handle cases where the column is unbounded, which should not
         * invoke the comparison procedure, and should not consider any later
         * columns. Note that the PartitionRangeDatumKind enum elements
         * compare the same way as the values they represent.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>kind1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>kind2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>kind1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>kind2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>kind1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>

            <comment type="block">/*
             * The column bounds are both MINVALUE or both MAXVALUE. No later
             * columns should be considered, but we still need to compare
             * whether they are upper or lower bounds.
             */</comment>
            <break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>partcollation</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                                 <argument><expr><name><name>datums1</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                                 <argument><expr><name><name>datums2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * If the comparison is anything other than equal, we're done. If they
     * compare equal though, we still have to consider whether the boundaries
     * are inclusive or exclusive.  Exclusive one is considered smaller of the
     * two.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>lower1</name> <operator>!=</operator> <name>lower2</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>cmpval</name> <operator>=</operator> <ternary><condition><expr><name>lower1</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>cmpval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partition_rbound_datum_cmp
 *
 * Return whether range bound (specified in rb_datums, rb_kind, and rb_lower)
 * is &lt;, =, or &gt; partition key of tuple (tuple_datums)
 *
 * n_tuple_datums, partsupfunc and partcollation give number of attributes in
 * the bounds to be compared, comparison function to be used and the collations
 * of attributes resp.
 *
 */</comment>
<function><type><name>int32</name></type>
<name>partition_rbound_datum_cmp</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>,
                           <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>rb_datums</name></decl></parameter>, <parameter><decl><type><name>PartitionRangeDatumKind</name> <modifier>*</modifier></type><name>rb_kind</name></decl></parameter>,
						   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>tuple_datums</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n_tuple_datums</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>cmpval</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_tuple_datums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>rb_kind</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_MINVALUE</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>rb_kind</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_MAXVALUE</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>partcollation</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                                 <argument><expr><name><name>rb_datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                                 <argument><expr><name><name>tuple_datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>cmpval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partition_list_bsearch
 *		Returns the index of the greatest bound datum that is less than equal
 * 		to the given value or -1 if all of the bound datums are greater
 *
 * *is_equal is set to true if the bound datum at the returned index is equal
 * to the input value.
 */</comment>
<function><type><name>int</name></type>
<name>partition_list_bsearch</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>,
					   <parameter><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name></decl></parameter>,
					   <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_equal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>lo</name></decl>,
				<decl><type ref="prev"/><name>hi</name></decl>,
				<decl><type ref="prev"/><name>mid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lo</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition>
			<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>mid</name> <operator>=</operator> <operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>partcollation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>mid</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
												 <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>is_equal</name> <operator>=</operator> <operator>(</operator><name>cmpval</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>is_equal</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>lo</name></expr>;</return>
</block_content>}</block></function>

                    <comment type="block">/*
 * partition_range_bsearch
 *		Returns the index of the greatest range bound that is less than or
 *		equal to the given range bound or -1 if all of the range bounds are
 *		greater
 *
 * *is_equal is set to true if the range bound at the returned index is equal
 * to the input range bound
                     */</comment>
<function><type><name>int</name></type>
<name>partition_range_bsearch</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>,
						<parameter><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name></decl></parameter>,
						<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>probe</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_equal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>lo</name></decl>,
				<decl><type ref="prev"/><name>hi</name></decl>,
				<decl><type ref="prev"/><name>mid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lo</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>mid</name> <operator>=</operator> <operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>partition_rbound_cmp</name><argument_list>(<argument><expr><name>partnatts</name></expr></argument>, <argument><expr><name>partsupfunc</name></expr></argument>, <argument><expr><name>partcollation</name></expr></argument>,
									  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>mid</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>mid</name></expr>]</index></name></expr></argument>,
									  <argument><expr><operator>(</operator><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>mid</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>,
									  <argument><expr><name>probe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>is_equal</name> <operator>=</operator> <operator>(</operator><name>cmpval</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>is_equal</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></while>

	<return>return <expr><name>lo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partition_range_bsearch
 *		Returns the index of the greatest range bound that is less than or
 *		equal to the given tuple or -1 if all of the range bounds are greater
 *
 * *is_equal is set to true if the range bound at the returned index is equal
 * to the input tuple.
 */</comment>
<function><type><name>int</name></type>
<name>partition_range_datum_bsearch</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>,
							  <parameter><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>nvalues</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_equal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>lo</name></decl>,
                <decl><type ref="prev"/><name>hi</name></decl>,
                <decl><type ref="prev"/><name>mid</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>lo</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>hi</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int32</name></type>        <name>cmpval</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>mid</name> <operator>=</operator> <operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>partition_rbound_datum_cmp</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
											<argument><expr><name>partcollation</name></expr></argument>,
											<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>mid</name></expr>]</index></name></expr></argument>,
											<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>mid</name></expr>]</index></name></expr></argument>,
											<argument><expr><name>values</name></expr></argument>,
											<argument><expr><name>nvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>is_equal</name> <operator>=</operator> <operator>(</operator><name>cmpval</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>is_equal</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>lo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partition_hash_bsearch
 *		Returns the index of the greatest (modulus, remainder) pair that is
 *		less than or equal to the given (modulus, remainder) pair or -1 if
 *		all of them are greater
 */</comment>
<function><type><name>int</name></type>
<name>partition_hash_bsearch</name><parameter_list>(<parameter><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>modulus</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>remainder</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>lo</name></decl>,
				<decl><type ref="prev"/><name>hi</name></decl>,
				<decl><type ref="prev"/><name>mid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lo</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name></decl>,
					<decl><type ref="prev"/><name>bound_modulus</name></decl>,
					<decl><type ref="prev"/><name>bound_remainder</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>mid</name> <operator>=</operator> <operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>bound_modulus</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>mid</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bound_remainder</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>mid</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>partition_hbound_cmp</name><argument_list>(<argument><expr><name>bound_modulus</name></expr></argument>, <argument><expr><name>bound_remainder</name></expr></argument>,
									  <argument><expr><name>modulus</name></expr></argument>, <argument><expr><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>lo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_default_oid_from_partdesc
 *
 * Given a partition descriptor, return the OID of the default partition, if
 * one exists; else, return InvalidOid.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_default_oid_from_partdesc</name><parameter_list>(<parameter><decl><type><name>PartitionDesc</name></type> <name>partdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>partdesc</name> <operator>&amp;&amp;</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>boundinfo</name></name> <operator>&amp;&amp;</operator>
		<call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name><name>partdesc</name><operator>-&gt;</operator><name>boundinfo</name><operator>-&gt;</operator><name>default_index</name></name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_default_partition_oid
 *
 * Given a relation OID, return the OID of the default partition, if one
 * exists.  Use get_default_oid_from_partdesc where possible, for
 * efficiency.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_default_partition_oid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>defaultPartId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PARTRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_partitioned_table</name></type> <name>part_table_form</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>part_table_form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_partitioned_table</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>defaultPartId</name> <operator>=</operator> <name><name>part_table_form</name><operator>-&gt;</operator><name>partdefid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>defaultPartId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * update_default_partition_oid
 *
 * Update pg_partition_table.partdefid with a new default partition OID.
 */</comment>
<function><type><name>void</name></type>
<name>update_default_partition_oid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>defaultPartId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_partitioned_table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_partitioned_table</name></type> <name>part_table_form</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pg_partitioned_table</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>PartitionedRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>PARTRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for partition key of relation %u"</literal></expr></argument>,
			 <argument><expr><name>parentId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>part_table_form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_partitioned_table</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>part_table_form</name><operator>-&gt;</operator><name>partdefid</name></name> <operator>=</operator> <name>defaultPartId</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_partitioned_table</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_partitioned_table</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_proposed_default_constraint
 *
 * This function returns the negation of new_part_constraints, which
 * would be an integral part of the default partition constraints after
 * addition of the partition to which the new_part_constraints belongs.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>get_proposed_default_constraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>new_part_constraints</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>defPartConstraint</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>defPartConstraint</name> <operator>=</operator> <call><name>make_ands_explicit</name><argument_list>(<argument><expr><name>new_part_constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Derive the partition constraints of default partition by negating the
	 * given partition constraints. The partition constraint never evaluates
	 * to NULL, so negating it like this is safe.
	 */</comment>
	<expr_stmt><expr><name>defPartConstraint</name> <operator>=</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>NOT_EXPR</name></expr></argument>,
									 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>defPartConstraint</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>defPartConstraint</name> <operator>=</operator>
		<operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>defPartConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>defPartConstraint</name> <operator>=</operator> <call><name>canonicalize_qual</name><argument_list>(<argument><expr><name>defPartConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>defPartConstraint</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_partition_bound_num_indexes
 *
 * Returns the number of the entries in the partition bound indexes array.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_partition_bound_num_indexes</name><parameter_list>(<parameter><decl><type><name>PartitionBoundInfo</name></type> <name>bound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_indexes</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>bound</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>

			<comment type="block">/*
			 * The number of the entries in the indexes array is same as the
			 * greatest modulus.
			 */</comment>
			<expr_stmt><expr><name>num_indexes</name> <operator>=</operator> <call><name>get_hash_partition_greatest_modulus</name><argument_list>(<argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
			<expr_stmt><expr><name>num_indexes</name> <operator>=</operator> <name><name>bound</name><operator>-&gt;</operator><name>ndatums</name></name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
			<comment type="block">/* Range partitioned table has an extra index. */</comment>
			<expr_stmt><expr><name>num_indexes</name> <operator>=</operator> <name><name>bound</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected partition strategy: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>bound</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>num_indexes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_hash_partition_greatest_modulus
 *
 * Returns the greatest modulus of the hash partition bound. The greatest
 * modulus will be at the end of the datums array because hash partitions are
 * arranged in the ascending order of their modulus and remainders.
 */</comment>
<function><type><name>int</name></type>
<name>get_hash_partition_greatest_modulus</name><parameter_list>(<parameter><decl><type><name>PartitionBoundInfo</name></type> <name>bound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bound</name> <operator>&amp;&amp;</operator> <name><name>bound</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bound</name><operator>-&gt;</operator><name>datums</name></name> <operator>&amp;&amp;</operator> <name><name>bound</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>bound</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>bound</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>bound</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>bound</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * compute_hash_value
 *
 * Compute the hash value for given not null partition key values.
 */</comment>
<function><type><name>uint64</name></type>
<name>compute_hash_value</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>rowHash</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>seed</name> <init>= <expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>HASH_PARTITION_SEED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>hash</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fn_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Compute hash for each datum value by calling respective
			 * datatype-specific hash functions of each partition key
			 * attribute.
			 */</comment>
			<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>FunctionCall2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Form a single 64-bit hash value */</comment>
			<expr_stmt><expr><name>rowHash</name> <operator>=</operator> <call><name>hash_combine64</name><argument_list>(<argument><expr><name>rowHash</name></expr></argument>, <argument><expr><call><name>DatumGetUInt64</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>rowHash</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * satisfies_hash_partition
 *
 * This is an SQL-callable function for use in hash partition constraints.
 * The first three arguments are the parent table OID, modulus, and remainder.
 * The remaining arguments are the value of the partitioning columns (or
 * expressions); these are hashed and the results are combined into a single
 * hash value by calling hash_combine64.
 *
 * Returns true if remainder produced when this computed single hash value is
 * divided by the given modulus is equal to given remainder, otherwise false.
 *
 * See get_qual_for_hash() for usage.
 */</comment>
<function><type><name>Datum</name></type>
<name>satisfies_hash_partition</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<typedef>typedef <type><struct>struct <name>ColumnsHashData</name>
	<block>{
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nkeys</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>variadic_type</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>variadic_typlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>variadic_typbyval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>variadic_typalign</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name><name>partsupfunc</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	}</block></struct></type>			<name>ColumnsHashData</name>;</typedef>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>parentId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>modulus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>remainder</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>seed</name> <init>= <expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>HASH_PARTITION_SEED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnsHashData</name> <modifier>*</modifier></type><name>my_extra</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>rowHash</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Return null if the parent OID, modulus, or remainder is NULL. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>parentId</name> <operator>=</operator> <call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>modulus</name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>remainder</name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sanity check modulus and remainder. */</comment>
	<if_stmt><if>if <condition>(<expr><name>modulus</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"modulus for hash partition must be a positive integer"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>remainder</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"remainder for hash partition must be a non-negative integer"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>remainder</name> <operator>&gt;=</operator> <name>modulus</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"remainder for hash partition must be less than modulus"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Cache hash function information.
	 */</comment>
	<expr_stmt><expr><name>my_extra</name> <operator>=</operator> <operator>(</operator><name>ColumnsHashData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>my_extra</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>relid</name></name> <operator>!=</operator> <name>parentId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>parent</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

		<comment type="block">/* Open parent relation and fetch partition keyinfo */</comment>
		<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>parent</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Reject parent table that is not hash-partitioned. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
			<name><name>key</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a hash partitioned table"</literal></expr></argument>,
							<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_fn_expr_variadic</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name> <init>= <expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>

			<comment type="block">/* complain if wrong number of column values */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>!=</operator> <name>nargs</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of partitioning columns (%d) does not match number of partition keys provided (%d)"</literal></expr></argument>,
								<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* allocate space for our cache */</comment>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator>
			<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>,
								   <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ColumnsHashData</name></expr></argument>, <argument><expr><name>partsupfunc</name></expr></argument>)</argument_list></call> <operator>+</operator>
									   <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>my_extra</name> <operator>=</operator> <operator>(</operator><name>ColumnsHashData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>parentId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</expr_stmt>

			<comment type="block">/* check argument types and save fmgr_infos */</comment>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>argtype</name> <init>= <expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><name>j</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>argtype</name> <operator>!=</operator> <name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name>argtype</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column %d of the partition key has type \"%s\", but supplied value is of type \"%s\""</literal></expr></argument>,
									<argument><expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>fmgr_info_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
							   <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>variadic_array</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* allocate space for our cache -- just one FmgrInfo in this case */</comment>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator>
				<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>,
									   <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ColumnsHashData</name></expr></argument>, <argument><expr><name>partsupfunc</name></expr></argument>)</argument_list></call> <operator>+</operator>
									   <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>my_extra</name> <operator>=</operator> <operator>(</operator><name>ColumnsHashData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>parentId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_type</name></name> <operator>=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>variadic_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_type</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_typlen</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_typbyval</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_typalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* check argument types */</comment>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
				<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>variadic_type</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column %d of the partition key has type \"%s\", but supplied value is of type \"%s\""</literal></expr></argument>,
									<argument><expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

			<expr_stmt><expr><call><name>fmgr_info_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
						   <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Hold lock until commit */</comment>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_type</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nkeys</name> <init>= <expr><name><name>my_extra</name><operator>-&gt;</operator><name>nkeys</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * For a non-variadic call, neither the number of arguments nor their
		 * types can change across calls, so avoid the expense of rechecking
		 * here.
		 */</comment>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>hash</name></decl>;</decl_stmt>

		<comment type="block">/* keys start from fourth argument of function. */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>argno</name> <init>= <expr><name>i</name> <operator>+</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><name>argno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fn_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>FunctionCall2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
								 <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><name>argno</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Form a single 64-bit hash value */</comment>
			<expr_stmt><expr><name>rowHash</name> <operator>=</operator> <call><name>hash_combine64</name><argument_list>(<argument><expr><name>rowHash</name></expr></argument>, <argument><expr><call><name>DatumGetUInt64</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>variadic_array</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>variadic_array</name></expr></argument>,
						  <argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_type</name></name></expr></argument>,
						  <argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_typlen</name></name></expr></argument>,
						  <argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_typbyval</name></name></expr></argument>,
						  <argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_typalign</name></name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>datum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* complain if wrong number of column values */</comment>
		<if_stmt><if>if <condition>(<expr><name>nelems</name> <operator>!=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>nkeys</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of partitioning columns (%d) does not match number of partition keys provided (%d)"</literal></expr></argument>,
							<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>, <argument><expr><name>nelems</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>hash</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>fn_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>FunctionCall2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
								 <argument><expr><name><name>datum</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
								 <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Form a single 64-bit hash value */</comment>
			<expr_stmt><expr><name>rowHash</name> <operator>=</operator> <call><name>hash_combine64</name><argument_list>(<argument><expr><name>rowHash</name></expr></argument>, <argument><expr><call><name>DatumGetUInt64</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>rowHash</name> <operator>%</operator> <name>modulus</name> <operator>==</operator> <name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
