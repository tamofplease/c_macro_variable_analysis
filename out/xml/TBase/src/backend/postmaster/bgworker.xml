<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/postmaster/bgworker.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<comment type="block">/*--------------------------------------------------------------------
 * bgworker.c
 *        POSTGRES pluggable background workers implementation
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *      src/backend/postmaster/bgworker.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/atomics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgworker_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicallauncher.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicalworker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/dsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pg_shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ascii.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timeout.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAgg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHashjoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/squeue.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"audit/audit_fga.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * The postmaster's list of registered background workers, in private memory.
 */</comment>
<decl_stmt><decl><type><name>slist_head</name></type>    <name>BackgroundWorkerList</name> <init>= <expr><call><name>SLIST_STATIC_INIT</name><argument_list>(<argument><expr><name>BackgroundWorkerList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * BackgroundWorkerSlots exist in shared memory and can be accessed (via
 * the BackgroundWorkerArray) by both the postmaster and by regular backends.
 * However, the postmaster cannot take locks, even spinlocks, because this
 * might allow it to crash or become wedged if shared memory gets corrupted.
 * Such an outcome is intolerable.  Therefore, we need a lockless protocol
 * for coordinating access to this data.
 *
 * The 'in_use' flag is used to hand off responsibility for the slot between
 * the postmaster and the rest of the system.  When 'in_use' is false,
 * the postmaster will ignore the slot entirely, except for the 'in_use' flag
 * itself, which it may read.  In this state, regular backends may modify the
 * slot.  Once a backend sets 'in_use' to true, the slot becomes the
 * responsibility of the postmaster.  Regular backends may no longer modify it,
 * but the postmaster may examine it.  Thus, a backend initializing a slot
 * must fully initialize the slot - and insert a write memory barrier - before
 * marking it as in use.
 *
 * As an exception, however, even when the slot is in use, regular backends
 * may set the 'terminate' flag for a slot, telling the postmaster not
 * to restart it.  Once the background worker is no longer running, the slot
 * will be released for reuse.
 *
 * In addition to coordinating with the postmaster, backends modifying this
 * data structure must coordinate with each other.  Since they can take locks,
 * this is straightforward: any backend wishing to manipulate a slot must
 * take BackgroundWorkerLock in exclusive mode.  Backends wishing to read
 * data that might get concurrently modified by other backends should take
 * this lock in shared mode.  No matter what, backends reading this data
 * structure must be able to tolerate concurrent modifications by the
 * postmaster.
 */</comment>
<typedef>typedef <type><struct>struct <name>BackgroundWorkerSlot</name>
<block>{
    <decl_stmt><decl><type><name>bool</name></type>        <name>in_use</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>terminate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pid_t</name></type>        <name>pid</name></decl>;</decl_stmt>            <comment type="block">/* InvalidPid = not started yet; 0 = dead */</comment>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>generation</name></decl>;</decl_stmt>        <comment type="block">/* incremented when slot is recycled */</comment>
    <decl_stmt><decl><type><name>BackgroundWorker</name></type> <name>worker</name></decl>;</decl_stmt>
}</block></struct></type> <name>BackgroundWorkerSlot</name>;</typedef>

<comment type="block">/*
 * In order to limit the total number of parallel workers (according to
 * max_parallel_workers GUC), we maintain the number of active parallel
 * workers.  Since the postmaster cannot take locks, two variables are used for
 * this purpose: the number of registered parallel workers (modified by the
 * backends, protected by BackgroundWorkerLock) and the number of terminated
 * parallel workers (modified only by the postmaster, lockless).  The active
 * number of parallel workers is the number of registered workers minus the
 * terminated ones.  These counters can of course overflow, but it's not
 * important here since the subtraction will still give the right number.
 */</comment>
<typedef>typedef <type><struct>struct <name>BackgroundWorkerArray</name>
<block>{
    <decl_stmt><decl><type><name>int</name></type>            <name>total_slots</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>parallel_register_count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>parallel_terminate_count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BackgroundWorkerSlot</name></type> <name><name>slot</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>BackgroundWorkerArray</name>;</typedef>

<struct>struct <name>BackgroundWorkerHandle</name>
<block>{
    <decl_stmt><decl><type><name>int</name></type>            <name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>generation</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>BackgroundWorkerArray</name> <modifier>*</modifier></type><name>BackgroundWorkerData</name></decl>;</decl_stmt>

<comment type="block">/*
 * List of internal background worker entry points.  We need this for
 * reasons explained in LookupBackgroundWorkerFunction(), below.
 */</comment>
<struct><specifier>static</specifier> <specifier>const</specifier> struct
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fn_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bgworker_main_type</name></type> <name>fn_addr</name></decl>;</decl_stmt>
}</block>            <decl><name><name>InternalBGWorkers</name><index>[]</index></name> <init>=

<expr><block>{
    <expr><block>{
        <expr><literal type="string">"ParallelWorkerMain"</literal></expr>, <expr><name>ParallelWorkerMain</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr><literal type="string">"ApplyLauncherMain"</literal></expr>, <expr><name>ApplyLauncherMain</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr><literal type="string">"ApplyWorkerMain"</literal></expr>, <expr><name>ApplyWorkerMain</name></expr>
    }</block></expr>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    ,<expr><block>{
        <expr><literal type="string">"ApplyAuditFgaMain"</literal></expr>, <expr><name>ApplyAuditFgaMain</name></expr>
    }</block></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</struct>

<comment type="block">/* Private functions. */</comment>
<function_decl><type><specifier>static</specifier> <name>bgworker_main_type</name></type> <name>LookupBackgroundWorkerFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>libraryname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Calculate shared memory needed.
 */</comment>
<function><type><name>Size</name></type>
<name>BackgroundWorkerShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type>        <name>size</name></decl>;</decl_stmt>

    <comment type="block">/* Array of workers is variably sized. */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>BackgroundWorkerArray</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>max_worker_processes</name></expr></argument>,
                                   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BackgroundWorkerSlot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize shared memory.
 */</comment>
<function><type><name>void</name></type>
<name>BackgroundWorkerShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>BackgroundWorkerData</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Background Worker Data"</literal></expr></argument>,
                                           <argument><expr><call><name>BackgroundWorkerShmemSize</name><argument_list>()</argument_list></call></expr></argument>,
                                           <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>slist_iter</name></type>    <name>siter</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>slotno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>total_slots</name></name> <operator>=</operator> <name>max_worker_processes</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>parallel_register_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>parallel_terminate_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/*
         * Copy contents of worker list into shared memory.  Record the shared
         * memory slot assigned to each worker.  This ensures a 1-to-1
         * correspondence between the postmaster's private list and the array
         * in shared memory.
         */</comment>
        <macro><name>slist_foreach</name><argument_list>(<argument>siter</argument>, <argument>&amp;BackgroundWorkerList</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>BackgroundWorkerSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>&amp;</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>rw</name> <operator>=</operator> <call><name>slist_container</name><argument_list>(<argument><expr><name>RegisteredBgWorker</name></expr></argument>, <argument><expr><name>rw_lnode</name></expr></argument>, <argument><expr><name><name>siter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slotno</name> <operator>&lt;</operator> <name>max_worker_processes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>in_use</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>terminate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name>InvalidPid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>generation</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_shmem_slot</name></name> <operator>=</operator> <name>slotno</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_notify_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <comment type="block">/* might be reinit after crash */</comment>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>worker</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BackgroundWorker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>++</operator><name>slotno</name></expr>;</expr_stmt>
        </block_content>}</block>

        <comment type="block">/*
         * Mark any remaining slots as not in use.
         */</comment>
        <while>while <condition>(<expr><name>slotno</name> <operator>&lt;</operator> <name>max_worker_processes</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>BackgroundWorkerSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>&amp;</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>in_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>++</operator><name>slotno</name></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Search the postmaster's backend-private list of RegisteredBgWorker objects
 * for the one that maps to the given slot number.
 */</comment>
<function><type><specifier>static</specifier> <name>RegisteredBgWorker</name> <modifier>*</modifier></type>
<name>FindRegisteredWorkerBySlotNumber</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>slist_iter</name></type>    <name>siter</name></decl>;</decl_stmt>

    <macro><name>slist_foreach</name><argument_list>(<argument>siter</argument>, <argument>&amp;BackgroundWorkerList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>rw</name> <operator>=</operator> <call><name>slist_container</name><argument_list>(<argument><expr><name>RegisteredBgWorker</name></expr></argument>, <argument><expr><name>rw_lnode</name></expr></argument>, <argument><expr><name><name>siter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_shmem_slot</name></name> <operator>==</operator> <name>slotno</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>rw</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Notice changes to shared memory made by other backends.  This code
 * runs in the postmaster, so we must be very careful not to assume that
 * shared memory contents are sane.  Otherwise, a rogue backend could take
 * out the postmaster.
 */</comment>
<function><type><name>void</name></type>
<name>BackgroundWorkerStateChange</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>slotno</name></decl>;</decl_stmt>

    <comment type="block">/*
     * The total number of slots stored in shared memory should match our
     * notion of max_worker_processes.  If it does not, something is very
     * wrong.  Further down, we always refer to this value as
     * max_worker_processes, in case shared memory gets corrupted while we're
     * looping.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>max_worker_processes</name> <operator>!=</operator> <name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>total_slots</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
             <argument><expr><literal type="string">"inconsistent background worker state (max_worker_processes=%d, total_slots=%d"</literal></expr></argument>,
             <argument><expr><name>max_worker_processes</name></expr></argument>,
             <argument><expr><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>total_slots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Iterate through slots, looking for newly-registered workers or workers
     * who must die.
     */</comment>
    <for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name>max_worker_processes</name></expr>;</condition> <incr><expr><operator>++</operator><name>slotno</name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BackgroundWorkerSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>&amp;</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>slot</name><operator>-&gt;</operator><name>in_use</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Make sure we don't see the in_use flag before the updated slot
         * contents.
         */</comment>
        <expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* See whether we already know about this worker. */</comment>
        <expr_stmt><expr><name>rw</name> <operator>=</operator> <call><name>FindRegisteredWorkerBySlotNumber</name><argument_list>(<argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>rw</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * In general, the worker data can't change after it's initially
             * registered.  However, someone can set the terminate flag.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>terminate</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rw</name><operator>-&gt;</operator><name>rw_terminate</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_terminate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Report never-started, now-terminated worker as dead. */</comment>
                    <expr_stmt><expr><call><name>ReportBackgroundWorkerPID</name><argument_list>(<argument><expr><name>rw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If the worker is marked for termination, we don't need to add it to
         * the registered workers list; we can just free the slot. However, if
         * bgw_notify_pid is set, the process that registered the worker may
         * need to know that we've processed the terminate request, so be sure
         * to signal it.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>terminate</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>notify_pid</name></decl>;</decl_stmt>

            <comment type="block">/*
             * We need a memory barrier here to make sure that the load of
             * bgw_notify_pid and the update of parallel_terminate_count
             * complete before the store to in_use.
             */</comment>
            <expr_stmt><expr><name>notify_pid</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_notify_pid</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_CLASS_PARALLEL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>parallel_terminate_count</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>in_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>notify_pid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>notify_pid</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Copy the registration data into the registered workers list.
         */</comment>
        <expr_stmt><expr><name>rw</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RegisteredBgWorker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>rw</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Copy strings in a paranoid way.  If shared memory is corrupted, the
         * source data might not even be NUL-terminated.
         */</comment>
        <expr_stmt><expr><call><name>ascii_safe_strlcpy</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_name</name></name></expr></argument>,
                           <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_name</name></name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ascii_safe_strlcpy</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_library_name</name></name></expr></argument>,
                           <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_library_name</name></name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ascii_safe_strlcpy</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_function_name</name></name></expr></argument>,
                           <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_function_name</name></name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Copy various fixed-size fields.
         *
         * flags, start_time, and restart_time are examined by the postmaster,
         * but nothing too bad will happen if they are corrupted.  The
         * remaining fields will only be examined by the child process.  It
         * might crash, but we won't.
         */</comment>
        <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_flags</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_flags</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_start_time</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_start_time</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_restart_time</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_restart_time</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_main_arg</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_main_arg</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_extra</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_extra</name></name></expr></argument>, <argument><expr><name>BGW_EXTRALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Copy the PID to be notified about state changes, but only if the
         * postmaster knows about a backend with that PID.  It isn't an error
         * if the postmaster doesn't know about the PID, because the backend
         * that requested the worker could have died (or been killed) just
         * after doing so.  Nonetheless, at least until we get some experience
         * with how this plays out in the wild, log a message at a relative
         * high debug level.
         */</comment>
        <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_notify_pid</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_notify_pid</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PostmasterMarkPIDForWorkerNotify</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_notify_pid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"worker notification PID %lu is not valid"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_notify_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_notify_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Initialize postmaster bookkeeping. */</comment>
        <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_backend</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_child_slot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_crashed_at</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_shmem_slot</name></name> <operator>=</operator> <name>slotno</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_terminate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <comment type="block">/* Log it! */</comment>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"registering background worker \"%s\""</literal></expr></argument>,
                        <argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>slist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BackgroundWorkerList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rw</name><operator>-&gt;</operator><name>rw_lnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Forget about a background worker that's no longer needed.
 *
 * The worker must be identified by passing an slist_mutable_iter that
 * points to it.  This convention allows deletion of workers during
 * searches of the worker list, and saves having to search the list again.
 *
 * This function must be invoked only in the postmaster.
 */</comment>
<function><type><name>void</name></type>
<name>ForgetBackgroundWorker</name><parameter_list>(<parameter><decl><type><name>slist_mutable_iter</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BackgroundWorkerSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rw</name> <operator>=</operator> <call><name>slist_container</name><argument_list>(<argument><expr><name>RegisteredBgWorker</name></expr></argument>, <argument><expr><name>rw_lnode</name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_shmem_slot</name></name> <operator>&lt;</operator> <name>max_worker_processes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_shmem_slot</name></name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_CLASS_PARALLEL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>parallel_terminate_count</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>in_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unregistering background worker \"%s\""</literal></expr></argument>,
                    <argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>slist_delete_current</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>rw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Report the PID of a newly-launched background worker in shared memory.
 *
 * This function should only be called from the postmaster.
 */</comment>
<function><type><name>void</name></type>
<name>ReportBackgroundWorkerPID</name><parameter_list>(<parameter><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BackgroundWorkerSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_shmem_slot</name></name> <operator>&lt;</operator> <name>max_worker_processes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_shmem_slot</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_notify_pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_notify_pid</name></name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Report that the PID of a background worker is now zero because a
 * previously-running background worker has exited.
 *
 * This function should only be called from the postmaster.
 */</comment>
<function><type><name>void</name></type>
<name>ReportBackgroundWorkerExit</name><parameter_list>(<parameter><decl><type><name>slist_mutable_iter</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BackgroundWorkerSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>notify_pid</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rw</name> <operator>=</operator> <call><name>slist_container</name><argument_list>(<argument><expr><name>RegisteredBgWorker</name></expr></argument>, <argument><expr><name>rw_lnode</name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_shmem_slot</name></name> <operator>&lt;</operator> <name>max_worker_processes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_shmem_slot</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>notify_pid</name> <operator>=</operator> <name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_notify_pid</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * If this worker is slated for deregistration, do that before notifying
     * the process which started it.  Otherwise, if that process tries to
     * reuse the slot immediately, it might not be available yet.  In theory
     * that could happen anyway if the process checks slot-&gt;pid at just the
     * wrong moment, but this makes the window narrower.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_terminate</name></name> <operator>||</operator>
        <name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_restart_time</name></name> <operator>==</operator> <name>BGW_NEVER_RESTART</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ForgetBackgroundWorker</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>notify_pid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>notify_pid</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Cancel SIGUSR1 notifications for a PID belonging to an exiting backend.
 *
 * This function should only be called from the postmaster.
 */</comment>
<function><type><name>void</name></type>
<name>BackgroundWorkerStopNotifications</name><parameter_list>(<parameter><decl><type><name>pid_t</name></type> <name>pid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>slist_iter</name></type>    <name>siter</name></decl>;</decl_stmt>

    <macro><name>slist_foreach</name><argument_list>(<argument>siter</argument>, <argument>&amp;BackgroundWorkerList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>rw</name> <operator>=</operator> <call><name>slist_container</name><argument_list>(<argument><expr><name>RegisteredBgWorker</name></expr></argument>, <argument><expr><name>rw_lnode</name></expr></argument>, <argument><expr><name><name>siter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_notify_pid</name></name> <operator>==</operator> <name>pid</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_notify_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Reset background worker crash state.
 *
 * We assume that, after a crash-and-restart cycle, background workers without
 * the never-restart flag should be restarted immediately, instead of waiting
 * for bgw_restart_time to elapse.
 */</comment>
<function><type><name>void</name></type>
<name>ResetBackgroundWorkerCrashTimes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>slist_mutable_iter</name></type> <name>iter</name></decl>;</decl_stmt>

    <macro><name>slist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;BackgroundWorkerList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>rw</name> <operator>=</operator> <call><name>slist_container</name><argument_list>(<argument><expr><name>RegisteredBgWorker</name></expr></argument>, <argument><expr><name>rw_lnode</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_restart_time</name></name> <operator>==</operator> <name>BGW_NEVER_RESTART</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Workers marked BGW_NVER_RESTART shouldn't get relaunched after
             * the crash, so forget about them.  (If we wait until after the
             * crash to forget about them, and they are parallel workers,
             * parallel_terminate_count will get incremented after we've
             * already zeroed parallel_register_count, which would be bad.)
             */</comment>
            <expr_stmt><expr><call><name>ForgetBackgroundWorker</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * The accounting which we do via parallel_register_count and
             * parallel_terminate_count would get messed up if a worker marked
             * parallel could survive a crash and restart cycle. All such
             * workers should be marked BGW_NEVER_RESTART, and thus control
             * should never reach this branch.
             */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_CLASS_PARALLEL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Allow this worker to be restarted immediately after we finish
             * resetting.
             */</comment>
            <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_crashed_at</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
<comment type="block">/*
 * In EXEC_BACKEND mode, workers use this to retrieve their details from
 * shared memory.
 */</comment>
<function><type><name>BackgroundWorker</name> <modifier>*</modifier></type>
<name>BackgroundWorkerEntry</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>BackgroundWorker</name></type> <name>myEntry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BackgroundWorkerSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slotno</name> <operator>&lt;</operator> <name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>total_slots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>in_use</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* must copy this in case we don't intend to retain shmem access */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myEntry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>worker</name></name></expr></argument>, <argument><expr><sizeof>sizeof <name>myEntry</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>&amp;</operator><name>myEntry</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Complain about the BackgroundWorker definition using error level elevel.
 * Return true if it looks ok, false if not (unless elevel &gt;= ERROR, in
 * which case we won't return at all in the not-OK case).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SanityCheckBackgroundWorker</name><parameter_list>(<parameter><decl><type><name>BackgroundWorker</name> <modifier>*</modifier></type><name>worker</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* sanity check for flags */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_BACKEND_DATABASE_CONNECTION</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>worker</name><operator>-&gt;</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_SHMEM_ACCESS</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"background worker \"%s\": must attach to shared memory in order to request a database connection"</literal></expr></argument>,
                            <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_start_time</name></name> <operator>==</operator> <name>BgWorkerStart_PostmasterStart</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"background worker \"%s\": cannot request database access if starting at postmaster start"</literal></expr></argument>,
                            <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* XXX other checks? */</comment>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>worker</name><operator>-&gt;</operator><name>bgw_restart_time</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
         <name><name>worker</name><operator>-&gt;</operator><name>bgw_restart_time</name></name> <operator>!=</operator> <name>BGW_NEVER_RESTART</name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name><name>worker</name><operator>-&gt;</operator><name>bgw_restart_time</name></name> <operator>&gt;</operator> <name>USECS_PER_DAY</name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"background worker \"%s\": invalid restart interval"</literal></expr></argument>,
                        <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Parallel workers may not be configured for restart, because the
     * parallel_register_count/parallel_terminate_count accounting can't
     * handle parallel workers lasting through a crash-and-restart cycle.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_restart_time</name></name> <operator>!=</operator> <name>BGW_NEVER_RESTART</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>worker</name><operator>-&gt;</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_CLASS_PARALLEL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"background worker \"%s\": parallel workers may not be configured for restart"</literal></expr></argument>,
                        <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bgworker_quickdie</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>, <argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* prevent nested calls */</comment>
    <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We DO NOT want to run proc_exit() callbacks -- we're here because
     * shared memory may be corrupted, so we don't want to try to clean up our
     * transaction.  Just nail the windows shut and get out of town.  Now that
     * there's an atexit callback to prevent third-party code from breaking
     * things by calling exit() directly, we have to reset the callbacks
     * explicitly to make this work as intended.
     */</comment>
    <expr_stmt><expr><call><name>on_exit_reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Note we do exit(2) not exit(0).  This is to force the postmaster into a
     * system reset cycle if some idiot DBA sends a manual SIGQUIT to a random
     * backend.  This is necessary precisely because we don't clean up our
     * shared memory state.  (The "dead man switch" mechanism in pmsignal.c
     * should ensure the postmaster sees this as a crash, too, but no harm in
     * being doubly sure.)
     */</comment>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Standard SIGTERM handler for background workers
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bgworker_die</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ADMIN_SHUTDOWN</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating background worker \"%s\" due to administrator command"</literal></expr></argument>,
                    <argument><expr><name><name>MyBgworkerEntry</name><operator>-&gt;</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Standard SIGUSR1 handler for unconnected workers
 *
 * Here, we want to make sure an unconnected worker will at least heed
 * latch activity.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bgworker_sigusr1_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>latch_sigusr1_handler</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Start a new background worker
 *
 * This is the main entry point for background worker, to be called from
 * postmaster.
 */</comment>
<function><type><name>void</name></type>
<name>StartBackgroundWorker</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>sigjmp_buf</name></type>    <name>local_sigjmp_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>buf</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BackgroundWorker</name> <modifier>*</modifier></type><name>worker</name> <init>= <expr><name>MyBgworkerEntry</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bgworker_main_type</name></type> <name>entrypt</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>worker</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"unable to find bgworker entry"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>IsBackgroundWorker</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/* Identify myself via ps */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"bgworker: %s"</literal></expr></argument>, <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_ps_display</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we're not supposed to have shared memory access, then detach from
     * shared memory.  If we didn't request shared memory access, the
     * postmaster won't force a cluster-wide restart if we exit unexpectedly,
     * so we'd better make sure that we don't mess anything up that would
     * require that sort of cleanup.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>worker</name><operator>-&gt;</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_SHMEM_ACCESS</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>dsm_detach_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PGSharedMemoryDetach</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>InitProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Apply PostAuthDelay */</comment>
    <if_stmt><if>if <condition>(<expr><name>PostAuthDelay</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>PostAuthDelay</name> <operator>*</operator> <literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Set up signal handlers.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_BACKEND_DATABASE_CONNECTION</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * SIGINT is used to signal canceling the current action
         */</comment>
        <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>StatementCancelHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>procsignal_sigusr1_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGFPE</name></expr></argument>, <argument><expr><name>FloatExceptionHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* XXX Any other handlers needed here? */</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>bgworker_sigusr1_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGFPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>bgworker_die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>bgworker_quickdie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>InitializeTimeouts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* establishes SIGALRM handler */</comment>

    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If an exception is encountered, processing resumes here.
     *
     * See notes in postgres.c about the design of this coding.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>sigsetjmp</name><argument_list>(<argument><expr><name>local_sigjmp_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Since not using PG_TRY, must reset error stack by hand */</comment>
        <expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <comment type="block">/* Prevent interrupts while cleaning up */</comment>
        <expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Report the error to the server log */</comment>
        <expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ParallelSendEreport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ParallelHashJoinEreport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ReDistributeEreport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>ParallelDsmDetach</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * Do we need more cleanup here?  For shmem-connected bgworkers, we
         * will call InitProcess below, which will install ProcKill as exit
         * callback.  That will take care of releasing locks, etc.
         */</comment>

        <comment type="block">/* and go away */</comment>
        <expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We can now handle ereport(ERROR) */</comment>
    <expr_stmt><expr><name>PG_exception_stack</name> <operator>=</operator> <operator>&amp;</operator><name>local_sigjmp_buf</name></expr>;</expr_stmt>

    <comment type="block">/*
     * If the background worker request shared memory access, set that up now;
     * else, detach all shared memory segments.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_SHMEM_ACCESS</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Early initialization.  Some of this could be useful even for
         * background workers that aren't using shared memory, but they can
         * call the individual startup routines for those subsystems if
         * needed.
         */</comment>
        <expr_stmt><expr><call><name>BaseInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Create a per-backend PGPROC struct in shared memory, except in the
         * EXEC_BACKEND case where this was done in SubPostmasterMain. We must
         * do this before we can use LWLocks (and in the EXEC_BACKEND case we
         * already had to do some stuff with LWLocks).
         */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
        <expr_stmt><expr><call><name>InitProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Look up the entry point function, loading its library if necessary.
     */</comment>
    <expr_stmt><expr><name>entrypt</name> <operator>=</operator> <call><name>LookupBackgroundWorkerFunction</name><argument_list>(<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_library_name</name></name></expr></argument>,
                                             <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_function_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Note that in normal processes, we would call InitPostgres here.  For a
     * worker, however, we don't know what database to connect to, yet; so we
     * need to wait until the user code does it via
     * BackgroundWorkerInitializeConnection().
     */</comment>

    <comment type="block">/*
     * Now invoke the user-defined worker code
     */</comment>
    <expr_stmt><expr><call><name>entrypt</name><argument_list>(<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_main_arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* ... and if it returns, we're done */</comment>
    <expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Register a new static background worker.
 *
 * This can only be called directly from postmaster or in the _PG_init
 * function of a module library that's loaded by shared_preload_libraries;
 * otherwise it will have no effect.
 */</comment>
<function><type><name>void</name></type>
<name>RegisterBackgroundWorker</name><parameter_list>(<parameter><decl><type><name>BackgroundWorker</name> <modifier>*</modifier></type><name>worker</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>numworkers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"registering background worker \"%s\""</literal></expr></argument>, <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>process_shared_preload_libraries_in_progress</name> <operator>&amp;&amp;</operator>
        <call><name>strcmp</name><argument_list>(<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_library_name</name></name></expr></argument>, <argument><expr><literal type="string">"postgres"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"background worker \"%s\": must be registered in shared_preload_libraries"</literal></expr></argument>,
                            <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SanityCheckBackgroundWorker</name><argument_list>(<argument><expr><name>worker</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_notify_pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"background worker \"%s\": only dynamic background workers can request notification"</literal></expr></argument>,
                        <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Enforce maximum number of workers.  Note this is overly restrictive: we
     * could allow more non-shmem-connected workers, because these don't count
     * towards the MAX_BACKENDS limit elsewhere.  For now, it doesn't seem
     * important to relax this restriction.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>++</operator><name>numworkers</name> <operator>&gt;</operator> <name>max_worker_processes</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIGURATION_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many background workers"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail_plural</name><argument_list>(<argument><expr><literal type="string">"Up to %d background worker can be registered with the current settings."</literal></expr></argument>,
                                  <argument><expr><literal type="string">"Up to %d background workers can be registered with the current settings."</literal></expr></argument>,
                                  <argument><expr><name>max_worker_processes</name></expr></argument>,
                                  <argument><expr><name>max_worker_processes</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider increasing the configuration parameter \"max_worker_processes\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Copy the registration data into the registered workers list.
     */</comment>
    <expr_stmt><expr><name>rw</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RegisteredBgWorker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rw</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name></name> <operator>=</operator> <operator>*</operator><name>worker</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_backend</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_child_slot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_crashed_at</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_terminate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>slist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BackgroundWorkerList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rw</name><operator>-&gt;</operator><name>rw_lnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Register a new background worker from a regular backend.
 *
 * Returns true on success and false on failure.  Failure typically indicates
 * that no background worker slots are currently available.
 *
 * If handle != NULL, we'll set *handle to a pointer that can subsequently
 * be used as an argument to GetBackgroundWorkerPid().  The caller can
 * free this pointer using pfree(), if desired.
 */</comment>
<function><type><name>bool</name></type>
<name>RegisterDynamicBackgroundWorker</name><parameter_list>(<parameter><decl><type><name>BackgroundWorker</name> <modifier>*</modifier></type><name>worker</name></decl></parameter>,
                                <parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier><modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>slotno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>success</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>parallel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>generation</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * We can't register dynamic background workers from the postmaster. If
     * this is a standalone backend, we're the only process and can't start
     * any more.  In a multi-process environment, it might be theoretically
     * possible, but we don't currently support it due to locking
     * considerations; see comments on the BackgroundWorkerSlot data
     * structure.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SanityCheckBackgroundWorker</name><argument_list>(<argument><expr><name>worker</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>parallel</name> <operator>=</operator> <operator>(</operator><name><name>worker</name><operator>-&gt;</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_CLASS_PARALLEL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>BackgroundWorkerLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If this is a parallel worker, check whether there are already too many
     * parallel workers; if so, don't register another one.  Our view of
     * parallel_terminate_count may be slightly stale, but that doesn't really
     * matter: we would have gotten the same result if we'd arrived here
     * slightly earlier anyway.  There's no help for it, either, since the
     * postmaster must not take locks; a memory barrier wouldn't guarantee
     * anything useful.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>parallel</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>parallel_register_count</name></name> <operator>-</operator>
                     <name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>parallel_terminate_count</name></name><operator>)</operator> <operator>&gt;=</operator>
        <name>max_parallel_workers</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>parallel_register_count</name></name> <operator>-</operator>
               <name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>parallel_terminate_count</name></name> <operator>&lt;=</operator>
               <name>MAX_PARALLEL_WORKER_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>BackgroundWorkerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Look for an unused slot.  If we find one, grab it.
     */</comment>
    <for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>total_slots</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>slotno</name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BackgroundWorkerSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>&amp;</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>slot</name><operator>-&gt;</operator><name>in_use</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>worker</name></name></expr></argument>, <argument><expr><name>worker</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BackgroundWorker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name>InvalidPid</name></expr>;</expr_stmt> <comment type="block">/* indicates not started yet */</comment>
            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>generation</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>terminate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>generation</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>generation</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>parallel</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>parallel_register_count</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Make sure postmaster doesn't see the slot as in use before it
             * sees the new contents.
             */</comment>
            <expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>in_use</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>BackgroundWorkerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If we found a slot, tell the postmaster to notice the change. */</comment>
    <if_stmt><if>if <condition>(<expr><name>success</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_BACKGROUND_WORKER_CHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If we found a slot and the user has provided a handle, initialize it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>success</name> <operator>&amp;&amp;</operator> <name>handle</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>handle</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BackgroundWorkerHandle</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>handle</name><operator>)</operator><operator>-&gt;</operator><name>slot</name></name> <operator>=</operator> <name>slotno</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>handle</name><operator>)</operator><operator>-&gt;</operator><name>generation</name></name> <operator>=</operator> <name>generation</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the PID of a dynamically-registered background worker.
 *
 * If the worker is determined to be running, the return value will be
 * BGWH_STARTED and *pidp will get the PID of the worker process.
 * Otherwise, the return value will be BGWH_NOT_YET_STARTED if the worker
 * hasn't been started yet, and BGWH_STOPPED if the worker was previously
 * running but is no longer.
 *
 * In the latter case, the worker may be stopped temporarily (if it is
 * configured for automatic restart and exited non-zero) or gone for
 * good (if it exited with code 0 or if it is configured not to restart).
 */</comment>
<function><type><name>BgwHandleStatus</name></type>
<name>GetBackgroundWorkerPid</name><parameter_list>(<parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>pid_t</name> <modifier>*</modifier></type><name>pidp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BackgroundWorkerSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pid_t</name></type>        <name>pid</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>slot</name></name> <operator>&lt;</operator> <name>max_worker_processes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>slot</name></name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/*
     * We could probably arrange to synchronize access to data using memory
     * barriers only, but for now, let's just keep it simple and grab the
     * lock.  It seems unlikely that there will be enough traffic here to
     * result in meaningful contention.
     */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>BackgroundWorkerLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The generation number can't be concurrently changed while we hold the
     * lock.  The pid, which is updated by the postmaster, can change at any
     * time, but we assume such changes are atomic.  So the value we read
     * won't be garbage, but it might be out of date by the time the caller
     * examines it (but that's unavoidable anyway).
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>generation</name></name> <operator>!=</operator> <name><name>slot</name><operator>-&gt;</operator><name>generation</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>pid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>pid</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* All done. */</comment>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>BackgroundWorkerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>BGWH_STOPPED</name></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>pid</name> <operator>==</operator> <name>InvalidPid</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>BGWH_NOT_YET_STARTED</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pidp</name> <operator>=</operator> <name>pid</name></expr>;</expr_stmt>
    <return>return <expr><name>BGWH_STARTED</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for a background worker to start up.
 *
 * This is like GetBackgroundWorkerPid(), except that if the worker has not
 * yet started, we wait for it to do so; thus, BGWH_NOT_YET_STARTED is never
 * returned.  However, if the postmaster has died, we give up and return
 * BGWH_POSTMASTER_DIED, since it that case we know that startup will not
 * take place.
 */</comment>
<function><type><name>BgwHandleStatus</name></type>
<name>WaitForBackgroundWorkerStartup</name><parameter_list>(<parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>pid_t</name> <modifier>*</modifier></type><name>pidp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BgwHandleStatus</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rc</name></decl>;</decl_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>pid_t</name></type>        <name>pid</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>GetBackgroundWorkerPid</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>BGWH_STARTED</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>pidp</name> <operator>=</operator> <name>pid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>BGWH_NOT_YET_STARTED</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
                       <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                       <argument><expr><name>WAIT_EVENT_BGWORKER_STARTUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>status</name> <operator>=</operator> <name>BGWH_POSTMASTER_DIED</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for a background worker to stop.
 *
 * If the worker hasn't yet started, or is running, we wait for it to stop
 * and then return BGWH_STOPPED.  However, if the postmaster has died, we give
 * up and return BGWH_POSTMASTER_DIED, because it's the postmaster that
 * notifies us when a worker's state changes.
 */</comment>
<function><type><name>BgwHandleStatus</name></type>
<name>WaitForBackgroundWorkerShutdown</name><parameter_list>(<parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BgwHandleStatus</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rc</name></decl>;</decl_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>pid_t</name></type>        <name>pid</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>GetBackgroundWorkerPid</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>BGWH_STOPPED</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
                       <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                       <argument><expr><name>WAIT_EVENT_BGWORKER_SHUTDOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>status</name> <operator>=</operator> <name>BGWH_POSTMASTER_DIED</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Instruct the postmaster to terminate a background worker.
 *
 * Note that it's safe to do this without regard to whether the worker is
 * still running, or even if the worker may already have existed and been
 * unregistered.
 */</comment>
<function><type><name>void</name></type>
<name>TerminateBackgroundWorker</name><parameter_list>(<parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BackgroundWorkerSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>signal_postmaster</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>slot</name></name> <operator>&lt;</operator> <name>max_worker_processes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>slot</name></name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/* Set terminate flag in shared memory, unless slot has been reused. */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>BackgroundWorkerLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>generation</name></name> <operator>==</operator> <name><name>slot</name><operator>-&gt;</operator><name>generation</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>terminate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>signal_postmaster</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>BackgroundWorkerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make sure the postmaster notices the change to shared memory. */</comment>
    <if_stmt><if>if <condition>(<expr><name>signal_postmaster</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_BACKGROUND_WORKER_CHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Look up (and possibly load) a bgworker entry point function.
 *
 * For functions contained in the core code, we use library name "postgres"
 * and consult the InternalBGWorkers array.  External functions are
 * looked up, and loaded if necessary, using load_external_function().
 *
 * The point of this is to pass function names as strings across process
 * boundaries.  We can't pass actual function addresses because of the
 * possibility that the function has been loaded at a different address
 * in a different process.  This is obviously a hazard for functions in
 * loadable libraries, but it can happen even for functions in the core code
 * on platforms using EXEC_BACKEND (e.g., Windows).
 *
 * At some point it might be worthwhile to get rid of InternalBGWorkers[]
 * in favor of applying load_external_function() for core functions too;
 * but that raises portability issues that are not worth addressing now.
 */</comment>
<function><type><specifier>static</specifier> <name>bgworker_main_type</name></type>
<name>LookupBackgroundWorkerFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>libraryname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * If the function is to be loaded from postgres itself, search the
     * InternalBGWorkers array.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>libraryname</name></expr></argument>, <argument><expr><literal type="string">"postgres"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>InternalBGWorkers</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>InternalBGWorkers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fn_name</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name><name>InternalBGWorkers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fn_addr</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* We can only reach this by programming error. */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"internal function \"%s\" not found"</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Otherwise load from external library. */</comment>
    <return>return <expr><operator>(</operator><name>bgworker_main_type</name><operator>)</operator>
        <call><name>load_external_function</name><argument_list>(<argument><expr><name>libraryname</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
