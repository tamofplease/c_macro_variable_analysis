<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/postmaster/clean2pc.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * clean2pc.c
 *
 * The background clean 2pc processes are added by whalesong.
 * They attempt to clean the abnormal 2pc.
 *
 * Portions Copyright (c) 1996-2021, TDSQL-PG Development Group
 *
 *
 * IDENTIFICATION
 *	  src/backend/postmaster/clean2pc.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/clean2pc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/fork_process.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/buf_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timeout.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_GID</name></cpp:macro>           <cpp:value>64</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_CMD_LEN</name></cpp:macro>       <cpp:value>1024</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_DB_SIZE</name></cpp:macro>       <cpp:value>100</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DB_TEMPLATE0</name></cpp:macro>     <cpp:value>"template0"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DB_TEMPLATE1</name></cpp:macro>     <cpp:value>"template1"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DB_DEFAULT</name></cpp:macro>       <cpp:value>"postgres"</cpp:value></cpp:define>

<typedef>typedef <type><enum>enum
<block>{
	<decl><name>Query2pcAttr_gid</name>             <init>= <expr><literal type="number">0</literal></expr></init></decl>,
	<decl><name>Query2pcAttr_database</name>        <init>= <expr><literal type="number">1</literal></expr></init></decl>,
	<decl><name>Query2pcAttr_global_status</name>   <init>= <expr><literal type="number">2</literal></expr></init></decl>,
	<decl><name>Query2pcAttr_status_on_nodes</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>,
	<decl><name>Query2pcAttr_butty</name></decl>
}</block></enum></type> <name>Query2pcAttrEnum</name>;</typedef>

<decl_stmt><decl><type><name>bool</name></type> <name>enable_clean_2pc_launcher</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>auto_clean_2pc_interval</name>        <init>= <expr><literal type="number">60</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>auto_clean_2pc_delay</name>           <init>= <expr><literal type="number">300</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>auto_clean_2pc_timeout</name>         <init>= <expr><literal type="number">1200</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>auto_clean_2pc_max_check_time</name>  <init>= <expr><literal type="number">1200</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_SIGTERM</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_SIGHUP</name>  <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_SIGUSR2</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Flags to tell if we are in an clean 2pc process */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>am_clean_2pc_launcher</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>am_clean_2pc_worker</name>   <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>StringInfo</name></type> <name>result_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>clean_2pc_launcher_forkexec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>clean_2pc_worker_forkexec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><name>NON_EXEC_STATIC</name> <name>void</name></type>
<name>Clean2pcLauncherMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list> pg_attribute_noreturn<parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>NON_EXEC_STATIC</name> <name>void</name></type>
<name>Clean2pcWorkerMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list> pg_attribute_noreturn<parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>	<name>start_query_worker</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>clean_time</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>	<name>start_clean_worker</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_query_2pc</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>clean_time</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_clean_2pc</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>clean_time</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clean_2pc_sigterm_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clean_2pc_sighup_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clean_2pc_sigusr2_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_database_list</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>   <name>get_default_database</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExitCleanRunning</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* struct to keep track of databases in worker */</comment>
<typedef>typedef <type><struct>struct <name>Clean2pcDBInfo</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>   <name>db_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>db_name</name></decl>;</decl_stmt>
}</block></struct></type> <name>Clean2pcDBInfo</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>clean_time</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>worker_running</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>  <name>worker_db</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>  <name>db_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>  <name><name>db_list</name><index>[<expr><name>MAX_DB_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>Clean2pcShmemStruct</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>Clean2pcShmemStruct</name> <modifier>*</modifier></type><name>Clean2pcShmem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Main entry point for 2pc clean launcher, to be called from the
 * postmaster.
 */</comment>
<function><type><name>int</name></type>
<name>StartClean2pcLauncher</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pid_t</name></type> <name>clean_2pc_pid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
	<switch>switch <condition>(<expr><operator>(</operator><name>clean_2pc_pid</name> <operator>=</operator> <call><name>clean_2pc_launcher_forkexec</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<switch>switch <condition>(<expr><operator>(</operator><name>clean_2pc_pid</name> <operator>=</operator> <call><name>fork_process</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fork 2pc clean launcher: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
		<case>case <expr><literal type="number">0</literal></expr>:</case>
			<comment type="block">/* in postmaster child ... */</comment>
			<expr_stmt><expr><call><name>InitPostmasterChild</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Close the postmaster's sockets */</comment>
			<expr_stmt><expr><call><name>ClosePostmasterPorts</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Clean2pcLauncherMain</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<default>default:</default>
			<return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <name>clean_2pc_pid</name></expr>;</return>
	</block_content>}</block></switch></block_content></block></switch>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Main loop for the 2pc clean launcher.
 */</comment>
<function><type><name>NON_EXEC_STATIC</name> <name>void</name></type>
<name>Clean2pcLauncherMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>wait_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>clean_time</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>am_clean_2pc_launcher</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Identify myself via ps */</comment>
	<expr_stmt><expr><call><name>init_ps_display</name><argument_list>(<argument><expr><literal type="string">"2pc clean launcher"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"2pc clean launcher start"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>InitProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up signal handlers.  We operate on databases much like a regular
	 * backend, so we use the same signal handling.  See equivalent code in
	 * tcop/postgres.c.
	 */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>clean_2pc_sighup_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>clean_2pc_sigterm_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>StatementCancelHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>quickdie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitializeTimeouts</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* establishes SIGALRM handler */</comment>

	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>procsignal_sigusr1_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>clean_2pc_sigusr2_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGFPE</name></expr></argument>, <argument><expr><name>FloatExceptionHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Early initialization */</comment>
	<expr_stmt><expr><call><name>BaseInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a per-backend PGPROC struct in shared memory, except in the
	 * EXEC_BACKEND case where this was done in SubPostmasterMain. We must do
	 * this before we can use LWLocks (and in the EXEC_BACKEND case we already
	 * had to do some stuff with LWLocks).
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
	<expr_stmt><expr><call><name>InitProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>InitPostgres</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>NormalProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>Clean2pcLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>worker_running</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>db_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>worker_db</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>Clean2pcLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>result_str</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>result_str</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>wait_time</name> <operator>=</operator> <name>auto_clean_2pc_delay</name></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal> <operator>*</operator> <name>wait_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>got_SIGTERM</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"2pc clean launcher got SIGTERM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>got_SIGTERM</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>got_SIGHUP</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"2pc clean launcher got SIGHUP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>wait_time</name> <operator>=</operator> <name>auto_clean_2pc_delay</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>got_SIGUSR2</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>got_SIGUSR2</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>clean_time</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>wait_time</name> <operator>=</operator> <name>auto_clean_2pc_delay</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"2pc clean launcher got SIGUSR2, clean_time: "</literal>
				<name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>clean_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>start_query_worker</name><argument_list>(<argument><expr><name>clean_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>got_SIGTERM</name> <operator>||</operator> <name>got_SIGHUP</name> <operator>||</operator> <name>got_SIGUSR2</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>wait_time</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>wait_time</name> <operator>=</operator> <name>auto_clean_2pc_interval</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Main entry point for 2pc clean worker, to be called from the
 * postmaster.
 */</comment>
<function><type><name>int</name></type>
<name>StartClean2pcWorker</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pid_t</name></type> <name>clean_2pc_pid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
	<switch>switch <condition>(<expr><operator>(</operator><name>clean_2pc_pid</name> <operator>=</operator> <call><name>clean_2pc_worker_forkexec</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<switch>switch <condition>(<expr><operator>(</operator><name>clean_2pc_pid</name> <operator>=</operator> <call><name>fork_process</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fork 2pc clean worker: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
		<case>case <expr><literal type="number">0</literal></expr>:</case>
			<comment type="block">/* in postmaster child ... */</comment>
			<expr_stmt><expr><call><name>InitPostmasterChild</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Close the postmaster's sockets */</comment>
			<expr_stmt><expr><call><name>ClosePostmasterPorts</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Clean2pcWorkerMain</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<default>default:</default>
			<return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <name>clean_2pc_pid</name></expr>;</return>
	</block_content>}</block></switch></block_content></block></switch>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Main for the 2pc clean worker.
 */</comment>
<function><type><name>NON_EXEC_STATIC</name> <name>void</name></type>
<name>Clean2pcWorkerMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>db_name</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>  <name>db_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>  <name>clean_db_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>am_clean_2pc_worker</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>on_proc_exit</name><argument_list>(<argument><expr><name>ExitCleanRunning</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Identify myself via ps */</comment>
	<expr_stmt><expr><call><name>init_ps_display</name><argument_list>(<argument><expr><literal type="string">"2pc clean worker"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"2pc clean worker start"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>InitProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up signal handlers.  We operate on databases much like a regular
	 * backend, so we use the same signal handling.  See equivalent code in
	 * tcop/postgres.c.
	 */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>clean_2pc_sighup_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>clean_2pc_sigterm_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>StatementCancelHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>quickdie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitializeTimeouts</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* establishes SIGALRM handler */</comment>

	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>procsignal_sigusr1_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>clean_2pc_sigusr2_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGFPE</name></expr></argument>, <argument><expr><name>FloatExceptionHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Early initialization */</comment>
	<expr_stmt><expr><call><name>BaseInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a per-backend PGPROC struct in shared memory, except in the
	 * EXEC_BACKEND case where this was done in SubPostmasterMain. We must do
	 * this before we can use LWLocks (and in the EXEC_BACKEND case we already
	 * had to do some stuff with LWLocks).
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
	<expr_stmt><expr><call><name>InitProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>Clean2pcLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>worker_running</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>db_oid</name> <operator>=</operator> <name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>worker_db</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>db_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InitPostgres</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>db_oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>db_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>NormalProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>result_str</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>result_str</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>db_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"query 2pc from db: %s"</literal></expr></argument>, <argument><expr><name>db_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>do_query_2pc</name><argument_list>(<argument><expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>clean_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>clean_db_count</name> <operator>=</operator> <name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>db_count</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"clean 2pc for db: %s"</literal></expr></argument>, <argument><expr><name>db_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>do_clean_2pc</name><argument_list>(<argument><expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>clean_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>worker_running</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>Clean2pcLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>clean_db_count</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>start_clean_worker</name><argument_list>(<argument><expr><name>clean_db_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* All done, go away */</comment>
	<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_query_2pc</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>clean_time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>                  <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>                  <name>count_db</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>                  <name>count_2pc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>        <name>oldcontext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>                 <name><name>query</name><index>[<expr><name>SQL_CMD_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>                 <name><name>gid</name><index>[<expr><name>MAX_GID</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>                <modifier>*</modifier></type><name>startnode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>                 <name>is_start_from</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>                  <name>db_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>                  <name>last_db_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>              <modifier>*</modifier></type><name>estate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RemoteQuery</name>         <modifier>*</modifier></type><name>plan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RemoteQueryState</name>    <modifier>*</modifier></type><name>pstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name>      <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name>                 <modifier>*</modifier></type><name>dummy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>                  <name>attr_num</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>                <name>check_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type>          <name>curr_time</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>                  <name>node_oid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>                 <name>node_type</name> <init>= <expr><name>PGXC_NODE_COORDINATOR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>                  <name>node_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name>   <modifier>*</modifier></type><name><name>attr_name</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"gid"</literal></expr>, <expr><literal type="string">"database"</literal></expr>,
							<expr><literal type="string">"global_transaction_status"</literal></expr>,
							<expr><literal type="string">"transaction_status_on_allnodes"</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result_str</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>result_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>check_time</name> <operator>=</operator> <operator>(</operator><name>curr_time</name> <operator>-</operator> <name>clean_time</name><operator>)</operator><operator>/</operator><name>USECS_PER_SEC</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>check_time</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Invalid check_time: "</literal> <name>INT64_FORMAT</name>
			<literal type="string">", curr_time: "</literal> <name>INT64_FORMAT</name> <literal type="string">", clean_time: "</literal> <name>INT64_FORMAT</name></expr></argument>,
			<argument><expr><name>check_time</name></expr></argument>, <argument><expr><name>curr_time</name></expr></argument>, <argument><expr><name>clean_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>check_time</name> <operator>&gt;</operator> <name>INT32_MAX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>check_time</name> <operator>=</operator> <name>INT32_MAX</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>auto_clean_2pc_max_check_time</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>check_time</name> <operator>&gt;</operator> <name>auto_clean_2pc_max_check_time</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>check_time</name> <operator>=</operator> <name>auto_clean_2pc_max_check_time</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>SQL_CMD_LEN</name></expr></argument>, <argument><expr><literal type="string">"select * FROM pg_clean_check_txn("</literal>
		<name>INT64_FORMAT</name> <literal type="string">") order by database limit 1000;"</literal></expr></argument>, <argument><expr><name>check_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InitMultinodeExecutor</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>node_oid</name> <operator>=</operator> <call><name>get_pgxc_nodeoid</name><argument_list>(<argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>node_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"get node(%s) oid failed"</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>node_index</name> <operator>=</operator> <call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name>node_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"node(%d) query: %s"</literal></expr></argument>, <argument><expr><name>node_index</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <name>COMBINE_TYPE_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_nodes</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_COORDS</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><name>node_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>query</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>force_autocommit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	* We only need the target entry to determine result data type.
	* So create dummy even if real expression is a function.
	*/</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>attr_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>dummy</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
										<argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>dummy</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* prepare to execute */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>ExecInitRemoteQuery</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>db_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>is_start_from</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>count_2pc</name><operator>++</operator></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextP</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>result_str</name></expr></argument>, <argument><expr><literal type="string">"\t%s: %s"</literal></expr></argument>, <argument><expr><name><name>attr_name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<switch>switch <condition>(<expr><name>i</name></expr>)</condition>
			<block>{<block_content>
			<case>case <expr><name>Query2pcAttr_gid</name></expr>:</case> <comment type="block">/* value is gid */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsXidImplicit</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* get start node from gid */</comment>
					<expr_stmt><expr><name>startnode</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>startnode</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>startnode</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"get startnode(%s) from gid(%s) failed"</literal></expr></argument>,
							<argument><expr><name>startnode</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>startnode</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>startnode</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"get startnode(%s) from gid(%s) failed"</literal></expr></argument>,
							<argument><expr><name>startnode</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>startnode</name></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>is_start_from</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>Query2pcAttr_database</name></expr>:</case> <comment type="block">/* value is database */</comment>
				<if_stmt><if>if <condition>(<expr><name>is_start_from</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>db_oid</name> <operator>=</operator> <call><name>get_database_oid</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>db_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"get database(%s) oid failed"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>db_oid</name> <operator>!=</operator> <name>last_db_oid</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>db_count</name></name> <operator>&lt;</operator> <name>MAX_DB_SIZE</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>db_list</name><index>[<expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>db_count</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>db_oid</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>last_db_oid</name> <operator>=</operator> <name>db_oid</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>count_db</name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>result_str</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>ExecEndRemoteQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>count_2pc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>result_str</name><operator>-&gt;</operator><name>data</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"query remain 2pc count(%d), db count(%d), sql: %s"</literal></expr></argument>,
			<argument><expr><name>count_2pc</name></expr></argument>, <argument><expr><name>count_db</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"remain 2pc:\n%s"</literal></expr></argument>, <argument><expr><name><name>result_str</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_clean_2pc</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>clean_time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>                  <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>                  <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>        <name>oldcontext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>                 <name><name>query</name><index>[<expr><name>SQL_CMD_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>              <modifier>*</modifier></type><name>estate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RemoteQuery</name>         <modifier>*</modifier></type><name>plan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RemoteQueryState</name>    <modifier>*</modifier></type><name>pstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name>      <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name>                 <modifier>*</modifier></type><name>dummy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>                  <name>attr_num</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>                  <name>node_oid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>                 <name>node_type</name> <init>= <expr><name>PGXC_NODE_COORDINATOR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>                  <name>node_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name>   <modifier>*</modifier></type><name><name>attr_name</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"gid"</literal></expr>, <expr><literal type="string">"global_transaction_status"</literal></expr>,
								<expr><literal type="string">"operation"</literal></expr>, <expr><literal type="string">"operation_status"</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result_str</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>result_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>SQL_CMD_LEN</name></expr></argument>, <argument><expr><literal type="string">"select * FROM pg_clean_execute_on_node('%s', %ld)"</literal>
			<literal type="string">" limit 1000;"</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name>clean_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InitMultinodeExecutor</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>node_oid</name> <operator>=</operator> <call><name>get_pgxc_nodeoid</name><argument_list>(<argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>node_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"get node(%s) oid failed"</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>node_index</name> <operator>=</operator> <call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name>node_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"node(%d) query: %s"</literal></expr></argument>, <argument><expr><name>node_index</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <name>COMBINE_TYPE_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_nodes</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_COORDS</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><name>node_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>query</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>force_autocommit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	* We only need the target entry to determine result data type.
	* So create dummy even if real expression is a function.
	*/</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>attr_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>dummy</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
										<argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>dummy</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* prepare to execute */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>ExecInitRemoteQuery</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

		<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextP</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>result_str</name></expr></argument>, <argument><expr><literal type="string">"\t%s: %s"</literal></expr></argument>, <argument><expr><name><name>attr_name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>result_str</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>ExecEndRemoteQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name><name>result_str</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"clean 2pc count(%d), sql: %s"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"clean 2pc:\n%s"</literal></expr></argument>, <argument><expr><name><name>result_str</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGTERM: set flag to exit normally */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>clean_2pc_sigterm_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"SIGTERM: %d"</literal></expr></argument>, <argument><expr><name>postgres_signal_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>got_SIGTERM</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* SIGHUP: set flag to re-read config file at next convenient time */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>clean_2pc_sighup_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"SIGHUP: %d"</literal></expr></argument>, <argument><expr><name>postgres_signal_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGUSR2: used for notify 2pc abnormal */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>clean_2pc_sigusr2_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"SIGUSR2: %d"</literal></expr></argument>, <argument><expr><name>postgres_signal_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>got_SIGUSR2</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * IsClean2pcLauncher functions
 *		Return whether this is a 2pc clean launcher.
 */</comment>
<function><type><name>bool</name></type>
<name>IsClean2pcLauncher</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>am_clean_2pc_launcher</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsClean2pcWorker functions
 *		Return whether this is a 2pc clean worker.
 */</comment>
<function><type><name>bool</name></type>
<name>IsClean2pcWorker</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>am_clean_2pc_worker</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_database_list
 *		Return a list of all databases found in pg_database.
 *
 * The list and associated data is allocated in the caller's memory context,
 * which is in charge of ensuring that it's properly cleaned up afterwards.
 *
 * Note: this is the only function in which the autovacuum launcher uses a
 * transaction.  Although we aren't attached to any particular database and
 * therefore can't access most catalogs, we do have enough infrastructure
 * to do a seqscan on pg_database.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_database_list</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>dblist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>resultcxt</name></decl>;</decl_stmt>

	<comment type="block">/* This is the context that we will allocate our output data in */</comment>
	<expr_stmt><expr><name>resultcxt</name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DatabaseRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_database</name></type> <name>pgdatabase</name> <init>= <expr><operator>(</operator><name>Form_pg_database</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Clean2pcDBInfo</name>  <modifier>*</modifier></type><name>db_info</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>resultcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>db_info</name> <operator>=</operator> <operator>(</operator><name>Clean2pcDBInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Clean2pcDBInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>db_info</name><operator>-&gt;</operator><name>db_oid</name></name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>db_info</name><operator>-&gt;</operator><name>db_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pgdatabase</name><operator>-&gt;</operator><name>datname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>dblist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dblist</name></expr></argument>, <argument><expr><name>db_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dblist</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>get_default_database</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>default_db</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>template0_db</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>template1_db</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dblist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Clean2pcDBInfo</name> <modifier>*</modifier></type><name>db_info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>default_db_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Get a list of databases */</comment>
	<expr_stmt><expr><name>dblist</name> <operator>=</operator> <call><name>get_database_list</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>dblist</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>db_info</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>db_info</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>, <argument><expr><name>DB_DEFAULT</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>default_db</name> <operator>=</operator> <name><name>db_info</name><operator>-&gt;</operator><name>db_oid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>default_db_name</name> <operator>=</operator> <name><name>db_info</name><operator>-&gt;</operator><name>db_name</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>db_info</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>, <argument><expr><name>DB_TEMPLATE0</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>template0_db</name> <operator>=</operator> <name><name>db_info</name><operator>-&gt;</operator><name>db_oid</name></name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>db_info</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>, <argument><expr><name>DB_TEMPLATE1</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>template1_db</name> <operator>=</operator> <name><name>db_info</name><operator>-&gt;</operator><name>db_oid</name></name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>default_db</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>default_db</name> <operator>=</operator> <name><name>db_info</name><operator>-&gt;</operator><name>db_oid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>default_db_name</name> <operator>=</operator> <name><name>db_info</name><operator>-&gt;</operator><name>db_name</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>default_db</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>template1_db</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>default_db</name> <operator>=</operator> <name>template1_db</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>default_db_name</name> <operator>=</operator> <name>DB_TEMPLATE1</name></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>template0_db</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>default_db</name> <operator>=</operator> <name>template0_db</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>default_db_name</name> <operator>=</operator> <name>DB_TEMPLATE0</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>default_db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"get default db: oid(%d), name(%s)"</literal></expr></argument>, <argument><expr><name>default_db</name></expr></argument>, <argument><expr><name>default_db_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>default_db</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * start query worker to query 2pc
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>start_query_worker</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>clean_time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>db_oid</name> <init>= <expr><call><name>get_default_database</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>db_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"get default database failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>db_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>auto_clean_2pc_timeout</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>curr_time</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>curr_time</name> <operator>-</operator> <name>clean_time</name> <operator>&gt;</operator> <name>auto_clean_2pc_timeout</name> <operator>*</operator> <name>USECS_PER_SEC</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>clean_time</name> <operator>=</operator> <name>curr_time</name> <operator>-</operator> <name>auto_clean_2pc_timeout</name> <operator>*</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>Clean2pcLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>clean_time</name></name> <operator>=</operator> <name>clean_time</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>worker_running</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>Clean2pcLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>got_SIGTERM</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* wait 1s */</comment>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"waiting to db(%d)"</literal></expr></argument>, <argument><expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>worker_db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>Clean2pcLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>worker_running</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>db_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>worker_db</name></name> <operator>=</operator> <name>db_oid</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>Clean2pcLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_START_CLEAN_2PC_WORKER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* wait 1s */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * start clean worker to clean 2pc
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>start_clean_worker</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>Clean2pcLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>worker_running</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>Clean2pcLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>got_SIGTERM</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* wait 1s */</comment>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"waiting to db(%d)"</literal></expr></argument>, <argument><expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>worker_db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>Clean2pcLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>worker_db</name></name> <operator>=</operator> <name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>db_list</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>db_count</name></name> <operator>!=</operator> <name>count</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"db_count(%d)!=count(%d)"</literal></expr></argument>, <argument><expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>db_count</name></name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>Clean2pcLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>worker_db</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"get invalid oid, count: %d, i: %d"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>Clean2pcLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>worker_running</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_START_CLEAN_2PC_WORKER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>Clean2pcLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* wait 1s */</comment>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * on_proc_exit callback to set worker_running to false
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExitCleanRunning</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>worker_running</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>Clean2pcShmem</name><operator>-&gt;</operator><name>worker_running</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"2pc clean worker exit abnormally"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"2pc clean worker exit normally"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Clean2pcShmemSize
 *		Compute space needed for clean 2pc related shared memory
 */</comment>
<function><type><name>Size</name></type>
<name>Clean2pcShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Need the fixed struct and the array of WorkerInfoData.
	 */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Clean2pcShmemStruct</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Clean2pcShmemInit
 *		Allocate and initialize clean 2pc related  shared memory
 */</comment>
<function><type><name>void</name></type>
<name>Clean2pcShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>Clean2pcShmem</name> <operator>=</operator> <operator>(</operator><name>Clean2pcShmemStruct</name> <operator>*</operator><operator>)</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Clean 2pc Data"</literal></expr></argument>,
															<argument><expr><call><name>Clean2pcShmemSize</name><argument_list>()</argument_list></call></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
<comment type="block">/*
 * forkexec routine for the 2pc clean launcher process.
 *
 * Format up the arglist, then fork and exec.
 */</comment>
<function><type><specifier>static</specifier> <name>pid_t</name></type>
<name>clean_2pc_launcher_forkexec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>av</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ac</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"postgres"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"--forkclean2pclauncher"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* filled in by postmaster_forkexec */</comment>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ac</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>av</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>postmaster_forkexec</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>av</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * forkexec routine for the 2pc clean worker process.
 *
 * Format up the arglist, then fork and exec.
 */</comment>
<function><type><specifier>static</specifier> <name>pid_t</name></type>
<name>clean_2pc_worker_forkexec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>av</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ac</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"postgres"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"--forkclean2pcworker"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* filled in by postmaster_forkexec */</comment>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ac</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>av</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>postmaster_forkexec</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>av</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * We need this set from the outside, before InitProcess is called
 */</comment>
<function><type><name>void</name></type>
<name>Clean2pcLauncherIAm</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>am_clean_2pc_launcher</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * We need this set from the outside, before InitProcess is called
 */</comment>
<function><type><name>void</name></type>
<name>Clean2pcWorkerIAm</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>am_clean_2pc_worker</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
