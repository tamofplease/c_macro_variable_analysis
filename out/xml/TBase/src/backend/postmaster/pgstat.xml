<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/postmaster/pgstat.c"><comment type="block">/* ----------
 * pgstat.c
 *
 *    All the statistics collector stuff hacked up in one big, ugly file.
 *
 *    TODO:    - Separate collector, postmaster and backend stuff
 *              into different files.
 *
 *            - Add some automatic call for pgstat vacuuming.
 *
 *            - Add a pgstat config column to pg_database, so this
 *              entire thing can be enabled/disabled on a per db basis.
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 *    Copyright (c) 2001-2017, PostgreSQL Global Development Group
 *
 *    src/backend/postmaster/pgstat.c
 * ----------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SELECT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase_rmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/ip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/clean2pc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/fork_process.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/backendid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/dsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pg_shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinvaladt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ascii.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>


<comment type="block">/* ----------
 * Timer definitions.
 * ----------
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGSTAT_STAT_INTERVAL</name></cpp:macro>    <cpp:value>500</cpp:value></cpp:define> <comment type="block">/* Minimum time between stats file
                                     * updates; in milliseconds. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGSTAT_RETRY_DELAY</name></cpp:macro>        <cpp:value>10</cpp:value></cpp:define>    <comment type="block">/* How long to wait between checks for a
                                     * new file; in milliseconds. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGSTAT_MAX_WAIT_TIME</name></cpp:macro>    <cpp:value>10000</cpp:value></cpp:define>    <comment type="block">/* Maximum time to wait for a stats
                                         * file update; in milliseconds. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGSTAT_INQ_INTERVAL</name></cpp:macro>        <cpp:value>640</cpp:value></cpp:define> <comment type="block">/* How often to ping the collector for a
                                     * new file; in milliseconds. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGSTAT_RESTART_INTERVAL</name></cpp:macro> <cpp:value>60</cpp:value></cpp:define>    <comment type="block">/* How often to attempt to restart a
                                     * failed statistics collector; in
                                     * seconds. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGSTAT_POLL_LOOP_COUNT</name></cpp:macro>    <cpp:value>(PGSTAT_MAX_WAIT_TIME / PGSTAT_RETRY_DELAY)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGSTAT_INQ_LOOP_COUNT</name></cpp:macro>    <cpp:value>(PGSTAT_INQ_INTERVAL / PGSTAT_RETRY_DELAY)</cpp:value></cpp:define>

<comment type="block">/* Minimum receive buffer size for the collector's socket. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGSTAT_MIN_RCVBUF</name></cpp:macro>        <cpp:value>(100 * 1024)</cpp:value></cpp:define>


<comment type="block">/* ----------
 * The initial size hints for the hash tables used in the collector.
 * ----------
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGSTAT_DB_HASH_SIZE</name></cpp:macro>        <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGSTAT_TAB_HASH_SIZE</name></cpp:macro>    <cpp:value>512</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGSTAT_FUNCTION_HASH_SIZE</name></cpp:macro>    <cpp:value>512</cpp:value></cpp:define>


<comment type="block">/* ----------
 * Total number of backends including auxiliary
 *
 * We reserve a slot for each possible BackendId, plus one for each
 * possible auxiliary process type.  (This scheme assumes there is not
 * more than one of any auxiliary process type at a time.) MaxBackends
 * includes autovacuum workers and background workers as well.
 * ----------
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NumBackendStatSlots</name></cpp:macro> <cpp:value>(MaxBackends + NUM_AUXPROCTYPES)</cpp:value></cpp:define>


<comment type="block">/* ----------
 * GUC parameters
 * ----------
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>        <name>pgstat_track_activities</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>        <name>pgstat_track_counts</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>            <name>pgstat_track_functions</name> <init>= <expr><name>TRACK_FUNC_OFF</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>            <name>pgstat_track_activity_query_size</name> <init>= <expr><literal type="number">1024</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* ----------
 * Built from GUC parameter
 * ----------
 */</comment>
<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>pgstat_stat_directory</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>pgstat_stat_filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>pgstat_stat_tmpname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * BgWriter global statistics counters (unused in other processes).
 * Stored directly in a stats message structure so it can be sent
 * without needing to copy things around.  We assume this inits to zeroes.
 */</comment>
<decl_stmt><decl><type><name>PgStat_MsgBgWriter</name></type> <name>BgWriterStats</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>pgstat_report_hook_type</name></type> <name>pgstat_report_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* ----------
 * Local data
 * ----------
 */</comment>
<decl_stmt><decl><type><name>NON_EXEC_STATIC</name> <name>pgsocket</name></type> <name>pgStatSock</name> <init>= <expr><name>PGINVALID_SOCKET</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>sockaddr_storage</name></name></type> <name>pgStatAddr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>time_t</name></type> <name>last_pgstat_start_time</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgStatRunningInCollector</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Structures in which backends store per-table info that's waiting to be
 * sent to the collector.
 *
 * NOTE: once allocated, TabStatusArray structures are never moved or deleted
 * for the life of the backend.  Also, we zero out the t_id fields of the
 * contained PgStat_TableStatus structs whenever they are not actively in use.
 * This allows relcache pgstat_info pointers to be treated as long-lived data,
 * avoiding repeated searches in pgstat_initstats() when a relation is
 * repeatedly opened during a transaction.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TABSTAT_QUANTUM</name></cpp:macro>        <cpp:value>100</cpp:value></cpp:define> <comment type="block">/* we alloc this many at a time */</comment>

<typedef>typedef <type><struct>struct <name>TabStatusArray</name>
<block>{
    <decl_stmt><decl><type><name><name>struct</name> <name>TabStatusArray</name></name> <modifier>*</modifier></type><name>tsa_next</name></decl>;</decl_stmt>    <comment type="block">/* link to next array, if any */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>tsa_used</name></decl>;</decl_stmt>        <comment type="block">/* # entries currently used */</comment>
    <decl_stmt><decl><type><name>PgStat_TableStatus</name></type> <name><name>tsa_entries</name><index>[<expr><name>TABSTAT_QUANTUM</name></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* per-table data */</comment>
}</block></struct></type> <name>TabStatusArray</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>TabStatusArray</name> <modifier>*</modifier></type><name>pgStatTabList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * pgStatTabHash entry: map from relation OID to PgStat_TableStatus pointer
 */</comment>
<typedef>typedef <type><struct>struct <name>TabStatHashEntry</name>
<block>{
    <decl_stmt><decl><type><name>Oid</name></type>            <name>t_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_TableStatus</name> <modifier>*</modifier></type><name>tsa_entry</name></decl>;</decl_stmt>
}</block></struct></type> <name>TabStatHashEntry</name>;</typedef>

<comment type="block">/*
 * Hash table for O(1) t_id -&gt; tsa_entry lookup
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>pgStatTabHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Backends store per-function info that's waiting to be sent to the collector
 * in this hash table (indexed by function OID).
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>pgStatFunctions</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Indicates if backend has some function stats that it hasn't yet
 * sent to the collector.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>have_function_stats</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Tuple insertion/deletion counts for an open transaction can't be propagated
 * into PgStat_TableStatus counters until we know if it is going to commit
 * or abort.  Hence, we keep these counts in per-subxact structs that live
 * in TopTransactionContext.  This data structure is designed on the assumption
 * that subxacts won't usually modify very many tables.
 */</comment>
<typedef>typedef <type><struct>struct <name>PgStat_SubXactStatus</name>
<block>{
    <decl_stmt><decl><type><name>int</name></type>            <name>nest_level</name></decl>;</decl_stmt>        <comment type="block">/* subtransaction nest level */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>PgStat_SubXactStatus</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>    <comment type="block">/* higher-level subxact if any */</comment>
    <decl_stmt><decl><type><name>PgStat_TableXactStatus</name> <modifier>*</modifier></type><name>first</name></decl>;</decl_stmt>    <comment type="block">/* head of list for this subxact */</comment>
}</block></struct></type> <name>PgStat_SubXactStatus</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>PgStat_SubXactStatus</name> <modifier>*</modifier></type><name>pgStatXactStack</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>pgStatXactCommit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>pgStatXactRollback</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PgStat_Counter</name></type> <name>pgStatBlockReadTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PgStat_Counter</name></type> <name>pgStatBlockWriteTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Record that's written to 2PC state file when pgstat state is persisted */</comment>
<typedef>typedef <type><struct>struct <name>TwoPhasePgStatRecord</name>
<block>{
    <decl_stmt><decl><type><name>PgStat_Counter</name></type> <name>tuples_inserted</name></decl>;</decl_stmt> <comment type="block">/* tuples inserted in xact */</comment>
    <decl_stmt><decl><type><name>PgStat_Counter</name></type> <name>tuples_updated</name></decl>;</decl_stmt>    <comment type="block">/* tuples updated in xact */</comment>
    <decl_stmt><decl><type><name>PgStat_Counter</name></type> <name>tuples_deleted</name></decl>;</decl_stmt>    <comment type="block">/* tuples deleted in xact */</comment>
    <decl_stmt><decl><type><name>PgStat_Counter</name></type> <name>inserted_pre_trunc</name></decl>;</decl_stmt>    <comment type="block">/* tuples inserted prior to truncate */</comment>
    <decl_stmt><decl><type><name>PgStat_Counter</name></type> <name>updated_pre_trunc</name></decl>;</decl_stmt>    <comment type="block">/* tuples updated prior to truncate */</comment>
    <decl_stmt><decl><type><name>PgStat_Counter</name></type> <name>deleted_pre_trunc</name></decl>;</decl_stmt>    <comment type="block">/* tuples deleted prior to truncate */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>t_id</name></decl>;</decl_stmt>            <comment type="block">/* table's OID */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>t_shared</name></decl>;</decl_stmt>        <comment type="block">/* is it a shared catalog? */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>t_truncated</name></decl>;</decl_stmt>    <comment type="block">/* was the relation truncated? */</comment>
}</block></struct></type> <name>TwoPhasePgStatRecord</name>;</typedef>

<comment type="block">/*
 * Info about current "snapshot" of stats file
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>pgStatLocalContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>pgStatDBHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Status for backends including auxiliary */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>LocalPgBackendStatus</name> <modifier>*</modifier></type><name>localBackendStatusTable</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Total number of backends including auxiliary */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>localNumBackends</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Cluster wide statistics, kept in the stats collector.
 * Contains statistics that are not collected per database
 * or per table.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PgStat_ArchiverStats</name></type> <name>archiverStats</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PgStat_GlobalStats</name></type> <name>globalStats</name></decl>;</decl_stmt>

<comment type="block">/*
 * List of OIDs of databases we need to write out.  If an entry is InvalidOid,
 * it means to write only the shared-catalog stats ("DB 0"); otherwise, we
 * will write both that DB's data and the shared stats.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>pending_write_requests</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Signal handler flags */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>bool</name></type> <name>need_exit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>bool</name></type> <name>got_SIGHUP</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Total time charged to functions so far in the current backend.
 * We use this to help separate "self" and "other" time charges.
 * (We assume this initializes to zero.)
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>instr_time</name></type> <name>total_func_time</name></decl>;</decl_stmt>


<comment type="block">/* ----------
 * Local function forward declarations
 * ----------
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>pgstat_forkexec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><name>NON_EXEC_STATIC</name> <name>void</name></type> <name>PgstatCollectorMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list> pg_attribute_noreturn<parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_exit</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_beshutdown_hook</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_sighup_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>pgstat_get_db_entry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PgStat_StatTabEntry</name> <modifier>*</modifier></type><name>pgstat_get_tab_entry</name><parameter_list>(<parameter><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl></parameter>,
                     <parameter><decl><type><name>Oid</name></type> <name>tableoid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_write_statsfiles</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>permanent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allDbs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_write_db_statsfile</name><parameter_list>(<parameter><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>permanent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>pgstat_read_statsfiles</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>onlydb</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>permanent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>deep</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_read_db_statsfile</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>, <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>tabhash</name></decl></parameter>, <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>funchash</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>permanent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>backend_read_statsfile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_read_current_status</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgstat_write_statsfile_needed</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgstat_db_requested</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_send_tabstat</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgTabstat</name> <modifier>*</modifier></type><name>tsmsg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_send_funcstats</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>pgstat_collect_oids</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>catalogid</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>PgStat_TableStatus</name> <modifier>*</modifier></type><name>get_tabstat_entry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>rel_id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isshared</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_setup_memcxt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pgstat_get_wait_activity</name><parameter_list>(<parameter><decl><type><name>WaitEventActivity</name></type> <name>w</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pgstat_get_wait_client</name><parameter_list>(<parameter><decl><type><name>WaitEventClient</name></type> <name>w</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pgstat_get_wait_ipc</name><parameter_list>(<parameter><decl><type><name>WaitEventIPC</name></type> <name>w</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pgstat_get_wait_timeout</name><parameter_list>(<parameter><decl><type><name>WaitEventTimeout</name></type> <name>w</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pgstat_get_wait_io</name><parameter_list>(<parameter><decl><type><name>WaitEventIO</name></type> <name>w</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_setheader</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgHdr</name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>, <parameter><decl><type><name>StatMsgType</name></type> <name>mtype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_send</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_recv_inquiry</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgInquiry</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_recv_tabstat</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgTabstat</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_recv_tabpurge</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgTabpurge</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_recv_dropdb</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgDropdb</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_recv_resetcounter</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgResetcounter</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_recv_resetsharedcounter</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgResetsharedcounter</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_recv_resetsinglecounter</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgResetsinglecounter</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_recv_autovac</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgAutovacStart</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_recv_vacuum</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgVacuum</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_recv_analyze</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgAnalyze</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_recv_archiver</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgArchiver</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_recv_bgwriter</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgBgWriter</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_recv_funcstat</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgFuncstat</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_recv_funcpurge</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgFuncpurge</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_recv_recoveryconflict</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgRecoveryConflict</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_recv_deadlock</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgDeadlock</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgstat_recv_tempfile</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgTempFile</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ------------------------------------------------------------
 * Public functions called from postmaster follow
 * ------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------
 * pgstat_init() -
 *
 *    Called from postmaster at startup. Create the resources required
 *    by the statistics collector process.  If unable to do so, do not
 *    fail --- better to let the postmaster start with stats collection
 *    disabled.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ACCEPT_TYPE_ARG3</name></type> <name>alen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>addrs</name> <init>= <expr><name>NULL</name></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>addr</name></decl>,
                <decl><type ref="prev"/><name>hints</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>fd_set</name></type>        <name>rset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>test_byte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>sel_res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>tries</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TESTBYTEVAL</name></cpp:macro> <cpp:value>((char) 199)</cpp:value></cpp:define>

    <comment type="block">/*
     * This static assertion verifies that we didn't mess up the calculations
     * involved in selecting maximum payload sizes for our UDP messages.
     * Because the only consequence of overrunning PGSTAT_MAX_MSG_SIZE would
     * be silent performance loss from fragmentation, it seems worth having a
     * compile-time cross-check that we didn't.
     */</comment>
    <expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_Msg</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>PGSTAT_MAX_MSG_SIZE</name></expr></argument>,
                     <argument><expr><literal type="string">"maximum stats message size exceeds PGSTAT_MAX_MSG_SIZE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create the UDP socket for sending and receiving statistic messages
     */</comment>
    <expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_flags</name></name> <operator>=</operator> <name>AI_PASSIVE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_family</name></name> <operator>=</operator> <name>AF_UNSPEC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_socktype</name></name> <operator>=</operator> <name>SOCK_DGRAM</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_protocol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_addrlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_addr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_canonname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pg_getaddrinfo_all</name><argument_list>(<argument><expr><literal type="string">"localhost"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hints</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>||</operator> <operator>!</operator><name>addrs</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not resolve \"localhost\": %s"</literal></expr></argument>,
                        <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>startup_failed</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * On some platforms, pg_getaddrinfo_all() may return multiple addresses
     * only one of which will actually work (eg, both IPv6 and IPv4 addresses
     * when kernel will reject IPv6).  Worse, the failure may occur at the
     * bind() or perhaps even connect() stage.  So we must loop through the
     * results till we find a working combination. We will generate LOG
     * messages, but no error, for bogus combinations.
     */</comment>
    <for>for <control>(<init><expr><name>addr</name> <operator>=</operator> <name>addrs</name></expr>;</init> <condition><expr><name>addr</name></expr>;</condition> <incr><expr><name>addr</name> <operator>=</operator> <name><name>addr</name><operator>-&gt;</operator><name>ai_next</name></name></expr></incr>)</control>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
        <comment type="block">/* Ignore AF_UNIX sockets, if any are returned. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>addr</name><operator>-&gt;</operator><name>ai_family</name></name> <operator>==</operator> <name>AF_UNIX</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if_stmt><if>if <condition>(<expr><operator>++</operator><name>tries</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trying another address for the statistics collector"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Create the socket.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pgStatSock</name> <operator>=</operator> <call><name>socket</name><argument_list>(<argument><expr><name><name>addr</name><operator>-&gt;</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>SOCK_DGRAM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create socket for statistics collector: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Bind it to a kernel assigned port on localhost and get the assigned
         * port via getsockname().
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>bind</name><argument_list>(<argument><expr><name>pgStatSock</name></expr></argument>, <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>ai_addr</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>ai_addrlen</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not bind socket for statistics collector: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>pgStatSock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pgStatSock</name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>alen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pgStatAddr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>getsockname</name><argument_list>(<argument><expr><name>pgStatSock</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pgStatAddr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>alen</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not get address of socket for statistics collector: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>pgStatSock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pgStatSock</name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Connect the socket to its own address.  This saves a few cycles by
         * not having to respecify the target address on every send. This also
         * provides a kernel-level check that only packets from this same
         * address will be received.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>connect</name><argument_list>(<argument><expr><name>pgStatSock</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pgStatAddr</name></expr></argument>, <argument><expr><name>alen</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not connect socket for statistics collector: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>pgStatSock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pgStatSock</name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Try to send and receive a one-byte test message on the socket. This
         * is to catch situations where the socket can be created but will not
         * actually pass data (for instance, because kernel packet filtering
         * rules prevent it).
         */</comment>
        <expr_stmt><expr><name>test_byte</name> <operator>=</operator> <name>TESTBYTEVAL</name></expr>;</expr_stmt>

<label><name>retry1</name>:</label>
        <if_stmt><if>if <condition>(<expr><call><name>send</name><argument_list>(<argument><expr><name>pgStatSock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_byte</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>retry1</name>;</goto></block_content></block></if></if_stmt>    <comment type="block">/* if interrupted, just retry */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not send test message on socket for statistics collector: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>pgStatSock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pgStatSock</name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * There could possibly be a little delay before the message can be
         * received.  We arbitrarily allow up to half a second before deciding
         * it's broken.
         */</comment>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>                <comment type="block">/* need a loop to handle EINTR */</comment>
        <block>{<block_content>
            <expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>pgStatSock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">500000</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>sel_res</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>pgStatSock</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>sel_res</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>errno</name> <operator>!=</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>sel_res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"select() failed in statistics collector: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>pgStatSock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pgStatSock</name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>sel_res</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>FD_ISSET</name><argument_list>(<argument><expr><name>pgStatSock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * This is the case we actually think is likely, so take pains to
             * give a specific message for it.
             *
             * errno will not be set meaningfully here, so don't use it.
             */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"test message did not get through on socket for statistics collector"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>pgStatSock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pgStatSock</name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>test_byte</name><operator>++</operator></expr>;</expr_stmt>            <comment type="block">/* just make sure variable is changed */</comment>

<label><name>retry2</name>:</label>
        <if_stmt><if>if <condition>(<expr><call><name>recv</name><argument_list>(<argument><expr><name>pgStatSock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_byte</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>retry2</name>;</goto></block_content></block></if></if_stmt>    <comment type="block">/* if interrupted, just retry */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not receive test message on socket for statistics collector: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>pgStatSock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pgStatSock</name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>test_byte</name> <operator>!=</operator> <name>TESTBYTEVAL</name></expr>)</condition>    <comment type="block">/* strictly paranoia ... */</comment>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"incorrect test message transmission on socket for statistics collector"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>pgStatSock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pgStatSock</name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* If we get here, we have a working socket */</comment>
        <break>break;</break>
    </block_content>}</block></for>

    <comment type="block">/* Did we find a working address? */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>addr</name> <operator>||</operator> <name>pgStatSock</name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>startup_failed</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Set the socket to non-blocking IO.  This ensures that if the collector
     * falls behind, statistics messages will be discarded; backends won't
     * block waiting to send messages to the collector.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_set_noblock</name><argument_list>(<argument><expr><name>pgStatSock</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not set statistics collector socket to nonblocking mode: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>startup_failed</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Try to ensure that the socket's receive buffer is at least
     * PGSTAT_MIN_RCVBUF bytes, so that it won't easily overflow and lose
     * data.  Use of UDP protocol means that we are willing to lose data under
     * heavy load, but we don't want it to happen just because of ridiculously
     * small default buffer sizes (such as 8KB on older Windows versions).
     */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>old_rcvbuf</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>new_rcvbuf</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ACCEPT_TYPE_ARG3</name></type> <name>rcvbufsize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>old_rcvbuf</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>getsockopt</name><argument_list>(<argument><expr><name>pgStatSock</name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>, <argument><expr><name>SO_RCVBUF</name></expr></argument>,
                       <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>old_rcvbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rcvbufsize</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"getsockopt(SO_RCVBUF) failed: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* if we can't get existing size, always try to set it */</comment>
            <expr_stmt><expr><name>old_rcvbuf</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>new_rcvbuf</name> <operator>=</operator> <name>PGSTAT_MIN_RCVBUF</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>old_rcvbuf</name> <operator>&lt;</operator> <name>new_rcvbuf</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>setsockopt</name><argument_list>(<argument><expr><name>pgStatSock</name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>, <argument><expr><name>SO_RCVBUF</name></expr></argument>,
                           <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>new_rcvbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_rcvbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"setsockopt(SO_RCVBUF) failed: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hints</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>

<label><name>startup_failed</name>:</label>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"disabling statistics collector for lack of working socket"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>addrs</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hints</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgStatSock</name> <operator>!=</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>pgStatSock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pgStatSock</name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Adjust GUC variables to suppress useless activity, and for debugging
     * purposes (seeing track_counts off is a clue that we failed here). We
     * use PGC_S_OVERRIDE because there is no point in trying to turn it back
     * on from postgresql.conf without a restart.
     */</comment>
    <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"track_counts"</literal></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>, <argument><expr><name>PGC_INTERNAL</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * subroutine for pgstat_reset_all
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_reset_remove_files</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>directory</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DIR</name>           <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>fname</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>directory</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>nchars</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>tmp_oid</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Skip directory entries that don't match the file names we write.
         * See get_dbstat_filename for the database-specific pattern.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"global."</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>nchars</name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>nchars</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"db_%u.%n"</literal></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name>tmp_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nchars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>nchars</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <comment type="block">/* %u allows leading whitespace, so reject that */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"0123456789"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>d_name</name></name> <operator>+</operator> <name>nchars</name></expr></argument>, <argument><expr><literal type="string">"tmp"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <call><name>strcmp</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>d_name</name></name> <operator>+</operator> <name>nchars</name></expr></argument>, <argument><expr><literal type="string">"stat"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>directory</name></expr></argument>,
                 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pgstat_reset_all() -
 *
 * Remove the stats files.  This is currently used only if WAL
 * recovery is needed after a crash.
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_reset_all</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>pgstat_reset_remove_files</name><argument_list>(<argument><expr><name>pgstat_stat_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_reset_remove_files</name><argument_list>(<argument><expr><name>PGSTAT_STAT_PERMANENT_DIRECTORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>

<comment type="block">/*
 * pgstat_forkexec() -
 *
 * Format up the arglist for, then fork and exec, statistics collector process
 */</comment>
<function><type><specifier>static</specifier> <name>pid_t</name></type>
<name>pgstat_forkexec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name><name>av</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ac</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"postgres"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"--forkcol"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>            <comment type="block">/* filled in by postmaster_forkexec */</comment>

    <expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ac</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>av</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>postmaster_forkexec</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>av</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* EXEC_BACKEND */</comment>


<comment type="block">/*
 * pgstat_start() -
 *
 *    Called from postmaster at startup or after an existing collector
 *    died.  Attempt to fire up a fresh statistics collector.
 *
 *    Returns PID of child process, or 0 if fail.
 *
 *    Note: if fail, we will be called again from the postmaster main loop.
 */</comment>
<function><type><name>int</name></type>
<name>pgstat_start</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>time_t</name></type>        <name>curtime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pid_t</name></type>        <name>pgStatPid</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Check that the socket is there, else pgstat_init failed and we can do
     * nothing useful.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>pgStatSock</name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Do nothing if too soon since last collector start.  This is a safety
     * valve to protect against continuous respawn attempts if the collector
     * is dying immediately at launch.  Note that since we will be re-called
     * from the postmaster main loop, we will get another chance later.
     */</comment>
    <expr_stmt><expr><name>curtime</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <operator>(</operator><name>curtime</name> <operator>-</operator> <name>last_pgstat_start_time</name><operator>)</operator> <operator>&lt;</operator>
        <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>PGSTAT_RESTART_INTERVAL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>last_pgstat_start_time</name> <operator>=</operator> <name>curtime</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Okay, fork off the collector.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
    <switch>switch <condition>(<expr><operator>(</operator><name>pgStatPid</name> <operator>=</operator> <call><name>pgstat_forkexec</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <switch>switch <condition>(<expr><operator>(</operator><name>pgStatPid</name> <operator>=</operator> <call><name>fork_process</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
        <case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fork statistics collector: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
        <case>case <expr><literal type="number">0</literal></expr>:</case>
            <comment type="block">/* in postmaster child ... */</comment>
            <expr_stmt><expr><call><name>InitPostmasterChild</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Close the postmaster's sockets */</comment>
            <expr_stmt><expr><call><name>ClosePostmasterPorts</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Drop our connection to postmaster's shared memory, as well */</comment>
            <expr_stmt><expr><call><name>dsm_detach_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PGSharedMemoryDetach</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>PgstatCollectorMain</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <default>default:</default>
            <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <name>pgStatPid</name></expr>;</return>
    </block_content>}</block></switch></block_content></block></switch>

    <comment type="block">/* shouldn't get here */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>allow_immediate_pgstat_restart</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>last_pgstat_start_time</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------
 * Public functions used by backends follow
 *------------------------------------------------------------
 */</comment>


<comment type="block">/* ----------
 * pgstat_report_stat() -
 *
 *    Must be called by processes that performs DML: tcop/postgres.c, logical
 *    receiver processes, SPI worker, etc. to send the so far collected
 *    per-table and function usage statistics to the collector.  Note that this
 *    is called only when not within a transaction, so it is fair to use
 *    transaction stop time as an approximation of current time.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_report_stat</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* we assume this inits to all zeroes: */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PgStat_TableCounts</name></type> <name>all_zeroes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>last_report</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_MsgTabstat</name></type> <name>regular_msg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_MsgTabstat</name></type> <name>shared_msg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TabStatusArray</name> <modifier>*</modifier></type><name>tsa</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Don't expend a clock check if nothing to do */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pgStatTabList</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>pgStatTabList</name><operator>-&gt;</operator><name>tsa_used</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
        <name>pgStatXactCommit</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pgStatXactRollback</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <operator>!</operator><name>have_function_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Don't send a message unless it's been at least PGSTAT_STAT_INTERVAL
     * msec since we last sent one, or the caller wants to force stats out.
     */</comment>
    <expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>GetCurrentTransactionStopTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>last_report</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>PGSTAT_STAT_INTERVAL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>last_report</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Destroy pgStatTabHash before we start invalidating PgStat_TableEntry
     * entries it points to.  (Should we fail partway through the loop below,
     * it's okay to have removed the hashtable already --- the only
     * consequence is we'd get multiple entries for the same table in the
     * pgStatTabList, and that's safe.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>pgStatTabHash</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>pgStatTabHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pgStatTabHash</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Scan through the TabStatusArray struct(s) to find tables that actually
     * have counts, and build messages to send.  We have to separate shared
     * relations from regular ones because the databaseid field in the message
     * header has to depend on that.
     */</comment>
    <expr_stmt><expr><name><name>regular_msg</name><operator>.</operator><name>m_databaseid</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>shared_msg</name><operator>.</operator><name>m_databaseid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>regular_msg</name><operator>.</operator><name>m_nentries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>shared_msg</name><operator>.</operator><name>m_nentries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>tsa</name> <operator>=</operator> <name>pgStatTabList</name></expr>;</init> <condition><expr><name>tsa</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>tsa</name> <operator>=</operator> <name><name>tsa</name><operator>-&gt;</operator><name>tsa_next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tsa</name><operator>-&gt;</operator><name>tsa_used</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PgStat_TableStatus</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>&amp;</operator><name><name>tsa</name><operator>-&gt;</operator><name>tsa_entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PgStat_MsgTabstat</name> <modifier>*</modifier></type><name>this_msg</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PgStat_TableEntry</name> <modifier>*</modifier></type><name>this_ent</name></decl>;</decl_stmt>

            <comment type="block">/* Shouldn't have any pending transaction-dependent counts */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>trans</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Ignore entries that didn't accumulate any actual counts, such
             * as indexes that were opened by the planner but not used.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>t_counts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>all_zeroes</name></expr></argument>,
                       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_TableCounts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/*
             * OK, insert data into the appropriate message, and send if full.
             */</comment>
            <expr_stmt><expr><name>this_msg</name> <operator>=</operator> <ternary><condition><expr><name><name>entry</name><operator>-&gt;</operator><name>t_shared</name></name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>shared_msg</name></expr> </then><else>: <expr><operator>&amp;</operator><name>regular_msg</name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name>this_ent</name> <operator>=</operator> <operator>&amp;</operator><name><name>this_msg</name><operator>-&gt;</operator><name>m_entry</name><index>[<expr><name><name>this_msg</name><operator>-&gt;</operator><name>m_nentries</name></name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this_ent</name><operator>-&gt;</operator><name>t_id</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>t_id</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<expr_stmt><expr><name><name>this_ent</name><operator>-&gt;</operator><name>t_parent_id</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>t_parent_id</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>this_ent</name><operator>-&gt;</operator><name>t_counts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>t_counts</name></name></expr></argument>,
                   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_TableCounts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>this_msg</name><operator>-&gt;</operator><name>m_nentries</name></name> <operator>&gt;=</operator> <name>PGSTAT_NUM_TABENTRIES</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pgstat_send_tabstat</name><argument_list>(<argument><expr><name>this_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this_msg</name><operator>-&gt;</operator><name>m_nentries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <comment type="block">/* zero out TableStatus structs after use */</comment>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>tsa</name><operator>-&gt;</operator><name>tsa_entries</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
               <argument><expr><name><name>tsa</name><operator>-&gt;</operator><name>tsa_used</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_TableStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tsa</name><operator>-&gt;</operator><name>tsa_used</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Send partial messages.  Make sure that any pending xact commit/abort
     * gets counted, even if there are no table stats to send.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>regular_msg</name><operator>.</operator><name>m_nentries</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
        <name>pgStatXactCommit</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>pgStatXactRollback</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pgstat_send_tabstat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regular_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>shared_msg</name><operator>.</operator><name>m_nentries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pgstat_send_tabstat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shared_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Now, send function statistics */</comment>
    <expr_stmt><expr><call><name>pgstat_send_funcstats</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for pgstat_report_stat: finish and send a tabstat message
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_send_tabstat</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgTabstat</name> <modifier>*</modifier></type><name>tsmsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>;</decl_stmt>

    <comment type="block">/* It's unlikely we'd get here with no socket, but maybe not impossible */</comment>
    <if_stmt><if>if <condition>(<expr><name>pgStatSock</name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Report and reset accumulated xact commit/rollback and I/O timings
     * whenever we send a normal tabstat message
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tsmsg</name><operator>-&gt;</operator><name>m_databaseid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>tsmsg</name><operator>-&gt;</operator><name>m_xact_commit</name></name> <operator>=</operator> <name>pgStatXactCommit</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tsmsg</name><operator>-&gt;</operator><name>m_xact_rollback</name></name> <operator>=</operator> <name>pgStatXactRollback</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tsmsg</name><operator>-&gt;</operator><name>m_block_read_time</name></name> <operator>=</operator> <name>pgStatBlockReadTime</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tsmsg</name><operator>-&gt;</operator><name>m_block_write_time</name></name> <operator>=</operator> <name>pgStatBlockWriteTime</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pgStatXactCommit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>pgStatXactRollback</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>pgStatBlockReadTime</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>pgStatBlockWriteTime</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>tsmsg</name><operator>-&gt;</operator><name>m_xact_commit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tsmsg</name><operator>-&gt;</operator><name>m_xact_rollback</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tsmsg</name><operator>-&gt;</operator><name>m_block_read_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tsmsg</name><operator>-&gt;</operator><name>m_block_write_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>tsmsg</name><operator>-&gt;</operator><name>m_nentries</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PgStat_MsgTabstat</name></expr></argument>, <argument><expr><name><name>m_entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator>
        <name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_TableEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pgstat_setheader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tsmsg</name><operator>-&gt;</operator><name>m_hdr</name></name></expr></argument>, <argument><expr><name>PGSTAT_MTYPE_TABSTAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_send</name><argument_list>(<argument><expr><name>tsmsg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for pgstat_report_stat: populate and send a function stat message
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_send_funcstats</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* we assume this inits to all zeroes: */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PgStat_FunctionCounts</name></type> <name>all_zeroes</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PgStat_MsgFuncstat</name></type> <name>msg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_BackendFunctionEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>fstat</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgStatFunctions</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>pgstat_setheader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>msg</name><operator>.</operator><name>m_hdr</name></name></expr></argument>, <argument><expr><name>PGSTAT_MTYPE_FUNCSTAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_databaseid</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_nentries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fstat</name></expr></argument>, <argument><expr><name>pgStatFunctions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>PgStat_BackendFunctionEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fstat</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PgStat_FunctionEntry</name> <modifier>*</modifier></type><name>m_ent</name></decl>;</decl_stmt>

        <comment type="block">/* Skip it if no counts accumulated since last time */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>f_counts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>all_zeroes</name></expr></argument>,
                   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_FunctionCounts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* need to convert format of time accumulators */</comment>
        <expr_stmt><expr><name>m_ent</name> <operator>=</operator> <operator>&amp;</operator><name><name>msg</name><operator>.</operator><name>m_entry</name><index>[<expr><name><name>msg</name><operator>.</operator><name>m_nentries</name></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>m_ent</name><operator>-&gt;</operator><name>f_id</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>f_id</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>m_ent</name><operator>-&gt;</operator><name>f_numcalls</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>f_counts</name><operator>.</operator><name>f_numcalls</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>m_ent</name><operator>-&gt;</operator><name>f_total_time</name></name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>f_counts</name><operator>.</operator><name>f_total_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>m_ent</name><operator>-&gt;</operator><name>f_self_time</name></name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>f_counts</name><operator>.</operator><name>f_self_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>msg</name><operator>.</operator><name>m_nentries</name></name> <operator>&gt;=</operator> <name>PGSTAT_NUM_FUNCENTRIES</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pgstat_send</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PgStat_MsgFuncstat</name></expr></argument>, <argument><expr><name><name>m_entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator>
                        <name><name>msg</name><operator>.</operator><name>m_nentries</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_FunctionEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_nentries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* reset the entry's counts */</comment>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>f_counts</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_FunctionCounts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name><name>msg</name><operator>.</operator><name>m_nentries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pgstat_send</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PgStat_MsgFuncstat</name></expr></argument>, <argument><expr><name><name>m_entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator>
                    <name><name>msg</name><operator>.</operator><name>m_nentries</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_FunctionEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>have_function_stats</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_vacuum_stat() -
 *
 *    Will tell the collector about objects he can get rid of.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_vacuum_stat</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HTAB</name>       <modifier>*</modifier></type><name>htab</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_MsgTabpurge</name></type> <name>msg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_MsgFuncpurge</name></type> <name>f_msg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hstat</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_StatTabEntry</name> <modifier>*</modifier></type><name>tabentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_StatFuncEntry</name> <modifier>*</modifier></type><name>funcentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgStatSock</name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If not done for this transaction, read the statistics collector stats
     * file into some hash tables.
     */</comment>
    <expr_stmt><expr><call><name>backend_read_statsfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Read pg_database and make a list of OIDs of all existing databases
     */</comment>
    <expr_stmt><expr><name>htab</name> <operator>=</operator> <call><name>pgstat_collect_oids</name><argument_list>(<argument><expr><name>DatabaseRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Search the database hash table for dead databases and tell the
     * collector to drop them.
     */</comment>
    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>, <argument><expr><name>pgStatDBHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>dbentry</name> <operator>=</operator> <operator>(</operator><name>PgStat_StatDBEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>dbid</name> <init>= <expr><name><name>dbentry</name><operator>-&gt;</operator><name>databaseid</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* the DB entry for shared tables (with InvalidOid) is never dropped */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>dbid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>hash_search</name><argument_list>(<argument><expr><name>htab</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>dbid</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pgstat_drop_database</name><argument_list>(<argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Clean up */</comment>
    <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Lookup our own database entry; if not found, nothing more to do.
     */</comment>
    <expr_stmt><expr><name>dbentry</name> <operator>=</operator> <operator>(</operator><name>PgStat_StatDBEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>pgStatDBHash</name></expr></argument>,
                                                 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>MyDatabaseId</name></expr></argument>,
                                                 <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dbentry</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Similarly to above, make a list of all known relations in this DB.
     */</comment>
    <expr_stmt><expr><name>htab</name> <operator>=</operator> <call><name>pgstat_collect_oids</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize our messages table counter to zero
     */</comment>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_nentries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Check for all tables listed in stats hashtable if they still exist.
     */</comment>
    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>, <argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>tabentry</name> <operator>=</operator> <operator>(</operator><name>PgStat_StatTabEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>tabid</name> <init>= <expr><name><name>tabentry</name><operator>-&gt;</operator><name>tableid</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>htab</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tabid</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Not there, so add this table's Oid to the message
         */</comment>
        <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_tableid</name><index>[<expr><name><name>msg</name><operator>.</operator><name>m_nentries</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>tabid</name></expr>;</expr_stmt>

        <comment type="block">/*
         * If the message is full, send it out and reinitialize to empty
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>msg</name><operator>.</operator><name>m_nentries</name></name> <operator>&gt;=</operator> <name>PGSTAT_NUM_TABPURGE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PgStat_MsgTabpurge</name></expr></argument>, <argument><expr><name><name>m_tableid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call>
                <operator>+</operator> <name><name>msg</name><operator>.</operator><name>m_nentries</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>pgstat_setheader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>msg</name><operator>.</operator><name>m_hdr</name></name></expr></argument>, <argument><expr><name>PGSTAT_MTYPE_TABPURGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_databaseid</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pgstat_send</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_nentries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * Send the rest
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>msg</name><operator>.</operator><name>m_nentries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PgStat_MsgTabpurge</name></expr></argument>, <argument><expr><name><name>m_tableid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call>
            <operator>+</operator> <name><name>msg</name><operator>.</operator><name>m_nentries</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pgstat_setheader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>msg</name><operator>.</operator><name>m_hdr</name></name></expr></argument>, <argument><expr><name>PGSTAT_MTYPE_TABPURGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_databaseid</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pgstat_send</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Clean up */</comment>
    <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now repeat the above steps for functions.  However, we needn't bother
     * in the common case where no function stats are being collected.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>dbentry</name><operator>-&gt;</operator><name>functions</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
        <call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>htab</name> <operator>=</operator> <call><name>pgstat_collect_oids</name><argument_list>(<argument><expr><name>ProcedureRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pgstat_setheader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f_msg</name><operator>.</operator><name>m_hdr</name></name></expr></argument>, <argument><expr><name>PGSTAT_MTYPE_FUNCPURGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>f_msg</name><operator>.</operator><name>m_databaseid</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>f_msg</name><operator>.</operator><name>m_nentries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>, <argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>funcentry</name> <operator>=</operator> <operator>(</operator><name>PgStat_StatFuncEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>funcid</name> <init>= <expr><name><name>funcentry</name><operator>-&gt;</operator><name>functionid</name></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>htab</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>funcid</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Not there, so add this function's Oid to the message
             */</comment>
            <expr_stmt><expr><name><name>f_msg</name><operator>.</operator><name>m_functionid</name><index>[<expr><name><name>f_msg</name><operator>.</operator><name>m_nentries</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>funcid</name></expr>;</expr_stmt>

            <comment type="block">/*
             * If the message is full, send it out and reinitialize to empty
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>f_msg</name><operator>.</operator><name>m_nentries</name></name> <operator>&gt;=</operator> <name>PGSTAT_NUM_FUNCPURGE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PgStat_MsgFuncpurge</name></expr></argument>, <argument><expr><name><name>m_functionid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call>
                    <operator>+</operator> <name><name>f_msg</name><operator>.</operator><name>m_nentries</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>pgstat_send</name><argument_list>(<argument><expr><operator>&amp;</operator><name>f_msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>f_msg</name><operator>.</operator><name>m_nentries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>

        <comment type="block">/*
         * Send the rest
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>f_msg</name><operator>.</operator><name>m_nentries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PgStat_MsgFuncpurge</name></expr></argument>, <argument><expr><name><name>m_functionid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call>
                <operator>+</operator> <name><name>f_msg</name><operator>.</operator><name>m_nentries</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>pgstat_send</name><argument_list>(<argument><expr><operator>&amp;</operator><name>f_msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_collect_oids() -
 *
 *    Collect the OIDs of all objects listed in the specified system catalog
 *    into a temporary hash table.  Caller should hash_destroy the result
 *    when done with it.  (However, we make the table in CurrentMemoryContext
 *    so that it will be freed properly in event of an error.)
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type>
<name>pgstat_collect_oids</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>catalogid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HTAB</name>       <modifier>*</modifier></type><name>htab</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HASHCTL</name></type>        <name>hash_ctl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Snapshot</name></type>    <name>snapshot</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>htab</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Temporary table of OIDs"</literal></expr></argument>,
                       <argument><expr><name>PGSTAT_TAB_HASH_SIZE</name></expr></argument>,
                       <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
                       <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>catalogid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>tup</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>thisoid</name> <init>= <expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>htab</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>thisoid</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>htab</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_drop_database() -
 *
 *    Tell the collector that we just dropped a database.
 *    (If the message gets lost, we will still clean the dead DB eventually
 *    via future invocations of pgstat_vacuum_stat().)
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_drop_database</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_MsgDropdb</name></type> <name>msg</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgStatSock</name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>pgstat_setheader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>msg</name><operator>.</operator><name>m_hdr</name></name></expr></argument>, <argument><expr><name>PGSTAT_MTYPE_DROPDB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_databaseid</name></name> <operator>=</operator> <name>databaseid</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_send</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_drop_relation() -
 *
 *    Tell the collector that we just dropped a relation.
 *    (If the message gets lost, we will still clean the dead entry eventually
 *    via future invocations of pgstat_vacuum_stat().)
 *
 *    Currently not used for lack of any good place to call it; we rely
 *    entirely on pgstat_vacuum_stat() to clean out stats for dead rels.
 * ----------
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>pgstat_drop_relation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_MsgTabpurge</name></type> <name>msg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgStatSock</name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_tableid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_nentries</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PgStat_MsgTabpurge</name></expr></argument>, <argument><expr><name><name>m_tableid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pgstat_setheader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>msg</name><operator>.</operator><name>m_hdr</name></name></expr></argument>, <argument><expr><name>PGSTAT_MTYPE_TABPURGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_databaseid</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_send</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* NOT_USED */</comment>


<comment type="block">/* ----------
 * pgstat_reset_counters() -
 *
 *    Tell the statistics collector to reset counters for our database.
 *
 *    Permission checking for this function is managed through the normal
 *    GRANT system.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_reset_counters</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_MsgResetcounter</name></type> <name>msg</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgStatSock</name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>pgstat_setheader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>msg</name><operator>.</operator><name>m_hdr</name></name></expr></argument>, <argument><expr><name>PGSTAT_MTYPE_RESETCOUNTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_databaseid</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_send</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_reset_shared_counters() -
 *
 *    Tell the statistics collector to reset cluster-wide shared counters.
 *
 *    Permission checking for this function is managed through the normal
 *    GRANT system.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_reset_shared_counters</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_MsgResetsharedcounter</name></type> <name>msg</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgStatSock</name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="string">"archiver"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_resettarget</name></name> <operator>=</operator> <name>RESET_ARCHIVER</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="string">"bgwriter"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_resettarget</name></name> <operator>=</operator> <name>RESET_BGWRITER</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized reset target: \"%s\""</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Target must be \"archiver\" or \"bgwriter\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>pgstat_setheader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>msg</name><operator>.</operator><name>m_hdr</name></name></expr></argument>, <argument><expr><name>PGSTAT_MTYPE_RESETSHAREDCOUNTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_send</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_reset_single_counter() -
 *
 *    Tell the statistics collector to reset a single counter.
 *
 *    Permission checking for this function is managed through the normal
 *    GRANT system.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_reset_single_counter</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>objoid</name></decl></parameter>, <parameter><decl><type><name>PgStat_Single_Reset_Type</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_MsgResetsinglecounter</name></type> <name>msg</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgStatSock</name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>pgstat_setheader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>msg</name><operator>.</operator><name>m_hdr</name></name></expr></argument>, <argument><expr><name>PGSTAT_MTYPE_RESETSINGLECOUNTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_databaseid</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_resettype</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_objectid</name></name> <operator>=</operator> <name>objoid</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pgstat_send</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_report_autovac() -
 *
 *    Called from autovacuum.c to report startup of an autovacuum process.
 *    We are called before InitPostgres is done, so can't rely on MyDatabaseId;
 *    the db OID must be passed in, instead.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_report_autovac</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dboid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_MsgAutovacStart</name></type> <name>msg</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgStatSock</name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>pgstat_setheader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>msg</name><operator>.</operator><name>m_hdr</name></name></expr></argument>, <argument><expr><name>PGSTAT_MTYPE_AUTOVAC_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_databaseid</name></name> <operator>=</operator> <name>dboid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_start_time</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pgstat_send</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ---------
 * pgstat_report_vacuum() -
 *
 *    Tell the collector about the table we just vacuumed.
 * ---------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_report_vacuum</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableoid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shared</name></decl></parameter>,
                     <parameter><decl><type><name>PgStat_Counter</name></type> <name>livetuples</name></decl></parameter>, <parameter><decl><type><name>PgStat_Counter</name></type> <name>deadtuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_MsgVacuum</name></type> <name>msg</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgStatSock</name> <operator>==</operator> <name>PGINVALID_SOCKET</name> <operator>||</operator> <operator>!</operator><name>pgstat_track_counts</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>pgstat_setheader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>msg</name><operator>.</operator><name>m_hdr</name></name></expr></argument>, <argument><expr><name>PGSTAT_MTYPE_VACUUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_databaseid</name></name> <operator>=</operator> <ternary><condition><expr><name>shared</name></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><name>MyDatabaseId</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_tableoid</name></name> <operator>=</operator> <name>tableoid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_autovacuum</name></name> <operator>=</operator> <call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_vacuumtime</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_live_tuples</name></name> <operator>=</operator> <name>livetuples</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_dead_tuples</name></name> <operator>=</operator> <name>deadtuples</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_send</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* --------
 * pgstat_report_analyze() -
 *
 *    Tell the collector about the table we just analyzed.
 *
 * Caller must provide new live- and dead-tuples estimates, as well as a
 * flag indicating whether to reset the changes_since_analyze counter.
 * --------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_report_analyze</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                      <parameter><decl><type><name>PgStat_Counter</name></type> <name>livetuples</name></decl></parameter>, <parameter><decl><type><name>PgStat_Counter</name></type> <name>deadtuples</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name></type> <name>resetcounter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_MsgAnalyze</name></type> <name>msg</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgStatSock</name> <operator>==</operator> <name>PGINVALID_SOCKET</name> <operator>||</operator> <operator>!</operator><name>pgstat_track_counts</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Unlike VACUUM, ANALYZE might be running inside a transaction that has
     * already inserted and/or deleted rows in the target table. ANALYZE will
     * have counted such rows as live or dead respectively. Because we will
     * report our counts of such rows at transaction end, we should subtract
     * off these counts from what we send to the collector now, else they'll
     * be double-counted after commit.  (This approach also ensures that the
     * collector ends up with the right numbers if we abort instead of
     * committing.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>pgstat_info</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PgStat_TableXactStatus</name> <modifier>*</modifier></type><name>trans</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>trans</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name></name></expr>;</init> <condition><expr><name>trans</name></expr>;</condition> <incr><expr><name>trans</name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>upper</name></name></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>livetuples</name> <operator>-=</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_inserted</name></name> <operator>-</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_deleted</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>deadtuples</name> <operator>-=</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_updated</name></name> <operator>+</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_deleted</name></name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <comment type="block">/* count stuff inserted by already-aborted subxacts, too */</comment>
        <expr_stmt><expr><name>deadtuples</name> <operator>-=</operator> <name><name>rel</name><operator>-&gt;</operator><name>pgstat_info</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_delta_dead_tuples</name></name></expr>;</expr_stmt>
        <comment type="block">/* Since ANALYZE's counts are estimates, we could have underflowed */</comment>
        <expr_stmt><expr><name>livetuples</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>livetuples</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>deadtuples</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>deadtuples</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>pgstat_setheader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>msg</name><operator>.</operator><name>m_hdr</name></name></expr></argument>, <argument><expr><name>PGSTAT_MTYPE_ANALYZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_databaseid</name></name> <operator>=</operator> <ternary><condition><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><name>MyDatabaseId</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_tableoid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_autovacuum</name></name> <operator>=</operator> <call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_resetcounter</name></name> <operator>=</operator> <name>resetcounter</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_analyzetime</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_live_tuples</name></name> <operator>=</operator> <name>livetuples</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_dead_tuples</name></name> <operator>=</operator> <name>deadtuples</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_send</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* --------
 * pgstat_report_recovery_conflict() -
 *
 *    Tell the collector about a Hot Standby recovery conflict.
 * --------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_report_recovery_conflict</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>reason</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_MsgRecoveryConflict</name></type> <name>msg</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgStatSock</name> <operator>==</operator> <name>PGINVALID_SOCKET</name> <operator>||</operator> <operator>!</operator><name>pgstat_track_counts</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>pgstat_setheader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>msg</name><operator>.</operator><name>m_hdr</name></name></expr></argument>, <argument><expr><name>PGSTAT_MTYPE_RECOVERYCONFLICT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_databaseid</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_reason</name></name> <operator>=</operator> <name>reason</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_send</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* --------
 * pgstat_report_deadlock() -
 *
 *    Tell the collector about a deadlock detected.
 * --------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_report_deadlock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_MsgDeadlock</name></type> <name>msg</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgStatSock</name> <operator>==</operator> <name>PGINVALID_SOCKET</name> <operator>||</operator> <operator>!</operator><name>pgstat_track_counts</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>pgstat_setheader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>msg</name><operator>.</operator><name>m_hdr</name></name></expr></argument>, <argument><expr><name>PGSTAT_MTYPE_DEADLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_databaseid</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_send</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* --------
 * pgstat_report_tempfile() -
 *
 *    Tell the collector about a temporary file.
 * --------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_report_tempfile</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>filesize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_MsgTempFile</name></type> <name>msg</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgStatSock</name> <operator>==</operator> <name>PGINVALID_SOCKET</name> <operator>||</operator> <operator>!</operator><name>pgstat_track_counts</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>pgstat_setheader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>msg</name><operator>.</operator><name>m_hdr</name></name></expr></argument>, <argument><expr><name>PGSTAT_MTYPE_TEMPFILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_databaseid</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_filesize</name></name> <operator>=</operator> <name>filesize</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_send</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_ping() -
 *
 *    Send some junk data to the collector to increase traffic.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_ping</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_MsgDummy</name></type> <name>msg</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgStatSock</name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>pgstat_setheader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>msg</name><operator>.</operator><name>m_hdr</name></name></expr></argument>, <argument><expr><name>PGSTAT_MTYPE_DUMMY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_send</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_send_inquiry() -
 *
 *    Notify collector that we need fresh data.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_send_inquiry</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>clock_time</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>cutoff_time</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_MsgInquiry</name></type> <name>msg</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pgstat_setheader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>msg</name><operator>.</operator><name>m_hdr</name></name></expr></argument>, <argument><expr><name>PGSTAT_MTYPE_INQUIRY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>clock_time</name></name> <operator>=</operator> <name>clock_time</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>cutoff_time</name></name> <operator>=</operator> <name>cutoff_time</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>databaseid</name></name> <operator>=</operator> <name>databaseid</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_send</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Initialize function call usage data.
 * Called by the executor before invoking a function.
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_init_function_usage</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfoData</name> <modifier>*</modifier></type><name>fcinfo</name></decl></parameter>,
                           <parameter><decl><type><name>PgStat_FunctionCallUsage</name> <modifier>*</modifier></type><name>fcu</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_BackendFunctionEntry</name> <modifier>*</modifier></type><name>htabent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgstat_track_functions</name> <operator>&lt;=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_stats</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* stats not wanted */</comment>
        <expr_stmt><expr><name><name>fcu</name><operator>-&gt;</operator><name>fs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pgStatFunctions</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* First time through - initialize function stat table */</comment>
        <decl_stmt><decl><type><name>HASHCTL</name></type>        <name>hash_ctl</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_BackendFunctionEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name>pgStatFunctions</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Function stat entries"</literal></expr></argument>,
                                      <argument><expr><name>PGSTAT_FUNCTION_HASH_SIZE</name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
                                      <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Get the stats entry for this function, create if necessary */</comment>
    <expr_stmt><expr><name>htabent</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>pgStatFunctions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>,
                          <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>htabent</name><operator>-&gt;</operator><name>f_counts</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_FunctionCounts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>fcu</name><operator>-&gt;</operator><name>fs</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>htabent</name><operator>-&gt;</operator><name>f_counts</name></name></expr>;</expr_stmt>

    <comment type="block">/* save stats for this function, later used to compensate for recursion */</comment>
    <expr_stmt><expr><name><name>fcu</name><operator>-&gt;</operator><name>save_f_total_time</name></name> <operator>=</operator> <name><name>htabent</name><operator>-&gt;</operator><name>f_counts</name><operator>.</operator><name>f_total_time</name></name></expr>;</expr_stmt>

    <comment type="block">/* save current backend-wide total time */</comment>
    <expr_stmt><expr><name><name>fcu</name><operator>-&gt;</operator><name>save_total</name></name> <operator>=</operator> <name>total_func_time</name></expr>;</expr_stmt>

    <comment type="block">/* get clock time as of function start */</comment>
    <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name><name>fcu</name><operator>-&gt;</operator><name>f_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * find_funcstat_entry - find any existing PgStat_BackendFunctionEntry entry
 *        for specified function
 *
 * If no entry, return NULL, don't create a new one
 */</comment>
<function><type><name>PgStat_BackendFunctionEntry</name> <modifier>*</modifier></type>
<name>find_funcstat_entry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>func_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>pgStatFunctions</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><operator>(</operator><name>PgStat_BackendFunctionEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>pgStatFunctions</name></expr></argument>,
                                                       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>func_id</name></expr></argument>,
                                                       <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate function call usage and update stat counters.
 * Called by the executor after invoking a function.
 *
 * In the case of a set-returning function that runs in value-per-call mode,
 * we will see multiple pgstat_init_function_usage/pgstat_end_function_usage
 * calls for what the user considers a single call of the function.  The
 * finalize flag should be TRUE on the last call.
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_end_function_usage</name><parameter_list>(<parameter><decl><type><name>PgStat_FunctionCallUsage</name> <modifier>*</modifier></type><name>fcu</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>finalize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_FunctionCounts</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>fcu</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>instr_time</name></type>    <name>f_total</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>instr_time</name></type>    <name>f_others</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>instr_time</name></type>    <name>f_self</name></decl>;</decl_stmt>

    <comment type="block">/* stats not wanted? */</comment>
    <if_stmt><if>if <condition>(<expr><name>fs</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* total elapsed time in this function call */</comment>
    <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>f_total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>f_total</name></expr></argument>, <argument><expr><name><name>fcu</name><operator>-&gt;</operator><name>f_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* self usage: elapsed minus anything already charged to other calls */</comment>
    <expr_stmt><expr><name>f_others</name> <operator>=</operator> <name>total_func_time</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>f_others</name></expr></argument>, <argument><expr><name><name>fcu</name><operator>-&gt;</operator><name>save_total</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>f_self</name> <operator>=</operator> <name>f_total</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>f_self</name></expr></argument>, <argument><expr><name>f_others</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* update backend-wide total time */</comment>
    <expr_stmt><expr><call><name>INSTR_TIME_ADD</name><argument_list>(<argument><expr><name>total_func_time</name></expr></argument>, <argument><expr><name>f_self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Compute the new f_total_time as the total elapsed time added to the
     * pre-call value of f_total_time.  This is necessary to avoid
     * double-counting any time taken by recursive calls of myself.  (We do
     * not need any similar kluge for self time, since that already excludes
     * any recursive calls.)
     */</comment>
    <expr_stmt><expr><call><name>INSTR_TIME_ADD</name><argument_list>(<argument><expr><name>f_total</name></expr></argument>, <argument><expr><name><name>fcu</name><operator>-&gt;</operator><name>save_f_total_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* update counters in function stats table */</comment>
    <if_stmt><if>if <condition>(<expr><name>finalize</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>f_numcalls</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>f_total_time</name></name> <operator>=</operator> <name>f_total</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>INSTR_TIME_ADD</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>f_self_time</name></name></expr></argument>, <argument><expr><name>f_self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* indicate that we have something to send */</comment>
    <expr_stmt><expr><name>have_function_stats</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_initstats() -
 *
 *    Initialize a relcache entry to count access statistics.
 *    Called whenever a relation is opened.
 *
 *    We assume that a relcache entry's pgstat_info field is zeroed by
 *    relcache.c when the relcache entry is made; thereafter it is long-lived
 *    data.  We can avoid repeated searches of the TabStatus arrays when the
 *    same relation is touched repeatedly within a transaction.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_initstats</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>rel_id</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>relkind</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* We only count stats for things that have storage */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
          <name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
          <name>relkind</name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
          <name>relkind</name> <operator>==</operator> <name>RELKIND_TOASTVALUE</name> <operator>||</operator>
          <name>relkind</name> <operator>==</operator> <name>RELKIND_SEQUENCE</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>pgstat_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgStatSock</name> <operator>==</operator> <name>PGINVALID_SOCKET</name> <operator>||</operator> <operator>!</operator><name>pgstat_track_counts</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We're not counting at all */</comment>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>pgstat_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If we already set up this relation in the current transaction, nothing
     * to do.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>pgstat_info</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
        <name><name>rel</name><operator>-&gt;</operator><name>pgstat_info</name><operator>-&gt;</operator><name>t_id</name></name> <operator>==</operator> <name>rel_id</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Else find or make the PgStat_TableStatus entry, and update link */</comment>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>pgstat_info</name></name> <operator>=</operator> <call><name>get_tabstat_entry</name><argument_list>(<argument><expr><name>rel_id</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>pgstat_info</name><operator>-&gt;</operator><name>t_parent_id</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relparent</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * get_tabstat_entry - find or create a PgStat_TableStatus entry for rel
 */</comment>
<function><type><specifier>static</specifier> <name>PgStat_TableStatus</name> <modifier>*</modifier></type>
<name>get_tabstat_entry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>rel_id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isshared</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TabStatHashEntry</name> <modifier>*</modifier></type><name>hash_entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_TableStatus</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TabStatusArray</name> <modifier>*</modifier></type><name>tsa</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Create hash table if we don't have it already.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>pgStatTabHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HASHCTL</name></type>        <name>ctl</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TabStatHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

        <expr_stmt><expr><name>pgStatTabHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"pgstat TabStatusArray lookup hash table"</literal></expr></argument>,
                                    <argument><expr><name>TABSTAT_QUANTUM</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
                                    <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Find an entry or create a new one.
     */</comment>
    <expr_stmt><expr><name>hash_entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>pgStatTabHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rel_id</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* initialize new entry with null pointer */</comment>
        <expr_stmt><expr><name><name>hash_entry</name><operator>-&gt;</operator><name>tsa_entry</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If entry is already valid, we're done.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hash_entry</name><operator>-&gt;</operator><name>tsa_entry</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name><name>hash_entry</name><operator>-&gt;</operator><name>tsa_entry</name></name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Locate the first pgStatTabList entry with free space, making a new list
     * entry if needed.  Note that we could get an OOM failure here, but if so
     * we have left the hashtable and the list in a consistent state.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>pgStatTabList</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Set up first pgStatTabList entry */</comment>
        <expr_stmt><expr><name>pgStatTabList</name> <operator>=</operator> <operator>(</operator><name>TabStatusArray</name> <operator>*</operator><operator>)</operator>
            <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TabStatusArray</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>tsa</name> <operator>=</operator> <name>pgStatTabList</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name><name>tsa</name><operator>-&gt;</operator><name>tsa_used</name></name> <operator>&gt;=</operator> <name>TABSTAT_QUANTUM</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>tsa</name><operator>-&gt;</operator><name>tsa_next</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>tsa</name><operator>-&gt;</operator><name>tsa_next</name></name> <operator>=</operator> <operator>(</operator><name>TabStatusArray</name> <operator>*</operator><operator>)</operator>
                <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TabStatusArray</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>tsa</name> <operator>=</operator> <name><name>tsa</name><operator>-&gt;</operator><name>tsa_next</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * Allocate a PgStat_TableStatus entry within this list entry.  We assume
     * the entry was already zeroed, either at creation or after last use.
     */</comment>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>&amp;</operator><name><name>tsa</name><operator>-&gt;</operator><name>tsa_entries</name><index>[<expr><name><name>tsa</name><operator>-&gt;</operator><name>tsa_used</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>t_id</name></name> <operator>=</operator> <name>rel_id</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>t_shared</name></name> <operator>=</operator> <name>isshared</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Now we can fill the entry in pgStatTabHash.
     */</comment>
    <expr_stmt><expr><name><name>hash_entry</name><operator>-&gt;</operator><name>tsa_entry</name></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>

    <return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_tabstat_entry - find any existing PgStat_TableStatus entry for rel
 *
 * If no entry, return NULL, don't create a new one
 *
 * Note: if we got an error in the most recent execution of pgstat_report_stat,
 * it's possible that an entry exists but there's no hashtable entry for it.
 * That's okay, we'll treat this case as "doesn't exist".
 */</comment>
<function><type><name>PgStat_TableStatus</name> <modifier>*</modifier></type>
<name>find_tabstat_entry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>rel_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TabStatHashEntry</name> <modifier>*</modifier></type><name>hash_entry</name></decl>;</decl_stmt>

    <comment type="block">/* If hashtable doesn't exist, there are no entries at all */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pgStatTabHash</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>hash_entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>pgStatTabHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rel_id</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>hash_entry</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Note that this step could also return NULL, but that's correct */</comment>
    <return>return <expr><name><name>hash_entry</name><operator>-&gt;</operator><name>tsa_entry</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_tabstat_stack_level - add a new (sub)transaction stack entry if needed
 */</comment>
<function><type><specifier>static</specifier> <name>PgStat_SubXactStatus</name> <modifier>*</modifier></type>
<name>get_tabstat_stack_level</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nest_level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_SubXactStatus</name> <modifier>*</modifier></type><name>xact_state</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>xact_state</name> <operator>=</operator> <name>pgStatXactStack</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>xact_state</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>xact_state</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>!=</operator> <name>nest_level</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>xact_state</name> <operator>=</operator> <operator>(</operator><name>PgStat_SubXactStatus</name> <operator>*</operator><operator>)</operator>
            <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>,
                               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_SubXactStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xact_state</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>=</operator> <name>nest_level</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xact_state</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>pgStatXactStack</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xact_state</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pgStatXactStack</name> <operator>=</operator> <name>xact_state</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>xact_state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * add_tabstat_xact_level - add a new (sub)transaction state record
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_tabstat_xact_level</name><parameter_list>(<parameter><decl><type><name>PgStat_TableStatus</name> <modifier>*</modifier></type><name>pgstat_info</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nest_level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_SubXactStatus</name> <modifier>*</modifier></type><name>xact_state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_TableXactStatus</name> <modifier>*</modifier></type><name>trans</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If this is the first rel to be modified at the current nest level, we
     * first have to push a transaction stack entry.
     */</comment>
    <expr_stmt><expr><name>xact_state</name> <operator>=</operator> <call><name>get_tabstat_stack_level</name><argument_list>(<argument><expr><name>nest_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now make a per-table stack entry */</comment>
    <expr_stmt><expr><name>trans</name> <operator>=</operator> <operator>(</operator><name>PgStat_TableXactStatus</name> <operator>*</operator><operator>)</operator>
        <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>,
                               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_TableXactStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>=</operator> <name>nest_level</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>upper</name></name> <operator>=</operator> <name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>pgstat_info</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>xact_state</name><operator>-&gt;</operator><name>first</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>xact_state</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name>trans</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name></name> <operator>=</operator> <name>trans</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pgstat_count_heap_insert - count a tuple insertion of n tuples
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_count_heap_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>PgStat_Counter</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_TableStatus</name> <modifier>*</modifier></type><name>pgstat_info</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>pgstat_info</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgstat_info</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We have to log the effect at the proper transactional level */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>nest_level</name> <init>= <expr><call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
            <name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>!=</operator> <name>nest_level</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>add_tabstat_xact_level</name><argument_list>(<argument><expr><name>pgstat_info</name></expr></argument>, <argument><expr><name>nest_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name><operator>-&gt;</operator><name>tuples_inserted</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pgstat_count_heap_update - count a tuple update
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_count_heap_update</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_TableStatus</name> <modifier>*</modifier></type><name>pgstat_info</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>pgstat_info</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgstat_info</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We have to log the effect at the proper transactional level */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>nest_level</name> <init>= <expr><call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
            <name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>!=</operator> <name>nest_level</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>add_tabstat_xact_level</name><argument_list>(<argument><expr><name>pgstat_info</name></expr></argument>, <argument><expr><name>nest_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name><operator>-&gt;</operator><name>tuples_updated</name></name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/* t_tuples_hot_updated is nontransactional, so just advance it */</comment>
        <if_stmt><if>if <condition>(<expr><name>hot</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_hot_updated</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pgstat_count_heap_delete - count a tuple deletion
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_count_heap_delete</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_TableStatus</name> <modifier>*</modifier></type><name>pgstat_info</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>pgstat_info</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgstat_info</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We have to log the effect at the proper transactional level */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>nest_level</name> <init>= <expr><call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
            <name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>!=</operator> <name>nest_level</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>add_tabstat_xact_level</name><argument_list>(<argument><expr><name>pgstat_info</name></expr></argument>, <argument><expr><name>nest_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name><operator>-&gt;</operator><name>tuples_deleted</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pgstat_truncate_save_counters
 *
 * Whenever a table is truncated, we save its i/u/d counters so that they can
 * be cleared, and if the (sub)xact that executed the truncate later aborts,
 * the counters can be restored to the saved (pre-truncate) values.  Note we do
 * this on the first truncate in any particular subxact level only.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_truncate_save_counters</name><parameter_list>(<parameter><decl><type><name>PgStat_TableXactStatus</name> <modifier>*</modifier></type><name>trans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>trans</name><operator>-&gt;</operator><name>truncated</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>inserted_pre_trunc</name></name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_inserted</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>updated_pre_trunc</name></name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_updated</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>deleted_pre_trunc</name></name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_deleted</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>truncated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pgstat_truncate_restore_counters - restore counters when a truncate aborts
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_truncate_restore_counters</name><parameter_list>(<parameter><decl><type><name>PgStat_TableXactStatus</name> <modifier>*</modifier></type><name>trans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>trans</name><operator>-&gt;</operator><name>truncated</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>tuples_inserted</name></name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>inserted_pre_trunc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>tuples_updated</name></name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>updated_pre_trunc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>tuples_deleted</name></name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>deleted_pre_trunc</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pgstat_count_truncate - update tuple counters due to truncate
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_count_truncate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_TableStatus</name> <modifier>*</modifier></type><name>pgstat_info</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>pgstat_info</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgstat_info</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We have to log the effect at the proper transactional level */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>nest_level</name> <init>= <expr><call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
            <name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>!=</operator> <name>nest_level</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>add_tabstat_xact_level</name><argument_list>(<argument><expr><name>pgstat_info</name></expr></argument>, <argument><expr><name>nest_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>pgstat_truncate_save_counters</name><argument_list>(<argument><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name><operator>-&gt;</operator><name>tuples_inserted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name><operator>-&gt;</operator><name>tuples_updated</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name><operator>-&gt;</operator><name>tuples_deleted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pgstat_update_heap_dead_tuples - update dead-tuples count
 *
 * The semantics of this are that we are reporting the nontransactional
 * recovery of "delta" dead tuples; so t_delta_dead_tuples decreases
 * rather than increasing, and the change goes straight into the per-table
 * counter, not into transactional state.
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_update_heap_dead_tuples</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>delta</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_TableStatus</name> <modifier>*</modifier></type><name>pgstat_info</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>pgstat_info</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgstat_info</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_delta_dead_tuples</name></name> <operator>-=</operator> <name>delta</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<comment type="block">/*
 * pgstat_count_remote_insert - count insertion of n tuples on remote Datanodes
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_count_remote_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* For now use the same counters as for heap insert */</comment>
    <expr_stmt><expr><call><name>pgstat_count_heap_insert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * pgstat_count_remote_update - count update of n tuples on remote Datanodes
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_count_remote_update</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_TableStatus</name> <modifier>*</modifier></type><name>pgstat_info</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>pgstat_info</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgstat_info</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We have to log the effect at the proper transactional level */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>nest_level</name> <init>= <expr><call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
            <name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>!=</operator> <name>nest_level</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>add_tabstat_xact_level</name><argument_list>(<argument><expr><name>pgstat_info</name></expr></argument>, <argument><expr><name>nest_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name><operator>-&gt;</operator><name>tuples_updated</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * pgstat_count_remote_delete - count delete of n tuples on remote Datanodes
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_count_remote_delete</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_TableStatus</name> <modifier>*</modifier></type><name>pgstat_info</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>pgstat_info</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Should be only applied to distributed table */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgstat_info</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We have to log the effect at the proper transactional level */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>nest_level</name> <init>= <expr><call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
            <name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>!=</operator> <name>nest_level</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>add_tabstat_xact_level</name><argument_list>(<argument><expr><name>pgstat_info</name></expr></argument>, <argument><expr><name>nest_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>trans</name><operator>-&gt;</operator><name>tuples_deleted</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* ----------
 * AtEOXact_PgStat
 *
 *    Called from access/transam/xact.c at top-level transaction commit/abort.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_PgStat</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_SubXactStatus</name> <modifier>*</modifier></type><name>xact_state</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Count transaction commit or abort.  (We use counters, not just bools,
     * in case the reporting message isn't sent right away.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>pgStatXactCommit</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>pgStatXactRollback</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Transfer transactional insert/update counts into the base tabstat
     * entries.  We don't bother to free any of the transactional state, since
     * it's all in TopTransactionContext and will go away anyway.
     */</comment>
    <expr_stmt><expr><name>xact_state</name> <operator>=</operator> <name>pgStatXactStack</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>xact_state</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PgStat_TableXactStatus</name> <modifier>*</modifier></type><name>trans</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>xact_state</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>xact_state</name><operator>-&gt;</operator><name>prev</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>trans</name> <operator>=</operator> <name><name>xact_state</name><operator>-&gt;</operator><name>first</name></name></expr>;</init> <condition><expr><name>trans</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>trans</name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PgStat_TableStatus</name> <modifier>*</modifier></type><name>tabstat</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>trans</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>trans</name><operator>-&gt;</operator><name>upper</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tabstat</name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tabstat</name><operator>-&gt;</operator><name>trans</name></name> <operator>==</operator> <name>trans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* restore pre-truncate stats (if any) in case of aborted xact */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgstat_truncate_restore_counters</name><argument_list>(<argument><expr><name>trans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* count attempted actions regardless of commit/abort */</comment>
            <expr_stmt><expr><name><name>tabstat</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_inserted</name></name> <operator>+=</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_inserted</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tabstat</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_updated</name></name> <operator>+=</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_updated</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tabstat</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_deleted</name></name> <operator>+=</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_deleted</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>tabstat</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_truncated</name></name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>truncated</name></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>trans</name><operator>-&gt;</operator><name>truncated</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* forget live/dead stats seen by backend thus far */</comment>
                    <expr_stmt><expr><name><name>tabstat</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_delta_live_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>tabstat</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_delta_dead_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* insert adds a live tuple, delete removes one */</comment>
                <expr_stmt><expr><name><name>tabstat</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_delta_live_tuples</name></name> <operator>+=</operator>
                    <name><name>trans</name><operator>-&gt;</operator><name>tuples_inserted</name></name> <operator>-</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_deleted</name></name></expr>;</expr_stmt>
                <comment type="block">/* update and delete each create a dead tuple */</comment>
                <expr_stmt><expr><name><name>tabstat</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_delta_dead_tuples</name></name> <operator>+=</operator>
                    <name><name>trans</name><operator>-&gt;</operator><name>tuples_updated</name></name> <operator>+</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_deleted</name></name></expr>;</expr_stmt>
                <comment type="block">/* insert, update, delete each count as one change event */</comment>
                <expr_stmt><expr><name><name>tabstat</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_changed_tuples</name></name> <operator>+=</operator>
                    <name><name>trans</name><operator>-&gt;</operator><name>tuples_inserted</name></name> <operator>+</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_updated</name></name> <operator>+</operator>
                    <name><name>trans</name><operator>-&gt;</operator><name>tuples_deleted</name></name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* inserted tuples are dead, deleted tuples are unaffected */</comment>
                <expr_stmt><expr><name><name>tabstat</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_delta_dead_tuples</name></name> <operator>+=</operator>
                    <name><name>trans</name><operator>-&gt;</operator><name>tuples_inserted</name></name> <operator>+</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_updated</name></name></expr>;</expr_stmt>
                <comment type="block">/* an aborted xact generates no changed_tuple events */</comment>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name><name>tabstat</name><operator>-&gt;</operator><name>trans</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pgStatXactStack</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* Make sure any stats snapshot is thrown away */</comment>
    <expr_stmt><expr><call><name>pgstat_clear_snapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * AtEOSubXact_PgStat
 *
 *    Called from access/transam/xact.c at subtransaction commit/abort.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>AtEOSubXact_PgStat</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nestDepth</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PgStat_SubXactStatus</name> <modifier>*</modifier></type><name>xact_state</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Transfer transactional insert/update counts into the next higher
     * subtransaction state.
     */</comment>
    <expr_stmt><expr><name>xact_state</name> <operator>=</operator> <name>pgStatXactStack</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>xact_state</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
        <name><name>xact_state</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>&gt;=</operator> <name>nestDepth</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PgStat_TableXactStatus</name> <modifier>*</modifier></type><name>trans</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PgStat_TableXactStatus</name> <modifier>*</modifier></type><name>next_trans</name></decl>;</decl_stmt>

        <comment type="block">/* delink xact_state from stack immediately to simplify reuse case */</comment>
        <expr_stmt><expr><name>pgStatXactStack</name> <operator>=</operator> <name><name>xact_state</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>trans</name> <operator>=</operator> <name><name>xact_state</name><operator>-&gt;</operator><name>first</name></name></expr>;</init> <condition><expr><name>trans</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>trans</name> <operator>=</operator> <name>next_trans</name></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PgStat_TableStatus</name> <modifier>*</modifier></type><name>tabstat</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>next_trans</name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>trans</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>==</operator> <name>nestDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tabstat</name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tabstat</name><operator>-&gt;</operator><name>trans</name></name> <operator>==</operator> <name>trans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>trans</name><operator>-&gt;</operator><name>upper</name></name> <operator>&amp;&amp;</operator> <name><name>trans</name><operator>-&gt;</operator><name>upper</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>==</operator> <name>nestDepth</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>trans</name><operator>-&gt;</operator><name>truncated</name></name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* propagate the truncate status one level up */</comment>
                        <expr_stmt><expr><call><name>pgstat_truncate_save_counters</name><argument_list>(<argument><expr><name><name>trans</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* replace upper xact stats with ours */</comment>
                        <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>upper</name><operator>-&gt;</operator><name>tuples_inserted</name></name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_inserted</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>upper</name><operator>-&gt;</operator><name>tuples_updated</name></name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_updated</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>upper</name><operator>-&gt;</operator><name>tuples_deleted</name></name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_deleted</name></name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>upper</name><operator>-&gt;</operator><name>tuples_inserted</name></name> <operator>+=</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_inserted</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>upper</name><operator>-&gt;</operator><name>tuples_updated</name></name> <operator>+=</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_updated</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>upper</name><operator>-&gt;</operator><name>tuples_deleted</name></name> <operator>+=</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_deleted</name></name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <expr_stmt><expr><name><name>tabstat</name><operator>-&gt;</operator><name>trans</name></name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>upper</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>trans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/*
                     * When there isn't an immediate parent state, we can just
                     * reuse the record instead of going through a
                     * palloc/pfree pushup (this works since it's all in
                     * TopTransactionContext anyway).  We have to re-link it
                     * into the parent level, though, and that might mean
                     * pushing a new entry into the pgStatXactStack.
                     */</comment>
                    <decl_stmt><decl><type><name>PgStat_SubXactStatus</name> <modifier>*</modifier></type><name>upper_xact_state</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>upper_xact_state</name> <operator>=</operator> <call><name>get_tabstat_stack_level</name><argument_list>(<argument><expr><name>nestDepth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>upper_xact_state</name><operator>-&gt;</operator><name>first</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>upper_xact_state</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name>trans</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>=</operator> <name>nestDepth</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * On abort, update top-level tabstat counts, then forget the
                 * subtransaction
                 */</comment>

                <comment type="block">/* first restore values obliterated by truncate */</comment>
                <expr_stmt><expr><call><name>pgstat_truncate_restore_counters</name><argument_list>(<argument><expr><name>trans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* count attempted actions regardless of commit/abort */</comment>
                <expr_stmt><expr><name><name>tabstat</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_inserted</name></name> <operator>+=</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_inserted</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tabstat</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_updated</name></name> <operator>+=</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_updated</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tabstat</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_deleted</name></name> <operator>+=</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_deleted</name></name></expr>;</expr_stmt>
                <comment type="block">/* inserted tuples are dead, deleted tuples are unaffected */</comment>
                <expr_stmt><expr><name><name>tabstat</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_delta_dead_tuples</name></name> <operator>+=</operator>
                    <name><name>trans</name><operator>-&gt;</operator><name>tuples_inserted</name></name> <operator>+</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_updated</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tabstat</name><operator>-&gt;</operator><name>trans</name></name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>upper</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>trans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>xact_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AtPrepare_PgStat
 *        Save the transactional stats state at 2PC transaction prepare.
 *
 * In this phase we just generate 2PC records for all the pending
 * transaction-dependent stats work.
 */</comment>
<function><type><name>void</name></type>
<name>AtPrepare_PgStat</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_SubXactStatus</name> <modifier>*</modifier></type><name>xact_state</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>xact_state</name> <operator>=</operator> <name>pgStatXactStack</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>xact_state</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PgStat_TableXactStatus</name> <modifier>*</modifier></type><name>trans</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>xact_state</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>xact_state</name><operator>-&gt;</operator><name>prev</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>trans</name> <operator>=</operator> <name><name>xact_state</name><operator>-&gt;</operator><name>first</name></name></expr>;</init> <condition><expr><name>trans</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>trans</name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PgStat_TableStatus</name> <modifier>*</modifier></type><name>tabstat</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TwoPhasePgStatRecord</name></type> <name>record</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>trans</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>trans</name><operator>-&gt;</operator><name>upper</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tabstat</name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tabstat</name><operator>-&gt;</operator><name>trans</name></name> <operator>==</operator> <name>trans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>record</name><operator>.</operator><name>tuples_inserted</name></name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_inserted</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>record</name><operator>.</operator><name>tuples_updated</name></name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_updated</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>record</name><operator>.</operator><name>tuples_deleted</name></name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>tuples_deleted</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>record</name><operator>.</operator><name>inserted_pre_trunc</name></name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>inserted_pre_trunc</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>record</name><operator>.</operator><name>updated_pre_trunc</name></name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>updated_pre_trunc</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>record</name><operator>.</operator><name>deleted_pre_trunc</name></name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>deleted_pre_trunc</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>record</name><operator>.</operator><name>t_id</name></name> <operator>=</operator> <name><name>tabstat</name><operator>-&gt;</operator><name>t_id</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>record</name><operator>.</operator><name>t_shared</name></name> <operator>=</operator> <name><name>tabstat</name><operator>-&gt;</operator><name>t_shared</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>record</name><operator>.</operator><name>t_truncated</name></name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>truncated</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>RegisterTwoPhaseRecord</name><argument_list>(<argument><expr><name>TWOPHASE_RM_PGSTAT_ID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                   <argument><expr><operator>&amp;</operator><name>record</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhasePgStatRecord</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PostPrepare_PgStat
 *        Clean up after successful PREPARE.
 *
 * All we need do here is unlink the transaction stats state from the
 * nontransactional state.  The nontransactional action counts will be
 * reported to the stats collector immediately, while the effects on live
 * and dead tuple counts are preserved in the 2PC state file.
 *
 * Note: AtEOXact_PgStat is not called during PREPARE.
 */</comment>
<function><type><name>void</name></type>
<name>PostPrepare_PgStat</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_SubXactStatus</name> <modifier>*</modifier></type><name>xact_state</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We don't bother to free any of the transactional state, since it's all
     * in TopTransactionContext and will go away anyway.
     */</comment>
    <expr_stmt><expr><name>xact_state</name> <operator>=</operator> <name>pgStatXactStack</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>xact_state</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PgStat_TableXactStatus</name> <modifier>*</modifier></type><name>trans</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>trans</name> <operator>=</operator> <name><name>xact_state</name><operator>-&gt;</operator><name>first</name></name></expr>;</init> <condition><expr><name>trans</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>trans</name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PgStat_TableStatus</name> <modifier>*</modifier></type><name>tabstat</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>tabstat</name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tabstat</name><operator>-&gt;</operator><name>trans</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pgStatXactStack</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* Make sure any stats snapshot is thrown away */</comment>
    <expr_stmt><expr><call><name>pgstat_clear_snapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * 2PC processing routine for COMMIT PREPARED case.
 *
 * Load the saved counts into our local pgstats state.
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_twophase_postcommit</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>info</name></decl></parameter>,
                           <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>recdata</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TwoPhasePgStatRecord</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>TwoPhasePgStatRecord</name> <operator>*</operator><operator>)</operator> <name>recdata</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_TableStatus</name> <modifier>*</modifier></type><name>pgstat_info</name></decl>;</decl_stmt>

    <comment type="block">/* Find or create a tabstat entry for the rel */</comment>
    <expr_stmt><expr><name>pgstat_info</name> <operator>=</operator> <call><name>get_tabstat_entry</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>t_id</name></name></expr></argument>, <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>t_shared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Same math as in AtEOXact_PgStat, commit case */</comment>
    <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_inserted</name></name> <operator>+=</operator> <name><name>rec</name><operator>-&gt;</operator><name>tuples_inserted</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_updated</name></name> <operator>+=</operator> <name><name>rec</name><operator>-&gt;</operator><name>tuples_updated</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_deleted</name></name> <operator>+=</operator> <name><name>rec</name><operator>-&gt;</operator><name>tuples_deleted</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_truncated</name></name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>t_truncated</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>t_truncated</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* forget live/dead stats seen by backend thus far */</comment>
        <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_delta_live_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_delta_dead_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_delta_live_tuples</name></name> <operator>+=</operator>
        <name><name>rec</name><operator>-&gt;</operator><name>tuples_inserted</name></name> <operator>-</operator> <name><name>rec</name><operator>-&gt;</operator><name>tuples_deleted</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_delta_dead_tuples</name></name> <operator>+=</operator>
        <name><name>rec</name><operator>-&gt;</operator><name>tuples_updated</name></name> <operator>+</operator> <name><name>rec</name><operator>-&gt;</operator><name>tuples_deleted</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_changed_tuples</name></name> <operator>+=</operator>
        <name><name>rec</name><operator>-&gt;</operator><name>tuples_inserted</name></name> <operator>+</operator> <name><name>rec</name><operator>-&gt;</operator><name>tuples_updated</name></name> <operator>+</operator>
        <name><name>rec</name><operator>-&gt;</operator><name>tuples_deleted</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * 2PC processing routine for ROLLBACK PREPARED case.
 *
 * Load the saved counts into our local pgstats state, but treat them
 * as aborted.
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_twophase_postabort</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>info</name></decl></parameter>,
                          <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>recdata</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TwoPhasePgStatRecord</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>TwoPhasePgStatRecord</name> <operator>*</operator><operator>)</operator> <name>recdata</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_TableStatus</name> <modifier>*</modifier></type><name>pgstat_info</name></decl>;</decl_stmt>

    <comment type="block">/* Find or create a tabstat entry for the rel */</comment>
    <expr_stmt><expr><name>pgstat_info</name> <operator>=</operator> <call><name>get_tabstat_entry</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>t_id</name></name></expr></argument>, <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>t_shared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Same math as in AtEOXact_PgStat, abort case */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>t_truncated</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>tuples_inserted</name></name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>inserted_pre_trunc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>tuples_updated</name></name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>updated_pre_trunc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>tuples_deleted</name></name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>deleted_pre_trunc</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_inserted</name></name> <operator>+=</operator> <name><name>rec</name><operator>-&gt;</operator><name>tuples_inserted</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_updated</name></name> <operator>+=</operator> <name><name>rec</name><operator>-&gt;</operator><name>tuples_updated</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_deleted</name></name> <operator>+=</operator> <name><name>rec</name><operator>-&gt;</operator><name>tuples_deleted</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgstat_info</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_delta_dead_tuples</name></name> <operator>+=</operator>
        <name><name>rec</name><operator>-&gt;</operator><name>tuples_inserted</name></name> <operator>+</operator> <name><name>rec</name><operator>-&gt;</operator><name>tuples_updated</name></name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_fetch_stat_dbentry() -
 *
 *    Support function for the SQL-callable pgstat* functions. Returns
 *    the collected statistics for one database or NULL. NULL doesn't mean
 *    that the database doesn't exist, it is just not yet known by the
 *    collector, so the caller is better off to report ZERO instead.
 * ----------
 */</comment>
<function><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type>
<name>pgstat_fetch_stat_dbentry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dbid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * If not done for this transaction, read the statistics collector stats
     * file into some hash tables.
     */</comment>
    <expr_stmt><expr><call><name>backend_read_statsfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Lookup the requested database; return NULL if not found
     */</comment>
    <return>return <expr><operator>(</operator><name>PgStat_StatDBEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>pgStatDBHash</name></expr></argument>,
                                              <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>dbid</name></expr></argument>,
                                              <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_fetch_stat_tabentry() -
 *
 *    Support function for the SQL-callable pgstat* functions. Returns
 *    the collected statistics for one table or NULL. NULL doesn't mean
 *    that the table doesn't exist, it is just not yet known by the
 *    collector, so the caller is better off to report ZERO instead.
 * ----------
 */</comment>
<function><type><name>PgStat_StatTabEntry</name> <modifier>*</modifier></type>
<name>pgstat_fetch_stat_tabentry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>dbid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_StatTabEntry</name> <modifier>*</modifier></type><name>tabentry</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If not done for this transaction, read the statistics collector stats
     * file into some hash tables.
     */</comment>
    <expr_stmt><expr><call><name>backend_read_statsfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Lookup our database, then look in its table hash table.
     */</comment>
    <expr_stmt><expr><name>dbid</name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>dbentry</name> <operator>=</operator> <operator>(</operator><name>PgStat_StatDBEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>pgStatDBHash</name></expr></argument>,
                                                 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>dbid</name></expr></argument>,
                                                 <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dbentry</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>tabentry</name> <operator>=</operator> <operator>(</operator><name>PgStat_StatTabEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name></expr></argument>,
                                                       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>relid</name></expr></argument>,
                                                       <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>tabentry</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>tabentry</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If we didn't find it, maybe it's a shared table.
     */</comment>
    <expr_stmt><expr><name>dbid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>dbentry</name> <operator>=</operator> <operator>(</operator><name>PgStat_StatDBEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>pgStatDBHash</name></expr></argument>,
                                                 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>dbid</name></expr></argument>,
                                                 <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dbentry</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>tabentry</name> <operator>=</operator> <operator>(</operator><name>PgStat_StatTabEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name></expr></argument>,
                                                       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>relid</name></expr></argument>,
                                                       <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>tabentry</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>tabentry</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_fetch_stat_funcentry() -
 *
 *    Support function for the SQL-callable pgstat* functions. Returns
 *    the collected statistics for one function or NULL.
 * ----------
 */</comment>
<function><type><name>PgStat_StatFuncEntry</name> <modifier>*</modifier></type>
<name>pgstat_fetch_stat_funcentry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>func_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_StatFuncEntry</name> <modifier>*</modifier></type><name>funcentry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* load the stats file if needed */</comment>
    <expr_stmt><expr><call><name>backend_read_statsfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Lookup our database, then find the requested function.  */</comment>
    <expr_stmt><expr><name>dbentry</name> <operator>=</operator> <call><name>pgstat_fetch_stat_dbentry</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dbentry</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>dbentry</name><operator>-&gt;</operator><name>functions</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>funcentry</name> <operator>=</operator> <operator>(</operator><name>PgStat_StatFuncEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>,
                                                         <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>func_id</name></expr></argument>,
                                                         <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>funcentry</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_fetch_stat_beentry() -
 *
 *    Support function for the SQL-callable pgstat* functions. Returns
 *    our local copy of the current-activity entry for one backend.
 *
 *    NB: caller is responsible for a check if the user is permitted to see
 *    this info (especially the querystring).
 * ----------
 */</comment>
<function><type><name>PgBackendStatus</name> <modifier>*</modifier></type>
<name>pgstat_fetch_stat_beentry</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>beid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>pgstat_read_current_status</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>beid</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>beid</name></expr></argument> &gt;</argument_list></name> <name>localNumBackends</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><operator>&amp;</operator><name><name>localBackendStatusTable</name><index>[<expr><name>beid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>backendStatus</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_fetch_stat_local_beentry() -
 *
 *    Like pgstat_fetch_stat_beentry() but with locally computed additions (like
 *    xid and xmin values of the backend)
 *
 *    NB: caller is responsible for a check if the user is permitted to see
 *    this info (especially the querystring).
 * ----------
 */</comment>
<function><type><name>LocalPgBackendStatus</name> <modifier>*</modifier></type>
<name>pgstat_fetch_stat_local_beentry</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>beid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>pgstat_read_current_status</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>beid</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>beid</name></expr></argument> &gt;</argument_list></name> <name>localNumBackends</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><operator>&amp;</operator><name><name>localBackendStatusTable</name><index>[<expr><name>beid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_fetch_stat_numbackends() -
 *
 *    Support function for the SQL-callable pgstat* functions. Returns
 *    the maximum current backend id.
 * ----------
 */</comment>
<function><type><name>int</name></type>
<name>pgstat_fetch_stat_numbackends</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>pgstat_read_current_status</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>localNumBackends</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ---------
 * pgstat_fetch_stat_archiver() -
 *
 *    Support function for the SQL-callable pgstat* functions. Returns
 *    a pointer to the archiver statistics struct.
 * ---------
 */</comment>
<function><type><name>PgStat_ArchiverStats</name> <modifier>*</modifier></type>
<name>pgstat_fetch_stat_archiver</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>backend_read_statsfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>&amp;</operator><name>archiverStats</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ---------
 * pgstat_fetch_global() -
 *
 *    Support function for the SQL-callable pgstat* functions. Returns
 *    a pointer to the global statistics struct.
 * ---------
 */</comment>
<function><type><name>PgStat_GlobalStats</name> <modifier>*</modifier></type>
<name>pgstat_fetch_global</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>backend_read_statsfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>&amp;</operator><name>globalStats</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ------------------------------------------------------------
 * Functions for management of the shared-memory PgBackendStatus array
 * ------------------------------------------------------------
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>PgBackendStatus</name> <modifier>*</modifier></type><name>BackendStatusArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PgBackendStatus</name> <modifier>*</modifier></type><name>MyBEEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>BackendAppnameBuffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>BackendClientHostnameBuffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>BackendActivityBuffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Size</name></type> <name>BackendActivityBufferSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PgBackendSSLStatus</name> <modifier>*</modifier></type><name>BackendSslStatusBuffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * Report shared-memory space needed by CreateSharedBackendStatus.
 */</comment>
<function><type><name>Size</name></type>
<name>BackendStatusShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type>        <name>size</name></decl>;</decl_stmt>

    <comment type="block">/* BackendStatusArray: */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgBackendStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NumBackendStatSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* BackendAppnameBuffer: */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>,
                    <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><name>NumBackendStatSlots</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* BackendClientHostnameBuffer: */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>,
                    <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><name>NumBackendStatSlots</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* BackendActivityBuffer: */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>,
                    <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>pgstat_track_activity_query_size</name></expr></argument>, <argument><expr><name>NumBackendStatSlots</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
    <comment type="block">/* BackendSslStatusBuffer: */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>,
                    <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgBackendSSLStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NumBackendStatSlots</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the shared status array and several string buffers
 * during postmaster startup.
 */</comment>
<function><type><name>void</name></type>
<name>CreateSharedBackendStatus</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>

    <comment type="block">/* Create or attach to the shared array */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgBackendStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NumBackendStatSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>BackendStatusArray</name> <operator>=</operator> <operator>(</operator><name>PgBackendStatus</name> <operator>*</operator><operator>)</operator>
        <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Backend Status Array"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We're the first - initialize.
         */</comment>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>BackendStatusArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Create or attach to the shared appname buffer */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>BackendAppnameBuffer</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator>
        <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Backend Application Name Buffer"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>BackendAppnameBuffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Initialize st_appname pointers. */</comment>
        <expr_stmt><expr><name>buffer</name> <operator>=</operator> <name>BackendAppnameBuffer</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumBackendStatSlots</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>BackendStatusArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_appname</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>buffer</name> <operator>+=</operator> <name>NAMEDATALEN</name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Create or attach to the shared client hostname buffer */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>BackendClientHostnameBuffer</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator>
        <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Backend Client Host Name Buffer"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>BackendClientHostnameBuffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Initialize st_clienthostname pointers. */</comment>
        <expr_stmt><expr><name>buffer</name> <operator>=</operator> <name>BackendClientHostnameBuffer</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumBackendStatSlots</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>BackendStatusArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_clienthostname</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>buffer</name> <operator>+=</operator> <name>NAMEDATALEN</name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Create or attach to the shared activity buffer */</comment>
    <expr_stmt><expr><name>BackendActivityBufferSize</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><name>pgstat_track_activity_query_size</name></expr></argument>,
                                         <argument><expr><name>NumBackendStatSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>BackendActivityBuffer</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator>
        <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Backend Activity Buffer"</literal></expr></argument>,
                        <argument><expr><name>BackendActivityBufferSize</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>BackendActivityBuffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Initialize st_activity pointers. */</comment>
        <expr_stmt><expr><name>buffer</name> <operator>=</operator> <name>BackendActivityBuffer</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumBackendStatSlots</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>BackendStatusArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_activity</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>buffer</name> <operator>+=</operator> <name>pgstat_track_activity_query_size</name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
    <comment type="block">/* Create or attach to the shared SSL status buffer */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgBackendSSLStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NumBackendStatSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>BackendSslStatusBuffer</name> <operator>=</operator> <operator>(</operator><name>PgBackendSSLStatus</name> <operator>*</operator><operator>)</operator>
        <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Backend SSL Status Buffer"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PgBackendSSLStatus</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>BackendSslStatusBuffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Initialize st_sslstatus pointers. */</comment>
        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>BackendSslStatusBuffer</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumBackendStatSlots</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>BackendStatusArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_sslstatus</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_initialize() -
 *
 *    Initialize pgstats state, and set up our on-proc-exit hook.
 *    Called from InitPostgres and AuxiliaryProcessMain. For auxiliary process,
 *    MyBackendId is invalid. Otherwise, MyBackendId must be set,
 *    but we must not have started any transaction yet (since the
 *    exit hook must run after the last transaction exit).
 *    NOTE: MyDatabaseId isn't set yet; so the shutdown hook has to be careful.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_initialize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Initialize MyBEEntry */</comment>
    <if_stmt><if>if <condition>(<expr><name>MyBackendId</name> <operator>!=</operator> <name>InvalidBackendId</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyBackendId</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>MyBackendId</name> <operator>&lt;=</operator> <name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>MyBEEntry</name> <operator>=</operator> <operator>&amp;</operator><name><name>BackendStatusArray</name><index>[<expr><name>MyBackendId</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Must be an auxiliary process */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyAuxProcType</name> <operator>!=</operator> <name>NotAnAuxProcess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Assign the MyBEEntry for an auxiliary process.  Since it doesn't
         * have a BackendId, the slot is statically allocated based on the
         * auxiliary process type (MyAuxProcType).  Backends use slots indexed
         * in the range from 1 to MaxBackends (inclusive), so we use
         * MaxBackends + AuxBackendType + 1 as the index of the slot for an
         * auxiliary process.
         */</comment>
        <expr_stmt><expr><name>MyBEEntry</name> <operator>=</operator> <operator>&amp;</operator><name><name>BackendStatusArray</name><index>[<expr><name>MaxBackends</name> <operator>+</operator> <name>MyAuxProcType</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Set up a process-exit hook to clean up */</comment>
    <expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>pgstat_beshutdown_hook</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_bestart() -
 *
 *    Initialize this backend's entry in the PgBackendStatus array.
 *    Called from InitPostgres.
 *
 *    Apart from auxiliary processes, MyBackendId, MyDatabaseId,
 *    session userid, and application_name must be set for a
 *    backend (hence, this cannot be combined with pgstat_initialize).
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_bestart</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>proc_start_timestamp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SockAddr</name></type>    <name>clientaddr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>PgBackendStatus</name> <modifier>*</modifier></type><name>beentry</name></decl>;</decl_stmt>

    <comment type="block">/*
     * To minimize the time spent modifying the PgBackendStatus entry, fetch
     * all the needed data first.
     *
     * If we have a MyProcPort, use its session start time (for consistency,
     * and to save a kernel call).
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>MyProcPort</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>proc_start_timestamp</name> <operator>=</operator> <name><name>MyProcPort</name><operator>-&gt;</operator><name>SessionStartTime</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>proc_start_timestamp</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * We may not have a MyProcPort (eg, if this is the autovacuum process).
     * If so, use all-zeroes client address, which is dealt with specially in
     * pg_stat_get_backend_client_addr and pg_stat_get_backend_client_port.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>MyProcPort</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>clientaddr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>MyProcPort</name><operator>-&gt;</operator><name>raddr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>clientaddr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>clientaddr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>clientaddr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Initialize my status entry, following the protocol of bumping
     * st_changecount before and after; and make sure it's even afterwards. We
     * use a volatile pointer here to ensure the compiler doesn't try to get
     * cute.
     */</comment>
    <expr_stmt><expr><name>beentry</name> <operator>=</operator> <name>MyBEEntry</name></expr>;</expr_stmt>

    <comment type="block">/* pgstats state must be initialized from pgstat_initialize() */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>beentry</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>MyBackendId</name> <operator>!=</operator> <name>InvalidBackendId</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumLauncherProcess</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Autovacuum Launcher */</comment>
            <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_backendType</name></name> <operator>=</operator> <name>B_AUTOVAC_LAUNCHER</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Autovacuum Worker */</comment>
            <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_backendType</name></name> <operator>=</operator> <name>B_AUTOVAC_WORKER</name></expr>;</expr_stmt>
        </block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsClean2pcLauncher</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Clean 2pc Launcher */</comment>
			<expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_backendType</name></name> <operator>=</operator> <name>B_CLEAN_2PC_LAUNCHER</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsClean2pcWorker</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Clean 2pc Worker */</comment>
			<expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_backendType</name></name> <operator>=</operator> <name>B_CLEAN_2PC_WORKER</name></expr>;</expr_stmt>
		</block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>am_walsender</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Wal sender */</comment>
            <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_backendType</name></name> <operator>=</operator> <name>B_WAL_SENDER</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>IsBackgroundWorker</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* bgworker */</comment>
            <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_backendType</name></name> <operator>=</operator> <name>B_BG_WORKER</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* client-backend */</comment>
            <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_backendType</name></name> <operator>=</operator> <name>B_BACKEND</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Must be an auxiliary process */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyAuxProcType</name> <operator>!=</operator> <name>NotAnAuxProcess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>MyAuxProcType</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>StartupProcess</name></expr>:</case>
                <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_backendType</name></name> <operator>=</operator> <name>B_STARTUP</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>BgWriterProcess</name></expr>:</case>
                <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_backendType</name></name> <operator>=</operator> <name>B_BG_WRITER</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>CheckpointerProcess</name></expr>:</case>
                <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_backendType</name></name> <operator>=</operator> <name>B_CHECKPOINTER</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>WalWriterProcess</name></expr>:</case>
                <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_backendType</name></name> <operator>=</operator> <name>B_WAL_WRITER</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>WalReceiverProcess</name></expr>:</case>
                <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_backendType</name></name> <operator>=</operator> <name>B_WAL_RECEIVER</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>PoolerProcess</name></expr>:</case>
                <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_backendType</name></name> <operator>=</operator> <name>B_PGXL_POOLER</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>ClusterMonitorProcess</name></expr>:</case>
                <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_backendType</name></name> <operator>=</operator> <name>B_PGXL_CLUSTER_MONITOR</name></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"unrecognized process type: %d"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>MyAuxProcType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></else></if_stmt>

    <do>do
    <block>{<block_content>
        <expr_stmt><expr><call><name>pgstat_increment_changecount_before</name><argument_list>(<argument><expr><name>beentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><operator>(</operator><name><name>beentry</name><operator>-&gt;</operator><name>st_changecount</name></name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>;</do>

    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_procpid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_proc_start_timestamp</name></name> <operator>=</operator> <name>proc_start_timestamp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_activity_start_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_state_start_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_xact_start_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_databaseid</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>

    <comment type="block">/* We have userid for client-backends, wal-sender and bgworker processes */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>beentry</name><operator>-&gt;</operator><name>st_backendType</name></name> <operator>==</operator> <name>B_BACKEND</name>
        <operator>||</operator> <name><name>beentry</name><operator>-&gt;</operator><name>st_backendType</name></name> <operator>==</operator> <name>B_WAL_SENDER</name>
        <operator>||</operator> <name><name>beentry</name><operator>-&gt;</operator><name>st_backendType</name></name> <operator>==</operator> <name>B_BG_WORKER</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_userid</name></name> <operator>=</operator> <call><name>GetSessionUserId</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_userid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_clientaddr</name></name> <operator>=</operator> <name>clientaddr</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>MyProcPort</name> <operator>&amp;&amp;</operator> <name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_hostname</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_clienthostname</name></name></expr></argument>, <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_hostname</name></name></expr></argument>,
                <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_clienthostname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>MyProcPort</name> <operator>&amp;&amp;</operator> <name><name>MyProcPort</name><operator>-&gt;</operator><name>ssl</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_ssl</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_sslstatus</name><operator>-&gt;</operator><name>ssl_bits</name></name> <operator>=</operator> <call><name>be_tls_get_cipher_bits</name><argument_list>(<argument><expr><name>MyProcPort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_sslstatus</name><operator>-&gt;</operator><name>ssl_compression</name></name> <operator>=</operator> <call><name>be_tls_get_compression</name><argument_list>(<argument><expr><name>MyProcPort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>be_tls_get_version</name><argument_list>(<argument><expr><name>MyProcPort</name></expr></argument>, <argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_sslstatus</name><operator>-&gt;</operator><name>ssl_version</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>be_tls_get_cipher</name><argument_list>(<argument><expr><name>MyProcPort</name></expr></argument>, <argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_sslstatus</name><operator>-&gt;</operator><name>ssl_cipher</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>be_tls_get_peerdn_name</name><argument_list>(<argument><expr><name>MyProcPort</name></expr></argument>, <argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_sslstatus</name><operator>-&gt;</operator><name>ssl_clientdn</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_ssl</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_ssl</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_state</name></name> <operator>=</operator> <name>STATE_UNDEFINED</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_appname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_activity</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <comment type="block">/* Also make sure the last byte in each string area is always 0 */</comment>
    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_clienthostname</name><index>[<expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_appname</name><index>[<expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_activity</name><index>[<expr><name>pgstat_track_activity_query_size</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_progress_command</name></name> <operator>=</operator> <name>PROGRESS_COMMAND_INVALID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_progress_command_target</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

    <comment type="block">/*
     * we don't zero st_progress_param here to save cycles; nobody should
     * examine it until st_progress_command has been set to something other
     * than PROGRESS_COMMAND_INVALID
     */</comment>

    <expr_stmt><expr><call><name>pgstat_increment_changecount_after</name><argument_list>(<argument><expr><name>beentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Update app name to current GUC setting */</comment>
    <if_stmt><if>if <condition>(<expr><name>application_name</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pgstat_report_appname</name><argument_list>(<argument><expr><name>application_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Shut down a single backend's statistics reporting at process exit.
 *
 * Flush any remaining statistics counts out to the collector.
 * Without this, operations triggered during backend exit (such as
 * temp table deletions) won't be counted.
 *
 * Lastly, clear out our entry in the PgBackendStatus array.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_beshutdown_hook</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>PgBackendStatus</name> <modifier>*</modifier></type><name>beentry</name> <init>= <expr><name>MyBEEntry</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * If we got as far as discovering our own database ID, we can report what
     * we did to the collector.  Otherwise, we'd be sending an invalid
     * database ID, so forget it.  (This means that accesses to pg_database
     * during failed backend starts might never get counted.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pgstat_report_stat</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Clear my status entry, following the protocol of bumping st_changecount
     * before and after.  We use a volatile pointer here to ensure the
     * compiler doesn't try to get cute.
     */</comment>
    <expr_stmt><expr><call><name>pgstat_increment_changecount_before</name><argument_list>(<argument><expr><name>beentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_procpid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <comment type="block">/* mark invalid */</comment>

    <expr_stmt><expr><call><name>pgstat_increment_changecount_after</name><argument_list>(<argument><expr><name>beentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_report_activity() -
 *
 *    Called from tcop/postgres.c to report what the backend is actually doing
 *    (but note cmd_str can be NULL for certain cases).
 *
 * All updates of the status entry follow the protocol of bumping
 * st_changecount before and after.  We use a volatile pointer here to
 * ensure the compiler doesn't try to get cute.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_report_activity</name><parameter_list>(<parameter><decl><type><name>BackendState</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd_str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>PgBackendStatus</name> <modifier>*</modifier></type><name>beentry</name> <init>= <expr><name>MyBEEntry</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>start_timestamp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>current_timestamp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE_POSTGRESQL_STATEMENT_STATUS</name><argument_list>(<argument><expr><name>cmd_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>beentry</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pgstat_track_activities</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>beentry</name><operator>-&gt;</operator><name>st_state</name></name> <operator>!=</operator> <name>STATE_DISABLED</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><name>MyProc</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * track_activities is disabled, but we last reported a
             * non-disabled state.  As our final update, change the state and
             * clear fields we will not be updating anymore.
             */</comment>
            <expr_stmt><expr><call><name>pgstat_increment_changecount_before</name><argument_list>(<argument><expr><name>beentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_state</name></name> <operator>=</operator> <name>STATE_DISABLED</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_state_start_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_activity</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_activity_start_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <comment type="block">/* st_xact_start_timestamp and wait_event_info are also disabled */</comment>
            <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_xact_start_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>wait_event_info</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pgstat_increment_changecount_after</name><argument_list>(<argument><expr><name>beentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * To minimize the time spent modifying the entry, fetch all the needed
     * data first.
     */</comment>
    <expr_stmt><expr><name>start_timestamp</name> <operator>=</operator> <call><name>GetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>cmd_str</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><name>cmd_str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cmd_str</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>pgstat_track_activity_query_size</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>current_timestamp</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now update the status entry
     */</comment>
    <expr_stmt><expr><call><name>pgstat_increment_changecount_before</name><argument_list>(<argument><expr><name>beentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_state</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_state_start_timestamp</name></name> <operator>=</operator> <name>current_timestamp</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>cmd_str</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>beentry</name><operator>-&gt;</operator><name>st_activity</name></name></expr></argument>, <argument><expr><name>cmd_str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_activity</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_activity_start_timestamp</name></name> <operator>=</operator> <name>start_timestamp</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>pgstat_increment_changecount_after</name><argument_list>(<argument><expr><name>beentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>pgstat_report_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgstat_report_hook</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>cmd_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*-----------
 * pgstat_progress_start_command() -
 *
 * Set st_progress_command (and st_progress_command_target) in own backend
 * entry.  Also, zero-initialize st_progress_param array.
 *-----------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_progress_start_command</name><parameter_list>(<parameter><decl><type><name>ProgressCommandType</name></type> <name>cmdtype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>PgBackendStatus</name> <modifier>*</modifier></type><name>beentry</name> <init>= <expr><name>MyBEEntry</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>beentry</name> <operator>||</operator> <operator>!</operator><name>pgstat_track_activities</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>pgstat_increment_changecount_before</name><argument_list>(<argument><expr><name>beentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_progress_command</name></name> <operator>=</operator> <name>cmdtype</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_progress_command_target</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>beentry</name><operator>-&gt;</operator><name>st_progress_param</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_progress_param</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_increment_changecount_after</name><argument_list>(<argument><expr><name>beentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-----------
 * pgstat_progress_update_param() -
 *
 * Update index'th member in st_progress_param[] of own backend entry.
 *-----------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_progress_update_param</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>PgBackendStatus</name> <modifier>*</modifier></type><name>beentry</name> <init>= <expr><name>MyBEEntry</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>index</name> <operator>&lt;</operator> <name>PGSTAT_NUM_PROGRESS_PARAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>beentry</name> <operator>||</operator> <operator>!</operator><name>pgstat_track_activities</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>pgstat_increment_changecount_before</name><argument_list>(<argument><expr><name>beentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_progress_param</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_increment_changecount_after</name><argument_list>(<argument><expr><name>beentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-----------
 * pgstat_progress_update_multi_param() -
 *
 * Update multiple members in st_progress_param[] of own backend entry.
 * This is atomic; readers won't see intermediate states.
 *-----------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_progress_update_multi_param</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nparam</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>index</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>int64</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>PgBackendStatus</name> <modifier>*</modifier></type><name>beentry</name> <init>= <expr><name>MyBEEntry</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>beentry</name> <operator>||</operator> <operator>!</operator><name>pgstat_track_activities</name> <operator>||</operator> <name>nparam</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>pgstat_increment_changecount_before</name><argument_list>(<argument><expr><name>beentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparam</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>index</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>index</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name>PGSTAT_NUM_PROGRESS_PARAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_progress_param</name><index>[<expr><name><name>index</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name><name>val</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>pgstat_increment_changecount_after</name><argument_list>(<argument><expr><name>beentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-----------
 * pgstat_progress_end_command() -
 *
 * Reset st_progress_command (and st_progress_command_target) in own backend
 * entry.  This signals the end of the command.
 *-----------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_progress_end_command</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>PgBackendStatus</name> <modifier>*</modifier></type><name>beentry</name> <init>= <expr><name>MyBEEntry</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>beentry</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pgstat_track_activities</name>
        <operator>&amp;&amp;</operator> <name><name>beentry</name><operator>-&gt;</operator><name>st_progress_command</name></name> <operator>==</operator> <name>PROGRESS_COMMAND_INVALID</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>pgstat_increment_changecount_before</name><argument_list>(<argument><expr><name>beentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_progress_command</name></name> <operator>=</operator> <name>PROGRESS_COMMAND_INVALID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_progress_command_target</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_increment_changecount_after</name><argument_list>(<argument><expr><name>beentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_report_appname() -
 *
 *    Called to update our application name.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_report_appname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>appname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>PgBackendStatus</name> <modifier>*</modifier></type><name>beentry</name> <init>= <expr><name>MyBEEntry</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>beentry</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* This should be unnecessary if GUC did its job, but be safe */</comment>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><name>appname</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>appname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Update my status entry, following the protocol of bumping
     * st_changecount before and after.  We use a volatile pointer here to
     * ensure the compiler doesn't try to get cute.
     */</comment>
    <expr_stmt><expr><call><name>pgstat_increment_changecount_before</name><argument_list>(<argument><expr><name>beentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>beentry</name><operator>-&gt;</operator><name>st_appname</name></name></expr></argument>, <argument><expr><name>appname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_appname</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pgstat_increment_changecount_after</name><argument_list>(<argument><expr><name>beentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Report current transaction start timestamp as the specified value.
 * Zero means there is no active transaction.
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_report_xact_timestamp</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>tstamp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>PgBackendStatus</name> <modifier>*</modifier></type><name>beentry</name> <init>= <expr><name>MyBEEntry</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pgstat_track_activities</name> <operator>||</operator> <operator>!</operator><name>beentry</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Update my status entry, following the protocol of bumping
     * st_changecount before and after.  We use a volatile pointer here to
     * ensure the compiler doesn't try to get cute.
     */</comment>
    <expr_stmt><expr><call><name>pgstat_increment_changecount_before</name><argument_list>(<argument><expr><name>beentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_xact_start_timestamp</name></name> <operator>=</operator> <name>tstamp</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_increment_changecount_after</name><argument_list>(<argument><expr><name>beentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_read_current_status() -
 *
 *    Copy the current contents of the PgBackendStatus array to local memory,
 *    if not already done in this transaction.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_read_current_status</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>PgBackendStatus</name> <modifier>*</modifier></type><name>beentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LocalPgBackendStatus</name> <modifier>*</modifier></type><name>localtable</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LocalPgBackendStatus</name> <modifier>*</modifier></type><name>localentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>localappname</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>localactivity</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
    <decl_stmt><decl><type><name>PgBackendSSLStatus</name> <modifier>*</modifier></type><name>localsslstatus</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>pgStatRunningInCollector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>localBackendStatusTable</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>                    <comment type="block">/* already done */</comment>

    <expr_stmt><expr><call><name>pgstat_setup_memcxt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>localtable</name> <operator>=</operator> <operator>(</operator><name>LocalPgBackendStatus</name> <operator>*</operator><operator>)</operator>
        <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>pgStatLocalContext</name></expr></argument>,
                           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocalPgBackendStatus</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>NumBackendStatSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>localappname</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator>
        <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>pgStatLocalContext</name></expr></argument>,
                           <argument><expr><name>NAMEDATALEN</name> <operator>*</operator> <name>NumBackendStatSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>localactivity</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator>
        <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>pgStatLocalContext</name></expr></argument>,
                           <argument><expr><name>pgstat_track_activity_query_size</name> <operator>*</operator> <name>NumBackendStatSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
    <expr_stmt><expr><name>localsslstatus</name> <operator>=</operator> <operator>(</operator><name>PgBackendSSLStatus</name> <operator>*</operator><operator>)</operator>
        <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>pgStatLocalContext</name></expr></argument>,
                           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgBackendSSLStatus</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>NumBackendStatSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>localNumBackends</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>beentry</name> <operator>=</operator> <name>BackendStatusArray</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>localentry</name> <operator>=</operator> <name>localtable</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>NumBackendStatSlots</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * Follow the protocol of retrying if st_changecount changes while we
         * copy the entry, or if it's odd.  (The check for odd is needed to
         * cover the case where we are able to completely copy the entry while
         * the source backend is between increment steps.)    We use a volatile
         * pointer here to ensure the compiler doesn't try to get cute.
         */</comment>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>before_changecount</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>after_changecount</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>pgstat_save_changecount_before</name><argument_list>(<argument><expr><name>beentry</name></expr></argument>, <argument><expr><name>before_changecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>localentry</name><operator>-&gt;</operator><name>backendStatus</name><operator>.</operator><name>st_procpid</name></name> <operator>=</operator> <name><name>beentry</name><operator>-&gt;</operator><name>st_procpid</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>localentry</name><operator>-&gt;</operator><name>backendStatus</name><operator>.</operator><name>st_procpid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>localentry</name><operator>-&gt;</operator><name>backendStatus</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>beentry</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgBackendStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * strcpy is safe even if the string is modified concurrently,
                 * because there's always a \0 at the end of the buffer.
                 */</comment>
                <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>localappname</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>beentry</name><operator>-&gt;</operator><name>st_appname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>localentry</name><operator>-&gt;</operator><name>backendStatus</name><operator>.</operator><name>st_appname</name></name> <operator>=</operator> <name>localappname</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>localactivity</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>beentry</name><operator>-&gt;</operator><name>st_activity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>localentry</name><operator>-&gt;</operator><name>backendStatus</name><operator>.</operator><name>st_activity</name></name> <operator>=</operator> <name>localactivity</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>localentry</name><operator>-&gt;</operator><name>backendStatus</name><operator>.</operator><name>st_ssl</name></name> <operator>=</operator> <name><name>beentry</name><operator>-&gt;</operator><name>st_ssl</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><name><name>beentry</name><operator>-&gt;</operator><name>st_ssl</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>localsslstatus</name></expr></argument>, <argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_sslstatus</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgBackendSSLStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>localentry</name><operator>-&gt;</operator><name>backendStatus</name><operator>.</operator><name>st_sslstatus</name></name> <operator>=</operator> <name>localsslstatus</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>pgstat_save_changecount_after</name><argument_list>(<argument><expr><name>beentry</name></expr></argument>, <argument><expr><name>after_changecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>before_changecount</name> <operator>==</operator> <name>after_changecount</name> <operator>&amp;&amp;</operator>
                <operator>(</operator><name>before_changecount</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <comment type="block">/* Make sure we can break out of loop if stuck... */</comment>
            <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name>beentry</name><operator>++</operator></expr>;</expr_stmt>
        <comment type="block">/* Only valid entries get included into the local array */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>localentry</name><operator>-&gt;</operator><name>backendStatus</name><operator>.</operator><name>st_procpid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>BackendIdGetTransactionIds</name><argument_list>(<argument><expr><name>i</name></expr></argument>,
                                       <argument><expr><operator>&amp;</operator><name><name>localentry</name><operator>-&gt;</operator><name>backend_xid</name></name></expr></argument>,
                                       <argument><expr><operator>&amp;</operator><name><name>localentry</name><operator>-&gt;</operator><name>backend_xmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>localentry</name><operator>-&gt;</operator><name>backend_id</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>localentry</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>localappname</name> <operator>+=</operator> <name>NAMEDATALEN</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>localactivity</name> <operator>+=</operator> <name>pgstat_track_activity_query_size</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
            <expr_stmt><expr><name>localsslstatus</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>localNumBackends</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Set the pointer only after completion of a valid table */</comment>
    <expr_stmt><expr><name>localBackendStatusTable</name> <operator>=</operator> <name>localtable</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_get_wait_event_type() -
 *
 *    Return a string representing the current wait event type, backend is
 *    waiting on.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pgstat_get_wait_event_type</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>wait_event_info</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>classId</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>event_type</name></decl>;</decl_stmt>

    <comment type="block">/* report process as not waiting. */</comment>
    <if_stmt><if>if <condition>(<expr><name>wait_event_info</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>classId</name> <operator>=</operator> <name>wait_event_info</name> <operator>&amp;</operator> <literal type="number">0xFF000000</literal></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>classId</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PG_WAIT_LWLOCK</name></expr>:</case>
            <expr_stmt><expr><name>event_type</name> <operator>=</operator> <literal type="string">"LWLock"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PG_WAIT_LOCK</name></expr>:</case>
            <expr_stmt><expr><name>event_type</name> <operator>=</operator> <literal type="string">"Lock"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PG_WAIT_BUFFER_PIN</name></expr>:</case>
            <expr_stmt><expr><name>event_type</name> <operator>=</operator> <literal type="string">"BufferPin"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PG_WAIT_ACTIVITY</name></expr>:</case>
            <expr_stmt><expr><name>event_type</name> <operator>=</operator> <literal type="string">"Activity"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PG_WAIT_CLIENT</name></expr>:</case>
            <expr_stmt><expr><name>event_type</name> <operator>=</operator> <literal type="string">"Client"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PG_WAIT_EXTENSION</name></expr>:</case>
            <expr_stmt><expr><name>event_type</name> <operator>=</operator> <literal type="string">"Extension"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PG_WAIT_IPC</name></expr>:</case>
            <expr_stmt><expr><name>event_type</name> <operator>=</operator> <literal type="string">"IPC"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PG_WAIT_TIMEOUT</name></expr>:</case>
            <expr_stmt><expr><name>event_type</name> <operator>=</operator> <literal type="string">"Timeout"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PG_WAIT_IO</name></expr>:</case>
            <expr_stmt><expr><name>event_type</name> <operator>=</operator> <literal type="string">"IO"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><name>event_type</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>event_type</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_get_wait_event() -
 *
 *    Return a string representing the current wait event, backend is
 *    waiting on.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pgstat_get_wait_event</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>wait_event_info</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>classId</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16</name></type>        <name>eventId</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>event_name</name></decl>;</decl_stmt>

    <comment type="block">/* report process as not waiting. */</comment>
    <if_stmt><if>if <condition>(<expr><name>wait_event_info</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>classId</name> <operator>=</operator> <name>wait_event_info</name> <operator>&amp;</operator> <literal type="number">0xFF000000</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>eventId</name> <operator>=</operator> <name>wait_event_info</name> <operator>&amp;</operator> <literal type="number">0x0000FFFF</literal></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>classId</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PG_WAIT_LWLOCK</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <call><name>GetLWLockIdentifier</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><name>eventId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PG_WAIT_LOCK</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <call><name>GetLockNameFromTagType</name><argument_list>(<argument><expr><name>eventId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PG_WAIT_BUFFER_PIN</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"BufferPin"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PG_WAIT_ACTIVITY</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>WaitEventActivity</name></type> <name>w</name> <init>= <expr><operator>(</operator><name>WaitEventActivity</name><operator>)</operator> <name>wait_event_info</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>event_name</name> <operator>=</operator> <call><name>pgstat_get_wait_activity</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>PG_WAIT_CLIENT</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>WaitEventClient</name></type> <name>w</name> <init>= <expr><operator>(</operator><name>WaitEventClient</name><operator>)</operator> <name>wait_event_info</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>event_name</name> <operator>=</operator> <call><name>pgstat_get_wait_client</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>PG_WAIT_EXTENSION</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"Extension"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PG_WAIT_IPC</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>WaitEventIPC</name></type> <name>w</name> <init>= <expr><operator>(</operator><name>WaitEventIPC</name><operator>)</operator> <name>wait_event_info</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>event_name</name> <operator>=</operator> <call><name>pgstat_get_wait_ipc</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>PG_WAIT_TIMEOUT</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>WaitEventTimeout</name></type> <name>w</name> <init>= <expr><operator>(</operator><name>WaitEventTimeout</name><operator>)</operator> <name>wait_event_info</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>event_name</name> <operator>=</operator> <call><name>pgstat_get_wait_timeout</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>PG_WAIT_IO</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>WaitEventIO</name></type> <name>w</name> <init>= <expr><operator>(</operator><name>WaitEventIO</name><operator>)</operator> <name>wait_event_info</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>event_name</name> <operator>=</operator> <call><name>pgstat_get_wait_io</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        <default>default:</default>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"unknown wait event"</literal></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>event_name</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_get_wait_activity() -
 *
 * Convert WaitEventActivity to string.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pgstat_get_wait_activity</name><parameter_list>(<parameter><decl><type><name>WaitEventActivity</name></type> <name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>event_name</name> <init>= <expr><literal type="string">"unknown wait event"</literal></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>w</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>WAIT_EVENT_ARCHIVER_MAIN</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"ArchiverMain"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_AUTOVACUUM_MAIN</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"AutoVacuumMain"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_BGWRITER_HIBERNATE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"BgWriterHibernate"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_BGWRITER_MAIN</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"BgWriterMain"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_CHECKPOINTER_MAIN</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"CheckpointerMain"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_LOGICAL_LAUNCHER_MAIN</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"LogicalLauncherMain"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_LOGICAL_APPLY_MAIN</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"LogicalApplyMain"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_PGSTAT_MAIN</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"PgStatMain"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_RECOVERY_WAL_ALL</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"RecoveryWalAll"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_RECOVERY_WAL_STREAM</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"RecoveryWalStream"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_SYSLOGGER_MAIN</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"SysLoggerMain"</literal></expr>;</expr_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
        <case>case <expr><name>WAIT_EVENT_AUDIT_LOGGER_MAIN</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"AuditLoggerMain"</literal></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>WAIT_EVENT_WAL_RECEIVER_MAIN</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"WalReceiverMain"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_WAL_SENDER_MAIN</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"WalSenderMain"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_WAL_WRITER_MAIN</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"WalWriterMain"</literal></expr>;</expr_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
        <case>case <expr><name>WAIT_EVENT_AUDIT_FGA_MAIN</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"AuditFgaMain"</literal></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>WAIT_EVENT_CLUSTER_MONITOR_MAIN</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"ClusterMonitorMain"</literal></expr>;</expr_stmt>
            <break>break;</break>
            <comment type="block">/* no default case, so that compiler will warn */</comment>
    </block_content>}</block></switch>

    <return>return <expr><name>event_name</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_get_wait_client() -
 *
 * Convert WaitEventClient to string.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pgstat_get_wait_client</name><parameter_list>(<parameter><decl><type><name>WaitEventClient</name></type> <name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>event_name</name> <init>= <expr><literal type="string">"unknown wait event"</literal></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>w</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>WAIT_EVENT_CLIENT_READ</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"ClientRead"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_CLIENT_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"ClientWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_LIBPQWALRECEIVER_CONNECT</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"LibPQWalReceiverConnect"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_LIBPQWALRECEIVER_RECEIVE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"LibPQWalReceiverReceive"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_SSL_OPEN_SERVER</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"SSLOpenServer"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_WAL_RECEIVER_WAIT_START</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"WalReceiverWaitStart"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_WAL_SENDER_WAIT_WAL</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"WalSenderWaitForWAL"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_WAL_SENDER_WRITE_DATA</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"WalSenderWriteData"</literal></expr>;</expr_stmt>
            <break>break;</break>
            <comment type="block">/* no default case, so that compiler will warn */</comment>
    </block_content>}</block></switch>

    <return>return <expr><name>event_name</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_get_wait_ipc() -
 *
 * Convert WaitEventIPC to string.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pgstat_get_wait_ipc</name><parameter_list>(<parameter><decl><type><name>WaitEventIPC</name></type> <name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>event_name</name> <init>= <expr><literal type="string">"unknown wait event"</literal></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>w</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>WAIT_EVENT_BGWORKER_SHUTDOWN</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"BgWorkerShutdown"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_BGWORKER_STARTUP</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"BgWorkerStartup"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_BTREE_PAGE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"BtreePage"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_EXECUTE_GATHER</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"ExecuteGather"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_LOGICAL_SYNC_DATA</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"LogicalSyncData"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_LOGICAL_SYNC_STATE_CHANGE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"LogicalSyncStateChange"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_MQ_INTERNAL</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"MessageQueueInternal"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_MQ_PUT_MESSAGE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"MessageQueuePutMessage"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_MQ_RECEIVE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"MessageQueueReceive"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_MQ_SEND</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"MessageQueueSend"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_PARALLEL_FINISH</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"ParallelFinish"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_PARALLEL_BITMAP_SCAN</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"ParallelBitmapScan"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_PROCARRAY_GROUP_UPDATE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"ProcArrayGroupUpdate"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_REPLICATION_ORIGIN_DROP</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"ReplicationOriginDrop"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_REPLICATION_SLOT_DROP</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"ReplicationSlotDrop"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_SAFE_SNAPSHOT</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"SafeSnapshot"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_SYNC_REP</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"SyncRep"</literal></expr>;</expr_stmt>
            <break>break;</break>
            <comment type="block">/* no default case, so that compiler will warn */</comment>
    </block_content>}</block></switch>

    <return>return <expr><name>event_name</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_get_wait_timeout() -
 *
 * Convert WaitEventTimeout to string.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pgstat_get_wait_timeout</name><parameter_list>(<parameter><decl><type><name>WaitEventTimeout</name></type> <name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>event_name</name> <init>= <expr><literal type="string">"unknown wait event"</literal></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>w</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>WAIT_EVENT_BASE_BACKUP_THROTTLE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"BaseBackupThrottle"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_PG_SLEEP</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"PgSleep"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_RECOVERY_APPLY_DELAY</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"RecoveryApplyDelay"</literal></expr>;</expr_stmt>
            <break>break;</break>
            <comment type="block">/* no default case, so that compiler will warn */</comment>
    </block_content>}</block></switch>

    <return>return <expr><name>event_name</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_get_wait_io() -
 *
 * Convert WaitEventIO to string.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pgstat_get_wait_io</name><parameter_list>(<parameter><decl><type><name>WaitEventIO</name></type> <name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>event_name</name> <init>= <expr><literal type="string">"unknown wait event"</literal></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>w</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>WAIT_EVENT_BUFFILE_READ</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"BufFileRead"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_BUFFILE_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"BufFileWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_CONTROL_FILE_READ</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"ControlFileRead"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_CONTROL_FILE_SYNC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"ControlFileSync"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_CONTROL_FILE_SYNC_UPDATE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"ControlFileSyncUpdate"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_CONTROL_FILE_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"ControlFileWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_CONTROL_FILE_WRITE_UPDATE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"ControlFileWriteUpdate"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_COPY_FILE_READ</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"CopyFileRead"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_COPY_FILE_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"CopyFileWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>            
        <case>case <expr><name>WAIT_EVENT_CRYPT_KEY_MAP_READ</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"CryptKeyMapRead"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_CRYPT_KEY_MAP_SYNC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"CryptKeyMapSync"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_CRYPT_KEY_MAP_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"CryptKeyMapWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    
        <case>case <expr><name>WAIT_EVENT_DATA_FILE_EXTEND</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"DataFileExtend"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_DATA_FILE_FLUSH</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"DataFileFlush"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_DATA_FILE_IMMEDIATE_SYNC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"DataFileImmediateSync"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_DATA_FILE_PREFETCH</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"DataFilePrefetch"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_DATA_FILE_READ</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"DataFileRead"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_DATA_FILE_SYNC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"DataFileSync"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_DATA_FILE_TRUNCATE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"DataFileTruncate"</literal></expr>;</expr_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <case>case <expr><name>WAIT_EVENT_DATA_FILE_DEALLOC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"DataFileDealloc"</literal></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>WAIT_EVENT_DATA_FILE_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"DataFileWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_DSM_FILL_ZERO_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"DSMFillZeroWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_LOCK_FILE_ADDTODATADIR_READ</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"LockFileAddToDataDirRead"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_LOCK_FILE_ADDTODATADIR_SYNC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"LockFileAddToDataDirSync"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_LOCK_FILE_ADDTODATADIR_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"LockFileAddToDataDirWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_LOCK_FILE_CREATE_READ</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"LockFileCreateRead"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_LOCK_FILE_CREATE_SYNC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"LockFileCreateSync"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_LOCK_FILE_CREATE_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"LockFileCreateWRITE"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_LOCK_FILE_RECHECKDATADIR_READ</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"LockFileReCheckDataDirRead"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_LOGICAL_REWRITE_CHECKPOINT_SYNC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"LogicalRewriteCheckpointSync"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_LOGICAL_REWRITE_MAPPING_SYNC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"LogicalRewriteMappingSync"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_LOGICAL_REWRITE_MAPPING_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"LogicalRewriteMappingWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_LOGICAL_REWRITE_SYNC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"LogicalRewriteSync"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_LOGICAL_REWRITE_TRUNCATE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"LogicalRewriteTruncate"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_LOGICAL_REWRITE_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"LogicalRewriteWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>            
        <case>case <expr><name>WAIT_EVENT_REL_CRYPT_MAP_READ</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"RelCryptMapRead"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_REL_CRYPT_MAP_SYNC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"RelCryptMapSync"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_REL_CRYPT_MAP_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"RelCryptMapWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    
        <case>case <expr><name>WAIT_EVENT_RELATION_MAP_READ</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"RelationMapRead"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_RELATION_MAP_SYNC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"RelationMapSync"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_RELATION_MAP_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"RelationMapWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_REORDER_BUFFER_READ</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"ReorderBufferRead"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_REORDER_BUFFER_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"ReorderBufferWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_REORDER_LOGICAL_MAPPING_READ</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"ReorderLogicalMappingRead"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_REPLICATION_SLOT_READ</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"ReplicationSlotRead"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_REPLICATION_SLOT_RESTORE_SYNC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"ReplicationSlotRestoreSync"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_REPLICATION_SLOT_SYNC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"ReplicationSlotSync"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_REPLICATION_SLOT_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"ReplicationSlotWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_SLRU_FLUSH_SYNC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"SLRUFlushSync"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_SLRU_READ</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"SLRURead"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_SLRU_SYNC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"SLRUSync"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_SLRU_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"SLRUWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_SNAPBUILD_READ</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"SnapbuildRead"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_SNAPBUILD_SYNC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"SnapbuildSync"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_SNAPBUILD_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"SnapbuildWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_TIMELINE_HISTORY_FILE_SYNC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"TimelineHistoryFileSync"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_TIMELINE_HISTORY_FILE_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"TimelineHistoryFileWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_TIMELINE_HISTORY_READ</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"TimelineHistoryRead"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_TIMELINE_HISTORY_SYNC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"TimelineHistorySync"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_TIMELINE_HISTORY_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"TimelineHistoryWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_TWOPHASE_FILE_READ</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"TwophaseFileRead"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_TWOPHASE_FILE_SYNC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"TwophaseFileSync"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_TWOPHASE_FILE_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"TwophaseFileWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_WALSENDER_TIMELINE_HISTORY_READ</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"WALSenderTimelineHistoryRead"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_WAL_BOOTSTRAP_SYNC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"WALBootstrapSync"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_WAL_BOOTSTRAP_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"WALBootstrapWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_WAL_COPY_READ</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"WALCopyRead"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_WAL_COPY_SYNC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"WALCopySync"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_WAL_COPY_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"WALCopyWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_WAL_INIT_SYNC</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"WALInitSync"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_WAL_INIT_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"WALInitWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_WAL_READ</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"WALRead"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_WAL_SYNC_METHOD_ASSIGN</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"WALSyncMethodAssign"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAIT_EVENT_WAL_WRITE</name></expr>:</case>
            <expr_stmt><expr><name>event_name</name> <operator>=</operator> <literal type="string">"WALWrite"</literal></expr>;</expr_stmt>
            <break>break;</break>

            <comment type="block">/* no default case, so that compiler will warn */</comment>
    </block_content>}</block></switch>

    <return>return <expr><name>event_name</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_get_backend_current_activity() -
 *
 *    Return a string representing the current activity of the backend with
 *    the specified PID.  This looks directly at the BackendStatusArray,
 *    and so will provide current information regardless of the age of our
 *    transaction's snapshot of the status array.
 *
 *    It is the caller's responsibility to invoke this only for backends whose
 *    state is expected to remain stable while the result is in use.  The
 *    only current use is in deadlock reporting, where we can expect that
 *    the target backend is blocked on a lock.  (There are corner cases
 *    where the target's wait could get aborted while we are looking at it,
 *    but the very worst consequence is to return a pointer to a string
 *    that's been changed, so we won't worry too much.)
 *
 *    Note: return strings for special cases match pg_stat_get_backend_activity.
 * ----------
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pgstat_get_backend_current_activity</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>checkUser</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PgBackendStatus</name> <modifier>*</modifier></type><name>beentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>beentry</name> <operator>=</operator> <name>BackendStatusArray</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>MaxBackends</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * Although we expect the target backend's entry to be stable, that
         * doesn't imply that anyone else's is.  To avoid identifying the
         * wrong backend, while we check for a match to the desired PID we
         * must follow the protocol of retrying if st_changecount changes
         * while we examine the entry, or if it's odd.  (This might be
         * unnecessary, since fetching or storing an int is almost certainly
         * atomic, but let's play it safe.)  We use a volatile pointer here to
         * ensure the compiler doesn't try to get cute.
         */</comment>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PgBackendStatus</name> <modifier>*</modifier></type><name>vbeentry</name> <init>= <expr><name>beentry</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>

        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>before_changecount</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>after_changecount</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>pgstat_save_changecount_before</name><argument_list>(<argument><expr><name>vbeentry</name></expr></argument>, <argument><expr><name>before_changecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>found</name> <operator>=</operator> <operator>(</operator><name><name>vbeentry</name><operator>-&gt;</operator><name>st_procpid</name></name> <operator>==</operator> <name>pid</name><operator>)</operator></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>pgstat_save_changecount_after</name><argument_list>(<argument><expr><name>vbeentry</name></expr></argument>, <argument><expr><name>after_changecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>before_changecount</name> <operator>==</operator> <name>after_changecount</name> <operator>&amp;&amp;</operator>
                <operator>(</operator><name>before_changecount</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <comment type="block">/* Make sure we can break out of loop if stuck... */</comment>
            <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Now it is safe to use the non-volatile pointer */</comment>
            <if_stmt><if>if <condition>(<expr><name>checkUser</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>beentry</name><operator>-&gt;</operator><name>st_userid</name></name> <operator>!=</operator> <call><name>GetUserId</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="string">"&lt;insufficient privilege&gt;"</literal></expr>;</return></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><operator>*</operator><operator>(</operator><name><name>beentry</name><operator>-&gt;</operator><name>st_activity</name></name><operator>)</operator> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="string">"&lt;command string not enabled&gt;"</literal></expr>;</return></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <return>return <expr><name><name>beentry</name><operator>-&gt;</operator><name>st_activity</name></name></expr>;</return></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>beentry</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* If we get here, caller is in error ... */</comment>
    <return>return <expr><literal type="string">"&lt;backend information not available&gt;"</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_get_crashed_backend_activity() -
 *
 *    Return a string representing the current activity of the backend with
 *    the specified PID.  Like the function above, but reads shared memory with
 *    the expectation that it may be corrupt.  On success, copy the string
 *    into the "buffer" argument and return that pointer.  On failure,
 *    return NULL.
 *
 *    This function is only intended to be used by the postmaster to report the
 *    query that crashed a backend.  In particular, no attempt is made to
 *    follow the correct concurrency protocol when accessing the
 *    BackendStatusArray.  But that's OK, in the worst case we'll return a
 *    corrupted message.  We also must take care not to trip on ereport(ERROR).
 * ----------
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pgstat_get_crashed_backend_activity</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>buflen</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>PgBackendStatus</name> <modifier>*</modifier></type><name>beentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>beentry</name> <operator>=</operator> <name>BackendStatusArray</name></expr>;</expr_stmt>

    <comment type="block">/*
     * We probably shouldn't get here before shared memory has been set up,
     * but be safe.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>beentry</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>BackendActivityBuffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>MaxBackends</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>beentry</name><operator>-&gt;</operator><name>st_procpid</name></name> <operator>==</operator> <name>pid</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Read pointer just once, so it can't change after validation */</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>activity</name> <init>= <expr><name><name>beentry</name><operator>-&gt;</operator><name>st_activity</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>activity_last</name></decl>;</decl_stmt>

            <comment type="block">/*
             * We mustn't access activity string before we verify that it
             * falls within the BackendActivityBuffer. To make sure that the
             * entire string including its ending is contained within the
             * buffer, subtract one activity length from the buffer size.
             */</comment>
            <expr_stmt><expr><name>activity_last</name> <operator>=</operator> <name>BackendActivityBuffer</name> <operator>+</operator> <name>BackendActivityBufferSize</name>
                <operator>-</operator> <name>pgstat_track_activity_query_size</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>activity</name> <argument_list type="generic">&lt; <argument><expr><name>BackendActivityBuffer</name> <operator>||</operator>
                <name>activity</name></expr></argument> &gt;</argument_list></name> <name>activity_last</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

            <comment type="block">/* If no string available, no point in a report */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>activity</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Copy only ASCII-safe characters so we don't run into encoding
             * problems when reporting the message; and be sure not to run off
             * the end of memory.
             */</comment>
            <expr_stmt><expr><call><name>ascii_safe_strlcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>activity</name></expr></argument>,
                               <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>pgstat_track_activity_query_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <return>return <expr><name>buffer</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>beentry</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* PID not found */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pgstat_get_backend_desc</name><parameter_list>(<parameter><decl><type><name>BackendType</name></type> <name>backendType</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>backendDesc</name> <init>= <expr><literal type="string">"unknown process type"</literal></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>backendType</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>B_AUTOVAC_LAUNCHER</name></expr>:</case>
            <expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"autovacuum launcher"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>B_AUTOVAC_WORKER</name></expr>:</case>
            <expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"autovacuum worker"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>B_BACKEND</name></expr>:</case>
            <expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"client backend"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>B_BG_WORKER</name></expr>:</case>
            <expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"background worker"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>B_BG_WRITER</name></expr>:</case>
            <expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"background writer"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>B_CHECKPOINTER</name></expr>:</case>
            <expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"checkpointer"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>B_STARTUP</name></expr>:</case>
            <expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"startup"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>B_WAL_RECEIVER</name></expr>:</case>
            <expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"walreceiver"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>B_WAL_SENDER</name></expr>:</case>
            <expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"walsender"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>B_WAL_WRITER</name></expr>:</case>
            <expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"walwriter"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>B_PGXL_POOLER</name></expr>:</case>
            <expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"pooler"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>B_PGXL_CLUSTER_MONITOR</name></expr>:</case>
            <expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"cluster monitor"</literal></expr>;</expr_stmt>
            <break>break;</break>
		<case>case <expr><name>B_CLEAN_2PC_LAUNCHER</name></expr>:</case>
			<expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"2pc clean launcher"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>B_CLEAN_2PC_WORKER</name></expr>:</case>
			<expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"2pc clean worker"</literal></expr>;</expr_stmt>
			<break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>backendDesc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------
 * Local support functions follow
 * ------------------------------------------------------------
 */</comment>


<comment type="block">/* ----------
 * pgstat_setheader() -
 *
 *        Set common header fields in a statistics message
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_setheader</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgHdr</name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>, <parameter><decl><type><name>StatMsgType</name></type> <name>mtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>m_type</name></name> <operator>=</operator> <name>mtype</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_send() -
 *
 *        Send out one statistics message to the collector
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_send</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>rc</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgStatSock</name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>PgStat_MsgHdr</name> <operator>*</operator><operator>)</operator> <name>msg</name><operator>)</operator><operator>-&gt;</operator><name>m_size</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

    <comment type="block">/* We'll retry after EINTR, but ignore all other failures */</comment>
    <do>do
    <block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>send</name><argument_list>(<argument><expr><name>pgStatSock</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>;</do>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
    <comment type="block">/* In debug builds, log send failures ... */</comment>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not send to statistics collector: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_send_archiver() -
 *
 *    Tell the collector about the WAL file that we successfully
 *    archived or failed to archive.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_send_archiver</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xlog</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>failed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_MsgArchiver</name></type> <name>msg</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Prepare and send the message
     */</comment>
    <expr_stmt><expr><call><name>pgstat_setheader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>msg</name><operator>.</operator><name>m_hdr</name></name></expr></argument>, <argument><expr><name>PGSTAT_MTYPE_ARCHIVER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_failed</name></name> <operator>=</operator> <name>failed</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name><name>msg</name><operator>.</operator><name>m_xlog</name></name></expr></argument>, <argument><expr><name>xlog</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>msg</name><operator>.</operator><name>m_xlog</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_timestamp</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_send</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_send_bgwriter() -
 *
 *        Send bgwriter statistics to the collector
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_send_bgwriter</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* We assume this initializes to zeroes */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PgStat_MsgBgWriter</name></type> <name>all_zeroes</name></decl>;</decl_stmt>

    <comment type="block">/*
     * This function can be called even if nothing at all has happened. In
     * this case, avoid sending a completely empty message to the stats
     * collector.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BgWriterStats</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>all_zeroes</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_MsgBgWriter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Prepare and send the message
     */</comment>
    <expr_stmt><expr><call><name>pgstat_setheader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>BgWriterStats</name><operator>.</operator><name>m_hdr</name></name></expr></argument>, <argument><expr><name>PGSTAT_MTYPE_BGWRITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_send</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BgWriterStats</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BgWriterStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Clear out the statistics buffer, so it can be re-used.
     */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BgWriterStats</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BgWriterStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * PgstatCollectorMain() -
 *
 *    Start up the statistics collector process.  This is the body of the
 *    postmaster child process.
 *
 *    The argc/argv parameters are valid only in EXEC_BACKEND case.
 * ----------
 */</comment>
<function><type><name>NON_EXEC_STATIC</name> <name>void</name></type>
<name>PgstatCollectorMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_Msg</name></type>    <name>msg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>wr</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Ignore all signals usually bound to some action in the postmaster,
     * except SIGHUP and SIGQUIT.  Note we don't need a SIGUSR1 handler to
     * support latch operations, because we only use a local latch.
     */</comment>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>pgstat_sighup_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>pgstat_exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGALRM</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTTIN</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTTOU</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCONT</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGWINCH</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Identify myself via ps
     */</comment>
    <expr_stmt><expr><call><name>init_ps_display</name><argument_list>(<argument><expr><literal type="string">"stats collector process"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Read in existing stats files or initialize the stats to zero.
     */</comment>
    <expr_stmt><expr><name>pgStatRunningInCollector</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pgStatDBHash</name> <operator>=</operator> <call><name>pgstat_read_statsfiles</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Loop to process messages until we get SIGQUIT or detect ungraceful
     * death of our parent postmaster.
     *
     * For performance reasons, we don't want to do ResetLatch/WaitLatch after
     * every message; instead, do that only after a recv() fails to obtain a
     * message.  (This effectively means that if backends are sending us stuff
     * like mad, we won't notice postmaster death until things slack off a
     * bit; which seems fine.)    To do that, we have an inner loop that
     * iterates as long as recv() succeeds.  We do recognize got_SIGHUP inside
     * the inner loop, which means that such interrupts will get serviced but
     * the latch won't get cleared until next time there is a break in the
     * action.
     */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <comment type="block">/* Clear any already-pending wakeups */</comment>
        <expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Quit if we get SIGQUIT from the postmaster.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>need_exit</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Inner loop iterates as long as we keep getting messages, or until
         * need_exit becomes set.
         */</comment>
        <while>while <condition>(<expr><operator>!</operator><name>need_exit</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Reload configuration if we got SIGHUP from the postmaster.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>got_SIGHUP</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Write the stats file(s) if a new request has arrived that is
             * not satisfied by existing file(s).
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>pgstat_write_statsfile_needed</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgstat_write_statsfiles</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Try to receive and process a message.  This will not block,
             * since the socket is set to non-blocking mode.
             *
             * XXX On Windows, we have to force pgwin32_recv to cooperate,
             * despite the previous use of pg_set_noblock() on the socket.
             * This is extremely broken and should be fixed someday.
             */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
            <expr_stmt><expr><name>pgwin32_noblock</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>recv</name><argument_list>(<argument><expr><name>pgStatSock</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>msg</name></expr></argument>,
                       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_Msg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
            <expr_stmt><expr><name>pgwin32_noblock</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EAGAIN</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>        <comment type="block">/* out of inner loop */</comment>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read statistics message: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * We ignore messages that are smaller than our common header
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_MsgHdr</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/*
             * The received length must match the length in the header
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>msg</name><operator>.</operator><name>msg_hdr</name><operator>.</operator><name>m_size</name></name> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/*
             * O.K. - we accept this message.  Process it.
             */</comment>
            <switch>switch <condition>(<expr><name><name>msg</name><operator>.</operator><name>msg_hdr</name><operator>.</operator><name>m_type</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>PGSTAT_MTYPE_DUMMY</name></expr>:</case>
                    <break>break;</break>

                <case>case <expr><name>PGSTAT_MTYPE_INQUIRY</name></expr>:</case>
                    <expr_stmt><expr><call><name>pgstat_recv_inquiry</name><argument_list>(<argument><expr><operator>(</operator><name>PgStat_MsgInquiry</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>PGSTAT_MTYPE_TABSTAT</name></expr>:</case>
                    <expr_stmt><expr><call><name>pgstat_recv_tabstat</name><argument_list>(<argument><expr><operator>(</operator><name>PgStat_MsgTabstat</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>PGSTAT_MTYPE_TABPURGE</name></expr>:</case>
                    <expr_stmt><expr><call><name>pgstat_recv_tabpurge</name><argument_list>(<argument><expr><operator>(</operator><name>PgStat_MsgTabpurge</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>PGSTAT_MTYPE_DROPDB</name></expr>:</case>
                    <expr_stmt><expr><call><name>pgstat_recv_dropdb</name><argument_list>(<argument><expr><operator>(</operator><name>PgStat_MsgDropdb</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>PGSTAT_MTYPE_RESETCOUNTER</name></expr>:</case>
                    <expr_stmt><expr><call><name>pgstat_recv_resetcounter</name><argument_list>(<argument><expr><operator>(</operator><name>PgStat_MsgResetcounter</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>msg</name></expr></argument>,
                                             <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>PGSTAT_MTYPE_RESETSHAREDCOUNTER</name></expr>:</case>
                    <expr_stmt><expr><call><name>pgstat_recv_resetsharedcounter</name><argument_list>(
                                                   <argument><expr><operator>(</operator><name>PgStat_MsgResetsharedcounter</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>msg</name></expr></argument>,
                                                   <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>PGSTAT_MTYPE_RESETSINGLECOUNTER</name></expr>:</case>
                    <expr_stmt><expr><call><name>pgstat_recv_resetsinglecounter</name><argument_list>(
                                                   <argument><expr><operator>(</operator><name>PgStat_MsgResetsinglecounter</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>msg</name></expr></argument>,
                                                   <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>PGSTAT_MTYPE_AUTOVAC_START</name></expr>:</case>
                    <expr_stmt><expr><call><name>pgstat_recv_autovac</name><argument_list>(<argument><expr><operator>(</operator><name>PgStat_MsgAutovacStart</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>PGSTAT_MTYPE_VACUUM</name></expr>:</case>
                    <expr_stmt><expr><call><name>pgstat_recv_vacuum</name><argument_list>(<argument><expr><operator>(</operator><name>PgStat_MsgVacuum</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>PGSTAT_MTYPE_ANALYZE</name></expr>:</case>
                    <expr_stmt><expr><call><name>pgstat_recv_analyze</name><argument_list>(<argument><expr><operator>(</operator><name>PgStat_MsgAnalyze</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>PGSTAT_MTYPE_ARCHIVER</name></expr>:</case>
                    <expr_stmt><expr><call><name>pgstat_recv_archiver</name><argument_list>(<argument><expr><operator>(</operator><name>PgStat_MsgArchiver</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>PGSTAT_MTYPE_BGWRITER</name></expr>:</case>
                    <expr_stmt><expr><call><name>pgstat_recv_bgwriter</name><argument_list>(<argument><expr><operator>(</operator><name>PgStat_MsgBgWriter</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>PGSTAT_MTYPE_FUNCSTAT</name></expr>:</case>
                    <expr_stmt><expr><call><name>pgstat_recv_funcstat</name><argument_list>(<argument><expr><operator>(</operator><name>PgStat_MsgFuncstat</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>PGSTAT_MTYPE_FUNCPURGE</name></expr>:</case>
                    <expr_stmt><expr><call><name>pgstat_recv_funcpurge</name><argument_list>(<argument><expr><operator>(</operator><name>PgStat_MsgFuncpurge</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>PGSTAT_MTYPE_RECOVERYCONFLICT</name></expr>:</case>
                    <expr_stmt><expr><call><name>pgstat_recv_recoveryconflict</name><argument_list>(<argument><expr><operator>(</operator><name>PgStat_MsgRecoveryConflict</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>PGSTAT_MTYPE_DEADLOCK</name></expr>:</case>
                    <expr_stmt><expr><call><name>pgstat_recv_deadlock</name><argument_list>(<argument><expr><operator>(</operator><name>PgStat_MsgDeadlock</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>PGSTAT_MTYPE_TEMPFILE</name></expr>:</case>
                    <expr_stmt><expr><call><name>pgstat_recv_tempfile</name><argument_list>(<argument><expr><operator>(</operator><name>PgStat_MsgTempFile</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <default>default:</default>
                    <break>break;</break>
            </block_content>}</block></switch>
        </block_content>}</block></while>                        <comment type="block">/* end of inner message-processing loop */</comment>

        <comment type="block">/* Sleep until there's something to do */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
        <expr_stmt><expr><name>wr</name> <operator>=</operator> <call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
                               <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name> <operator>|</operator> <name>WL_SOCKET_READABLE</name></expr></argument>,
                               <argument><expr><name>pgStatSock</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1L</literal></expr></argument>,
                               <argument><expr><name>WAIT_EVENT_PGSTAT_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

        <comment type="block">/*
         * Windows, at least in its Windows Server 2003 R2 incarnation,
         * sometimes loses FD_READ events.  Waking up and retrying the recv()
         * fixes that, so don't sleep indefinitely.  This is a crock of the
         * first water, but until somebody wants to debug exactly what's
         * happening there, this is the best we can do.  The two-second
         * timeout matches our pre-9.2 behavior, and needs to be short enough
         * to not provoke "using stale statistics" complaints from
         * backend_read_statsfile.
         */</comment>
        <expr_stmt><expr><name>wr</name> <operator>=</operator> <call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
                               <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name> <operator>|</operator> <name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_TIMEOUT</name></expr></argument>,
                               <argument><expr><name>pgStatSock</name></expr></argument>,
                               <argument><expr><literal type="number">2</literal> <operator>*</operator> <literal type="number">1000L</literal></expr></argument> <comment type="block">/* msec */</comment> ,
                               <argument><expr><name>WAIT_EVENT_PGSTAT_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * Emergency bailout if postmaster has died.  This is to avoid the
         * necessity for manual cleanup of all postmaster children.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>wr</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>                            <comment type="block">/* end of outer loop */</comment>

    <comment type="block">/*
     * Save the final stats to reuse at next startup.
     */</comment>
    <expr_stmt><expr><call><name>pgstat_write_statsfiles</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* SIGQUIT signal handler for collector process */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_exit</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>need_exit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGHUP handler for collector process */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_sighup_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine to clear stats in a database entry
 *
 * Tables and functions hashes are initialized to empty.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reset_dbentry_counters</name><parameter_list>(<parameter><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASHCTL</name></type>        <name>hash_ctl</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_xact_commit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_xact_rollback</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_blocks_fetched</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_blocks_hit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_tuples_returned</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_tuples_fetched</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_tuples_inserted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_tuples_updated</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_tuples_deleted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>last_autovac_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_conflict_tablespace</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_conflict_lock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_conflict_snapshot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_conflict_bufferpin</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_conflict_startup_deadlock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_temp_files</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_temp_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_deadlocks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_block_read_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_block_write_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>stat_reset_timestamp</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>stats_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_StatTabEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Per-database table"</literal></expr></argument>,
                                  <argument><expr><name>PGSTAT_TAB_HASH_SIZE</name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
                                  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_StatFuncEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>functions</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Per-database function"</literal></expr></argument>,
                                     <argument><expr><name>PGSTAT_FUNCTION_HASH_SIZE</name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
                                     <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Lookup the hash table entry for the specified database. If no hash
 * table entry exists, initialize it, if the create parameter is true.
 * Else, return NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>PgStat_StatDBEntry</name> <modifier>*</modifier></type>
<name>pgstat_get_db_entry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HASHACTION</name></type>    <name>action</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>create</name></expr> ?</condition><then> <expr><name>HASH_ENTER</name></expr> </then><else>: <expr><name>HASH_FIND</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Lookup or create the hash table entry for this database */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PgStat_StatDBEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>pgStatDBHash</name></expr></argument>,
                                                <argument><expr><operator>&amp;</operator><name>databaseid</name></expr></argument>,
                                                <argument><expr><name>action</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>create</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If not found, initialize the new one.  This creates empty hash tables
     * for tables and functions, too.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>reset_dbentry_counters</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Lookup the hash table entry for the specified table. If no hash
 * table entry exists, initialize it, if the create parameter is true.
 * Else, return NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>PgStat_StatTabEntry</name> <modifier>*</modifier></type>
<name>pgstat_get_tab_entry</name><parameter_list>(<parameter><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>tableoid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_StatTabEntry</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HASHACTION</name></type>    <name>action</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>create</name></expr> ?</condition><then> <expr><name>HASH_ENTER</name></expr> </then><else>: <expr><name>HASH_FIND</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Lookup or create the hash table entry for this table */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PgStat_StatTabEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name></expr></argument>,
                                                 <argument><expr><operator>&amp;</operator><name>tableoid</name></expr></argument>,
                                                 <argument><expr><name>action</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>create</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If not found, initialize the new one. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>numscans</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>tuples_returned</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>tuples_fetched</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>tuples_inserted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>tuples_updated</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>tuples_deleted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>tuples_hot_updated</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>n_live_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>n_dead_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>changes_since_analyze</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>blocks_fetched</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>blocks_hit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>vacuum_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>vacuum_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>autovac_vacuum_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>autovac_vacuum_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>analyze_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>analyze_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>autovac_analyze_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>autovac_analyze_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_write_statsfiles() -
 *        Write the global statistics file, as well as requested DB files.
 *
 *    'permanent' specifies writing to the permanent files not temporary ones.
 *    When true (happens only when the collector is shutting down), also remove
 *    the temporary files so that backends starting up under a new postmaster
 *    can't read old data before the new collector is ready.
 *
 *    When 'allDbs' is false, only the requested databases (listed in
 *    pending_write_requests) will be written; otherwise, all databases
 *    will be written.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_write_statsfiles</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>permanent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allDbs</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hstat</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fpout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>format_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmpfile</name> <init>= <expr><ternary><condition><expr><name>permanent</name></expr> ?</condition><then> <expr><name>PGSTAT_STAT_PERMANENT_TMPFILE</name></expr> </then><else>: <expr><name>pgstat_stat_tmpname</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>statfile</name> <init>= <expr><ternary><condition><expr><name>permanent</name></expr> ?</condition><then> <expr><name>PGSTAT_STAT_PERMANENT_FILENAME</name></expr> </then><else>: <expr><name>pgstat_stat_filename</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rc</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"writing stats file \"%s\""</literal></expr></argument>, <argument><expr><name>statfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Open the statistics temp file to write out the current values.
     */</comment>
    <expr_stmt><expr><name>fpout</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fpout</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open temporary statistics file \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>tmpfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Set the timestamp of the stats file.
     */</comment>
    <expr_stmt><expr><name><name>globalStats</name><operator>.</operator><name>stats_timestamp</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Write the file header --- currently just a format ID.
     */</comment>
    <expr_stmt><expr><name>format_id</name> <operator>=</operator> <name>PGSTAT_FILE_FORMAT_ID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name>format_id</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>format_id</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fpout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>rc</name></expr>;</expr_stmt>                    <comment type="block">/* we'll check for error with ferror */</comment>

    <comment type="block">/*
     * Write global stats struct
     */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name>globalStats</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>globalStats</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fpout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>rc</name></expr>;</expr_stmt>                    <comment type="block">/* we'll check for error with ferror */</comment>

    <comment type="block">/*
     * Write archiver stats struct
     */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name>archiverStats</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>archiverStats</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fpout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>rc</name></expr>;</expr_stmt>                    <comment type="block">/* we'll check for error with ferror */</comment>

    <comment type="block">/*
     * Walk through the database table.
     */</comment>
    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>, <argument><expr><name>pgStatDBHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>dbentry</name> <operator>=</operator> <operator>(</operator><name>PgStat_StatDBEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Write out the table and function stats for this DB into the
         * appropriate per-DB stat file, if required.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>allDbs</name> <operator>||</operator> <call><name>pgstat_db_requested</name><argument_list>(<argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>databaseid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Make DB's timestamp consistent with the global stats */</comment>
            <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>stats_timestamp</name></name> <operator>=</operator> <name><name>globalStats</name><operator>.</operator><name>stats_timestamp</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>pgstat_write_db_statsfile</name><argument_list>(<argument><expr><name>dbentry</name></expr></argument>, <argument><expr><name>permanent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Write out the DB entry. We don't write the tables or functions
         * pointers, since they're of no use to any other process.
         */</comment>
        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'D'</literal></expr></argument>, <argument><expr><name>fpout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>dbentry</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PgStat_StatDBEntry</name></expr></argument>, <argument><expr><name>tables</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fpout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>rc</name></expr>;</expr_stmt>                <comment type="block">/* we'll check for error with ferror */</comment>
    </block_content>}</block></while>

    <comment type="block">/*
     * No more output to be done. Close the temp file and replace the old
     * pgstat.stat with it.  The ferror() check replaces testing for error
     * after each individual fputc or fwrite above.
     */</comment>
    <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'E'</literal></expr></argument>, <argument><expr><name>fpout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>fpout</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write temporary statistics file \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>tmpfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fpout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fpout</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close temporary statistics file \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>tmpfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>, <argument><expr><name>statfile</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rename temporary statistics file \"%s\" to \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>tmpfile</name></expr></argument>, <argument><expr><name>statfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>permanent</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>pgstat_stat_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Now throw away the list of requests.  Note that requests sent after we
     * started the write are still waiting on the network socket.
     */</comment>
    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>pending_write_requests</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pending_write_requests</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * return the filename for a DB stat file; filename is the output buffer,
 * of length len.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_dbstat_filename</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>permanent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>tempname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>,
                    <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>printed</name></decl>;</decl_stmt>

    <comment type="block">/* NB -- pgstat_reset_remove_files knows about the pattern this uses */</comment>
    <expr_stmt><expr><name>printed</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"%s/db_%u.%s"</literal></expr></argument>,
                       <argument><expr><ternary><condition><expr><name>permanent</name></expr> ?</condition><then> <expr><name>PGSTAT_STAT_PERMANENT_DIRECTORY</name></expr> </then><else>:
                       <expr><name>pgstat_stat_directory</name></expr></else></ternary></expr></argument>,
                       <argument><expr><name>databaseid</name></expr></argument>,
                       <argument><expr><ternary><condition><expr><name>tempname</name></expr> ?</condition><then> <expr><literal type="string">"tmp"</literal></expr> </then><else>: <expr><literal type="string">"stat"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>printed</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"overlength pgstat path"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_write_db_statsfile() -
 *        Write the stat file for a single database.
 *
 *    If writing to the permanent file (happens when the collector is
 *    shutting down only), remove the temporary file so that backends
 *    starting up under a new postmaster can't read the old data before
 *    the new collector is ready.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_write_db_statsfile</name><parameter_list>(<parameter><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>permanent</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>tstat</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>fstat</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_StatTabEntry</name> <modifier>*</modifier></type><name>tabentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_StatFuncEntry</name> <modifier>*</modifier></type><name>funcentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fpout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>format_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>dbid</name> <init>= <expr><name><name>dbentry</name><operator>-&gt;</operator><name>databaseid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>tmpfile</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>statfile</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>get_dbstat_filename</name><argument_list>(<argument><expr><name>permanent</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>dbid</name></expr></argument>, <argument><expr><name>tmpfile</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>get_dbstat_filename</name><argument_list>(<argument><expr><name>permanent</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>dbid</name></expr></argument>, <argument><expr><name>statfile</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"writing stats file \"%s\""</literal></expr></argument>, <argument><expr><name>statfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Open the statistics temp file to write out the current values.
     */</comment>
    <expr_stmt><expr><name>fpout</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fpout</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open temporary statistics file \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>tmpfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Write the file header --- currently just a format ID.
     */</comment>
    <expr_stmt><expr><name>format_id</name> <operator>=</operator> <name>PGSTAT_FILE_FORMAT_ID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name>format_id</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>format_id</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fpout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>rc</name></expr>;</expr_stmt>                    <comment type="block">/* we'll check for error with ferror */</comment>

    <comment type="block">/*
     * Walk through the database's access stats per table.
     */</comment>
    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tstat</name></expr></argument>, <argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>tabentry</name> <operator>=</operator> <operator>(</operator><name>PgStat_StatTabEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tstat</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'T'</literal></expr></argument>, <argument><expr><name>fpout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>tabentry</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_StatTabEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fpout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>rc</name></expr>;</expr_stmt>                <comment type="block">/* we'll check for error with ferror */</comment>
    </block_content>}</block></while>

    <comment type="block">/*
     * Walk through the database's function stats table.
     */</comment>
    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fstat</name></expr></argument>, <argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>funcentry</name> <operator>=</operator> <operator>(</operator><name>PgStat_StatFuncEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fstat</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'F'</literal></expr></argument>, <argument><expr><name>fpout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>funcentry</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_StatFuncEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fpout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>rc</name></expr>;</expr_stmt>                <comment type="block">/* we'll check for error with ferror */</comment>
    </block_content>}</block></while>

    <comment type="block">/*
     * No more output to be done. Close the temp file and replace the old
     * pgstat.stat with it.  The ferror() check replaces testing for error
     * after each individual fputc or fwrite above.
     */</comment>
    <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'E'</literal></expr></argument>, <argument><expr><name>fpout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>fpout</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write temporary statistics file \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>tmpfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fpout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fpout</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close temporary statistics file \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>tmpfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>, <argument><expr><name>statfile</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rename temporary statistics file \"%s\" to \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>tmpfile</name></expr></argument>, <argument><expr><name>statfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tmpfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>permanent</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>get_dbstat_filename</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>dbid</name></expr></argument>, <argument><expr><name>statfile</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"removing temporary stats file \"%s\""</literal></expr></argument>, <argument><expr><name>statfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>statfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_read_statsfiles() -
 *
 *    Reads in some existing statistics collector files and returns the
 *    databases hash table that is the top level of the data.
 *
 *    If 'onlydb' is not InvalidOid, it means we only want data for that DB
 *    plus the shared catalogs ("DB 0").  We'll still populate the DB hash
 *    table for all databases, but we don't bother even creating table/function
 *    hash tables for other databases.
 *
 *    'permanent' specifies reading from the permanent files not temporary ones.
 *    When true (happens only when the collector is starting up), remove the
 *    files after reading; the in-memory status is now authoritative, and the
 *    files would be out of date in case somebody else reads them.
 *
 *    If a 'deep' read is requested, table/function stats are read, otherwise
 *    the table/function hash tables remain empty.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type>
<name>pgstat_read_statsfiles</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>onlydb</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>permanent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>deep</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_StatDBEntry</name></type> <name>dbbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HASHCTL</name></type>        <name>hash_ctl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HTAB</name>       <modifier>*</modifier></type><name>dbhash</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fpin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>format_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>statfile</name> <init>= <expr><ternary><condition><expr><name>permanent</name></expr> ?</condition><then> <expr><name>PGSTAT_STAT_PERMANENT_FILENAME</name></expr> </then><else>: <expr><name>pgstat_stat_filename</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * The tables will live in pgStatLocalContext.
     */</comment>
    <expr_stmt><expr><call><name>pgstat_setup_memcxt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create the DB hashtable
     */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_StatDBEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>pgStatLocalContext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>dbhash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Databases hash"</literal></expr></argument>, <argument><expr><name>PGSTAT_DB_HASH_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
                         <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Clear out global and archiver statistics so they start from zero in
     * case we can't load an existing statsfile.
     */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>globalStats</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>globalStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>archiverStats</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>archiverStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Set the current timestamp (will be kept only in case we can't load an
     * existing statsfile).
     */</comment>
    <expr_stmt><expr><name><name>globalStats</name><operator>.</operator><name>stat_reset_timestamp</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>archiverStats</name><operator>.</operator><name>stat_reset_timestamp</name></name> <operator>=</operator> <name><name>globalStats</name><operator>.</operator><name>stat_reset_timestamp</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Try to open the stats file. If it doesn't exist, the backends simply
     * return zero for anything and the collector simply starts from scratch
     * with empty counters.
     *
     * ENOENT is a possibility if the stats collector is not running or has
     * not yet written the stats file the first time.  Any other failure
     * condition is suspicious.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fpin</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>statfile</name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>pgStatRunningInCollector</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>WARNING</name></expr></else></ternary></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open statistics file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>statfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>dbhash</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Verify it's of the expected format.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>format_id</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>format_id</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fpin</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>format_id</name></expr></argument>)</argument_list></sizeof> <operator>||</operator>
        <name>format_id</name> <operator>!=</operator> <name>PGSTAT_FILE_FORMAT_ID</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>pgStatRunningInCollector</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>WARNING</name></expr></else></ternary></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted statistics file \"%s\""</literal></expr></argument>, <argument><expr><name>statfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>done</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Read global stats struct
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>globalStats</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>globalStats</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fpin</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>globalStats</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>pgStatRunningInCollector</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>WARNING</name></expr></else></ternary></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted statistics file \"%s\""</literal></expr></argument>, <argument><expr><name>statfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>globalStats</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>globalStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>done</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * In the collector, disregard the timestamp we read from the permanent
     * stats file; we should be willing to write a temp stats file immediately
     * upon the first request from any backend.  This only matters if the old
     * file's timestamp is less than PGSTAT_STAT_INTERVAL ago, but that's not
     * an unusual scenario.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>pgStatRunningInCollector</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>globalStats</name><operator>.</operator><name>stats_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Read archiver stats struct
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>archiverStats</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>archiverStats</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fpin</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>archiverStats</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>pgStatRunningInCollector</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>WARNING</name></expr></else></ternary></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted statistics file \"%s\""</literal></expr></argument>, <argument><expr><name>statfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>archiverStats</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>archiverStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>done</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We found an existing collector stats file. Read it and put all the
     * hashtable entries into place.
     */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <switch>switch <condition>(<expr><call><name>fgetc</name><argument_list>(<argument><expr><name>fpin</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
                <comment type="block">/*
                 * 'D'    A PgStat_StatDBEntry struct describing a database
                 * follows.
                 */</comment>
            <case>case <expr><literal type="char">'D'</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dbbuf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PgStat_StatDBEntry</name></expr></argument>, <argument><expr><name>tables</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>fpin</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PgStat_StatDBEntry</name></expr></argument>, <argument><expr><name>tables</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>pgStatRunningInCollector</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>WARNING</name></expr></else></ternary></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted statistics file \"%s\""</literal></expr></argument>,
                                    <argument><expr><name>statfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>done</name>;</goto>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * Add to the DB hash
                 */</comment>
                <expr_stmt><expr><name>dbentry</name> <operator>=</operator> <operator>(</operator><name>PgStat_StatDBEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>dbhash</name></expr></argument>,
                                                             <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>dbbuf</name><operator>.</operator><name>databaseid</name></name></expr></argument>,
                                                             <argument><expr><name>HASH_ENTER</name></expr></argument>,
                                                             <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>pgStatRunningInCollector</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>WARNING</name></expr></else></ternary></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted statistics file \"%s\""</literal></expr></argument>,
                                    <argument><expr><name>statfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>done</name>;</goto>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dbentry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dbbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_StatDBEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>functions</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * In the collector, disregard the timestamp we read from the
                 * permanent stats file; we should be willing to write a temp
                 * stats file immediately upon the first request from any
                 * backend.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>pgStatRunningInCollector</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>stats_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * Don't create tables/functions hashtables for uninteresting
                 * databases.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>onlydb</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>dbbuf</name><operator>.</operator><name>databaseid</name></name> <operator>!=</operator> <name>onlydb</name> <operator>&amp;&amp;</operator>
                        <name><name>dbbuf</name><operator>.</operator><name>databaseid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_StatTabEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>pgStatLocalContext</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Per-database table"</literal></expr></argument>,
                                              <argument><expr><name>PGSTAT_TAB_HASH_SIZE</name></expr></argument>,
                                              <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
                                              <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_StatFuncEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>pgStatLocalContext</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>functions</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Per-database function"</literal></expr></argument>,
                                                 <argument><expr><name>PGSTAT_FUNCTION_HASH_SIZE</name></expr></argument>,
                                                 <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
                                                 <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * If requested, read the data from the database-specific
                 * file.  Otherwise we just leave the hashtables empty.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>deep</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>pgstat_read_db_statsfile</name><argument_list>(<argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>databaseid</name></name></expr></argument>,
                                             <argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name></expr></argument>,
                                             <argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>,
                                             <argument><expr><name>permanent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <break>break;</break>

            <case>case <expr><literal type="char">'E'</literal></expr>:</case>
                <goto>goto <name>done</name>;</goto>

            <default>default:</default>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>pgStatRunningInCollector</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>WARNING</name></expr></else></ternary></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted statistics file \"%s\""</literal></expr></argument>,
                                <argument><expr><name>statfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>done</name>;</goto>
        </block_content>}</block></switch>
    </block_content>}</block></for>

<label><name>done</name>:</label>
    <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fpin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If requested to read the permanent file, also get rid of it. */</comment>
    <if_stmt><if>if <condition>(<expr><name>permanent</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"removing permanent stats file \"%s\""</literal></expr></argument>, <argument><expr><name>statfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>statfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>dbhash</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_read_db_statsfile() -
 *
 *    Reads in the existing statistics collector file for the given database,
 *    filling the passed-in tables and functions hash tables.
 *
 *    As in pgstat_read_statsfiles, if the permanent file is requested, it is
 *    removed after reading.
 *
 *    Note: this code has the ability to skip storing per-table or per-function
 *    data, if NULL is passed for the corresponding hashtable.  That's not used
 *    at the moment though.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_read_db_statsfile</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>, <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>tabhash</name></decl></parameter>, <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>funchash</name></decl></parameter>,
                         <parameter><decl><type><name>bool</name></type> <name>permanent</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PgStat_StatTabEntry</name> <modifier>*</modifier></type><name>tabentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_StatTabEntry</name></type> <name>tabbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_StatFuncEntry</name></type> <name>funcbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_StatFuncEntry</name> <modifier>*</modifier></type><name>funcentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fpin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>format_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>statfile</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>get_dbstat_filename</name><argument_list>(<argument><expr><name>permanent</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>databaseid</name></expr></argument>, <argument><expr><name>statfile</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Try to open the stats file. If it doesn't exist, the backends simply
     * return zero for anything and the collector simply starts from scratch
     * with empty counters.
     *
     * ENOENT is a possibility if the stats collector is not running or has
     * not yet written the stats file the first time.  Any other failure
     * condition is suspicious.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fpin</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>statfile</name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>pgStatRunningInCollector</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>WARNING</name></expr></else></ternary></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open statistics file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>statfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Verify it's of the expected format.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>format_id</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>format_id</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fpin</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>format_id</name></expr></argument>)</argument_list></sizeof> <operator>||</operator>
        <name>format_id</name> <operator>!=</operator> <name>PGSTAT_FILE_FORMAT_ID</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>pgStatRunningInCollector</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>WARNING</name></expr></else></ternary></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted statistics file \"%s\""</literal></expr></argument>, <argument><expr><name>statfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>done</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We found an existing collector stats file. Read it and put all the
     * hashtable entries into place.
     */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <switch>switch <condition>(<expr><call><name>fgetc</name><argument_list>(<argument><expr><name>fpin</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
                <comment type="block">/*
                 * 'T'    A PgStat_StatTabEntry follows.
                 */</comment>
            <case>case <expr><literal type="char">'T'</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tabbuf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_StatTabEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                          <argument><expr><name>fpin</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_StatTabEntry</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>pgStatRunningInCollector</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>WARNING</name></expr></else></ternary></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted statistics file \"%s\""</literal></expr></argument>,
                                    <argument><expr><name>statfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>done</name>;</goto>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * Skip if table data not wanted.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>tabhash</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>tabentry</name> <operator>=</operator> <operator>(</operator><name>PgStat_StatTabEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>tabhash</name></expr></argument>,
                                                               <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>tabbuf</name><operator>.</operator><name>tableid</name></name></expr></argument>,
                                                               <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>pgStatRunningInCollector</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>WARNING</name></expr></else></ternary></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted statistics file \"%s\""</literal></expr></argument>,
                                    <argument><expr><name>statfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>done</name>;</goto>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tabentry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tabbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tabbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

                <comment type="block">/*
                 * 'F'    A PgStat_StatFuncEntry follows.
                 */</comment>
            <case>case <expr><literal type="char">'F'</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>funcbuf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_StatFuncEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                          <argument><expr><name>fpin</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PgStat_StatFuncEntry</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>pgStatRunningInCollector</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>WARNING</name></expr></else></ternary></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted statistics file \"%s\""</literal></expr></argument>,
                                    <argument><expr><name>statfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>done</name>;</goto>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * Skip if function data not wanted.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>funchash</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>funcentry</name> <operator>=</operator> <operator>(</operator><name>PgStat_StatFuncEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>funchash</name></expr></argument>,
                                                                 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>funcbuf</name><operator>.</operator><name>functionid</name></name></expr></argument>,
                                                                 <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>pgStatRunningInCollector</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>WARNING</name></expr></else></ternary></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted statistics file \"%s\""</literal></expr></argument>,
                                    <argument><expr><name>statfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>done</name>;</goto>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>funcentry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>funcbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>funcbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

                <comment type="block">/*
                 * 'E'    The EOF marker of a complete stats file.
                 */</comment>
            <case>case <expr><literal type="char">'E'</literal></expr>:</case>
                <goto>goto <name>done</name>;</goto>

            <default>default:</default>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>pgStatRunningInCollector</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>WARNING</name></expr></else></ternary></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted statistics file \"%s\""</literal></expr></argument>,
                                <argument><expr><name>statfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>done</name>;</goto>
        </block_content>}</block></switch>
    </block_content>}</block></for>

<label><name>done</name>:</label>
    <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fpin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>permanent</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"removing permanent stats file \"%s\""</literal></expr></argument>, <argument><expr><name>statfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>statfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_read_db_statsfile_timestamp() -
 *
 *    Attempt to determine the timestamp of the last db statfile write.
 *    Returns TRUE if successful; the timestamp is stored in *ts.
 *
 *    This needs to be careful about handling databases for which no stats file
 *    exists, such as databases without a stat entry or those not yet written:
 *
 *    - if there's a database entry in the global file, return the corresponding
 *    stats_timestamp value.
 *
 *    - if there's no db stat entry (e.g. for a new or inactive database),
 *    there's no stats_timestamp value, but also nothing to write so we return
 *    the timestamp of the global statfile.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgstat_read_db_statsfile_timestamp</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>permanent</name></decl></parameter>,
                                   <parameter><decl><type><name>TimestampTz</name> <modifier>*</modifier></type><name>ts</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PgStat_StatDBEntry</name></type> <name>dbentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_GlobalStats</name></type> <name>myGlobalStats</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_ArchiverStats</name></type> <name>myArchiverStats</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fpin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>format_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>statfile</name> <init>= <expr><ternary><condition><expr><name>permanent</name></expr> ?</condition><then> <expr><name>PGSTAT_STAT_PERMANENT_FILENAME</name></expr> </then><else>: <expr><name>pgstat_stat_filename</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Try to open the stats file.  As above, anything but ENOENT is worthy of
     * complaining about.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fpin</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>statfile</name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>pgStatRunningInCollector</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>WARNING</name></expr></else></ternary></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open statistics file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>statfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Verify it's of the expected format.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>format_id</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>format_id</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fpin</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>format_id</name></expr></argument>)</argument_list></sizeof> <operator>||</operator>
        <name>format_id</name> <operator>!=</operator> <name>PGSTAT_FILE_FORMAT_ID</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>pgStatRunningInCollector</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>WARNING</name></expr></else></ternary></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted statistics file \"%s\""</literal></expr></argument>, <argument><expr><name>statfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fpin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Read global stats struct
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myGlobalStats</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>myGlobalStats</name></expr></argument>)</argument_list></sizeof></expr></argument>,
              <argument><expr><name>fpin</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>myGlobalStats</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>pgStatRunningInCollector</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>WARNING</name></expr></else></ternary></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted statistics file \"%s\""</literal></expr></argument>, <argument><expr><name>statfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fpin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Read archiver stats struct
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myArchiverStats</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>myArchiverStats</name></expr></argument>)</argument_list></sizeof></expr></argument>,
              <argument><expr><name>fpin</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>myArchiverStats</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>pgStatRunningInCollector</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>WARNING</name></expr></else></ternary></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted statistics file \"%s\""</literal></expr></argument>, <argument><expr><name>statfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fpin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* By default, we're going to return the timestamp of the global file. */</comment>
    <expr_stmt><expr><operator>*</operator><name>ts</name> <operator>=</operator> <name><name>myGlobalStats</name><operator>.</operator><name>stats_timestamp</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * We found an existing collector stats file.  Read it and look for a
     * record for the requested database.  If found, use its timestamp.
     */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <switch>switch <condition>(<expr><call><name>fgetc</name><argument_list>(<argument><expr><name>fpin</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
                <comment type="block">/*
                 * 'D'    A PgStat_StatDBEntry struct describing a database
                 * follows.
                 */</comment>
            <case>case <expr><literal type="char">'D'</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dbentry</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PgStat_StatDBEntry</name></expr></argument>, <argument><expr><name>tables</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>fpin</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PgStat_StatDBEntry</name></expr></argument>, <argument><expr><name>tables</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>pgStatRunningInCollector</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>WARNING</name></expr></else></ternary></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted statistics file \"%s\""</literal></expr></argument>,
                                    <argument><expr><name>statfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>done</name>;</goto>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * If this is the DB we're looking for, save its timestamp and
                 * we're done.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>dbentry</name><operator>.</operator><name>databaseid</name></name> <operator>==</operator> <name>databaseid</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>ts</name> <operator>=</operator> <name><name>dbentry</name><operator>.</operator><name>stats_timestamp</name></name></expr>;</expr_stmt>
                    <goto>goto <name>done</name>;</goto>
                </block_content>}</block></if></if_stmt>

                <break>break;</break>

            <case>case <expr><literal type="char">'E'</literal></expr>:</case>
                <goto>goto <name>done</name>;</goto>

            <default>default:</default>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>pgStatRunningInCollector</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>WARNING</name></expr></else></ternary></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted statistics file \"%s\""</literal></expr></argument>,
                                <argument><expr><name>statfile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>done</name>;</goto>
        </block_content>}</block></switch>
    </block_content>}</block></for>

<label><name>done</name>:</label>
    <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fpin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If not already done, read the statistics collector stats file into
 * some hash tables.  The results will be kept until pgstat_clear_snapshot()
 * is called (typically, at end of transaction).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>backend_read_statsfile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>min_ts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>ref_ts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>inquiry_db</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>count</name></decl>;</decl_stmt>

    <comment type="block">/* already read it? */</comment>
    <if_stmt><if>if <condition>(<expr><name>pgStatDBHash</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>pgStatRunningInCollector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * In a normal backend, we check staleness of the data for our own DB, and
     * so we send MyDatabaseId in inquiry messages.  In the autovac launcher,
     * check staleness of the shared-catalog data, and send InvalidOid in
     * inquiry messages so as not to force writing unnecessary data.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumLauncherProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>inquiry_db</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>inquiry_db</name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Loop until fresh enough stats file is available or we ran out of time.
     * The stats inquiry message is sent repeatedly in case collector drops
     * it; but not every single time, as that just swamps the collector.
     */</comment>
    <for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>count</name> <operator>&lt;</operator> <name>PGSTAT_POLL_LOOP_COUNT</name></expr>;</condition> <incr><expr><name>count</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>        <name>ok</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TimestampTz</name></type> <name>file_ts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TimestampTz</name></type> <name>cur_ts</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>pgstat_read_db_statsfile_timestamp</name><argument_list>(<argument><expr><name>inquiry_db</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>cur_ts</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Calculate min acceptable timestamp, if we didn't already */</comment>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>cur_ts</name> <operator>&lt;</operator> <name>ref_ts</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We set the minimum acceptable timestamp to PGSTAT_STAT_INTERVAL
             * msec before now.  This indirectly ensures that the collector
             * needn't write the file more often than PGSTAT_STAT_INTERVAL. In
             * an autovacuum worker, however, we want a lower delay to avoid
             * using stale data, so we use PGSTAT_RETRY_DELAY (since the
             * number of workers is low, this shouldn't be a problem).
             *
             * We don't recompute min_ts after sleeping, except in the
             * unlikely case that cur_ts went backwards.  So we might end up
             * accepting a file a bit older than PGSTAT_STAT_INTERVAL.  In
             * practice that shouldn't happen, though, as long as the sleep
             * time is less than PGSTAT_STAT_INTERVAL; and we don't want to
             * tell the collector that our cutoff time is less than what we'd
             * actually accept.
             */</comment>
            <expr_stmt><expr><name>ref_ts</name> <operator>=</operator> <name>cur_ts</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>min_ts</name> <operator>=</operator> <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>ref_ts</name></expr></argument>,
                                                     <argument><expr><operator>-</operator><name>PGSTAT_RETRY_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>min_ts</name> <operator>=</operator> <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>ref_ts</name></expr></argument>,
                                                     <argument><expr><operator>-</operator><name>PGSTAT_STAT_INTERVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If the file timestamp is actually newer than cur_ts, we must have
         * had a clock glitch (system time went backwards) or there is clock
         * skew between our processor and the stats collector's processor.
         * Accept the file, but send an inquiry message anyway to make
         * pgstat_recv_inquiry do a sanity check on the collector's time.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>ok</name> <operator>&amp;&amp;</operator> <name>file_ts</name> <operator>&gt;</operator> <name>cur_ts</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * A small amount of clock skew between processors isn't terribly
             * surprising, but a large difference is worth logging.  We
             * arbitrarily define "large" as 1000 msec.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>file_ts</name> <operator>&gt;=</operator> <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>cur_ts</name></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>filetime</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>mytime</name></decl>;</decl_stmt>

                <comment type="block">/* Copy because timestamptz_to_str returns a static buffer */</comment>
                <expr_stmt><expr><name>filetime</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name>file_ts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>mytime</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name>cur_ts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"stats collector's time %s is later than backend local time %s"</literal></expr></argument>,
                     <argument><expr><name>filetime</name></expr></argument>, <argument><expr><name>mytime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filetime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>mytime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>pgstat_send_inquiry</name><argument_list>(<argument><expr><name>cur_ts</name></expr></argument>, <argument><expr><name>min_ts</name></expr></argument>, <argument><expr><name>inquiry_db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Normal acceptance case: file is not older than cutoff time */</comment>
        <if_stmt><if>if <condition>(<expr><name>ok</name> <operator>&amp;&amp;</operator> <name>file_ts</name> <operator>&gt;=</operator> <name>min_ts</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/* Not there or too old, so kick the collector and wait a bit */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>count</name> <operator>%</operator> <name>PGSTAT_INQ_LOOP_COUNT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pgstat_send_inquiry</name><argument_list>(<argument><expr><name>cur_ts</name></expr></argument>, <argument><expr><name>min_ts</name></expr></argument>, <argument><expr><name>inquiry_db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>PGSTAT_RETRY_DELAY</name> <operator>*</operator> <literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;=</operator> <name>PGSTAT_POLL_LOOP_COUNT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"using stale statistics instead of current ones "</literal>
                        <literal type="string">"because stats collector is not responding"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Autovacuum launcher wants stats about all databases, but a shallow read
     * is sufficient.  Regular backends want a deep read for just the tables
     * they can see (MyDatabaseId + shared catalogs).
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumLauncherProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>pgStatDBHash</name> <operator>=</operator> <call><name>pgstat_read_statsfiles</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>pgStatDBHash</name> <operator>=</operator> <call><name>pgstat_read_statsfiles</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_setup_memcxt() -
 *
 *    Create pgStatLocalContext, if not already done.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_setup_memcxt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pgStatLocalContext</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>pgStatLocalContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                                   <argument><expr><literal type="string">"Statistics snapshot"</literal></expr></argument>,
                                                   <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_clear_snapshot() -
 *
 *    Discard any data collected in the current transaction.  Any subsequent
 *    request will cause new snapshots to be read.
 *
 *    This is also invoked during transaction commit or abort to discard
 *    the no-longer-wanted snapshot.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>pgstat_clear_snapshot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Release memory, if any was allocated */</comment>
    <if_stmt><if>if <condition>(<expr><name>pgStatLocalContext</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>pgStatLocalContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Reset variables */</comment>
    <expr_stmt><expr><name>pgStatLocalContext</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pgStatDBHash</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>localBackendStatusTable</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>localNumBackends</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_recv_inquiry() -
 *
 *    Process stat inquiry requests.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_recv_inquiry</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgInquiry</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"received inquiry for database %u"</literal></expr></argument>, <argument><expr><name><name>msg</name><operator>-&gt;</operator><name>databaseid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If there's already a write request for this DB, there's nothing to do.
     *
     * Note that if a request is found, we return early and skip the below
     * check for clock skew.  This is okay, since the only way for a DB
     * request to be present in the list is that we have been here since the
     * last write round.  It seems sufficient to check for clock skew once per
     * write round.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>pending_write_requests</name></expr></argument>, <argument><expr><name><name>msg</name><operator>-&gt;</operator><name>databaseid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Check to see if we last wrote this database at a time &gt;= the requested
     * cutoff time.  If so, this is a stale request that was generated before
     * we updated the DB file, and we don't need to do so again.
     *
     * If the requestor's local clock time is older than stats_timestamp, we
     * should suspect a clock glitch, ie system time going backwards; though
     * the more likely explanation is just delayed message receipt.  It is
     * worth expending a GetCurrentTimestamp call to be sure, since a large
     * retreat in the system clock reading could otherwise cause us to neglect
     * to update the stats file for a long time.
     */</comment>
    <expr_stmt><expr><name>dbentry</name> <operator>=</operator> <call><name>pgstat_get_db_entry</name><argument_list>(<argument><expr><name><name>msg</name><operator>-&gt;</operator><name>databaseid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dbentry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We have no data for this DB.  Enter a write request anyway so that
         * the global stats will get updated.  This is needed to prevent
         * backend_read_statsfile from waiting for data that we cannot supply,
         * in the case of a new DB that nobody has yet reported any stats for.
         * See the behavior of pgstat_read_db_statsfile_timestamp.
         */</comment>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>msg</name><operator>-&gt;</operator><name>clock_time</name></name> <operator>&lt;</operator> <name><name>dbentry</name><operator>-&gt;</operator><name>stats_timestamp</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TimestampTz</name></type> <name>cur_ts</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>cur_ts</name> <operator>&lt;</operator> <name><name>dbentry</name><operator>-&gt;</operator><name>stats_timestamp</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Sure enough, time went backwards.  Force a new stats file write
             * to get back in sync; but first, log a complaint.
             */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>writetime</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>mytime</name></decl>;</decl_stmt>

            <comment type="block">/* Copy because timestamptz_to_str returns a static buffer */</comment>
            <expr_stmt><expr><name>writetime</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>stats_timestamp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mytime</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name>cur_ts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                 <argument><expr><literal type="string">"stats_timestamp %s is later than collector's time %s for database %u"</literal></expr></argument>,
                 <argument><expr><name>writetime</name></expr></argument>, <argument><expr><name>mytime</name></expr></argument>, <argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>databaseid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>writetime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>mytime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Nope, it's just an old request.  Assuming msg's clock_time is
             * &gt;= its cutoff_time, it must be stale, so we can ignore it.
             */</comment>
            <return>return;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>msg</name><operator>-&gt;</operator><name>cutoff_time</name></name> <operator>&lt;=</operator> <name><name>dbentry</name><operator>-&gt;</operator><name>stats_timestamp</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Stale request, ignore it */</comment>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We need to write this DB, so create a request.
     */</comment>
    <expr_stmt><expr><name>pending_write_requests</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>pending_write_requests</name></expr></argument>,
                                         <argument><expr><name><name>msg</name><operator>-&gt;</operator><name>databaseid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type> 
<name>pgstat_update_tabstat</name><parameter_list>(<parameter><decl><type><name>PgStat_StatTabEntry</name> <modifier>*</modifier></type><name>tabentry</name></decl></parameter>, 
					  <parameter><decl><type><name>PgStat_TableEntry</name> <modifier>*</modifier></type><name>tabmsg</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>found</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
			* If it's a new table entry, initialize counters to the values we
			* just got.
			*/</comment>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>numscans</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_numscans</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_returned</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_returned</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_fetched</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_fetched</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_inserted</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_inserted</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_updated</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_updated</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_deleted</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_deleted</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_hot_updated</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_hot_updated</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_live_tuples</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_delta_live_tuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_dead_tuples</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_delta_dead_tuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>changes_since_analyze</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_changed_tuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>blocks_fetched</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_blocks_fetched</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>blocks_hit</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_blocks_hit</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>vacuum_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>vacuum_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>autovac_vacuum_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>autovac_vacuum_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>analyze_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>analyze_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>autovac_analyze_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>autovac_analyze_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
			* Otherwise add the values to the existing entry.
			*/</comment>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>numscans</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_numscans</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_returned</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_returned</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_fetched</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_fetched</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_inserted</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_inserted</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_updated</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_updated</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_deleted</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_deleted</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_hot_updated</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_hot_updated</name></name></expr>;</expr_stmt>
		<comment type="block">/* If table was truncated, first reset the live/dead counters */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_truncated</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_live_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_dead_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_live_tuples</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_delta_live_tuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_dead_tuples</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_delta_dead_tuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>changes_since_analyze</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_changed_tuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>blocks_fetched</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_blocks_fetched</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>blocks_hit</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_blocks_hit</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* ----------
 * pgstat_recv_tabstat() -
 *
 *    Count what the backend has done.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_recv_tabstat</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgTabstat</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_StatTabEntry</name> <modifier>*</modifier></type><name>tabentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>dbentry</name> <operator>=</operator> <call><name>pgstat_get_db_entry</name><argument_list>(<argument><expr><name><name>msg</name><operator>-&gt;</operator><name>m_databaseid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Update database-wide stats.
     */</comment>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_xact_commit</name></name> <operator>+=</operator> <operator>(</operator><name>PgStat_Counter</name><operator>)</operator> <operator>(</operator><name><name>msg</name><operator>-&gt;</operator><name>m_xact_commit</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_xact_rollback</name></name> <operator>+=</operator> <operator>(</operator><name>PgStat_Counter</name><operator>)</operator> <operator>(</operator><name><name>msg</name><operator>-&gt;</operator><name>m_xact_rollback</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_block_read_time</name></name> <operator>+=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_block_read_time</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_block_write_time</name></name> <operator>+=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_block_write_time</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Process all table entries in the message.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_nentries</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PgStat_TableEntry</name> <modifier>*</modifier></type><name>tabmsg</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>msg</name><operator>-&gt;</operator><name>m_entry</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>tabentry</name> <operator>=</operator> <operator>(</operator><name>PgStat_StatTabEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name></expr></argument>,
                                                       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>tabmsg</name><operator>-&gt;</operator><name>t_id</name></name><operator>)</operator></expr></argument>,
                                                       <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__TBASE__</name></cpp:ifndef>													
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
				* If it's a new table entry, initialize counters to the values we
				* just got.
				*/</comment>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>numscans</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_numscans</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_returned</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_returned</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_fetched</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_fetched</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_inserted</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_inserted</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_updated</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_updated</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_deleted</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_deleted</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_hot_updated</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_hot_updated</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_live_tuples</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_delta_live_tuples</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_dead_tuples</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_delta_dead_tuples</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>changes_since_analyze</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_changed_tuples</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>blocks_fetched</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_blocks_fetched</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>blocks_hit</name></name> <operator>=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_blocks_hit</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>vacuum_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>vacuum_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>autovac_vacuum_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>autovac_vacuum_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>analyze_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>analyze_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>autovac_analyze_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>autovac_analyze_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
				* Otherwise add the values to the existing entry.
				*/</comment>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>numscans</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_numscans</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_returned</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_returned</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_fetched</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_fetched</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_inserted</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_inserted</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_updated</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_updated</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_deleted</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_deleted</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>tuples_hot_updated</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_hot_updated</name></name></expr>;</expr_stmt>
			<comment type="block">/* If table was truncated, first reset the live/dead counters */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_truncated</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_live_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_dead_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_live_tuples</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_delta_live_tuples</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_dead_tuples</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_delta_dead_tuples</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>changes_since_analyze</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_changed_tuples</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>blocks_fetched</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_blocks_fetched</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>blocks_hit</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_blocks_hit</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>pgstat_update_tabstat</name><argument_list>(<argument><expr><name>tabentry</name></expr></argument>, <argument><expr><name>tabmsg</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Clamp n_live_tuples in case of negative delta_live_tuples */</comment>
        <expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_live_tuples</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_live_tuples</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Likewise for n_dead_tuples */</comment>
        <expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_dead_tuples</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_dead_tuples</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name><name>tabmsg</name><operator>-&gt;</operator><name>t_parent_id</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tabentry</name> <operator>=</operator> <operator>(</operator><name>PgStat_StatTabEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name></expr></argument>,
													   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>tabmsg</name><operator>-&gt;</operator><name>t_parent_id</name></name><operator>)</operator></expr></argument>,
													   <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pgstat_update_tabstat</name><argument_list>(<argument><expr><name>tabentry</name></expr></argument>, <argument><expr><name>tabmsg</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Clamp n_live_tuples in case of negative delta_live_tuples */</comment>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_live_tuples</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_live_tuples</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Likewise for n_dead_tuples */</comment>
			<expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_dead_tuples</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_dead_tuples</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/*
         * Add per-table stats to the per-database entry, too.
         */</comment>
        <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_tuples_returned</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_returned</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_tuples_fetched</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_fetched</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_tuples_inserted</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_inserted</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_tuples_updated</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_updated</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_tuples_deleted</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_tuples_deleted</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_blocks_fetched</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_blocks_fetched</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_blocks_hit</name></name> <operator>+=</operator> <name><name>tabmsg</name><operator>-&gt;</operator><name>t_counts</name><operator>.</operator><name>t_blocks_hit</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_recv_tabpurge() -
 *
 *    Arrange for dead table removal.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_recv_tabpurge</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgTabpurge</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>dbentry</name> <operator>=</operator> <call><name>pgstat_get_db_entry</name><argument_list>(<argument><expr><name><name>msg</name><operator>-&gt;</operator><name>m_databaseid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * No need to purge if we don't even know the database.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dbentry</name> <operator>||</operator> <operator>!</operator><name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Process all table entries in the message.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_nentries</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* Remove from hashtable if present; we don't care if it's not. */</comment>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name></expr></argument>,
                           <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>msg</name><operator>-&gt;</operator><name>m_tableid</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>,
                           <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_recv_dropdb() -
 *
 *    Arrange for dead database removal
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_recv_dropdb</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgDropdb</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>dbid</name> <init>= <expr><name><name>msg</name><operator>-&gt;</operator><name>m_databaseid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Lookup the database in the hashtable.
     */</comment>
    <expr_stmt><expr><name>dbentry</name> <operator>=</operator> <call><name>pgstat_get_db_entry</name><argument_list>(<argument><expr><name>dbid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If found, remove it (along with the db statfile).
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>dbentry</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>statfile</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>get_dbstat_filename</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>dbid</name></expr></argument>, <argument><expr><name>statfile</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"removing stats file \"%s\""</literal></expr></argument>, <argument><expr><name>statfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>statfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>dbentry</name><operator>-&gt;</operator><name>functions</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>pgStatDBHash</name></expr></argument>,
                        <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>dbid</name></expr></argument>,
                        <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database hash table corrupted during cleanup --- abort"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_recv_resetcounter() -
 *
 *    Reset the statistics for the specified database.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_recv_resetcounter</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgResetcounter</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Lookup the database in the hashtable.  Nothing to do if not there.
     */</comment>
    <expr_stmt><expr><name>dbentry</name> <operator>=</operator> <call><name>pgstat_get_db_entry</name><argument_list>(<argument><expr><name><name>msg</name><operator>-&gt;</operator><name>m_databaseid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dbentry</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We simply throw away all the database's table entries by recreating a
     * new hash table for them.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>dbentry</name><operator>-&gt;</operator><name>functions</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>functions</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Reset database-level stats, too.  This creates empty hash tables for
     * tables and functions.
     */</comment>
    <expr_stmt><expr><call><name>reset_dbentry_counters</name><argument_list>(<argument><expr><name>dbentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_recv_resetshared() -
 *
 *    Reset some shared statistics of the cluster.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_recv_resetsharedcounter</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgResetsharedcounter</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>msg</name><operator>-&gt;</operator><name>m_resettarget</name></name> <operator>==</operator> <name>RESET_BGWRITER</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Reset the global background writer statistics for the cluster. */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>globalStats</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>globalStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>globalStats</name><operator>.</operator><name>stat_reset_timestamp</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>msg</name><operator>-&gt;</operator><name>m_resettarget</name></name> <operator>==</operator> <name>RESET_ARCHIVER</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Reset the archiver statistics for the cluster. */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>archiverStats</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>archiverStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>archiverStats</name><operator>.</operator><name>stat_reset_timestamp</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Presumably the sender of this message validated the target, don't
     * complain here if it's not valid
     */</comment>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_recv_resetsinglecounter() -
 *
 *    Reset a statistics for a single object
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_recv_resetsinglecounter</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgResetsinglecounter</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>dbentry</name> <operator>=</operator> <call><name>pgstat_get_db_entry</name><argument_list>(<argument><expr><name><name>msg</name><operator>-&gt;</operator><name>m_databaseid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dbentry</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Set the reset timestamp for the whole database */</comment>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>stat_reset_timestamp</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Remove object if it exists, ignore it if not */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>msg</name><operator>-&gt;</operator><name>m_resettype</name></name> <operator>==</operator> <name>RESET_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>msg</name><operator>-&gt;</operator><name>m_objectid</name></name><operator>)</operator></expr></argument>,
                           <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>msg</name><operator>-&gt;</operator><name>m_resettype</name></name> <operator>==</operator> <name>RESET_FUNCTION</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>msg</name><operator>-&gt;</operator><name>m_objectid</name></name><operator>)</operator></expr></argument>,
                           <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_recv_autovac() -
 *
 *    Process an autovacuum signalling message.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_recv_autovac</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgAutovacStart</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Store the last autovacuum time in the database's hashtable entry.
     */</comment>
    <expr_stmt><expr><name>dbentry</name> <operator>=</operator> <call><name>pgstat_get_db_entry</name><argument_list>(<argument><expr><name><name>msg</name><operator>-&gt;</operator><name>m_databaseid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>last_autovac_time</name></name> <operator>=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_start_time</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_recv_vacuum() -
 *
 *    Process a VACUUM message.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_recv_vacuum</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgVacuum</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_StatTabEntry</name> <modifier>*</modifier></type><name>tabentry</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Store the data in the table's hashtable entry.
     */</comment>
    <expr_stmt><expr><name>dbentry</name> <operator>=</operator> <call><name>pgstat_get_db_entry</name><argument_list>(<argument><expr><name><name>msg</name><operator>-&gt;</operator><name>m_databaseid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tabentry</name> <operator>=</operator> <call><name>pgstat_get_tab_entry</name><argument_list>(<argument><expr><name>dbentry</name></expr></argument>, <argument><expr><name><name>msg</name><operator>-&gt;</operator><name>m_tableoid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_live_tuples</name></name> <operator>=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_live_tuples</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_dead_tuples</name></name> <operator>=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_dead_tuples</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>msg</name><operator>-&gt;</operator><name>m_autovacuum</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>autovac_vacuum_timestamp</name></name> <operator>=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_vacuumtime</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>autovac_vacuum_count</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>vacuum_timestamp</name></name> <operator>=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_vacuumtime</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>vacuum_count</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_recv_analyze() -
 *
 *    Process an ANALYZE message.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_recv_analyze</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgAnalyze</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_StatTabEntry</name> <modifier>*</modifier></type><name>tabentry</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Store the data in the table's hashtable entry.
     */</comment>
    <expr_stmt><expr><name>dbentry</name> <operator>=</operator> <call><name>pgstat_get_db_entry</name><argument_list>(<argument><expr><name><name>msg</name><operator>-&gt;</operator><name>m_databaseid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tabentry</name> <operator>=</operator> <call><name>pgstat_get_tab_entry</name><argument_list>(<argument><expr><name>dbentry</name></expr></argument>, <argument><expr><name><name>msg</name><operator>-&gt;</operator><name>m_tableoid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_live_tuples</name></name> <operator>=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_live_tuples</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>n_dead_tuples</name></name> <operator>=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_dead_tuples</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * If commanded, reset changes_since_analyze to zero.  This forgets any
     * changes that were committed while the ANALYZE was in progress, but we
     * have no good way to estimate how many of those there were.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>msg</name><operator>-&gt;</operator><name>m_resetcounter</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>changes_since_analyze</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>msg</name><operator>-&gt;</operator><name>m_autovacuum</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>autovac_analyze_timestamp</name></name> <operator>=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_analyzetime</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>autovac_analyze_count</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>analyze_timestamp</name></name> <operator>=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_analyzetime</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tabentry</name><operator>-&gt;</operator><name>analyze_count</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * pgstat_recv_archiver() -
 *
 *    Process a ARCHIVER message.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_recv_archiver</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgArchiver</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>msg</name><operator>-&gt;</operator><name>m_failed</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Failed archival attempt */</comment>
        <expr_stmt><expr><operator>++</operator><name><name>archiverStats</name><operator>.</operator><name>failed_count</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>archiverStats</name><operator>.</operator><name>last_failed_wal</name></name></expr></argument>, <argument><expr><name><name>msg</name><operator>-&gt;</operator><name>m_xlog</name></name></expr></argument>,
               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>archiverStats</name><operator>.</operator><name>last_failed_wal</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>archiverStats</name><operator>.</operator><name>last_failed_timestamp</name></name> <operator>=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_timestamp</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Successful archival operation */</comment>
        <expr_stmt><expr><operator>++</operator><name><name>archiverStats</name><operator>.</operator><name>archived_count</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>archiverStats</name><operator>.</operator><name>last_archived_wal</name></name></expr></argument>, <argument><expr><name><name>msg</name><operator>-&gt;</operator><name>m_xlog</name></name></expr></argument>,
               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>archiverStats</name><operator>.</operator><name>last_archived_wal</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>archiverStats</name><operator>.</operator><name>last_archived_timestamp</name></name> <operator>=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_timestamp</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_recv_bgwriter() -
 *
 *    Process a BGWRITER message.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_recv_bgwriter</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgBgWriter</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>globalStats</name><operator>.</operator><name>timed_checkpoints</name></name> <operator>+=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_timed_checkpoints</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>globalStats</name><operator>.</operator><name>requested_checkpoints</name></name> <operator>+=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_requested_checkpoints</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>globalStats</name><operator>.</operator><name>checkpoint_write_time</name></name> <operator>+=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_checkpoint_write_time</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>globalStats</name><operator>.</operator><name>checkpoint_sync_time</name></name> <operator>+=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_checkpoint_sync_time</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>globalStats</name><operator>.</operator><name>buf_written_checkpoints</name></name> <operator>+=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_buf_written_checkpoints</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>globalStats</name><operator>.</operator><name>buf_written_clean</name></name> <operator>+=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_buf_written_clean</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>globalStats</name><operator>.</operator><name>maxwritten_clean</name></name> <operator>+=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_maxwritten_clean</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>globalStats</name><operator>.</operator><name>buf_written_backend</name></name> <operator>+=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_buf_written_backend</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>globalStats</name><operator>.</operator><name>buf_fsync_backend</name></name> <operator>+=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_buf_fsync_backend</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>globalStats</name><operator>.</operator><name>buf_alloc</name></name> <operator>+=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_buf_alloc</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_recv_recoveryconflict() -
 *
 *    Process a RECOVERYCONFLICT message.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_recv_recoveryconflict</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgRecoveryConflict</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>dbentry</name> <operator>=</operator> <call><name>pgstat_get_db_entry</name><argument_list>(<argument><expr><name><name>msg</name><operator>-&gt;</operator><name>m_databaseid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name><name>msg</name><operator>-&gt;</operator><name>m_reason</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_DATABASE</name></expr>:</case>

            <comment type="block">/*
             * Since we drop the information about the database as soon as it
             * replicates, there is no point in counting these conflicts.
             */</comment>
            <break>break;</break>
        <case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_TABLESPACE</name></expr>:</case>
            <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_conflict_tablespace</name></name><operator>++</operator></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_LOCK</name></expr>:</case>
            <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_conflict_lock</name></name><operator>++</operator></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_SNAPSHOT</name></expr>:</case>
            <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_conflict_snapshot</name></name><operator>++</operator></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_BUFFERPIN</name></expr>:</case>
            <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_conflict_bufferpin</name></name><operator>++</operator></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK</name></expr>:</case>
            <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_conflict_startup_deadlock</name></name><operator>++</operator></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_recv_deadlock() -
 *
 *    Process a DEADLOCK message.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_recv_deadlock</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgDeadlock</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>dbentry</name> <operator>=</operator> <call><name>pgstat_get_db_entry</name><argument_list>(<argument><expr><name><name>msg</name><operator>-&gt;</operator><name>m_databaseid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_deadlocks</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_recv_tempfile() -
 *
 *    Process a TEMPFILE message.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_recv_tempfile</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgTempFile</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>dbentry</name> <operator>=</operator> <call><name>pgstat_get_db_entry</name><argument_list>(<argument><expr><name><name>msg</name><operator>-&gt;</operator><name>m_databaseid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_temp_bytes</name></name> <operator>+=</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_filesize</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbentry</name><operator>-&gt;</operator><name>n_temp_files</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_recv_funcstat() -
 *
 *    Count what the backend has done.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_recv_funcstat</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgFuncstat</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_FunctionEntry</name> <modifier>*</modifier></type><name>funcmsg</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>msg</name><operator>-&gt;</operator><name>m_entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgStat_StatFuncEntry</name> <modifier>*</modifier></type><name>funcentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>dbentry</name> <operator>=</operator> <call><name>pgstat_get_db_entry</name><argument_list>(<argument><expr><name><name>msg</name><operator>-&gt;</operator><name>m_databaseid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Process all function entries in the message.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_nentries</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>funcmsg</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>funcentry</name> <operator>=</operator> <operator>(</operator><name>PgStat_StatFuncEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>,
                                                         <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>funcmsg</name><operator>-&gt;</operator><name>f_id</name></name><operator>)</operator></expr></argument>,
                                                         <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If it's a new function entry, initialize counters to the values
             * we just got.
             */</comment>
            <expr_stmt><expr><name><name>funcentry</name><operator>-&gt;</operator><name>f_numcalls</name></name> <operator>=</operator> <name><name>funcmsg</name><operator>-&gt;</operator><name>f_numcalls</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>funcentry</name><operator>-&gt;</operator><name>f_total_time</name></name> <operator>=</operator> <name><name>funcmsg</name><operator>-&gt;</operator><name>f_total_time</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>funcentry</name><operator>-&gt;</operator><name>f_self_time</name></name> <operator>=</operator> <name><name>funcmsg</name><operator>-&gt;</operator><name>f_self_time</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Otherwise add the values to the existing entry.
             */</comment>
            <expr_stmt><expr><name><name>funcentry</name><operator>-&gt;</operator><name>f_numcalls</name></name> <operator>+=</operator> <name><name>funcmsg</name><operator>-&gt;</operator><name>f_numcalls</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>funcentry</name><operator>-&gt;</operator><name>f_total_time</name></name> <operator>+=</operator> <name><name>funcmsg</name><operator>-&gt;</operator><name>f_total_time</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>funcentry</name><operator>-&gt;</operator><name>f_self_time</name></name> <operator>+=</operator> <name><name>funcmsg</name><operator>-&gt;</operator><name>f_self_time</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_recv_funcpurge() -
 *
 *    Arrange for dead function removal.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgstat_recv_funcpurge</name><parameter_list>(<parameter><decl><type><name>PgStat_MsgFuncpurge</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>dbentry</name> <operator>=</operator> <call><name>pgstat_get_db_entry</name><argument_list>(<argument><expr><name><name>msg</name><operator>-&gt;</operator><name>m_databaseid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * No need to purge if we don't even know the database.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dbentry</name> <operator>||</operator> <operator>!</operator><name><name>dbentry</name><operator>-&gt;</operator><name>functions</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Process all function entries in the message.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>msg</name><operator>-&gt;</operator><name>m_nentries</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* Remove from hashtable if present; we don't care if it's not. */</comment>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>,
                           <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>msg</name><operator>-&gt;</operator><name>m_functionid</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>,
                           <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_write_statsfile_needed() -
 *
 *    Do we need to write out any stats files?
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgstat_write_statsfile_needed</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>pending_write_requests</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Everything was written recently */</comment>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pgstat_db_requested() -
 *
 *    Checks whether stats for a particular DB need to be written to a file.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgstat_db_requested</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * If any requests are outstanding at all, we should write the stats for
     * shared catalogs (the "database" with OID 0).  This ensures that
     * backends will see up-to-date stats for shared catalogs, even though
     * they send inquiry messages mentioning only their own DB.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>databaseid</name> <operator>==</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator> <name>pending_write_requests</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Search to see if there's an open request to write this database. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>pending_write_requests</name></expr></argument>, <argument><expr><name>databaseid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
</unit>
