<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/postmaster/clustermon.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * clustermon.c
 *
 * Postgres-XL Cluster Monitor
 *
 * Portions Copyright (c) 2015, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2015, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/postmaster/clustermon.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_c.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_gxid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/clustermon.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/fork_process.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timeout.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>

<comment type="block">/* Flags to tell if we are in a clustermon process */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>am_clustermon</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Flags set by signal handlers */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_SIGHUP</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_SIGTERM</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Memory context for long-lived data */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>ClusterMonitorMemCxt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ClusterMonitorCtlData</name> <modifier>*</modifier></type><name>ClusterMonitorCtl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cm_sighup_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cm_sigterm_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ClusterMonitorSetReportedGlobalXmin</name><parameter_list>(<parameter><decl><type><name>GlobalTransactionId</name></type> <name>xmin</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ClusterMonitorSetReportingGlobalXmin</name><parameter_list>(<parameter><decl><type><name>GlobalTransactionId</name></type> <name>xmin</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* PID of clustser monitoring process */</comment>
<decl_stmt><decl><type><name>int</name></type>            <name>ClusterMonitorPid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_MONITOR_NAPTIME</name></cpp:macro>    <cpp:value>5</cpp:value></cpp:define>

<comment type="block">/*
 * Main loop for the cluster monitor process.
 */</comment>
<function><type><name>int</name></type>
<name>ClusterMonitorInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>sigjmp_buf</name></type>    <name>local_sigjmp_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_PGXCNodeType</name></type> <name>nodetype</name> <init>= <expr><ternary><condition><expr><name>IS_PGXC_DATANODE</name></expr> ?</condition><then>
                                    <expr><name>GTM_NODE_DATANODE</name></expr> </then><else>:
                                    <expr><name>GTM_NODE_COORDINATOR</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>GlobalTransactionId</name></type> <name>oldestXmin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GlobalTransactionId</name></type> <name>newOldestXmin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GlobalTransactionId</name></type> <name>lastGlobalXmin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GlobalTransactionId</name></type> <name>latestCompletedXid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>am_clustermon</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/* Identify myself via ps */</comment>
    <expr_stmt><expr><call><name>init_ps_display</name><argument_list>(<argument><expr><literal type="string">"cluster monitor process"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cluster monitor started"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>PostAuthDelay</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>PostAuthDelay</name> <operator>*</operator> <literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Set up signal handlers.  We operate on databases much like a regular
     * backend, so we use the same signal handling.  See equivalent code in
     * tcop/postgres.c.
     */</comment>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>cm_sighup_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>StatementCancelHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>cm_sigterm_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>quickdie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>InitializeTimeouts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* establishes SIGALRM handler */</comment>

    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>procsignal_sigusr1_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGFPE</name></expr></argument>, <argument><expr><name>FloatExceptionHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create a memory context that we will do all our work in.  We do this so
     * that we can reset the context during error recovery and thereby avoid
     * possible memory leaks.
     */</comment>
    <expr_stmt><expr><name>ClusterMonitorMemCxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                          <argument><expr><literal type="string">"Cluster Monitor"</literal></expr></argument>,
                                          <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
                                          <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
                                          <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ClusterMonitorMemCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>NormalProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>RegisterGTM</name><argument_list>(<argument><expr><name>nodetype</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>UnregisterGTM</name><argument_list>(<argument><expr><name>nodetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>RegisterGTM</name><argument_list>(<argument><expr><name>nodetype</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IO_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Can not register node on GTM"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If an exception is encountered, processing resumes here.
     *
     * This code is a stripped down version of PostgresMain error recovery.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>sigsetjmp</name><argument_list>(<argument><expr><name>local_sigjmp_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* since not using PG_TRY, must reset error stack by hand */</comment>
        <expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <comment type="block">/* Prevents interrupts while cleaning up */</comment>
        <expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Forget any pending QueryCancel or timeout request */</comment>
        <expr_stmt><expr><call><name>disable_all_timeouts</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>        <comment type="block">/* second to avoid race condition */</comment>

        <comment type="block">/* Report the error to the server log */</comment>
        <expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Now return to normal top-level context and clear ErrorContext for
         * next time.
         */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ClusterMonitorMemCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Flush any leaked data in the top-level context */</comment>
        <expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>ClusterMonitorMemCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Now we can allow interrupts again */</comment>
        <expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* if in shutdown mode, no need for anything further; just go away */</comment>
        <if_stmt><if>if <condition>(<expr><name>got_SIGTERM</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>shutdown</name>;</goto></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Sleep at least 1 second after any error.  We don't want to be
         * filling the error logs as fast as we can.
         */</comment>
        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We can now handle ereport(ERROR) */</comment>
    <expr_stmt><expr><name>PG_exception_stack</name> <operator>=</operator> <operator>&amp;</operator><name>local_sigjmp_buf</name></expr>;</expr_stmt>

    <comment type="block">/* must unblock signals before calling rebuild_database_list */</comment>
    <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Force statement_timeout and lock_timeout to zero to avoid letting these
     * settings prevent regular maintenance from being executed.
     */</comment>
    <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"statement_timeout"</literal></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>, <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"lock_timeout"</literal></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>, <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* loop until shutdown request */</comment>
    <while>while <condition>(<expr><operator>!</operator><name>got_SIGTERM</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>nap</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>rc</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Repeat at CLUSTER_MONITOR_NAPTIME seconds interval
         */</comment>
        <expr_stmt><expr><name><name>nap</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name>CLUSTER_MONITOR_NAPTIME</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nap</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/*
         * Wait until naptime expires or we get some type of signal (all the
         * signal handlers will wake us by calling SetLatch).
         */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
                       <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>,
                       <argument><expr><operator>(</operator><name><name>nap</name><operator>.</operator><name>tv_sec</name></name> <operator>*</operator> <literal type="number">1000L</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>nap</name><operator>.</operator><name>tv_usec</name></name> <operator>/</operator> <literal type="number">1000L</literal><operator>)</operator></expr></argument>,
                       <argument><expr><name>WAIT_EVENT_CLUSTER_MONITOR_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Process sinval catchup interrupts that happened while sleeping */</comment>
        <expr_stmt><expr><call><name>ProcessCatchupInterrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Emergency bailout if postmaster has died.  This is to avoid the
         * necessity for manual cleanup of all postmaster children.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* the normal shutdown case */</comment>
        <if_stmt><if>if <condition>(<expr><name>got_SIGTERM</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>got_SIGHUP</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>

        <comment type="block">/*
         * Compute RecentGlobalXmin, report it to the GTM and sleep for the set
         * interval. Keep doing this forever
         */</comment>
        <expr_stmt><expr><name>lastGlobalXmin</name> <operator>=</operator> <call><name>ClusterMonitorGetGlobalXmin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ClusterMonitorLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>oldestXmin</name> <operator>=</operator> <call><name>GetOldestXminInternal</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lastGlobalXmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ClusterMonitorSetReportingGlobalXmin</name><argument_list>(<argument><expr><name>oldestXmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ClusterMonitorLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>=</operator> <call><name>ReportGlobalXmin</name><argument_list>(<argument><expr><name>oldestXmin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newOldestXmin</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>latestCompletedXid</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Failed (status %d) to report RecentGlobalXmin "</literal>
                    <literal type="string">"- reported RecentGlobalXmin %d, received "</literal>
                    <literal type="string">"RecentGlobalXmin %d, "</literal> <literal type="string">"received latestCompletedXid %d"</literal></expr></argument>,
                    <argument><expr><name>status</name></expr></argument>, <argument><expr><name>oldestXmin</name></expr></argument>, <argument><expr><name>newOldestXmin</name></expr></argument>,
                    <argument><expr><name>latestCompletedXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>GTM_ERRCODE_TOO_OLD_XMIN</name> <operator>||</operator>
                <name>status</name> <operator>==</operator> <name>GTM_ERRCODE_NODE_EXCLUDED</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * If we haven't seen a new transaction for a very long time or
                 * were disconncted for a while or excluded from the xmin
                 * computation for any reason, our xmin calculation could be
                 * well in the past, especially because its capped by the
                 * latestCompletedXid which may not advance on an idle server.
                 * In such cases, use the value of latestCompletedXid as
                 * returned by GTM and then recompute local xmin.
                 *
                 * If the GTM's global xmin advances even further while we are
                 * ready with a new xmin, just repeat the entire exercise as
                 * long as GTM keeps returning us a more current value of
                 * latestCompletedXid and thus pushing forward our local xmin
                 * calculation
                 */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>GlobalTransactionIdIsValid</name><argument_list>(<argument><expr><name>latestCompletedXid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                        <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>oldestXmin</name></expr></argument>, <argument><expr><name>latestCompletedXid</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>SetLatestCompletedXid</name><argument_list>(<argument><expr><name>latestCompletedXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Successfully reported xmin to GTM - reported_xmin %d,"</literal>
                    <literal type="string">"received RecentGlobalXmin %d, "</literal>
                    <literal type="string">"received latestCompletedXid %d"</literal></expr></argument>, <argument><expr><name>oldestXmin</name></expr></argument>,
                    <argument><expr><name>newOldestXmin</name></expr></argument>, <argument><expr><name>latestCompletedXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>SetLatestCompletedXid</name><argument_list>(<argument><expr><name>latestCompletedXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ClusterMonitorSetReportedGlobalXmin</name><argument_list>(<argument><expr><name>oldestXmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>GlobalTransactionIdIsValid</name><argument_list>(<argument><expr><name>newOldestXmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ClusterMonitorSetGlobalXmin</name><argument_list>(<argument><expr><name>newOldestXmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>ClusterMonitorSetReportingGlobalXmin</name><argument_list>(<argument><expr><name>InvalidGlobalTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </block_content>}</block></while>

    <comment type="block">/* Normal exit from the cluster monitor is here */</comment>
<label><name>shutdown</name>:</label>
    <expr_stmt><expr><call><name>UnregisterGTM</name><argument_list>(<argument><expr><name>nodetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cluster monitor shutting down"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>                <comment type="block">/* done */</comment>
</block_content>}</block></function>

<comment type="block">/* SIGHUP: set flag to re-read config file at next convenient time */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cm_sighup_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGTERM: time to die */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cm_sigterm_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>got_SIGTERM</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IsClusterMonitor functions
 *        Return whether this is either a cluster monitor process or a worker
 *        process.
 */</comment>
<function><type><name>bool</name></type>
<name>IsClusterMonitorProcess</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>am_clustermon</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Report shared-memory space needed by ClusterMonitor */</comment>
<function><type><name>Size</name></type>
<name>ClusterMonitorShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><sizeof>sizeof <argument_list>(<argument><expr><name>ClusterMonitorCtlData</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ClusterMonitorShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>ClusterMonitorCtl</name> <operator>=</operator> <operator>(</operator><name>ClusterMonitorCtlData</name> <operator>*</operator><operator>)</operator>
        <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Cluster Monitor Ctl"</literal></expr></argument>, <argument><expr><call><name>ClusterMonitorShmemSize</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* First time through, so initialize */</comment>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>ClusterMonitorCtl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>ClusterMonitorShmemSize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ClusterMonitorCtl</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>GlobalTransactionId</name></type>
<name>ClusterMonitorGetGlobalXmin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GlobalTransactionId</name></type> <name>xmin</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ClusterMonitorCtl</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>xmin</name> <operator>=</operator> <name><name>ClusterMonitorCtl</name><operator>-&gt;</operator><name>gtm_recent_global_xmin</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ClusterMonitorCtl</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>xmin</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ClusterMonitorSetGlobalXmin</name><parameter_list>(<parameter><decl><type><name>GlobalTransactionId</name></type> <name>xmin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * First extend the commit logs. Even though we may not have actually
     * started any transactions in the new range, we must still extend the logs
     * so that later operations which rely on the RecentGlobalXmin to truncate
     * the logs work correctly.
     */</comment>
    <expr_stmt><expr><call><name>ExtendLogs</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Do a consistency check to ensure that we NEVER have running transactions
     * with xmin less than what the GTM has already computed. While during
     * normal execution, this should never happen, if we ever been excluded
     * from the xmin calculation by the GTM while we are still running old
     * transactions, PANIC is our best bet to avoid corruption
     */</comment> 
    <expr_stmt><expr><call><name>ProcArrayCheckXminConsistency</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ClusterMonitorCtl</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ClusterMonitorCtl</name><operator>-&gt;</operator><name>gtm_recent_global_xmin</name></name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ClusterMonitorCtl</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ClusterMonitorSetReportedGlobalXmin</name><parameter_list>(<parameter><decl><type><name>GlobalTransactionId</name></type> <name>xmin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"ClusterMonitorSetReportedGlobalXmin - old %d, new %d"</literal></expr></argument>,
            <argument><expr><name><name>ClusterMonitorCtl</name><operator>-&gt;</operator><name>reported_recent_global_xmin</name></name></expr></argument>,
            <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ClusterMonitorCtl</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ClusterMonitorCtl</name><operator>-&gt;</operator><name>reported_recent_global_xmin</name></name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ClusterMonitorCtl</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ClusterMonitorSetReportingGlobalXmin</name><parameter_list>(<parameter><decl><type><name>GlobalTransactionId</name></type> <name>xmin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"ClusterMonitorSetReportingGlobalXmin - old %d, new %d"</literal></expr></argument>,
            <argument><expr><name><name>ClusterMonitorCtl</name><operator>-&gt;</operator><name>reporting_recent_global_xmin</name></name></expr></argument>,
            <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ClusterMonitorCtl</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ClusterMonitorCtl</name><operator>-&gt;</operator><name>reporting_recent_global_xmin</name></name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ClusterMonitorCtl</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>GlobalTransactionId</name></type>
<name>ClusterMonitorGetReportingGlobalXmin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GlobalTransactionId</name></type> <name>reporting_xmin</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ClusterMonitorCtl</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>reporting_xmin</name> <operator>=</operator> <name><name>ClusterMonitorCtl</name><operator>-&gt;</operator><name>reporting_recent_global_xmin</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ClusterMonitorCtl</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>reporting_xmin</name></expr>;</return>
</block_content>}</block></function>
</unit>
