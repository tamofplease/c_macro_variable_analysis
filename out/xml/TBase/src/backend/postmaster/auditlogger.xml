<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/postmaster/auditlogger.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<comment type="block">/*-------------------------------------------------------------------------
 *
 * auditlogger.c
 *
 * Copyright (c) 2004-2017, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *      src/backend/postmaster/auditlogger.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgtime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/fork_process.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/auditlogger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/syslogger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/dsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pg_shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/squeue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/palloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/squeue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/shardmap.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive>        <cpp:macro><name>BYTES_PER_KB</name></cpp:macro>            <cpp:value>1024</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>        <cpp:macro><name>AUDIT_BITMAP_WORD</name></cpp:macro>        <cpp:value>(WORDNUM(MaxBackends) + 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>        <cpp:macro><name>AUDIT_BITMAP_SIZE</name></cpp:macro>        <cpp:value>(BITMAPSET_SIZE(AUDIT_BITMAP_WORD))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive>        <cpp:macro><name>AUDIT_SLEEP_MICROSEC</name></cpp:macro>    <cpp:value>100000L</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>        <cpp:macro><name>AUDIT_LATCH_MICROSEC</name></cpp:macro>    <cpp:value>10000000L</cpp:value></cpp:define>

<comment type="line">// #define     Use_Audit_Assert         0</comment>

<cpp:define>#<cpp:directive>define</cpp:directive>     <cpp:macro><name>AuditLog_001_For_Main</name></cpp:macro>                <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>        <cpp:macro><name>AuditLog_002_For_ShareMemoryQueue</name></cpp:macro>    <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>        <cpp:macro><name>AuditLog_003_For_LogFile</name></cpp:macro>            <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>        <cpp:macro><name>AuditLog_004_For_QueueReadWrite</name></cpp:macro>        <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>        <cpp:macro><name>AuditLog_005_For_ThreadWorker</name></cpp:macro>        <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>        <cpp:macro><name>AuditLog_006_For_Elog</name></cpp:macro>                <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>        <cpp:macro><name>AuditLog_007_For_ShardStatistics</name></cpp:macro>    <cpp:value>0</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Use_Audit_Assert</name></cpp:ifdef>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Trap</name></cpp:ifdef>
        <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Trap</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Trap</name><parameter_list>(<parameter><type><name>condition</name></type></parameter>, <parameter><type><name>errorType</name></type></parameter>)</parameter_list></cpp:macro> \
            <cpp:value>do { \
                if (condition) \
                    ExceptionalCondition(CppAsString(condition), (errorType), \
                                         __FILE__, __LINE__); \
            } while (0)</cpp:value></cpp:define>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Assert</name></cpp:ifdef>
        <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Assert</name></cpp:undef>
        <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Assert</name><parameter_list>(<parameter><type><name>condition</name></type></parameter>)</parameter_list></cpp:macro> \
            <cpp:value>Trap(!(condition), "FailedAssertion")</cpp:value></cpp:define>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><struct>struct <name>AuditLogQueue</name>
<block>{
	<decl_stmt><decl><type><name>pid_t</name></type>					<name>q_pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>						<name>q_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>slock_t</name></type>					<name>q_lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type>			<name>q_head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type>			<name>q_tail</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>					<name><name>q_area</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>AlogQueue</name>;</typedef>

<typedef>typedef <type><struct>struct <name>AuditLogQueueArray</name>
<block>{
    <decl_stmt><decl><type><name>int</name></type>                        <name>a_count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name>              <modifier>*</modifier></type>    <name>a_bitmap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AlogQueue</name>              <modifier>*</modifier></type>    <name><name>a_queue</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>AlogQueueArray</name>;</typedef>

<typedef>typedef <type><struct>struct <name>AuditLogQueueCache</name>
<block>{
	<comment type="block">/* local ThreadSema for CommonLogWriter, FGALogWriter and TraceLogWriter. */</comment>
	<decl_stmt><decl><type><name>ThreadSema</name></type>				<name>q_sema</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>						<name>q_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlogQueue</name>			  <modifier>*</modifier></type> <name><name>q_cache</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>AlogQueueCache</name>;</typedef>

<comment type="block">/*
 * shared memory queue array
 *
 * store common audit logs, each elem for a backend
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>AlogQueueArray</name>	  <modifier>*</modifier></type> <name>AuditCommonLogQueueArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* store fga audit logs, each elem for a backend */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>AlogQueueArray</name>	  <modifier>*</modifier></type> <name>AuditFGALogQueueArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* store trace audit logs, each elem for a backend */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>AlogQueueArray</name>	  <modifier>*</modifier></type> <name>AuditTraceLogQueueArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * shared memory bitmap to notify consumers to read audit log from AlogQueueArray above
 * each element for one consumer
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name>                  <modifier>*</modifier></type>    <name>AuditConsumerNotifyBitmap</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Postgres backend state, used in postgres backend only
 *
 * Postgres backend write common audit log into AuditCommonLogQueueArray-&gt;a_queue[idx]
 * and write fga audit log info AuditFGALogQueueArray-&gt;a_queue[idx]
 * and write trace audit log info AuditTraceLogQueueArray-&gt;a_queue[idx]
 *
 * Postgres backend acqurie free index by AuditLoggerQueueAcquire
 *
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>                    <name>AuditPostgresAlogQueueIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Consumer local queue cache for AuditLog_max_worker_number consumers, used in
 * audit logger process only.
 *
 * store common audit logs, each elem for a thread Consumer
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>AlogQueueCache</name>	  <modifier>*</modifier></type> <name>AuditCommonLogLocalCache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* store fga audit logs, each elem for a thread Consumer */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>AlogQueueCache</name>	  <modifier>*</modifier></type> <name>AuditFGALogLocalCache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* store trace audit logs, each elem for a thread Consumer */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>AlogQueueCache</name>	  <modifier>*</modifier></type> <name>AuditTraceLogLocalCache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * local ThreadSema array for AuditLog_max_worker_number consumers, used in audit
 * logger process only.
 *
 * each elem for a thread Consumer.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ThreadSema</name>		  <modifier>*</modifier></type> <name>AuditConsumerNotifySemas</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * GUC parameters.    can change at SIGHUP.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>							<name>AuditLog_RotationAge</name> <init>= <expr><name>HOURS_PER_DAY</name> <operator>*</operator> <name>MINS_PER_HOUR</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>							<name>AuditLog_RotationSize</name> <init>= <expr><literal type="number">10</literal> <operator>*</operator> <literal type="number">1024</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>					  <modifier>*</modifier></type> <name>AuditLog_filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name>				  <modifier>*</modifier></type> <name>TraceLog_filename</name> <init>= <expr><literal type="string">"maintain-%A-%H.log"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>						<name>AuditLog_truncate_on_rotation</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>							<name>AuditLog_file_mode</name> <init>= <expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* max number of worker thead to read audit log */</comment>
<decl_stmt><decl><type><name>int</name></type>							<name>AuditLog_max_worker_number</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>
<comment type="block">/* size of AlogQueue-&gt;q_area for each backend to store common audit log, KB */</comment>
<decl_stmt><decl><type><name>int</name></type>							<name>AuditLog_common_log_queue_size_kb</name> <init>= <expr><literal type="number">64</literal></expr></init></decl>;</decl_stmt>
<comment type="block">/* size of AlogQueue-&gt;q_area for each backend to store fga audit log, KB */</comment>
<decl_stmt><decl><type><name>int</name></type>							<name>AuditLog_fga_log_queue_size_kb</name> <init>= <expr><literal type="number">64</literal></expr></init></decl>;</decl_stmt>
<comment type="block">/* size of AlogQueue-&gt;q_area for each backend to store trace audit log, KB */</comment>
<decl_stmt><decl><type><name>int</name></type>							<name>Maintain_trace_log_queue_size_kb</name> <init>= <expr><literal type="number">64</literal></expr></init></decl>;</decl_stmt>
<comment type="block">/* size of common audit log local buffer for each worker */</comment>
<decl_stmt><decl><type><name>int</name></type>							<name>AuditLog_common_log_cache_size_kb</name> <init>= <expr><literal type="number">64</literal></expr></init></decl>;</decl_stmt>
<comment type="block">/* size of fga audit log local buffer for each worker */</comment>
<decl_stmt><decl><type><name>int</name></type>							<name>AuditLog_fga_log_cacae_size_kb</name> <init>= <expr><literal type="number">64</literal></expr></init></decl>;</decl_stmt>
<comment type="block">/* size of trace audit log local buffer for each worker */</comment>
<decl_stmt><decl><type><name>int</name></type>							<name>Maintain_trace_log_cache_size_kb</name> <init>= <expr><literal type="number">64</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Globally visible state
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>                        <name>am_auditlogger</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>                        <name>enable_auditlogger_warning</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Logger Private state
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>pg_time_t</name></type>			<name>audit_next_rotation_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>					<name>audit_rotation_disabled</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name>				  <modifier>*</modifier></type> <name>audit_comm_log_file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name>				  <modifier>*</modifier></type> <name>audit_fga_log_file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name>				  <modifier>*</modifier></type> <name>audit_trace_log_file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>slock_t</name></type>				<name>audit_comm_log_file_lock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>slock_t</name></type>				<name>audit_fga_log_file_lock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>slock_t</name></type>				<name>audit_trace_log_file_lock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NON_EXEC_STATIC</name> <name>pg_time_t</name></type>	<name>audit_first_log_file_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name>				  <modifier>*</modifier></type> <name>audit_last_comm_log_file_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name>				  <modifier>*</modifier></type> <name>audit_last_fga_log_file_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name>				  <modifier>*</modifier></type> <name>audit_last_trace_log_file_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name>				  <modifier>*</modifier></type> <name>audit_log_directory</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name>				  <modifier>*</modifier></type> <name>trace_log_directory</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name>				  <modifier>*</modifier></type> <name>audit_curr_log_dir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name>				  <modifier>*</modifier></type> <name>trace_curr_log_dir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name>				  <modifier>*</modifier></type> <name>audit_curr_log_file_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>					<name>audit_curr_log_rotation_age</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Flags set by interrupt handlers for later service in the main loop.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>audit_gotSIGHUP</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>            <comment type="block">/* pg_ctl reload */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>audit_gotSIGQUIT</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>            <comment type="block">/* pg_ctl stop -m immediate */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>audit_gotSIGTERM</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>            <comment type="block">/* pg_ctl stop -m smart */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>audit_gotSIGINT</name><init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>            <comment type="block">/* pg_ctl stop -m fast */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>audit_rotation_requested</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* SIGUSR1, killed by pg_rotate_audit_logfile() */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>audit_consume_requested</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* SIGUSR2, killed by alog() */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AuditLog_001_For_Main</name></cpp:ifdef>

<comment type="block">/* Local subroutines */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>pid_t</name></type>                <name>auditlogger_forkexec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><name>NON_EXEC_STATIC</name> <name>void</name></type>        <name>AuditLoggerMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list> pg_attribute_noreturn<parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>        <name>audit_logger_MainLoop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>        <name>audit_sigHupHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>        <name>audit_sigUsr1Handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>        <name>audit_sigUsr2Handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>        <name>audit_sigQuitHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>        <name>audit_sigTermHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>        <name>audit_sigIntHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>        <name>audit_process_sighup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>        <name>audit_process_sigusr1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>        <name>audit_process_sigusr2</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>        <name>audit_process_sigterm</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>        <name>audit_process_sigint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>        <name>audit_process_sigquit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>        <name>audit_process_rotate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>        <name>audit_process_wakeup</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>timeout</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>        <name>audit_assign_log_dir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AuditLog_002_For_ShareMemoryQueue</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> 	<name>audit_queue_elem_size</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>queue_size_kb</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Size</name></type>		<name>audit_shared_queue_array_bitmap_offset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type>		<name>audit_shared_queue_array_header_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type>		<name>audit_shared_common_queue_elem_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type>		<name>audit_shared_common_queue_array_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type>		<name>audit_shared_fga_queue_elem_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type>		<name>audit_shared_fga_queue_array_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type>		<name>audit_shared_trace_queue_elem_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type>		<name>audit_shared_trace_queue_array_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> 	<name>audit_shared_consumer_bitmap_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> 		<name>audit_shared_consumer_bitmap_get_value</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>consumer_id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> 	<name>audit_shared_consumer_bitmap_set_value</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>consumer_id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AuditLog_003_For_LogFile</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>int</name></type>		<name>audit_write_log_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>destination</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type>	<name>audit_open_log_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_errors</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>		<name>audit_open_fga_log_file</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>		<name>audit_open_trace_log_file</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>		<name>audit_rotate_log_file</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>time_based_rotation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size_rotation_for</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>	<name>audit_log_file_getname</name><parameter_list>(<parameter><decl><type><name>pg_time_t</name></type> <name>timestamp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>	<name>trace_log_file_getname</name><parameter_list>(<parameter><decl><type><name>pg_time_t</name></type> <name>timestamp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>		<name>audit_set_next_rotation_time</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AuditLog_004_For_QueueReadWrite</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type>     <name>alog_just_caller</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>var</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>     <name>alog_queue_init</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>queue_size_kb</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>     <name>alog_queue_offset_to</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>     <name>alog_queue_is_full</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>q_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_head</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_tail</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>     <name>alog_queue_is_empty</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>q_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_head</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_tail</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>     <name>alog_queue_is_empty2</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>     <name>alog_queue_is_enough</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>q_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_head</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_tail</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>         <name>alog_queue_used</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>q_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_head</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_tail</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>         <name>alog_queue_remain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>q_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_head</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_tail</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>     <name>alog_queue_push</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>buff</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>     <name>alog_queue_push2</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>buff1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len1</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>buff2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>     <name>alog_queue_pushn</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name><name>buff</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name><name>len</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>         <name>alog_queue_get_str_len</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>     <name>alog_queue_pop_to_queue</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>to</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>     <name>alog_queue_pop_to_file</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>destination</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AuditLog_005_For_ThreadWorker</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>AlogQueue</name> <modifier>*</modifier></type>		<name>alog_get_shared_common_queue</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AlogQueue</name> <modifier>*</modifier></type> 		<name>alog_get_shared_fga_queue</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AlogQueue</name> <modifier>*</modifier></type> 		<name>alog_get_shared_trace_queue</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AlogQueue</name> <modifier>*</modifier></type>		<name>alog_get_local_common_cache</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>consumer_id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AlogQueue</name> <modifier>*</modifier></type>		<name>alog_get_local_fga_cache</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>consumer_id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AlogQueue</name> <modifier>*</modifier></type>		<name>alog_get_local_trace_cache</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>consumer_id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AlogQueueCache</name> <modifier>*</modifier></type> <name>alog_make_local_cache</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cache_number</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>queue_size_kb</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ThreadSema</name> <modifier>*</modifier></type>        <name>alog_make_consumer_semas</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>consumer_count</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>             <name>alog_consumer_wakeup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>consumer_id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>             <name>alog_consumer_sleep</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>consumer_id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>            <name>alog_consumer_main</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>             <name>alog_writer_wakeup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>writer_destination</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>             <name>alog_writer_sleep</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>writer_destination</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>            <name>alog_writer_main</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>                <name>alog_start_writer</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>writer_destination</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>                <name>alog_start_consumer</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>consumer_id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>                <name>alog_start_all_worker</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AuditLog_006_For_Elog</name></cpp:ifdef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AuditLog_007_For_ShardStatistics</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>            <name>alog_shard_stat_main</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>                <name>alog_start_shard_stat_worker</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AuditLog_001_For_Main</name></cpp:ifdef>
<comment type="block">/*
 * Postmaster subroutine to start a auditlogger subprocess.
 */</comment>
<function><type><name>int</name></type>
<name>AuditLogger_Start</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>pid_t</name></type>        <name>auditLoggerPid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>AuditLog_max_worker_number</name> <operator>&gt;</operator> <name>MaxConnections</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"alog_max_worker_number can't be bigger than max_connections"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
    <switch>switch <condition>(<expr><operator>(</operator><name>auditLoggerPid</name> <operator>=</operator> <call><name>auditlogger_forkexec</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <switch>switch <condition>(<expr><operator>(</operator><name>auditLoggerPid</name> <operator>=</operator> <call><name>fork_process</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
        <case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fork audit logger: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
        <case>case <expr><literal type="number">0</literal></expr>:</case>
            <comment type="block">/* in postmaster child ... */</comment>
            <expr_stmt><expr><call><name>InitPostmasterChild</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Close the postmaster's sockets */</comment>
            <expr_stmt><expr><call><name>ClosePostmasterPorts</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Drop our connection to postmaster's shared memory, as well */</comment>
            <expr_stmt><expr><call><name>dsm_detach_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* do the work */</comment>
            <expr_stmt><expr><call><name>AuditLoggerMain</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <default>default:</default>
            <comment type="block">/* success, in postmaster */</comment>
            <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <name>auditLoggerPid</name></expr>;</return>
    </block_content>}</block></switch></block_content></block></switch>

    <comment type="block">/* we should never reach here */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>

<comment type="block">/*
 * auditlogger_forkexec() -
 *
 * Format up the arglist for, then fork and exec, a auditlogger process
 */</comment>
<function><type><specifier>static</specifier> <name>pid_t</name></type>
<name>auditlogger_forkexec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name><name>av</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ac</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"postgres"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"--forkalog"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>            <comment type="block">/* filled in by postmaster_forkexec */</comment>

    <expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ac</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>av</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>postmaster_forkexec</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>av</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* EXEC_BACKEND */</comment>

<comment type="block">/*
 * Main entry point for auditlogger process
 * argc/argv parameters are valid only in EXEC_BACKEND case.
 */</comment>
<function><type><name>NON_EXEC_STATIC</name> <name>void</name></type>
<name>AuditLoggerMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>am_auditlogger</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    
    <comment type="block">/*
     * Properly accept or ignore signals the postmaster might send us
     *
     * Note: we ignore all termination signals, and instead exit only when all
     * upstream processes are gone, to ensure we don't miss any dying gasps of
     * broken backends...
     */</comment>

    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>audit_sigHupHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* set flag to read config file */</comment>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>audit_sigIntHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>audit_sigTermHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>audit_sigQuitHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGALRM</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>audit_sigUsr1Handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* request log rotation */</comment>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>audit_sigUsr2Handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* request consumer to read audit log */</comment>

    <comment type="block">/*
     * Reset some signals that are accepted by postmaster but not here
     */</comment>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTTIN</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTTOU</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCONT</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGWINCH</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <call><name>ResourceOwnerCreate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"Audit Logger"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>CurrentMemoryContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                                 <argument><expr><literal type="string">"Audit Logger"</literal></expr></argument>,
                                                 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We allow SIGQUIT (quickdie) at all times */</comment>
    <expr_stmt><expr><call><name>sigdelset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>, <argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Unblock signals (they were blocked when the postmaster forked us)
     */</comment>
    <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Identify myself via ps
     */</comment>
    <expr_stmt><expr><call><name>init_ps_display</name><argument_list>(<argument><expr><literal type="string">"audit logger process"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>audit_logger_MainLoop</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * audit_logger_MainLoop
 *
 * Main loop for audit logger process
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>audit_logger_MainLoop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Create log directory if not present; ignore errors
	 */</comment>
	<expr_stmt><expr><call><name>audit_assign_log_dir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>mkdir</name><argument_list>(<argument><expr><name>audit_log_directory</name></expr></argument>, <argument><expr><name>S_IRWXU</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>mkdir</name><argument_list>(<argument><expr><name>trace_log_directory</name></expr></argument>, <argument><expr><name>S_IRWXU</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remember active logfile's name.	We recompute this from the reference
	 * time because passing down just the pg_time_t is a lot cheaper than
	 * passing a whole file path in the EXEC_BACKEND case.
	 */</comment>
	<expr_stmt><expr><name>audit_first_log_file_time</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>audit_last_comm_log_file_name</name> <operator>=</operator> <call><name>audit_log_file_getname</name><argument_list>(<argument><expr><name>audit_first_log_file_time</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>audit_comm_log_file</name> <operator>=</operator> <call><name>audit_open_log_file</name><argument_list>(<argument><expr><name>audit_last_comm_log_file_name</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>audit_open_fga_log_file</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>audit_open_trace_log_file</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* remember active logfile parameters */</comment>
	<expr_stmt><expr><name>audit_curr_log_dir</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>audit_log_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>trace_curr_log_dir</name><operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>trace_log_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>audit_curr_log_file_name</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>AuditLog_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>audit_curr_log_rotation_age</name> <operator>=</operator> <name>AuditLog_RotationAge</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name>audit_comm_log_file_lock</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name>audit_fga_log_file_lock</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name>audit_trace_log_file_lock</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set next planned rotation time */</comment>
	<expr_stmt><expr><call><name>audit_set_next_rotation_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* start consumer and writer thread*/</comment>
	<expr_stmt><expr><call><name>alog_start_all_worker</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* main worker loop */</comment>
	<while>while <condition>(<expr><call><name>PostmasterIsAlive</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>	<name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Clear any already-pending wakeups */</comment>
		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>audit_process_sighup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>audit_process_sigusr1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>audit_process_sigusr2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>audit_process_sigterm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>audit_process_sigint</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>audit_process_sigquit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>audit_process_rotate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>audit_process_wakeup</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
					   <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>,
					   <argument><expr><name>AUDIT_LATCH_MICROSEC</name></expr></argument>,
					   <argument><expr><name>WAIT_EVENT_AUDIT_LOGGER_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"audit logger exit after postmaster die"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_TIMEOUT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>audit_consume_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>audit_process_wakeup</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *        signal handler routines
 * --------------------------------
 */</comment>

<comment type="block">/* SIGHUP: set flag to reload config file */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>audit_sigHupHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>enable_auditlogger_warning</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"audit logger %d got SIGHUP in audit_sigHupHandler: %m"</literal></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* select pg_reload_conf(); */</comment>
    <expr_stmt><expr><name>audit_gotSIGHUP</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGUSR1: set flag to rotate logfile */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>audit_sigUsr1Handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>enable_auditlogger_warning</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"audit logger %d got SIGUSR1 in audit_sigUsr1Handler: %m"</literal></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* select pg_rotate_audit_logfile(); */</comment>
    <expr_stmt><expr><name>audit_rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGUSR2: set flag to wakeup consumers to read audit log */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>audit_sigUsr2Handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>enable_auditlogger_warning</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"audit logger %d got SIGUSR2 in audit_sigUsr2Handler: %m"</literal></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>audit_consume_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGQUIT signal handler for audit logger process */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>audit_sigQuitHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>enable_auditlogger_warning</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"audit logger %d got SIGQUIT in audit_sigQuitHandler: %m"</literal></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* pg_ctl stop -m immediate */</comment>
    <expr_stmt><expr><name>audit_gotSIGQUIT</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGTERM signal handler for audit logger process */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>audit_sigTermHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>enable_auditlogger_warning</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"audit logger %d got SIGTERM in audit_sigTermHandler: %m"</literal></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* pg_ctl stop */</comment>
    <expr_stmt><expr><name>audit_gotSIGTERM</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGINT signal handler for audit logger process */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>audit_sigIntHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>enable_auditlogger_warning</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"audit logger %d got SIGINT in audit_sigIntHandler: %m"</literal></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* pg_ctl stop -m fast */</comment>
    <expr_stmt><expr><name>audit_gotSIGINT</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>audit_process_sighup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * Process any requests or signals received recently.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>audit_gotSIGHUP</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>audit_gotSIGHUP</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>audit_assign_log_dir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Check if the log directory or filename pattern changed in
         * postgresql.conf. If so, force rotation to make sure we're
         * writing the logfiles in the right place.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>audit_log_directory</name></expr></argument>, <argument><expr><name>audit_curr_log_dir</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>audit_curr_log_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>audit_curr_log_dir</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>audit_log_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>audit_rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Also, create new directory if not present; ignore errors
             */</comment>
            <expr_stmt><expr><call><name>mkdir</name><argument_list>(<argument><expr><name>audit_log_directory</name></expr></argument>, <argument><expr><name>S_IRWXU</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>AuditLog_filename</name></expr></argument>, <argument><expr><name>audit_curr_log_file_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>audit_curr_log_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>audit_curr_log_file_name</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>AuditLog_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>audit_rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If rotation time parameter changed, reset next rotation time,
         * but don't immediately force a rotation.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>audit_curr_log_rotation_age</name> <operator>!=</operator> <name>AuditLog_RotationAge</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>audit_curr_log_rotation_age</name> <operator>=</operator> <name>AuditLog_RotationAge</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>audit_set_next_rotation_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If we had a rotation-disabling failure, re-enable rotation
         * attempts after SIGHUP, and force one immediately.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>audit_rotation_disabled</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>audit_rotation_disabled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>audit_rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>audit_process_sigusr1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* sigusr1 was processed by audit_process_rotate */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>audit_process_sigusr2</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* sigusr2 was processed by audit_process_wakeup */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>audit_process_sigterm</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>audit_gotSIGTERM</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>audit_gotSIGTERM</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>audit_process_sigint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>audit_gotSIGINT</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>audit_gotSIGINT</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>audit_process_sigquit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>audit_gotSIGQUIT</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>audit_gotSIGQUIT</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>audit_process_rotate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>time_based_rotation</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>size_rotation_for</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>now</name> <init>= <expr><name>MyStartTime</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>AuditLog_RotationAge</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>audit_rotation_disabled</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Do a logfile rotation if it's time */</comment>
		<expr_stmt><expr><name>now</name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>now</name> <operator>&gt;=</operator> <name>audit_next_rotation_time</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>audit_rotation_requested</name> <operator>=</operator> <name>time_based_rotation</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>audit_rotation_requested</name> <operator>&amp;&amp;</operator> <name>AuditLog_RotationSize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>audit_rotation_disabled</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Do a rotation if file is too big */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ftell</name><argument_list>(<argument><expr><name>audit_comm_log_file</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>AuditLog_RotationSize</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>audit_rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>size_rotation_for</name> <operator>|=</operator> <name>AUDIT_COMMON_LOG</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>audit_fga_log_file</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>ftell</name><argument_list>(<argument><expr><name>audit_fga_log_file</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>AuditLog_RotationSize</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>audit_rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>size_rotation_for</name> <operator>|=</operator> <name>AUDIT_FGA_LOG</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>audit_trace_log_file</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>ftell</name><argument_list>(<argument><expr><name>audit_trace_log_file</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>AuditLog_RotationSize</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>audit_rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>size_rotation_for</name> <operator>|=</operator> <name>MAINTAIN_TRACE_LOG</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>audit_rotation_requested</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Force rotation when both values are zero. It means the request
		 * was sent by pg_rotate_log_file.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>time_based_rotation</name> <operator>&amp;&amp;</operator> <name>size_rotation_for</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>size_rotation_for</name> <operator>=</operator> <name>AUDIT_COMMON_LOG</name> <operator>|</operator> <name>AUDIT_FGA_LOG</name> <operator>|</operator> <name>MAINTAIN_TRACE_LOG</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>audit_rotate_log_file</name><argument_list>(<argument><expr><name>time_based_rotation</name></expr></argument>, <argument><expr><name>size_rotation_for</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * if any audit log was coming,
 * wakeup a consumer to read
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>	<name>audit_process_wakeup</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>audit_consume_requested</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>timeout</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MaxBackends</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type> <name>sharedIdx</name> <init>= <expr><name>i</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type> <name>consumer_id</name> <init>= <expr><name>sharedIdx</name> <operator>%</operator> <name>AuditLog_max_worker_number</name></expr></init></decl>;</decl_stmt>

				<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>shared_common_queue</name> <init>= <expr><call><name>alog_get_shared_common_queue</name><argument_list>(<argument><expr><name>sharedIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>shared_fga_queue</name> <init>= <expr><call><name>alog_get_shared_fga_queue</name><argument_list>(<argument><expr><name>sharedIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>shared_trace_queue</name> <init>= <expr><call><name>alog_get_shared_trace_queue</name><argument_list>(<argument><expr><name>sharedIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<decl_stmt><decl><type><name>bool</name></type> <name>b_common_is_empty</name> <init>= <expr><call><name>alog_queue_is_empty2</name><argument_list>(<argument><expr><name>shared_common_queue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type> <name>b_fga_is_empty</name> <init>= <expr><call><name>alog_queue_is_empty2</name><argument_list>(<argument><expr><name>shared_fga_queue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type> <name>b_trace_is_empty</name> <init>= <expr><call><name>alog_queue_is_empty2</name><argument_list>(<argument><expr><name>shared_trace_queue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>b_common_is_empty</name> <operator>||</operator> <operator>!</operator><name>b_fga_is_empty</name> <operator>||</operator> <operator>!</operator><name>b_trace_is_empty</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>audit_shared_consumer_bitmap_get_value</name><argument_list>(<argument><expr><name>consumer_id</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>audit_shared_consumer_bitmap_set_value</name><argument_list>(<argument><expr><name>consumer_id</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>alog_consumer_wakeup</name><argument_list>(<argument><expr><name>consumer_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>AuditLog_max_worker_number</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type> <name>consumer_id</name> <init>= <expr><name>i</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type> <name>bitmap_value</name> <init>= <expr><call><name>audit_shared_consumer_bitmap_get_value</name><argument_list>(<argument><expr><name>consumer_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>bitmap_value</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>alog_consumer_wakeup</name><argument_list>(<argument><expr><name>consumer_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>audit_consume_requested</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AuditLog_002_For_ShareMemoryQueue</name></cpp:ifdef>

<comment type="block">/* --------------------------------
 *        shmem routines
 * --------------------------------
 */</comment>

<comment type="block">/* --------------------------------
 *
 * 01. AlogQueueArray  as follows
 *
 *                    __________________________________
 *                   |                                  |
 * | a_count | a_bitmap pointer | a_queue [MaxBackends] |   a_bitmap content    | AlogQueue0 | AlogQueue1 | AlogQueue2 | ... | AlogQueue[MaxBackends - 1] |
 * |                               |___|___|___|___|____________________________|            |            |            |     |                            |
 * |                                   |___|___|___|_________________________________________|            |            |     |                            |
 * |                                       |___|___|______________________________________________________|            |     |                            |
 * |                                           |___|___________________________________________________________________|     |                            |
 * |                                               |_________________________________________________________________________|                            |
 * |                                                                                                                                                      |
 * |         |                  |                       |                       |                                                                         |
 * |         |                  |                       |                       |&lt;-------- audit_shared_common_queue_elem_size() * MaxBackends ----------&gt;|
 * |&lt;- 4B -&gt; |&lt;------ 4B ------&gt;|&lt;- 4 * MaxBackends B -&gt;|&lt;- AUDIT_BITMAP_SIZE -&gt;|&lt;--------- audit_shared_fga_queue_elem_size() * MaxBackends ------------&gt;|
 * |         |                  |                       |                       |&lt;-------- audit_shared_trace_queue_elem_size() * MaxBackends -----------&gt;|
 * |                                                                            |                                                                         |
 * |                                                                            |                                                                         |
 * |&lt;------------------------- Shared Log Queue Array Header ------------------&gt;|&lt;------------------- AlogQueue Array [MaxBackends] ---------------------&gt;|
 *
 *
 * 02. AlogQueue as follows
 *
 *                                             | q_area -&gt; char[AuditLog_common_log_queue_size_kb * BYTES_PER_KB] |
 * | q_pid | q_size | q_lock | q_head | q_tail |                              OR                                  |
 *                                             | q_area -&gt;  char[AuditLog_fga_log_queue_size_kb * BYTES_PER_KB]   |
 *                                             |                              OR                                  |
 *                                             | q_area -&gt;  char[Maintain_trace_log_queue_size_kb * BYTES_PER_KB] |
 *
 * --------------------------------
 */</comment>

<function><type><specifier>static</specifier> <name>Size</name></type> <name>audit_shared_queue_array_bitmap_offset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type> <name>alogQueueArrayBitmapOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* store AlogQueueArray-&gt;a_count, a_bitmap */</comment>
	<expr_stmt><expr><name>alogQueueArrayBitmapOffset</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>alogQueueArrayBitmapOffset</name></expr></argument>,
										<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>AlogQueueArray</name></expr></argument>, <argument><expr><name>a_queue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* store AlogQueueArray-&gt;a_queue */</comment>
	<expr_stmt><expr><name>alogQueueArrayBitmapOffset</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>alogQueueArrayBitmapOffset</name></expr></argument>,
										  <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AlogQueue</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>MaxBackends</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>alogQueueArrayBitmapOffset</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type> <name>audit_shared_queue_array_header_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type> <name>alogQueueArrayHeaderSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* store AlogQueueArray-&gt;a_count, a_bitmap, a_queue */</comment>
	<expr_stmt><expr><name>alogQueueArrayHeaderSize</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>alogQueueArrayHeaderSize</name></expr></argument>,
										<argument><expr><call><name>audit_shared_queue_array_bitmap_offset</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* store content of AlogQueueArray-&gt;a_bitmap */</comment>
	<expr_stmt><expr><name>alogQueueArrayHeaderSize</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>alogQueueArrayHeaderSize</name></expr></argument>,
										<argument><expr><name>AUDIT_BITMAP_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>alogQueueArrayHeaderSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type> <name>audit_queue_elem_size</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>queue_size_kb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type> <name>elemQueueSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>elemQueueSize</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>AlogQueue</name></expr></argument>, <argument><expr><name>q_area</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>elemQueueSize</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>elemQueueSize</name></expr></argument>,
                             <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>queue_size_kb</name></expr></argument>, <argument><expr><name>BYTES_PER_KB</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>elemQueueSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type> <name>audit_shared_common_queue_elem_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type>        <name>alogCommonQueueItemSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* store content of common audit log */</comment>
    <expr_stmt><expr><name>alogCommonQueueItemSize</name> <operator>=</operator> <call><name>audit_queue_elem_size</name><argument_list>(<argument><expr><name>AuditLog_common_log_queue_size_kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>alogCommonQueueItemSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type> <name>audit_shared_common_queue_array_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type>        <name>alogCommonQueueSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* store content of common audit log */</comment>
    <expr_stmt><expr><name>alogCommonQueueSize</name> <operator>=</operator> <call><name>audit_shared_common_queue_elem_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>alogCommonQueueSize</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><name>alogCommonQueueSize</name></expr></argument>, <argument><expr><name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>alogCommonQueueSize</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>alogCommonQueueSize</name></expr></argument>,
                                   <argument><expr><call><name>audit_shared_queue_array_header_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>alogCommonQueueSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type> <name>audit_shared_fga_queue_elem_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type>        <name>alogFgaQueueItemSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* store content of fga audit log */</comment>
    <expr_stmt><expr><name>alogFgaQueueItemSize</name> <operator>=</operator> <call><name>audit_queue_elem_size</name><argument_list>(<argument><expr><name>AuditLog_fga_log_queue_size_kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>alogFgaQueueItemSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type> <name>audit_shared_fga_queue_array_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type>        <name>alogFgaQueueSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* store content of fga audit log */</comment>
    <expr_stmt><expr><name>alogFgaQueueSize</name> <operator>=</operator> <call><name>audit_shared_fga_queue_elem_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>alogFgaQueueSize</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><name>alogFgaQueueSize</name></expr></argument>, <argument><expr><name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>alogFgaQueueSize</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>alogFgaQueueSize</name></expr></argument>,
                                <argument><expr><call><name>audit_shared_queue_array_header_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>alogFgaQueueSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type> <name>audit_shared_trace_queue_elem_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>alogTraceQueueItemSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* store content of trace audit log */</comment>
	<expr_stmt><expr><name>alogTraceQueueItemSize</name> <operator>=</operator> <call><name>audit_queue_elem_size</name><argument_list>(<argument><expr><name>Maintain_trace_log_queue_size_kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>alogTraceQueueItemSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type> <name>audit_shared_trace_queue_array_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>alogTraceQueueSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* store content of trace audit log */</comment>
	<expr_stmt><expr><name>alogTraceQueueSize</name> <operator>=</operator> <call><name>audit_shared_trace_queue_elem_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>alogTraceQueueSize</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><name>alogTraceQueueSize</name></expr></argument>, <argument><expr><name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>alogTraceQueueSize</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>alogTraceQueueSize</name></expr></argument>,
								<argument><expr><call><name>audit_shared_queue_array_header_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>alogTraceQueueSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type> <name>audit_shared_consumer_bitmap_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type> <name>alogConsumerBitmapSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>alogConsumerBitmapSize</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><name>AuditLog_max_worker_number</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>alogConsumerBitmapSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>audit_shared_consumer_bitmap_get_value</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>consumer_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>consumer_id</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>consumer_id</name> <operator>&lt;</operator> <name>AuditLog_max_worker_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>AuditConsumerNotifyBitmap</name><index>[<expr><name>consumer_id</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>audit_shared_consumer_bitmap_set_value</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>consumer_id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>consumer_id</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>consumer_id</name> <operator>&lt;</operator> <name>AuditLog_max_worker_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>AuditConsumerNotifyBitmap</name><index>[<expr><name>consumer_id</name></expr>]</index></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Size</name></type> <name>AuditLoggerShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>alogCommonQueueSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>alogFgaQueueSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>alogTraceQueueSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>alogConsumerBmpSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* for common audit log */</comment>
    <expr_stmt><expr><name>alogCommonQueueSize</name> <operator>=</operator> <call><name>audit_shared_common_queue_array_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* for fga audit log*/</comment>
    <expr_stmt><expr><name>alogFgaQueueSize</name> <operator>=</operator> <call><name>audit_shared_fga_queue_array_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* for trace audit log */</comment>
	<expr_stmt><expr><name>alogTraceQueueSize</name> <operator>=</operator> <call><name>audit_shared_trace_queue_array_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* for consumer notify bitmap */</comment>
	<expr_stmt><expr><name>alogConsumerBmpSize</name> <operator>=</operator> <call><name>audit_shared_consumer_bitmap_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* for total size */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>alogCommonQueueSize</name></expr></argument>, <argument><expr><name>alogFgaQueueSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>alogTraceQueueSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>alogConsumerBmpSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>AuditLoggerShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>alogBmpOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>alogHeaderSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>alogItemSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>alogArraySize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>alogConsumerBmpSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>alogBmpOffset</name> <operator>=</operator> <call><name>audit_shared_queue_array_bitmap_offset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>alogHeaderSize</name> <operator>=</operator> <call><name>audit_shared_queue_array_header_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>alogItemSize</name> <operator>=</operator> <call><name>audit_shared_common_queue_elem_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>alogArraySize</name> <operator>=</operator> <call><name>audit_shared_common_queue_array_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>AuditCommonLogQueueArray</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Audit Common Log Queue"</literal></expr></argument>,
												<argument><expr><name>alogArraySize</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Mark it empty upon creation */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlogQueueArray</name> <modifier>*</modifier></type> <name>alogQueueArray</name> <init>= <expr><name>AuditCommonLogQueueArray</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>falogQueueArray</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type> <name>sharedMemSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>enable_auditlogger_warning</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sharedMemSize</name> <operator>+=</operator> <name>alogHeaderSize</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>alogQueueArray</name></expr></argument>, <argument><expr><literal type="char">'a'</literal></expr></argument>, <argument><expr><name>alogHeaderSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MaxBackends</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>alogQueueItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>alogQueueItem</name> <operator>=</operator> <operator>(</operator><name>AlogQueue</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>alogQueueArray</name><operator>)</operator> <operator>+</operator> <name>alogHeaderSize</name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>alogItemSize</name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>sharedMemSize</name> <operator>+=</operator> <call><name>audit_shared_common_queue_elem_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>alogQueueItem</name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>, <argument><expr><call><name>audit_shared_common_queue_elem_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><name>falogQueueArray</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><literal type="string">"AuditCommonLogQueueArray.txt"</literal></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_TRUNC</name> <operator>|</operator> <name>O_CREAT</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>falogQueueArray</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>write</name><argument_list>(<argument><expr><name>falogQueueArray</name></expr></argument>, <argument><expr><name>alogQueueArray</name></expr></argument>, <argument><expr><name>alogArraySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>write</name><argument_list>(<argument><expr><name>falogQueueArray</name></expr></argument>, <argument><expr><literal type="string">"\nNew Line\n"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"\nNew Line\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sharedMemSize</name> <operator>==</operator> <name>alogArraySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>alogQueueArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>alogArraySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>alogQueueArray</name><operator>-&gt;</operator><name>a_count</name></name> <operator>=</operator> <name>MaxBackends</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>alogQueueArray</name><operator>-&gt;</operator><name>a_bitmap</name></name> <operator>=</operator> <call><name>bms_make</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>alogQueueArray</name><operator>)</operator> <operator>+</operator> <name>alogBmpOffset</name></expr></argument>, 
											<argument><expr><name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MaxBackends</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>alogQueueItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>alogQueueItem</name> <operator>=</operator> <operator>(</operator><name>AlogQueue</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>alogQueueArray</name><operator>)</operator> <operator>+</operator> <name>alogHeaderSize</name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>alogItemSize</name><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>alog_queue_init</name><argument_list>(<argument><expr><name>alogQueueItem</name></expr></argument>, <argument><expr><name>AuditLog_common_log_queue_size_kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>alogQueueArray</name><operator>-&gt;</operator><name>a_queue</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>alogQueueItem</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>enable_auditlogger_warning</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>falogQueueArray</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>write</name><argument_list>(<argument><expr><name>falogQueueArray</name></expr></argument>, <argument><expr><name>alogQueueArray</name></expr></argument>, <argument><expr><name>alogArraySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>falogQueueArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>alogBmpOffset</name> <operator>=</operator> <call><name>audit_shared_queue_array_bitmap_offset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>alogHeaderSize</name> <operator>=</operator> <call><name>audit_shared_queue_array_header_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>alogItemSize</name> <operator>=</operator> <call><name>audit_shared_fga_queue_elem_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>alogArraySize</name> <operator>=</operator> <call><name>audit_shared_fga_queue_array_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>AuditFGALogQueueArray</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Audit FGA Log Queue"</literal></expr></argument>,
											<argument><expr><name>alogArraySize</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Mark it empty upon creation */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlogQueueArray</name> <modifier>*</modifier></type> <name>alogQueueArray</name> <init>= <expr><name>AuditFGALogQueueArray</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>falogQueueArray</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type> <name>sharedMemSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>enable_auditlogger_warning</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sharedMemSize</name> <operator>+=</operator> <name>alogHeaderSize</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>alogQueueArray</name></expr></argument>, <argument><expr><literal type="char">'c'</literal></expr></argument>, <argument><expr><name>alogHeaderSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MaxBackends</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>alogQueueItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>alogQueueItem</name> <operator>=</operator> <operator>(</operator><name>AlogQueue</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>alogQueueArray</name><operator>)</operator> <operator>+</operator> <name>alogHeaderSize</name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>alogItemSize</name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>sharedMemSize</name> <operator>+=</operator> <call><name>audit_shared_fga_queue_elem_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>alogQueueItem</name></expr></argument>, <argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><call><name>audit_shared_fga_queue_elem_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><name>falogQueueArray</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><literal type="string">"AuditFGALogQueueArray.txt"</literal></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_TRUNC</name> <operator>|</operator> <name>O_CREAT</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>falogQueueArray</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>write</name><argument_list>(<argument><expr><name>falogQueueArray</name></expr></argument>, <argument><expr><name>alogQueueArray</name></expr></argument>, <argument><expr><name>alogArraySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>write</name><argument_list>(<argument><expr><name>falogQueueArray</name></expr></argument>, <argument><expr><literal type="string">"\nNew Line\n"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"\nNew Line\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sharedMemSize</name> <operator>==</operator> <name>alogArraySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>alogQueueArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>alogArraySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>alogQueueArray</name><operator>-&gt;</operator><name>a_count</name></name> <operator>=</operator> <name>MaxBackends</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>alogQueueArray</name><operator>-&gt;</operator><name>a_bitmap</name></name> <operator>=</operator> <call><name>bms_make</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>alogQueueArray</name><operator>)</operator> <operator>+</operator> <name>alogBmpOffset</name></expr></argument>, 
										<argument><expr><name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MaxBackends</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>alogQueueItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>alogQueueItem</name> <operator>=</operator> <operator>(</operator><name>AlogQueue</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>alogQueueArray</name><operator>)</operator> <operator>+</operator> <name>alogHeaderSize</name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>alogItemSize</name><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>alog_queue_init</name><argument_list>(<argument><expr><name>alogQueueItem</name></expr></argument>, <argument><expr><name>AuditLog_fga_log_queue_size_kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>alogQueueArray</name><operator>-&gt;</operator><name>a_queue</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>alogQueueItem</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>enable_auditlogger_warning</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>falogQueueArray</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>write</name><argument_list>(<argument><expr><name>falogQueueArray</name></expr></argument>, <argument><expr><name>alogQueueArray</name></expr></argument>, <argument><expr><name>alogArraySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>falogQueueArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>alogBmpOffset</name> <operator>=</operator> <call><name>audit_shared_queue_array_bitmap_offset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>alogHeaderSize</name> <operator>=</operator> <call><name>audit_shared_queue_array_header_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>alogItemSize</name> <operator>=</operator> <call><name>audit_shared_trace_queue_elem_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>alogArraySize</name> <operator>=</operator> <call><name>audit_shared_trace_queue_array_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>AuditTraceLogQueueArray</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Audit Trace Log Queue"</literal></expr></argument>,
											<argument><expr><name>alogArraySize</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Mark it empty upon creation */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlogQueueArray</name> <modifier>*</modifier></type> <name>alogQueueArray</name> <init>= <expr><name>AuditTraceLogQueueArray</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>falogQueueArray</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type> <name>sharedMemSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>enable_auditlogger_warning</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sharedMemSize</name> <operator>+=</operator> <name>alogHeaderSize</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>alogQueueArray</name></expr></argument>, <argument><expr><literal type="char">'e'</literal></expr></argument>, <argument><expr><name>alogHeaderSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MaxBackends</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>alogQueueItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>alogQueueItem</name> <operator>=</operator> <operator>(</operator><name>AlogQueue</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>alogQueueArray</name><operator>)</operator> <operator>+</operator> <name>alogHeaderSize</name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>alogItemSize</name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>sharedMemSize</name> <operator>+=</operator> <call><name>audit_shared_trace_queue_elem_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>alogQueueItem</name></expr></argument>, <argument><expr><literal type="char">'f'</literal></expr></argument>, <argument><expr><call><name>audit_shared_trace_queue_elem_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><name>falogQueueArray</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><literal type="string">"AuditTraceLogQueueArray.txt"</literal></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_TRUNC</name> <operator>|</operator> <name>O_CREAT</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>falogQueueArray</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>write</name><argument_list>(<argument><expr><name>falogQueueArray</name></expr></argument>, <argument><expr><name>alogQueueArray</name></expr></argument>, <argument><expr><name>alogArraySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>write</name><argument_list>(<argument><expr><name>falogQueueArray</name></expr></argument>, <argument><expr><literal type="string">"\nNew Line\n"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"\nNew Line\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sharedMemSize</name> <operator>==</operator> <name>alogArraySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>alogQueueArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>alogArraySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>alogQueueArray</name><operator>-&gt;</operator><name>a_count</name></name> <operator>=</operator> <name>MaxBackends</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>alogQueueArray</name><operator>-&gt;</operator><name>a_bitmap</name></name> <operator>=</operator> <call><name>bms_make</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>alogQueueArray</name><operator>)</operator> <operator>+</operator> <name>alogBmpOffset</name></expr></argument>,
											<argument><expr><name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MaxBackends</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>alogQueueItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>alogQueueItem</name> <operator>=</operator> <operator>(</operator><name>AlogQueue</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>alogQueueArray</name><operator>)</operator> <operator>+</operator> <name>alogHeaderSize</name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>alogItemSize</name><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>alog_queue_init</name><argument_list>(<argument><expr><name>alogQueueItem</name></expr></argument>, <argument><expr><name>Maintain_trace_log_queue_size_kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>alogQueueArray</name><operator>-&gt;</operator><name>a_queue</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>alogQueueItem</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>enable_auditlogger_warning</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>falogQueueArray</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>write</name><argument_list>(<argument><expr><name>falogQueueArray</name></expr></argument>, <argument><expr><name>alogQueueArray</name></expr></argument>, <argument><expr><name>alogArraySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>falogQueueArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>alogConsumerBmpSize</name> <operator>=</operator> <call><name>audit_shared_consumer_bitmap_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>AuditConsumerNotifyBitmap</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Audit Consumer Bitmap"</literal></expr></argument>,
										  <argument><expr><name>alogConsumerBmpSize</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Mark it empty upon creation */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>AuditConsumerNotifyBitmap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>alogConsumerBmpSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AuditLog_003_For_LogFile</name></cpp:ifdef>

<comment type="block">/* --------------------------------
 *        logfile routines
 * --------------------------------
 */</comment>

<comment type="block">/*
 * Make audit_log_directory from Log_directory
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>audit_assign_log_dir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>audit_log_directory</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>audit_log_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>audit_log_directory</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>Log_directory</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>audit_log_directory</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"pg_log/audit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>StringInfoData</name></type> <name>alog_dir</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>alog_dir</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>alog_dir</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>alog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>alog_dir</name></expr></argument>, <argument><expr><literal type="string">"%s/audit"</literal></expr></argument>, <argument><expr><name>Log_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>audit_log_directory</name> <operator>=</operator> <name><name>alog_dir</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>trace_log_directory</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>trace_log_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>trace_log_directory</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>trace_log_directory</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"pg_log/maintain"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write text to the currently open logfile
 *
 * This is exported so that elog.c can call it when am_auditlogger is true.
 * This allows the auditlogger process to record elog messages of its own,
 * even though its stderr does not point at the syslog pipe.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>audit_write_log_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>destination</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>destination</name> <operator>==</operator> <name>AUDIT_FGA_LOG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>audit_fga_log_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>destination</name> <operator>==</operator> <name>MAINTAIN_TRACE_LOG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>audit_trace_log_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>destination</name> <operator>==</operator> <name>AUDIT_COMMON_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>audit_comm_log_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

    <comment type="block">/* can't use ereport here because of possible recursion */</comment>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>count</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"could not write to audit log file: %s\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>audit_open_fga_log_file</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>audit_log_file_getname</name><argument_list>(<argument><expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">".fga"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>audit_fga_log_file</name> <operator>=</operator> <call><name>audit_open_log_file</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>audit_last_fga_log_file_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* probably shouldn't happen */</comment>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>audit_last_fga_log_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>audit_last_fga_log_file_name</name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>audit_open_trace_log_file</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>trace_log_file_getname</name><argument_list>(<argument><expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">".trace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>audit_trace_log_file</name> <operator>=</operator> <call><name>audit_open_log_file</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>audit_last_trace_log_file_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* probably shouldn't happen */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>audit_last_trace_log_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>audit_last_trace_log_file_name</name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Open a new logfile with proper permissions and buffering options.
 *
 * If allow_errors is true, we just log any open failure and return NULL
 * (with errno still correct for the fopen failure).
 * Otherwise, errors are treated as fatal.
 */</comment>
<function><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type>
<name>audit_open_log_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_errors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fh</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mode_t</name></type>        <name>oumask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Note we do not let AuditLog_file_mode disable IWUSR, since we certainly want
     * to be able to write the files ourselves.
     */</comment>
    <expr_stmt><expr><name>oumask</name> <operator>=</operator> <call><name>umask</name><argument_list>(<argument><expr><operator>(</operator><name>mode_t</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>~</operator><operator>(</operator><name>AuditLog_file_mode</name> <operator>|</operator> <name>S_IWUSR</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>S_IRWXU</name> <operator>|</operator> <name>S_IRWXG</name> <operator>|</operator> <name>S_IRWXO</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>oumask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>fh</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>fh</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PG_IOLBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
        <comment type="block">/* use CRLF line endings on Windows */</comment>
        <expr_stmt><expr><call><name>_setmode</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>_O_TEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>allow_errors</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>FATAL</name></expr></else></ternary></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open audit log file \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>fh</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * perform logfile rotation
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>audit_rotate_log_file</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>time_based_rotation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size_rotation_for</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fgafilename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tracefilename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>fntime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fh</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>audit_rotation_requested</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * When doing a time-based rotation, invent the new logfile name based on
	 * the planned rotation time, not current time, to avoid "slippage" in the
	 * file name when we don't do the rotation immediately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>time_based_rotation</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fntime</name> <operator>=</operator> <name>audit_next_rotation_time</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>fntime</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>audit_log_file_getname</name><argument_list>(<argument><expr><name>fntime</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>audit_fga_log_file</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fgafilename</name> <operator>=</operator> <call><name>audit_log_file_getname</name><argument_list>(<argument><expr><name>fntime</name></expr></argument>, <argument><expr><literal type="string">".fga"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>audit_trace_log_file</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tracefilename</name> <operator>=</operator> <call><name>trace_log_file_getname</name><argument_list>(<argument><expr><name>fntime</name></expr></argument>, <argument><expr><literal type="string">".trace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Decide whether to overwrite or append.  We can overwrite if (a)
	 * AuditLog_truncate_on_rotation is set, (b) the rotation was triggered by
	 * elapsed time and not something else, and (c) the computed file name is
	 * different from what we were previously logging into.
	 *
	 * Note: audit_last_comm_log_file_name should never be NULL here, but if it is, append.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>time_based_rotation</name> <operator>||</operator> <operator>(</operator><name>size_rotation_for</name> <operator>&amp;</operator> <name>AUDIT_COMMON_LOG</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>AuditLog_truncate_on_rotation</name> <operator>&amp;&amp;</operator> <name>time_based_rotation</name> <operator>&amp;&amp;</operator>
			<name>audit_last_comm_log_file_name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>audit_last_comm_log_file_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>audit_open_log_file</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>audit_open_log_file</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fh</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * ENFILE/EMFILE are not too surprising on a busy system; just
			 * keep using the old file till we manage to get a new one.
			 * Otherwise, assume something's wrong with audit_log_directory and stop
			 * trying to create files.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENFILE</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EMFILE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"disabling automatic rotation audit log file (use SIGHUP to re-enable)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>audit_rotation_disabled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>filename</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>fgafilename</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fgafilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>tracefilename</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tracefilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name>audit_comm_log_file_lock</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>audit_comm_log_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>audit_comm_log_file</name> <operator>=</operator> <name>fh</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name>audit_comm_log_file_lock</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* instead of pfree'ing filename, remember it for next time */</comment>
		<if_stmt><if>if <condition>(<expr><name>audit_last_comm_log_file_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>audit_last_comm_log_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>audit_last_comm_log_file_name</name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>filename</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Same as above, but for fga audit log file. */</comment>
	<if_stmt><if>if <condition>(<expr><name>audit_fga_log_file</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>time_based_rotation</name> <operator>||</operator> <operator>(</operator><name>size_rotation_for</name> <operator>&amp;</operator> <name>AUDIT_FGA_LOG</name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>AuditLog_truncate_on_rotation</name> <operator>&amp;&amp;</operator> <name>time_based_rotation</name> <operator>&amp;&amp;</operator>
			<name>audit_last_fga_log_file_name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>fgafilename</name></expr></argument>, <argument><expr><name>audit_last_fga_log_file_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>audit_open_log_file</name><argument_list>(<argument><expr><name>fgafilename</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>audit_open_log_file</name><argument_list>(<argument><expr><name>fgafilename</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fh</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * ENFILE/EMFILE are not too surprising on a busy system; just
			 * keep using the old file till we manage to get a new one.
			 * Otherwise, assume something's wrong with audit_log_directory and stop
			 * trying to create files.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENFILE</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EMFILE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"disabling automatic rotation audit log file (use SIGHUP to re-enable)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>audit_rotation_disabled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>filename</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>fgafilename</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fgafilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>tracefilename</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tracefilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name>audit_fga_log_file_lock</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>audit_fga_log_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>audit_fga_log_file</name> <operator>=</operator> <name>fh</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name>audit_fga_log_file_lock</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* instead of pfree'ing filename, remember it for next time */</comment>
		<if_stmt><if>if <condition>(<expr><name>audit_last_fga_log_file_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>audit_last_fga_log_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>audit_last_fga_log_file_name</name> <operator>=</operator> <name>fgafilename</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>fgafilename</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Same as above, but for trace audit log file. */</comment>
	<if_stmt><if>if <condition>(<expr><name>audit_trace_log_file</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>time_based_rotation</name> <operator>||</operator> <operator>(</operator><name>size_rotation_for</name> <operator>&amp;</operator> <name>MAINTAIN_TRACE_LOG</name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Only append writeï¼do not consider overwrite for maintain trace log.
		 * That is different from audit common log and fga log.
		 *
		if (AuditLog_truncate_on_rotation &amp;&amp; time_based_rotation &amp;&amp;
			audit_last_trace_log_file_name != NULL &amp;&amp;
			strcmp(tracefilename, audit_last_trace_log_file_name) != 0)
			fh = audit_open_log_file(tracefilename, "w", true);
		else
		*/</comment>
		<block>{<block_content>
			<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>audit_open_log_file</name><argument_list>(<argument><expr><name>tracefilename</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fh</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * ENFILE/EMFILE are not too surprising on a busy system; just
			 * keep using the old file till we manage to get a new one.
			 * Otherwise, assume something's wrong with audit_log_directory and stop
			 * trying to create files.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENFILE</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EMFILE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"disabling automatic rotation audit log file (use SIGHUP to re-enable)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>audit_rotation_disabled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>filename</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>fgafilename</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fgafilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>tracefilename</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tracefilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name>audit_trace_log_file_lock</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>audit_trace_log_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>audit_trace_log_file</name> <operator>=</operator> <name>fh</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name>audit_trace_log_file_lock</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* instead of pfree'ing filename, remember it for next time */</comment>
		<if_stmt><if>if <condition>(<expr><name>audit_last_trace_log_file_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>audit_last_trace_log_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>audit_last_trace_log_file_name</name> <operator>=</operator> <name>tracefilename</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tracefilename</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>filename</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>fgafilename</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fgafilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>tracefilename</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tracefilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>audit_set_next_rotation_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * construct logfile name using timestamp information
 *
 * If suffix isn't NULL, append it to the name, replacing any ".log"
 * that may be in the pattern.
 *
 * Result is palloc'd.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>audit_log_file_getname</name><parameter_list>(<parameter><decl><type><name>pg_time_t</name></type> <name>timestamp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/"</literal></expr></argument>, <argument><expr><name>audit_log_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* treat AuditLog_filename as a strftime pattern */</comment>
    <expr_stmt><expr><call><name>pg_strftime</name><argument_list>(<argument><expr><name>filename</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>MAXPGPATH</name> <operator>-</operator> <name>len</name></expr></argument>, <argument><expr><name>AuditLog_filename</name></expr></argument>,
                <argument><expr><call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>timestamp</name></expr></argument>, <argument><expr><name>log_timezone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>suffix</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>filename</name> <operator>+</operator> <operator>(</operator><name>len</name> <operator>-</operator> <literal type="number">4</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="string">".log"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>filename</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>, <argument><expr><name>MAXPGPATH</name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>filename</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * construct logfile name using timestamp information.
 * acoording to audit_log_file_getname().
 *
 * If suffix isn't NULL, append it to the name, replacing any ".log"
 * that may be in the pattern.
 *
 * Result is palloc'd.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>trace_log_file_getname</name><parameter_list>(<parameter><decl><type><name>pg_time_t</name></type> <name>timestamp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/"</literal></expr></argument>, <argument><expr><name>trace_log_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* treat AuditLog_filename as a strftime pattern */</comment>
	<expr_stmt><expr><call><name>pg_strftime</name><argument_list>(<argument><expr><name>filename</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>MAXPGPATH</name> <operator>-</operator> <name>len</name></expr></argument>, <argument><expr><name>TraceLog_filename</name></expr></argument>,
				<argument><expr><call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>timestamp</name></expr></argument>, <argument><expr><name>log_timezone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>suffix</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>filename</name> <operator>+</operator> <operator>(</operator><name>len</name> <operator>-</operator> <literal type="number">4</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="string">".log"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>filename</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>, <argument><expr><name>MAXPGPATH</name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>filename</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Determine the next planned rotation time, and store in audit_next_rotation_time.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>audit_set_next_rotation_time</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>pg_time_t</name></type>    <name>now</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rotinterval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* nothing to do if time-based rotation is disabled */</comment>
    <if_stmt><if>if <condition>(<expr><name>AuditLog_RotationAge</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * The requirements here are to choose the next time &gt; now that is a
     * "multiple" of the log rotation interval.     "Multiple" can be interpreted
     * fairly loosely.    In this version we align to log_timezone rather than
     * GMT.
     */</comment>
    <expr_stmt><expr><name>rotinterval</name> <operator>=</operator> <name>AuditLog_RotationAge</name> <operator>*</operator> <name>SECS_PER_MINUTE</name></expr>;</expr_stmt>    <comment type="block">/* convert to seconds */</comment>
    <expr_stmt><expr><name>now</name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now</name></expr></argument>, <argument><expr><name>log_timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>now</name> <operator>+=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>now</name> <operator>-=</operator> <name>now</name> <operator>%</operator> <name>rotinterval</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>now</name> <operator>+=</operator> <name>rotinterval</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>now</name> <operator>-=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>audit_next_rotation_time</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AuditLog_004_For_QueueReadWrite</name></cpp:ifdef>

<comment type="block">/* --------------------------------
 *        AlogQueue routines
 * --------------------------------
 */</comment>

<comment type="block">/*
 * just for compile warning: unused-but-set-variable
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>alog_just_caller</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<comment type="block">/*
 * init queue area
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>alog_queue_init</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>queue_size_kb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>q_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>q_size</name></name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><name>queue_size_kb</name></expr></argument>, <argument><expr><name>BYTES_PER_KB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>queue</name><operator>-&gt;</operator><name>q_lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>q_head</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>q_tail</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>queue</name><operator>-&gt;</operator><name>q_area</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>queue</name><operator>-&gt;</operator><name>q_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get a write pointer in queue
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>alog_queue_offset_to</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>start</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>queue</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&lt;</operator> <name><name>queue</name><operator>-&gt;</operator><name>q_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>start</name> <operator>+=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>AlogQueue</name></expr></argument>, <argument><expr><name>q_area</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>start</name> <operator>+=</operator> <name>offset</name></expr>;</expr_stmt>

    <return>return <expr><name>start</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>alog_queue_is_full</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>q_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_head</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_tail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_size</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_head</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_head</name> <operator>&lt;</operator> <name>q_size</name> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>q_tail</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>q_size</name> <operator>==</operator> <name>q_head</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>alog_queue_is_empty</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>q_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_head</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_tail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_size</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_head</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_head</name> <operator>&lt;</operator> <name>q_size</name> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>q_tail</name> <operator>==</operator> <name>q_head</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>alog_queue_is_empty2</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_head</name> <init>= <expr><name><name>queue</name><operator>-&gt;</operator><name>q_head</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_tail</name> <init>= <expr><name><name>queue</name><operator>-&gt;</operator><name>q_tail</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_size</name> <init>= <expr><name><name>queue</name><operator>-&gt;</operator><name>q_size</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>alog_queue_is_empty</name><argument_list>(<argument><expr><name>q_size</name></expr></argument>, <argument><expr><name>q_head</name></expr></argument>, <argument><expr><name>q_tail</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * how many bytes already in used
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>alog_queue_used</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>q_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_head</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_tail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>used</name> <init>= <expr><operator>(</operator><name>q_tail</name> <operator>-</operator> <name>q_head</name> <operator>+</operator> <name>q_size</name><operator>)</operator> <operator>%</operator> <name>q_size</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_size</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_head</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_head</name> <operator>&lt;</operator> <name>q_size</name> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>used</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * how many bytes remain in Queue
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>alog_queue_remain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>q_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_head</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_tail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>remain</name> <init>= <expr><operator>(</operator><name>q_head</name> <operator>-</operator> <name>q_tail</name> <operator>+</operator> <name>q_size</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>q_size</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_size</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_head</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_head</name> <operator>&lt;</operator> <name>q_size</name> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>remain</name> <operator>==</operator> <operator>(</operator><name>q_size</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><operator>(</operator><name>q_tail</name> <operator>-</operator> <name>q_head</name> <operator>+</operator> <name>q_size</name><operator>)</operator> <operator>%</operator> <name>q_size</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>remain</name> <operator>==</operator> <operator>(</operator><name>q_size</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>q_size</name></expr></argument>, <argument><expr><name>q_head</name></expr></argument>, <argument><expr><name>q_tail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>remain</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * whether queue has enough space for N bytes ?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>alog_queue_is_enough</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>q_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_head</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q_tail</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>remain</name> <init>= <expr><call><name>alog_queue_remain</name><argument_list>(<argument><expr><name>q_size</name></expr></argument>, <argument><expr><name>q_head</name></expr></argument>, <argument><expr><name>q_tail</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_size</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_head</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>N</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_head</name> <operator>&lt;</operator> <name>q_size</name> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>remain</name> <operator>&gt;</operator> <name>N</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * write one buff to queue
 *
 * len = size(int) + strlen(str)
 *
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>alog_queue_push</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>buff</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name><name>buff_array</name> <index>[]</index></name> <init>= <expr><block>{ <expr><name>buff</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name><name>len_array</name> <index>[]</index></name> <init>= <expr><block>{ <expr><name>len</name></expr> }</block></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>alog_queue_pushn</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>buff_array</name></expr></argument>, <argument><expr><name>len_array</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len_array</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>len_array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * write buff1 and buff2 to queue
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>alog_queue_push2</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>buff1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len1</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>buff2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name><name>buff_array</name><index>[]</index></name> <init>= <expr><block>{<expr><name>buff1</name></expr>, <expr><name>buff2</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name><name>len_array</name><index>[]</index></name> <init>= <expr><block>{<expr><name>len1</name></expr>, <expr><name>len2</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>alog_queue_pushn</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>buff_array</name></expr></argument>, <argument><expr><name>len_array</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len_array</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>len_array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * write n buffs to queue
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>alog_queue_pushn</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name><name>buff</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name><name>len</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_head</name> <init>= <expr><name><name>queue</name><operator>-&gt;</operator><name>q_head</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_tail</name> <init>= <expr><name><name>queue</name><operator>-&gt;</operator><name>q_tail</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_size</name> <init>= <expr><name><name>queue</name><operator>-&gt;</operator><name>q_size</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>q_head_before</name> <init>= <expr><name>q_head</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>q_tail_before</name> <init>= <expr><name>q_tail</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>q_size_before</name> <init>= <expr><name>q_size</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>q_used_before</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>q_used_after</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>total_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>total_len</name> <operator>+=</operator> <name><name>len</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

    <expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>alog_just_caller</name><argument_list>(<argument><expr><operator>&amp;</operator><name>q_used_before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>alog_just_caller</name><argument_list>(<argument><expr><operator>&amp;</operator><name>q_used_after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_size</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_head</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_head</name> <operator>&lt;</operator> <name>q_size</name> <operator>&amp;&amp;</operator> <name>q_tail</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buff</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>total_len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>q_used_before</name> <operator>=</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>q_size_before</name></expr></argument>, <argument><expr><name>q_head_before</name></expr></argument>, <argument><expr><name>q_tail_before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>alog_queue_is_full</name><argument_list>(<argument><expr><name>q_size</name></expr></argument>, <argument><expr><name>q_head</name></expr></argument>, <argument><expr><name>q_tail</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>alog_queue_is_enough</name><argument_list>(<argument><expr><name>q_size</name></expr></argument>, <argument><expr><name>q_head</name></expr></argument>, <argument><expr><name>q_tail</name></expr></argument>, <argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>curr_buff</name> <init>= <expr><name><name>buff</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>curr_len</name> <init>= <expr><name><name>len</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* has enough space, write directly */</comment>
        <if_stmt><if>if <condition>(<expr><name>q_size</name> <operator>-</operator> <name>q_tail</name> <operator>&gt;=</operator> <name>curr_len</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>p_start</name> <init>= <expr><call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>q_tail</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>curr_buff</name></expr></argument>, <argument><expr><name>curr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* must write as two parts */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>first_len</name> <init>= <expr><name>q_size</name> <operator>-</operator> <name>q_tail</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>second_len</name> <init>= <expr><name>curr_len</name> <operator>-</operator> <name>first_len</name></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>first_buf</name> <init>= <expr><name>curr_buff</name> <operator>+</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>second_buf</name> <init>= <expr><name>curr_buff</name> <operator>+</operator> <name>first_len</name></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>p_start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>first_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>first_len</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>second_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>second_len</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* 01. write the first parts into the tail of queue-&gt;q_area */</comment>
            <expr_stmt><expr><name>p_start</name> <operator>=</operator> <call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>q_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>first_buf</name></expr></argument>, <argument><expr><name>first_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>q_tail</name> <operator>+</operator> <name>first_len</name><operator>)</operator> <operator>%</operator> <name>q_size</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* 02. write the remain parts into the head of queue-&gt;q_area */</comment>
            <expr_stmt><expr><name>p_start</name> <operator>=</operator> <call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>second_buf</name></expr></argument>, <argument><expr><name>second_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>q_tail</name> <operator>=</operator> <operator>(</operator><name>q_tail</name> <operator>+</operator> <name>curr_len</name><operator>)</operator> <operator>%</operator> <name>q_size</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>q_used_after</name> <operator>=</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>q_size</name></expr></argument>, <argument><expr><name>q_head</name></expr></argument>, <argument><expr><name>q_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q_used_before</name> <operator>+</operator> <name>total_len</name> <operator>==</operator> <name>q_used_after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>q_tail</name></name> <operator>=</operator> <name>q_tail</name></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * |&lt;- strlen value -&gt;|&lt;- string message content -&gt;|
 * |											   |
 * |											   |
 * |&lt;------------------ buff ---------------------&gt;|
 *
 * len = size(int) + strlen(str)
 *
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>alog_queue_get_str_len</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_size</name> <init>= <expr><name><name>queue</name><operator>-&gt;</operator><name>q_size</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="char">'\0'</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* read len directly */</comment>
    <if_stmt><if>if <condition>(<expr><name>q_size</name> <operator>-</operator> <name>offset</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>q_start</name> <init>= <expr><call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>q_start</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* must read as two parts */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>first_len</name> <init>= <expr><name>q_size</name> <operator>-</operator> <name>offset</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>second_len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>first_len</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>p_start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>first_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>first_len</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>second_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>second_len</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* 01. copy the first parts */</comment>
        <expr_stmt><expr><name>p_start</name> <operator>=</operator> <call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>first_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* 02. copy the remain parts */</comment>
        <expr_stmt><expr><name>p_start</name> <operator>=</operator> <call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <name>first_len</name></expr></argument>, <argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>second_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>len</name><operator>)</operator></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>len</name> <operator>&lt;</operator> <name>q_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * copy message from queue to another as much as possible
 *
 * |&lt;- strlen value -&gt;|&lt;- string message content -&gt;|
 * |											   |
 * |											   |
 * |&lt;------------------ buff ---------------------&gt;|
 *
 * len = size(int) + strlen(str)
 *
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>alog_queue_pop_to_queue</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>to</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_from_head</name> <init>= <expr><name><name>from</name><operator>-&gt;</operator><name>q_head</name></name></expr></init></decl>;</decl_stmt>      
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_from_tail</name> <init>= <expr><name><name>from</name><operator>-&gt;</operator><name>q_tail</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_from_size</name> <init>= <expr><name><name>from</name><operator>-&gt;</operator><name>q_size</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_to_head</name> <init>= <expr><name><name>to</name><operator>-&gt;</operator><name>q_head</name></name></expr></init></decl>;</decl_stmt>      
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_to_tail</name> <init>= <expr><name><name>to</name><operator>-&gt;</operator><name>q_tail</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_to_size</name> <init>= <expr><name><name>to</name><operator>-&gt;</operator><name>q_size</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>from_head</name> <init>= <expr><name>q_from_head</name></expr></init></decl>;</decl_stmt>      
    <decl_stmt><decl><type><name>int</name></type> <name>from_tail</name> <init>= <expr><name>q_from_tail</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>from_size</name> <init>= <expr><name>q_from_size</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>to_head</name> <init>= <expr><name>q_to_head</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>to_tail</name> <init>= <expr><name>q_to_tail</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>to_size</name> <init>= <expr><name>q_to_size</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>from_total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>from_used</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>from_copyed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>to_used</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>to_copyed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>alog_just_caller</name><argument_list>(<argument><expr><operator>&amp;</operator><name>from_total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>alog_just_caller</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>from_total</name> <operator>=</operator> <name>from_used</name> <operator>=</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>from_size</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>, <argument><expr><name>from_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>to_used</name> <operator>=</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>to_size</name></expr></argument>, <argument><expr><name>to_head</name></expr></argument>, <argument><expr><name>to_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>from_size</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>from_head</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>from_tail</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>from_head</name> <operator>&lt;</operator> <name>from_size</name> <operator>&amp;&amp;</operator> <name>from_tail</name> <operator>&lt;</operator> <name>from_size</name> <operator>&amp;&amp;</operator> <name>from_used</name> <operator>&lt;=</operator> <name>from_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>to_size</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>to_head</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>to_tail</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>to_head</name> <operator>&lt;</operator> <name>to_size</name> <operator>&amp;&amp;</operator> <name>to_tail</name> <operator>&lt;</operator> <name>to_size</name> <operator>&amp;&amp;</operator> <name>to_used</name> <operator>&lt;=</operator> <name>to_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* from is empty, ignore */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>alog_queue_is_empty</name><argument_list>(<argument><expr><name>from_size</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>, <argument><expr><name>from_tail</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* to is full, can not write */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>alog_queue_is_full</name><argument_list>(<argument><expr><name>to_size</name></expr></argument>, <argument><expr><name>to_head</name></expr></argument>, <argument><expr><name>to_tail</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* copy message into queue until to is full or from is empty */</comment>
    <do>do
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>string_len</name> <init>= <expr><call><name>alog_queue_get_str_len</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>copy_len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>string_len</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>string_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>string_len</name> <operator>&lt;</operator> <name>from_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>copy_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>copy_len</name> <operator>&lt;</operator> <name>from_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>alog_queue_is_enough</name><argument_list>(<argument><expr><name>to_size</name></expr></argument>, <argument><expr><name>to_head</name></expr></argument>, <argument><expr><name>to_tail</name></expr></argument>, <argument><expr><name>copy_len</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* just copy dierctly */</comment>
        <if_stmt><if>if <condition>(<expr><name>from_size</name> <operator>-</operator> <name>from_head</name> <operator>&gt;=</operator> <name>copy_len</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>p_start</name> <init>= <expr><call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>alog_queue_push</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>copy_len</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* must copy as two parts */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>first_len</name> <init>= <expr><name>from_size</name> <operator>-</operator> <name>from_head</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>second_len</name> <init>= <expr><name>copy_len</name> <operator>-</operator> <name>first_len</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>p_first_start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>p_second_start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>first_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>first_len</name> <operator>&lt;</operator> <name>from_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>second_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>second_len</name> <operator>&lt;</operator> <name>from_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>p_first_start</name> <operator>=</operator> <call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>p_second_start</name> <operator>=</operator> <call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* 01. copy the content parts into the tail of to-&gt;q_area */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>alog_queue_push2</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>p_first_start</name></expr></argument>, <argument><expr><name>first_len</name></expr></argument>, <argument><expr><name>p_second_start</name></expr></argument>, <argument><expr><name>second_len</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>from_head</name> <operator>=</operator> <operator>(</operator><name>from_head</name> <operator>+</operator> <name>copy_len</name><operator>)</operator> <operator>%</operator> <name>from_size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>to_tail</name> <operator>=</operator> <operator>(</operator><name>to_tail</name> <operator>+</operator> <name>copy_len</name><operator>)</operator> <operator>%</operator> <name>to_size</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>from_copyed</name> <operator>+=</operator> <name>copy_len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>to_copyed</name> <operator>+=</operator> <name>copy_len</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>from_copyed</name> <operator>&lt;=</operator> <name>from_total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>from_used</name> <operator>-</operator> <name>copy_len</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>to_used</name> <operator>+</operator> <name>copy_len</name> <operator>&lt;=</operator> <name>to_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>from_used</name> <operator>-</operator> <name>copy_len</name> <operator>==</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>from_size</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>, <argument><expr><name>from_tail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>to_used</name> <operator>+</operator> <name>copy_len</name> <operator>==</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>to_size</name></expr></argument>, <argument><expr><name>to_head</name></expr></argument>, <argument><expr><name>to_tail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>from_used</name> <operator>=</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>from_size</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>, <argument><expr><name>from_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>to_used</name> <operator>=</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>to_size</name></expr></argument>, <argument><expr><name>to_head</name></expr></argument>, <argument><expr><name>to_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><operator>!</operator><call><name>alog_queue_is_empty</name><argument_list>(<argument><expr><name>from_size</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>, <argument><expr><name>from_tail</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

    <expr_stmt><expr><name><name>from</name><operator>-&gt;</operator><name>q_head</name></name> <operator>=</operator> <name>from_head</name></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * copy message from queue to file as much as possible
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>alog_queue_pop_to_file</name><parameter_list>(<parameter><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>destination</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_from_head</name> <init>= <expr><name><name>from</name><operator>-&gt;</operator><name>q_head</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_from_tail</name> <init>= <expr><name><name>from</name><operator>-&gt;</operator><name>q_tail</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>q_from_size</name> <init>= <expr><name><name>from</name><operator>-&gt;</operator><name>q_size</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>from_head</name> <init>= <expr><name>q_from_head</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>from_tail</name> <init>= <expr><name>q_from_tail</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>from_size</name> <init>= <expr><name>q_from_size</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>from_total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>from_used</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>from_copyed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>volatile</specifier> <name>slock_t</name> <modifier>*</modifier></type> <name>file_lock</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>alog_just_caller</name><argument_list>(<argument><expr><operator>&amp;</operator><name>from_total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>from_total</name> <operator>=</operator> <name>from_used</name> <operator>=</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>from_size</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>, <argument><expr><name>from_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>from_size</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>from_head</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>from_tail</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>from_head</name> <operator>&lt;</operator> <name>from_size</name> <operator>&amp;&amp;</operator> <name>from_tail</name> <operator>&lt;</operator> <name>from_size</name> <operator>&amp;&amp;</operator> <name>from_used</name> <operator>&lt;=</operator> <name>from_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>destination</name> <operator>==</operator> <name>AUDIT_COMMON_LOG</name> <operator>||</operator>
		<name>destination</name> <operator>==</operator> <name>AUDIT_FGA_LOG</name> <operator>||</operator>
		<name>destination</name> <operator>==</operator> <name>MAINTAIN_TRACE_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>destination</name> <operator>==</operator> <name>AUDIT_COMMON_LOG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>file_lock</name> <operator>=</operator> <operator>&amp;</operator><name>audit_comm_log_file_lock</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>destination</name> <operator>==</operator> <name>AUDIT_FGA_LOG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>file_lock</name> <operator>=</operator> <operator>&amp;</operator><name>audit_fga_log_file_lock</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>destination</name> <operator>==</operator> <name>MAINTAIN_TRACE_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>file_lock</name> <operator>=</operator> <operator>&amp;</operator><name>audit_trace_log_file_lock</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* from is empty, ignore */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>alog_queue_is_empty</name><argument_list>(<argument><expr><name>from_size</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>, <argument><expr><name>from_tail</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* copy message into file until from is empty */</comment>
	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>string_len</name> <init>= <expr><call><name>alog_queue_get_str_len</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>copy_len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>string_len</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* just copy dierctly */</comment>
		<if_stmt><if>if <condition>(<expr><name>from_size</name> <operator>-</operator> <name>from_head</name> <operator>&gt;=</operator> <name>copy_len</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>p_start</name> <init>= <expr><call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>from_head</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* only copy message content, not write message len */</comment>
			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>file_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>audit_write_log_file</name><argument_list>(<argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>string_len</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>file_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>from_size</name> <operator>-</operator> <name>from_head</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* must copy as two parts */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>first_len</name> <init>= <expr><name>from_size</name> <operator>-</operator> <name>from_head</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>second_len</name> <init>= <expr><name>string_len</name> <operator>-</operator> <name>first_len</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>p_start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>first_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>first_len</name> <operator>&lt;</operator> <name>from_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>second_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>second_len</name> <operator>&lt;</operator> <name>from_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>file_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p_start</name> <operator>=</operator> <call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>from_head</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>audit_write_log_file</name><argument_list>(<argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>first_len</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>p_start</name> <operator>=</operator> <call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>audit_write_log_file</name><argument_list>(<argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>second_len</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>file_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* just copy content only */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>cpy_offset</name> <init>= <expr><operator>(</operator><name>from_head</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>%</operator> <name>from_size</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>p_start</name> <init>= <expr><call><name>alog_queue_offset_to</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>cpy_offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>from_size</name> <operator>-</operator> <name>from_head</name> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>file_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>audit_write_log_file</name><argument_list>(<argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>string_len</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>file_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>from_head</name> <operator>=</operator> <operator>(</operator><name>from_head</name> <operator>+</operator> <name>copy_len</name><operator>)</operator> <operator>%</operator> <name>from_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>from_copyed</name> <operator>+=</operator> <name>copy_len</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>from_copyed</name> <operator>&lt;=</operator> <name>from_total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>from_used</name> <operator>-</operator> <name>copy_len</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>from_used</name> <operator>-</operator> <name>copy_len</name> <operator>==</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>from_size</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>, <argument><expr><name>from_tail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>from_used</name> <operator>=</operator> <call><name>alog_queue_used</name><argument_list>(<argument><expr><name>from_size</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>, <argument><expr><name>from_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><operator>!</operator><call><name>alog_queue_is_empty</name><argument_list>(<argument><expr><name>from_size</name></expr></argument>, <argument><expr><name>from_head</name></expr></argument>, <argument><expr><name>from_tail</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

	<expr_stmt><expr><name><name>from</name><operator>-&gt;</operator><name>q_head</name></name> <operator>=</operator> <name>from_head</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AuditLog_005_For_ThreadWorker</name></cpp:ifdef>

<comment type="block">/*
 * find an unused shard entry id in AuditCommonLogQueueArray, AuditFGALogQueueArray
 * and AuditTraceLogQueueArray.
 *
 * called by postgres backend to init AuditPostgresAlogQueueIndex
 */</comment>
<function><type><name>int</name></type> <name>AuditLoggerQueueAcquire</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>alogIdx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>common_queue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>fga_queue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>trace_queue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsBackendPostgres</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only postgres backend can acqurie shared queue to write audit log"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>alogIdx</name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>alogIdx</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>alogIdx</name> <operator>&lt;</operator> <name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>common_queue</name> <operator>=</operator> <call><name>alog_get_shared_common_queue</name><argument_list>(<argument><expr><name>alogIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fga_queue</name> <operator>=</operator> <call><name>alog_get_shared_fga_queue</name><argument_list>(<argument><expr><name>alogIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>trace_queue</name> <operator>=</operator> <call><name>alog_get_shared_trace_queue</name><argument_list>(<argument><expr><name>alogIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>common_queue</name><operator>-&gt;</operator><name>q_pid</name></name> <operator>==</operator> <name><name>fga_queue</name><operator>-&gt;</operator><name>q_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>common_queue</name><operator>-&gt;</operator><name>q_pid</name></name> <operator>==</operator> <name><name>trace_queue</name><operator>-&gt;</operator><name>q_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>AuditPostgresAlogQueueIndex</name> <operator>=</operator> <name>alogIdx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>common_queue</name><operator>-&gt;</operator><name>q_pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fga_queue</name><operator>-&gt;</operator><name>q_pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trace_queue</name><operator>-&gt;</operator><name>q_pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>enable_auditlogger_warning</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>alogIdx</name> <operator>&lt;</operator> <name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"acquire alog queue index %d for backend %d "</literal></expr></argument>, <argument><expr><name>alogIdx</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>alogIdx</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlogQueue</name> <modifier>*</modifier></type> <name>alog_get_shared_common_queue</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>idx</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>idx</name> <operator>&lt;</operator> <name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>queue</name> <operator>=</operator> <name><name>AuditCommonLogQueueArray</name><operator>-&gt;</operator><name>a_queue</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>

    <return>return <expr><name>queue</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlogQueue</name> <modifier>*</modifier></type> <name>alog_get_shared_fga_queue</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>idx</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>idx</name> <operator>&lt;</operator> <name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>queue</name> <operator>=</operator> <name><name>AuditFGALogQueueArray</name><operator>-&gt;</operator><name>a_queue</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>

    <return>return <expr><name>queue</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlogQueue</name> <modifier>*</modifier></type> <name>alog_get_shared_trace_queue</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>idx</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>idx</name> <operator>&lt;</operator> <name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>queue</name> <operator>=</operator> <name><name>AuditTraceLogQueueArray</name><operator>-&gt;</operator><name>a_queue</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>

	<return>return <expr><name>queue</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlogQueue</name> <modifier>*</modifier></type> <name>alog_get_local_common_cache</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>consumer_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>consumer_id</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>consumer_id</name> <operator>&lt;</operator> <name>AuditLog_max_worker_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>queue</name> <operator>=</operator> <name><name>AuditCommonLogLocalCache</name><operator>-&gt;</operator><name>q_cache</name><index>[<expr><name>consumer_id</name></expr>]</index></name></expr>;</expr_stmt>

    <return>return <expr><name>queue</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlogQueue</name> <modifier>*</modifier></type> <name>alog_get_local_fga_cache</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>consumer_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>consumer_id</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>consumer_id</name> <operator>&lt;</operator> <name>AuditLog_max_worker_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>queue</name> <operator>=</operator> <name><name>AuditFGALogLocalCache</name><operator>-&gt;</operator><name>q_cache</name><index>[<expr><name>consumer_id</name></expr>]</index></name></expr>;</expr_stmt>

    <return>return <expr><name>queue</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlogQueue</name> <modifier>*</modifier></type> <name>alog_get_local_trace_cache</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>consumer_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>consumer_id</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>consumer_id</name> <operator>&lt;</operator> <name>AuditLog_max_worker_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>queue</name> <operator>=</operator> <name><name>AuditTraceLogLocalCache</name><operator>-&gt;</operator><name>q_cache</name><index>[<expr><name>consumer_id</name></expr>]</index></name></expr>;</expr_stmt>

	<return>return <expr><name>queue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * local cache for log Consumer
 *
 * AuditCommonLogLocalCache = alog_make_local_cache(AuditLog_max_worker_number,
 * 		AuditLog_common_log_cache_size_kb);
 *
 * AuditFGALogLocalCache = alog_make_local_cache(AuditLog_max_worker_number,
 * 		AuditLog_fga_log_cacae_size_kb);
 *
 * AuditTraceLogLocalCache = alog_make_local_cache(AuditLog_max_worker_number,
 * 		Maintain_trace_log_cache_size_kb);
 */</comment>
<function><type><specifier>static</specifier> <name>AlogQueueCache</name> <modifier>*</modifier></type> <name>alog_make_local_cache</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cache_number</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>queue_size_kb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type> <name>headerSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type> <name>cacheSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type> <name>queueSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>AlogQueueCache</name> <modifier>*</modifier></type> <name>cache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ThreadSema</name> <modifier>*</modifier></type> <name>sema</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>headerSize</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>AlogQueueCache</name></expr></argument>, <argument><expr><name>q_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>headerSize</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>headerSize</name></expr></argument>, <argument><expr><name>cache_number</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AlogQueue</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>queueSize</name> <operator>=</operator> <call><name>audit_queue_elem_size</name><argument_list>(<argument><expr><name>queue_size_kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>cacheSize</name> <operator>=</operator> <name>queueSize</name> <operator>*</operator> <name>cache_number</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cacheSize</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>cacheSize</name></expr></argument>, <argument><expr><name>headerSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>cache</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>cacheSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sema</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>cache</name><operator>-&gt;</operator><name>q_sema</name></name><operator>)</operator></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cache_number</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>queue</name> <operator>=</operator> <operator>(</operator><name>AlogQueue</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>cache</name><operator>)</operator> <operator>+</operator> <name>headerSize</name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>queueSize</name><operator>)</operator></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>alog_queue_init</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>queue_size_kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>q_cache</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>queue</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>ThreadSemaInit</name><argument_list>(<argument><expr><name>sema</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>q_count</name></name> <operator>=</operator> <name>cache_number</name></expr>;</expr_stmt>

    <return>return <expr><name>cache</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make local ThreadSema array for AuditLog_max_worker_number consumers
 */</comment>
<function><type><specifier>static</specifier> <name>ThreadSema</name> <modifier>*</modifier></type>    <name>alog_make_consumer_semas</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>consumer_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ThreadSema</name> <modifier>*</modifier></type> <name>sema_array</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>consumer_count</name> <operator>==</operator> <name>AuditLog_max_worker_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>sema_array</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>consumer_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ThreadSema</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>consumer_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ThreadSema</name> <modifier>*</modifier></type> <name>sema</name> <init>= <expr><operator>(</operator><operator>&amp;</operator><operator>(</operator><name><name>sema_array</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ThreadSemaInit</name><argument_list>(<argument><expr><name>sema</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>sema_array</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Wakeup a consumer thread to read audit log
 * from shared audit log queue
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>alog_consumer_wakeup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>consumer_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ThreadSema</name> <modifier>*</modifier></type> <name>sema</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>consumer_id</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>consumer_id</name> <operator>&lt;</operator> <name>AuditLog_max_worker_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>sema</name> <operator>=</operator> <operator>(</operator><operator>&amp;</operator><operator>(</operator><name><name>AuditConsumerNotifySemas</name><index>[<expr><name>consumer_id</name></expr>]</index></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ThreadSemaUp</name><argument_list>(<argument><expr><name>sema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Sleep if there is no log to read in
 * shared audit log queue
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>alog_consumer_sleep</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>consumer_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ThreadSema</name> <modifier>*</modifier></type> <name>sema</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>consumer_id</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>consumer_id</name> <operator>&lt;</operator> <name>AuditLog_max_worker_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>sema</name> <operator>=</operator> <operator>(</operator><operator>&amp;</operator><operator>(</operator><name><name>AuditConsumerNotifySemas</name><index>[<expr><name>consumer_id</name></expr>]</index></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ThreadSemaDown</name><argument_list>(<argument><expr><name>sema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AuditLog_max_worker_number consumers
 *
 * read log from part of AuditCommonLogQueueArray, AuditFGALogQueueArray and
 * AuditTraceLogQueueArray; write to one cache in AuditCommonLogLocalCache,
 * AuditFgaLogQueueCache and AuditTraceLogQueueCache.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type> <name>alog_consumer_main</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>consumer_id</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>local_common_cache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>local_fga_cache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>local_trace_cache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>consumer_id</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>consumer_id</name> <operator>&lt;</operator> <name>AuditLog_max_worker_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get local common queue cache entry from AuditCommonLogLocalCache */</comment>
	<expr_stmt><expr><name>local_common_cache</name> <operator>=</operator> <call><name>alog_get_local_common_cache</name><argument_list>(<argument><expr><name>consumer_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get local fga queue cache entry from AuditFgaLogQueueCache */</comment>
	<expr_stmt><expr><name>local_fga_cache</name> <operator>=</operator> <call><name>alog_get_local_fga_cache</name><argument_list>(<argument><expr><name>consumer_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get local trace queue cache entry from AuditTraceLogQueueCache */</comment>
	<expr_stmt><expr><name>local_trace_cache</name> <operator>=</operator> <call><name>alog_get_local_trace_cache</name><argument_list>(<argument><expr><name>consumer_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>shared_is_empty</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name>MaxBackends</name> <operator>/</operator> <name>AuditLog_max_worker_number</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>sharedIdx</name> <init>= <expr><name>consumer_id</name> <operator>+</operator>  <name>i</name> <operator>*</operator> <name>AuditLog_max_worker_number</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>shared_common_queue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>shared_fga_queue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>shared_trace_queue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>consumer_id</name> <operator>==</operator> <operator>(</operator><name>sharedIdx</name> <operator>%</operator> <name>AuditLog_max_worker_number</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>sharedIdx</name> <operator>&lt;</operator> <name>MaxBackends</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type> <name>local_is_empty</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* get shared common queue entry from AuditCommonLogQueueArray */</comment>
				<expr_stmt><expr><name>shared_common_queue</name> <operator>=</operator> <call><name>alog_get_shared_common_queue</name><argument_list>(<argument><expr><name>sharedIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* get shared fga queue entry from AuditFGALogQueueArray */</comment>
				<expr_stmt><expr><name>shared_fga_queue</name> <operator>=</operator> <call><name>alog_get_shared_fga_queue</name><argument_list>(<argument><expr><name>sharedIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* get shared trace queue entry from AuditTraceLogQueueArray */</comment>
				<expr_stmt><expr><name>shared_trace_queue</name> <operator>=</operator> <call><name>alog_get_shared_trace_queue</name><argument_list>(<argument><expr><name>sharedIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>local_is_empty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>alog_queue_is_empty2</name><argument_list>(<argument><expr><name>local_common_cache</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>local_is_empty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* read from shared queue, and write to local cache queue */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>alog_queue_pop_to_queue</name><argument_list>(<argument><expr><name>shared_common_queue</name></expr></argument>, <argument><expr><name>local_common_cache</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>local_is_empty</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>alog_writer_wakeup</name><argument_list>(<argument><expr><name>AUDIT_COMMON_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>local_is_empty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>alog_queue_is_empty2</name><argument_list>(<argument><expr><name>local_fga_cache</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>local_is_empty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>alog_queue_pop_to_queue</name><argument_list>(<argument><expr><name>shared_fga_queue</name></expr></argument>, <argument><expr><name>local_fga_cache</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>local_is_empty</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>alog_writer_wakeup</name><argument_list>(<argument><expr><name>AUDIT_FGA_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>local_is_empty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>alog_queue_is_empty2</name><argument_list>(<argument><expr><name>local_trace_cache</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>local_is_empty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>alog_queue_pop_to_queue</name><argument_list>(<argument><expr><name>shared_trace_queue</name></expr></argument>, <argument><expr><name>local_trace_cache</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>local_is_empty</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>alog_writer_wakeup</name><argument_list>(<argument><expr><name>MAINTAIN_TRACE_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>alog_queue_is_empty2</name><argument_list>(<argument><expr><name>shared_common_queue</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<operator>!</operator><call><name>alog_queue_is_empty2</name><argument_list>(<argument><expr><name>shared_fga_queue</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<operator>!</operator><call><name>alog_queue_is_empty2</name><argument_list>(<argument><expr><name>shared_trace_queue</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>shared_is_empty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>shared_is_empty</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * maybe shared input is empty,
			 * local output is full,
			 * so wait a moment and retry
			 */</comment>
			<expr_stmt><expr><call><name>audit_shared_consumer_bitmap_set_value</name><argument_list>(<argument><expr><name>consumer_id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>alog_consumer_sleep</name><argument_list>(<argument><expr><name>consumer_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Wakeup a writer thread to read audit log
 * from local audit log cache
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>alog_writer_wakeup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>writer_destination</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ThreadSema</name> <modifier>*</modifier></type> <name>sema</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AlogQueueCache</name> <modifier>*</modifier></type> <name>local_cache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>writer_destination</name> <operator>==</operator> <name>AUDIT_COMMON_LOG</name> <operator>||</operator>
		   <name>writer_destination</name> <operator>==</operator> <name>AUDIT_FGA_LOG</name> <operator>||</operator>
		   <name>writer_destination</name> <operator>==</operator> <name>MAINTAIN_TRACE_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>writer_destination</name> <operator>==</operator> <name>AUDIT_COMMON_LOG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>local_cache</name> <operator>=</operator> <name>AuditCommonLogLocalCache</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>writer_destination</name> <operator>==</operator> <name>AUDIT_FGA_LOG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>local_cache</name> <operator>=</operator> <name>AuditFGALogLocalCache</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>writer_destination</name> <operator>==</operator> <name>MAINTAIN_TRACE_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>local_cache</name> <operator>=</operator> <name>AuditTraceLogLocalCache</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>sema</name> <operator>=</operator> <operator>(</operator><operator>&amp;</operator><operator>(</operator><name><name>local_cache</name><operator>-&gt;</operator><name>q_sema</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ThreadSemaUp</name><argument_list>(<argument><expr><name>sema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Sleep if there is no log to read in
 * local audit log cache
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>alog_writer_sleep</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>writer_destination</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ThreadSema</name> <modifier>*</modifier></type> <name>sema</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AlogQueueCache</name> <modifier>*</modifier></type> <name>local_cache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>writer_destination</name> <operator>==</operator> <name>AUDIT_COMMON_LOG</name> <operator>||</operator>
		   <name>writer_destination</name> <operator>==</operator> <name>AUDIT_FGA_LOG</name> <operator>||</operator>
		   <name>writer_destination</name> <operator>==</operator> <name>MAINTAIN_TRACE_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>writer_destination</name> <operator>==</operator> <name>AUDIT_COMMON_LOG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>local_cache</name> <operator>=</operator> <name>AuditCommonLogLocalCache</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>writer_destination</name> <operator>==</operator> <name>AUDIT_FGA_LOG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>local_cache</name> <operator>=</operator> <name>AuditFGALogLocalCache</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>writer_destination</name> <operator>==</operator> <name>MAINTAIN_TRACE_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>local_cache</name> <operator>=</operator> <name>AuditTraceLogLocalCache</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>sema</name> <operator>=</operator> <operator>(</operator><operator>&amp;</operator><operator>(</operator><name><name>local_cache</name><operator>-&gt;</operator><name>q_sema</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ThreadSemaDown</name><argument_list>(<argument><expr><name>sema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * three writer, write log to logfile
 *
 * one for AuditCommonLogLocalCache
 * one for AuditFgaLogQueueCache
 * one for AuditTraceLogQueueCache
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type> <name>alog_writer_main</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>writer_destination</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlogQueueCache</name> <modifier>*</modifier></type> <name>local_cache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>writer_destination</name> <operator>==</operator> <name>AUDIT_COMMON_LOG</name> <operator>||</operator>
		<name>writer_destination</name> <operator>==</operator> <name>AUDIT_FGA_LOG</name> <operator>||</operator>
		<name>writer_destination</name> <operator>==</operator> <name>MAINTAIN_TRACE_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>writer_destination</name> <operator>==</operator> <name>AUDIT_COMMON_LOG</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* read from AuditCommonLogLocalCache, and write to common log file */</comment>
		<expr_stmt><expr><name>local_cache</name> <operator>=</operator> <name>AuditCommonLogLocalCache</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>writer_destination</name> <operator>==</operator> <name>AUDIT_FGA_LOG</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* read from AuditFgaLogQueueCache, and write to fga log file */</comment>
		<expr_stmt><expr><name>local_cache</name> <operator>=</operator> <name>AuditFGALogLocalCache</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* read from AuditTraceLogQueueCache, and write to trace log file */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>writer_destination</name> <operator>==</operator> <name>MAINTAIN_TRACE_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>local_cache</name> <operator>=</operator> <name>AuditTraceLogLocalCache</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>copy_nothing</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>AuditLog_max_worker_number</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>consumer_id</name> <init>= <expr><name>i</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>local_queue</name> <init>= <expr><name><name>local_cache</name><operator>-&gt;</operator><name>q_cache</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>alog_queue_pop_to_file</name><argument_list>(<argument><expr><name>local_queue</name></expr></argument>, <argument><expr><name>writer_destination</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>copy_nothing</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>alog_queue_is_empty2</name><argument_list>(<argument><expr><name>local_queue</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>alog_consumer_wakeup</name><argument_list>(<argument><expr><name>consumer_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>copy_nothing</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * maybe local input is empty,
			 * so wait a moment and retry
			 */</comment>
			<expr_stmt><expr><call><name>alog_writer_sleep</name><argument_list>(<argument><expr><name>writer_destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>alog_start_writer</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>writer_destination</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type> <name>des</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>writer_destination</name> <operator>==</operator> <name>AUDIT_COMMON_LOG</name> <operator>||</operator>
		<name>writer_destination</name> <operator>==</operator> <name>AUDIT_FGA_LOG</name> <operator>||</operator>
		<name>writer_destination</name> <operator>==</operator> <name>MAINTAIN_TRACE_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>des</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>des</name> <operator>=</operator> <name>writer_destination</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>CreateThread</name><argument_list>(<argument><expr><name>alog_writer_main</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>des</name></expr></argument>, <argument><expr><name>MT_THR_DETACHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* failed to create thread, exit */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not start audit log write worker"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>alog_start_consumer</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>consumer_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type> <name>id</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>consumer_id</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>consumer_id</name> <operator>&lt;</operator> <name>AuditLog_max_worker_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>id</name> <operator>=</operator> <name>consumer_id</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>CreateThread</name><argument_list>(<argument><expr><name>alog_consumer_main</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>id</name></expr></argument>, <argument><expr><name>MT_THR_DETACHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* failed to create thread, exit */</comment>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not start audit log consumer worker"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>alog_start_all_worker</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>AuditCommonLogLocalCache</name> <operator>=</operator> <call><name>alog_make_local_cache</name><argument_list>(<argument><expr><name>AuditLog_max_worker_number</name></expr></argument>,
											<argument><expr><name>AuditLog_common_log_cache_size_kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>AuditFGALogLocalCache</name> <operator>=</operator> <call><name>alog_make_local_cache</name><argument_list>(<argument><expr><name>AuditLog_max_worker_number</name></expr></argument>,
											<argument><expr><name>AuditLog_fga_log_cacae_size_kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>AuditTraceLogLocalCache</name> <operator>=</operator> <call><name>alog_make_local_cache</name><argument_list>(<argument><expr><name>AuditLog_max_worker_number</name></expr></argument>,
											<argument><expr><name>Maintain_trace_log_cache_size_kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>AuditConsumerNotifySemas</name> <operator>=</operator> <call><name>alog_make_consumer_semas</name><argument_list>(<argument><expr><name>AuditLog_max_worker_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 00, start writer worker, one for common log, one for fga log, one for trace log. */</comment>
	<expr_stmt><expr><call><name>alog_start_writer</name><argument_list>(<argument><expr><name>AUDIT_COMMON_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>alog_start_writer</name><argument_list>(<argument><expr><name>AUDIT_FGA_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>alog_start_writer</name><argument_list>(<argument><expr><name>MAINTAIN_TRACE_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* 001, start AuditLog_max_worker_number consumer worker */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>AuditLog_max_worker_number</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>alog_start_consumer</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* 002, start a worker for shard statistics */</comment>
    <expr_stmt><expr><call><name>alog_start_shard_stat_worker</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AuditLog_006_For_Elog</name></cpp:ifdef>

<function><type><name>void</name></type> <name>alog</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>destination</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlogQueue</name> <modifier>*</modifier></type> <name>queue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>consumer_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>AuditPostgresAlogQueueIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		   <name>AuditPostgresAlogQueueIndex</name> <operator>&lt;</operator> <name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>idx</name> <operator>=</operator> <name>AuditPostgresAlogQueueIndex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>consumer_id</name> <operator>=</operator> <operator>(</operator><name>idx</name> <operator>%</operator> <name>AuditLog_max_worker_number</name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name>destination</name> <operator>!=</operator> <name>AUDIT_COMMON_LOG</name> <operator>&amp;&amp;</operator>
		<name>destination</name> <operator>!=</operator> <name>AUDIT_FGA_LOG</name> <operator>&amp;&amp;</operator>
		<name>destination</name> <operator>!=</operator> <name>MAINTAIN_TRACE_LOG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only common/fga/trace audit log can be processed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsBackendPostgres</name> <operator>||</operator>
		<operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only postgres backend can write audit log"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>destination</name> <operator>==</operator> <name>AUDIT_COMMON_LOG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>queue</name> <operator>=</operator> <call><name>alog_get_shared_common_queue</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>destination</name> <operator>==</operator> <name>AUDIT_FGA_LOG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>queue</name> <operator>=</operator> <call><name>alog_get_shared_fga_queue</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>destination</name> <operator>==</operator> <name>MAINTAIN_TRACE_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>queue</name> <operator>=</operator> <call><name>alog_get_shared_trace_queue</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>queue</name><operator>-&gt;</operator><name>q_pid</name></name> <operator>==</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>len</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>va_list</name></type>		<name>args</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>needed</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>needed</name> <operator>=</operator> <call><name>appendStringInfoVA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>needed</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* push string len to header */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>len</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>len</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* push total buff into queue */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>false</name> <operator>==</operator> <call><name>alog_queue_push</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>audit_shared_consumer_bitmap_get_value</name><argument_list>(<argument><expr><name>consumer_id</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * set shared consumer bitmap value to 1 to
			 * notify consumer to read log
			 */</comment>
			<expr_stmt><expr><call><name>audit_shared_consumer_bitmap_set_value</name><argument_list>(<argument><expr><name>consumer_id</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Notify logger process that it's got something to do */</comment>
			<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_WAKEN_AUDIT_LOGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>AUDIT_SLEEP_MICROSEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>audit_shared_consumer_bitmap_get_value</name><argument_list>(<argument><expr><name>consumer_id</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * set shared consumer bitmap value to 1 to
		 * notify consumer to read audit log
		 */</comment>
		<expr_stmt><expr><call><name>audit_shared_consumer_bitmap_set_value</name><argument_list>(<argument><expr><name>consumer_id</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Notify audit logger process that it's got something to do */</comment>
		<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_WAKEN_AUDIT_LOGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AuditLog_007_For_ShardStatistics</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type> <name>alog_shard_stat_main</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>FlushShardStatistic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>long</name></type> <name>shard_stat_interval</name> <init>= <expr><name>g_ShardInfoFlushInterval</name> <operator>*</operator> <literal type="number">1000000L</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>FlushShardStatistic</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>shard_stat_interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>    <name>alog_start_shard_stat_worker</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>CreateThread</name><argument_list>(<argument><expr><name>alog_shard_stat_main</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>, <argument><expr><name>MT_THR_DETACHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* failed to create thread, exit */</comment>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not start shard stat worker"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
