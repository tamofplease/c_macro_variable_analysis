<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/tsearch/spell.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * spell.c
 *        Normalizing word with ISpell
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 *
 * Ispell dictionary
 * -----------------
 *
 * Rules of dictionaries are defined in two files with .affix and .dict
 * extensions. They are used by spell checker programs Ispell and Hunspell.
 *
 * An .affix file declares morphological rules to get a basic form of words.
 * The format of an .affix file has different structure for Ispell and Hunspell
 * dictionaries. The Hunspell format is more complicated. But when an .affix
 * file is imported and compiled, it is stored in the same structure AffixNode.
 *
 * A .dict file stores a list of basic forms of words with references to
 * affix rules. The format of a .dict file has the same structure for Ispell
 * and Hunspell dictionaries.
 *
 * Compilation of a dictionary
 * ---------------------------
 *
 * A compiled dictionary is stored in the IspellDict structure. Compilation of
 * a dictionary is divided into the several steps:
 *    - NIImportDictionary() - stores each word of a .dict file in the
 *      temporary Spell field.
 *    - NIImportAffixes() - stores affix rules of an .affix file in the
 *      Affix field (not temporary) if an .affix file has the Ispell format.
 *      -&gt; NIImportOOAffixes() - stores affix rules if an .affix file has the
 *         Hunspell format. The AffixData field is initialized if AF parameter
 *         is defined.
 *    - NISortDictionary() - builds a prefix tree (Trie) from the words list
 *      and stores it in the Dictionary field. The words list is got from the
 *      Spell field. The AffixData field is initialized if AF parameter is not
 *      defined.
 *    - NISortAffixes():
 *      - builds a list of compound affixes from the affix list and stores it
 *        in the CompoundAffix.
 *      - builds prefix trees (Trie) from the affix list for prefixes and suffixes
 *        and stores them in Suffix and Prefix fields.
 *      The affix list is got from the Affix field.
 *
 * Memory management
 * -----------------
 *
 * The IspellDict structure has the Spell field which is used only in compile
 * time. The Spell field stores a words list. It can take a lot of memory.
 * Therefore when a dictionary is compiled this field is cleared by
 * NIFinishBuild().
 *
 * All resources which should cleared by NIFinishBuild() is initialized using
 * tmpalloc() and tmpalloc0().
 *
 * IDENTIFICATION
 *      src/backend/tsearch/spell.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tsearch/dicts/spell.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tsearch/ts_locale.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Initialization requires a lot of memory that's not needed
 * after the initialization is done.  During initialization,
 * CurrentMemoryContext is the long-lived memory context associated
 * with the dictionary cache entry.  We keep the short-lived stuff
 * in the Conf-&gt;buildCxt context.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tmpalloc</name><parameter_list>(<parameter><type><name>sz</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>MemoryContextAlloc(Conf-&gt;buildCxt, (sz))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tmpalloc0</name><parameter_list>(<parameter><type><name>sz</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>MemoryContextAllocZero(Conf-&gt;buildCxt, (sz))</cpp:value></cpp:define>

<comment type="block">/*
 * Prepare for constructing an ISpell dictionary.
 *
 * The IspellDict struct is assumed to be zeroed when allocated.
 */</comment>
<function><type><name>void</name></type>
<name>NIStartBuild</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * The temp context is a child of CurTransactionContext, so that it will
     * go away automatically on error.
     */</comment>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>buildCxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurTransactionContext</name></expr></argument>,
                                           <argument><expr><literal type="string">"Ispell dictionary init context"</literal></expr></argument>,
                                           <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Clean up when dictionary construction is complete.
 */</comment>
<function><type><name>void</name></type>
<name>NIFinishBuild</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Release no-longer-needed temp memory */</comment>
    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>buildCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Just for cleanliness, zero the now-dangling pointers */</comment>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>buildCxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>firstfree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>CompoundAffixFlags</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * "Compact" palloc: allocate without extra palloc overhead.
 *
 * Since we have no need to free the ispell data items individually, there's
 * not much value in the per-chunk overhead normally consumed by palloc.
 * Getting rid of it is helpful since ispell can allocate a lot of small nodes.
 *
 * We currently pre-zero all data allocated this way, even though some of it
 * doesn't need that.  The cpalloc and cpalloc0 macros are just documentation
 * to indicate which allocations actually require zeroing.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPACT_ALLOC_CHUNK</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>    <comment type="block">/* amount to get from palloc at once */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPACT_MAX_REQ</name></cpp:macro>        <cpp:value>1024</cpp:value></cpp:define>    <comment type="block">/* must be &lt; COMPACT_ALLOC_CHUNK */</comment>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>compact_palloc0</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <comment type="block">/* Should only be called during init */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>buildCxt</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* No point in this for large chunks */</comment>
    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <name>COMPACT_MAX_REQ</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Keep everything maxaligned */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Need more space? */</comment>
    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <name><name>Conf</name><operator>-&gt;</operator><name>avail</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>firstfree</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>COMPACT_ALLOC_CHUNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>avail</name></name> <operator>=</operator> <name>COMPACT_ALLOC_CHUNK</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>Conf</name><operator>-&gt;</operator><name>firstfree</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>firstfree</name></name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>avail</name></name> <operator>-=</operator> <name>size</name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cpalloc</name><parameter_list>(<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>compact_palloc0(Conf, size)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cpalloc0</name><parameter_list>(<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>compact_palloc0(Conf, size)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>cpstrdup</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>cpalloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Apply lowerstr(), producing a temporary result (in the buildCxt).
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>lowerstr_ctx</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>saveCtx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>dst</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>saveCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>buildCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>lowerstr</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>saveCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>dst</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_NORM</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXNORMLEN</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRNCMP</name><parameter_list>(<parameter><type><name>s</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>strncmp( (s), (p), strlen(p) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETWCHAR</name><parameter_list>(<parameter><type><name>W</name></type></parameter>,<parameter><type><name>L</name></type></parameter>,<parameter><type><name>N</name></type></parameter>,<parameter><type><name>T</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( ((const uint8*)(W))[ ((T)==FF_PREFIX) ? (N) : ( (L) - 1 - (N) ) ] )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETCHAR</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>N</name></type></parameter>,<parameter><type><name>T</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>GETWCHAR( (A)-&gt;repl, (A)-&gt;replen, N, T )</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>VoidString</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmpspell</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><operator>(</operator><name>SPELL</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>s1</name><operator>)</operator><operator>-&gt;</operator><name>word</name></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><operator>(</operator><name>SPELL</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>s2</name><operator>)</operator><operator>-&gt;</operator><name>word</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmpspellaffix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><operator>(</operator><name>SPELL</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>s1</name><operator>)</operator><operator>-&gt;</operator><name><name>p</name><operator>.</operator><name>flag</name></name></expr></argument>,
                   <argument><expr><operator>(</operator><operator>*</operator><operator>(</operator><name>SPELL</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>s2</name><operator>)</operator><operator>-&gt;</operator><name><name>p</name><operator>.</operator><name>flag</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmpcmdflag</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>f1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>f2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CompoundAffixFlag</name> <modifier>*</modifier></type><name>fv1</name> <init>= <expr><operator>(</operator><name>CompoundAffixFlag</name> <operator>*</operator><operator>)</operator> <name>f1</name></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>fv2</name> <init>= <expr><operator>(</operator><name>CompoundAffixFlag</name> <operator>*</operator><operator>)</operator> <name>f2</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fv1</name><operator>-&gt;</operator><name>flagMode</name></name> <operator>==</operator> <name><name>fv2</name><operator>-&gt;</operator><name>flagMode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>fv1</name><operator>-&gt;</operator><name>flagMode</name></name> <operator>==</operator> <name>FM_NUM</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>fv1</name><operator>-&gt;</operator><name>flag</name><operator>.</operator><name>i</name></name> <operator>==</operator> <name><name>fv2</name><operator>-&gt;</operator><name>flag</name><operator>.</operator><name>i</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

        <return>return <expr><ternary><condition><expr><operator>(</operator><name><name>fv1</name><operator>-&gt;</operator><name>flag</name><operator>.</operator><name>i</name></name> <operator>&gt;</operator> <name><name>fv2</name><operator>-&gt;</operator><name>flag</name><operator>.</operator><name>i</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fv1</name><operator>-&gt;</operator><name>flag</name><operator>.</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>fv2</name><operator>-&gt;</operator><name>flag</name><operator>.</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>findchar</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <while>while <condition>(<expr><operator>*</operator><name>str</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>str</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>findchar2</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <while>while <condition>(<expr><operator>*</operator><name>str</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>c1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>t_iseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>str</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* backward string compare for suffix tree operations */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>strbcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>l1</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>s1</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>l2</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>s2</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>l1</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>l2</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>s1</name><index>[<expr><name>l1</name></expr>]</index></name> <operator>&lt;</operator> <name><name>s2</name><index>[<expr><name>l2</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s1</name><index>[<expr><name>l1</name></expr>]</index></name> <operator>&gt;</operator> <name><name>s2</name><index>[<expr><name>l2</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>l1</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>l2</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><name>l1</name> <operator>&lt;</operator> <name>l2</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>l1</name> <operator>&gt;</operator> <name>l2</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>strbncmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>l1</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>s1</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>l2</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>s2</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>l</name> <init>= <expr><name>count</name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>l1</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>l2</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>l</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>s1</name><index>[<expr><name>l1</name></expr>]</index></name> <operator>&lt;</operator> <name><name>s2</name><index>[<expr><name>l2</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>s1</name><index>[<expr><name>l1</name></expr>]</index></name> <operator>&gt;</operator> <name><name>s2</name><index>[<expr><name>l2</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>l1</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>l2</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>l</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>l1</name> <operator>&lt;</operator> <name>l2</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>l1</name> <operator>&gt;</operator> <name>l2</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compares affixes.
 * First compares the type of an affix. Prefixes should go before affixes.
 * If types are equal then compares replaceable string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmpaffix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>AFFIX</name> <modifier>*</modifier></type><name>a1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>AFFIX</name> <operator>*</operator><operator>)</operator> <name>s1</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>AFFIX</name> <modifier>*</modifier></type><name>a2</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>AFFIX</name> <operator>*</operator><operator>)</operator> <name>s2</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>a1</name><operator>-&gt;</operator><name>type</name></name> <operator>&lt;</operator> <name><name>a2</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>a1</name><operator>-&gt;</operator><name>type</name></name> <operator>&gt;</operator> <name><name>a2</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>a1</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>FF_PREFIX</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>a1</name><operator>-&gt;</operator><name>repl</name></name></expr></argument>, <argument><expr><name><name>a2</name><operator>-&gt;</operator><name>repl</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>strbcmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>a1</name><operator>-&gt;</operator><name>repl</name></name></expr></argument>,
                       <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>a2</name><operator>-&gt;</operator><name>repl</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Gets an affix flag from the set of affix flags (sflagset).
 *
 * Several flags can be stored in a single string. Flags can be represented by:
 * - 1 character (FM_CHAR). A character may be Unicode.
 * - 2 characters (FM_LONG). A character may be Unicode.
 * - numbers from 1 to 65000 (FM_NUM).
 *
 * Depending on the flagMode an affix string can have the following format:
 * - FM_CHAR: ABCD
 *     Here we have 4 flags: A, B, C and D
 * - FM_LONG: ABCDE*
 *     Here we have 3 flags: AB, CD and E*
 * - FM_NUM: 200,205,50
 *     Here we have 3 flags: 200, 205 and 50
 *
 * Conf: current dictionary.
 * sflagset: the set of affix flags. Returns a reference to the start of a next
 *             affix flag.
 * sflag: returns an affix flag from sflagset.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getNextFlagFromString</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sflagset</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sflag</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int32</name></type>        <name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>next</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>sbuf</name> <init>= <expr><operator>*</operator><name>sflagset</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>maxstep</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>stop</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>met_comma</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>maxstep</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>Conf</name><operator>-&gt;</operator><name>flagMode</name></name> <operator>==</operator> <name>FM_LONG</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>*</operator><operator>*</operator><name>sflagset</name></expr>)</condition>
    <block>{<block_content>
        <switch>switch <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>flagMode</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>FM_LONG</name></expr>:</case>
            <case>case <expr><name>FM_CHAR</name></expr>:</case>
                <expr_stmt><expr><call><name>COPYCHAR</name><argument_list>(<argument><expr><name>sflag</name></expr></argument>, <argument><expr><operator>*</operator><name>sflagset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>sflag</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><operator>*</operator><name>sflagset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Go to start of the next flag */</comment>
                <expr_stmt><expr><operator>*</operator><name>sflagset</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><operator>*</operator><name>sflagset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Check if we get all characters of flag */</comment>
                <expr_stmt><expr><name>maxstep</name><operator>--</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>stop</name> <operator>=</operator> <operator>(</operator><name>maxstep</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>FM_NUM</name></expr>:</case>
                <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><operator>*</operator><name>sflagset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>*</operator><name>sflagset</name> <operator>==</operator> <name>next</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid affix flag \"%s\""</literal></expr></argument>, <argument><expr><operator>*</operator><name>sflagset</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>s</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>s</name></expr></argument> &gt;</argument_list></name> <name>FLAGNUM_MAXSIZE</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"affix flag \"%s\" is out of range"</literal></expr></argument>,
                                    <argument><expr><operator>*</operator><name>sflagset</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>sflag</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>sflag</name></expr></argument>, <argument><expr><literal type="string">"%0d"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Go to start of the next flag */</comment>
                <expr_stmt><expr><operator>*</operator><name>sflagset</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
                <while>while <condition>(<expr><operator>*</operator><operator>*</operator><name>sflagset</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>t_isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>sflagset</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>met_comma</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid affix flag \"%s\""</literal></expr></argument>,
                                            <argument><expr><operator>*</operator><name>sflagset</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <break>break;</break>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><operator>*</operator><name>sflagset</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>met_comma</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid affix flag \"%s\""</literal></expr></argument>,
                                            <argument><expr><operator>*</operator><name>sflagset</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <expr_stmt><expr><name>met_comma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>t_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>sflagset</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid character in affix flag \"%s\""</literal></expr></argument>,
                                        <argument><expr><operator>*</operator><name>sflagset</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><operator>*</operator><name>sflagset</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><operator>*</operator><name>sflagset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></while>
                <expr_stmt><expr><name>stop</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized type of Conf-&gt;flagMode: %d"</literal></expr></argument>,
                     <argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>flagMode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><name>stop</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>flagMode</name></name> <operator>==</operator> <name>FM_LONG</name> <operator>&amp;&amp;</operator> <name>maxstep</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid affix flag \"%s\" with \"long\" flag value"</literal></expr></argument>,
                        <argument><expr><name>sbuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>sflag</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Checks if the affix set Conf-&gt;AffixData[affix] contains affixflag.
 * Conf-&gt;AffixData[affix] does not contain affixflag if this flag is not used
 * actually by the .dict file.
 *
 * Conf: current dictionary.
 * affix: index of the Conf-&gt;AffixData array.
 * affixflag: the affix flag.
 *
 * Returns true if the string Conf-&gt;AffixData[affix] contains affixflag,
 * otherwise returns false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsAffixFlagInUse</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>affix</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>affixflag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>flagcur</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>flag</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>affixflag</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>flagcur</name> <operator>=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>AffixData</name><index>[<expr><name>affix</name></expr>]</index></name></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>*</operator><name>flagcur</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>getNextFlagFromString</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flagcur</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Compare first affix flag in flagcur with affixflag */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>flag</name></expr></argument>, <argument><expr><name>affixflag</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Could not find affixflag */</comment>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Adds the new word into the temporary array Spell.
 *
 * Conf: current dictionary.
 * word: new word.
 * flag: set of affix flags. Single flag can be get by getNextFlagFromString().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>NIAddSpell</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>flag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>nspell</name></name> <operator>&gt;=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>mspell</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>mspell</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>mspell</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name></name> <operator>=</operator> <operator>(</operator><name>SPELL</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name></name></expr></argument>, <argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>mspell</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SPELL</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>mspell</name></name> <operator>=</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">20</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name></name> <operator>=</operator> <operator>(</operator><name>SPELL</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>tmpalloc</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>mspell</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SPELL</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name><name>Conf</name><operator>-&gt;</operator><name>nspell</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>SPELL</name> <operator>*</operator><operator>)</operator> <call><name>tmpalloc</name><argument_list>(<argument><expr><name>SPELLHDRSZ</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name><name>Conf</name><operator>-&gt;</operator><name>nspell</name></name></expr>]</index></name><operator>-&gt;</operator><name>word</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name><name>Conf</name><operator>-&gt;</operator><name>nspell</name></name></expr>]</index></name><operator>-&gt;</operator><name><name>p</name><operator>.</operator><name>flag</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name>flag</name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>
        ?</condition><then> <expr><call><name>cpstrdup</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>VoidString</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>nspell</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Imports dictionary into the temporary array Spell.
 *
 * Note caller must already have applied get_tsearch_config_filename.
 *
 * Conf: current dictionary.
 * filename: path to the .dict file.
 */</comment>
<function><type><name>void</name></type>
<name>NIImportDictionary</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>tsearch_readline_state</name></type> <name>trst</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tsearch_readline_begin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trst</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open dictionary file \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>line</name> <operator>=</operator> <call><name>tsearch_readline</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trst</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>s</name></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>pstr</name></decl>;</decl_stmt>

        <comment type="block">/* Set of affix flags */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>flag</name></decl>;</decl_stmt>

        <comment type="block">/* Extract flag from the line */</comment>
        <expr_stmt><expr><name>flag</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>s</name> <operator>=</operator> <call><name>findchar</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>s</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>flag</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
            <while>while <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* we allow only single encoded flags for faster works */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>t_isprint</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>t_isspace</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>flag</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* Remove trailing spaces */</comment>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>t_isspace</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name>pstr</name> <operator>=</operator> <call><name>lowerstr_ctx</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>NIAddSpell</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>pstr</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>tsearch_readline_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Searches a basic form of word in the prefix tree. This word was generated
 * using an affix rule. This rule may not be presented in an affix set of
 * a basic form of word.
 *
 * For example, we have the entry in the .dict file:
 * meter/GMD
 *
 * The affix rule with the flag S:
 * SFX S   y     ies        [^aeiou]y
 * is not presented here.
 *
 * The affix rule with the flag M:
 * SFX M   0     's         .
 * is presented here.
 *
 * Conf: current dictionary.
 * word: basic form of word.
 * affixflag: affix flag, by which a basic form of word was generated.
 * flag: compound flag used to compare with StopMiddle-&gt;compoundflag.
 *
 * Returns 1 if the word was found in the prefix tree, else returns 0.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>FindWord</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>affixflag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>SPNode</name>       <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>Conf</name><operator>-&gt;</operator><name>Dictionary</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SPNodeData</name> <modifier>*</modifier></type><name>StopLow</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>StopHigh</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>StopMiddle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint8</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>uint8</name> <operator>*</operator><operator>)</operator> <name>word</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>flag</name> <operator>&amp;=</operator> <name>FF_COMPOUNDFLAGMASK</name></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>StopLow</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>StopHigh</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>node</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>StopLow</name> <operator>&lt;</operator> <name>StopHigh</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>StopMiddle</name> <operator>=</operator> <name>StopLow</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>StopHigh</name> <operator>-</operator> <name>StopLow</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>StopMiddle</name><operator>-&gt;</operator><name>val</name></name> <operator>==</operator> <operator>*</operator><name>ptr</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>ptr</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name><name>StopMiddle</name><operator>-&gt;</operator><name>isword</name></name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>flag</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * The word can be formed only with another word. And
                         * in the flag parameter there is not a sign that we
                         * search compound words.
                         */</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>StopMiddle</name><operator>-&gt;</operator><name>compoundflag</name></name> <operator>&amp;</operator> <name>FF_COMPOUNDONLY</name></expr>)</condition><block type="pseudo"><block_content>
                            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><operator>(</operator><name>flag</name> <operator>&amp;</operator> <name><name>StopMiddle</name><operator>-&gt;</operator><name>compoundflag</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

                    <comment type="block">/*
                     * Check if this affix rule is presented in the affix set
                     * with index StopMiddle-&gt;affix.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>IsAffixFlagInUse</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name><name>StopMiddle</name><operator>-&gt;</operator><name>affix</name></name></expr></argument>, <argument><expr><name>affixflag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>StopMiddle</name><operator>-&gt;</operator><name>node</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>StopMiddle</name><operator>-&gt;</operator><name>val</name></name> <operator>&lt;</operator> <operator>*</operator><name>ptr</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>StopLow</name> <operator>=</operator> <name>StopMiddle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>StopHigh</name> <operator>=</operator> <name>StopMiddle</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>StopLow</name> <operator>&gt;=</operator> <name>StopHigh</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Adds a new affix rule to the Affix field.
 *
 * Conf: current dictionary.
 * flag: affix flag ('\' in the below example).
 * flagflags: set of flags from the flagval field for this affix rule. This set
 *              is listed after '/' character in the added string (repl).
 *
 *              For example L flag in the hunspell_sample.affix:
 *              SFX \   0 Y/L [^Y]
 *
 * mask: condition for search ('[^Y]' in the above example).
 * find: stripping characters from beginning (at prefix) or end (at suffix)
 *         of the word ('0' in the above example, 0 means that there is not
 *         stripping character).
 * repl: adding string after stripping ('Y' in the above example).
 * type: FF_SUFFIX or FF_PREFIX.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>NIAddAffix</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>flag</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>flagflags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mask</name></decl></parameter>,
           <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>find</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>repl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>AFFIX</name>       <modifier>*</modifier></type><name>Affix</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>naffixes</name></name> <operator>&gt;=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>maffixes</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>maffixes</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>maffixes</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>Affix</name></name> <operator>=</operator> <operator>(</operator><name>AFFIX</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>Conf</name><operator>-&gt;</operator><name>Affix</name></name></expr></argument>, <argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>maffixes</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AFFIX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>maffixes</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>Affix</name></name> <operator>=</operator> <operator>(</operator><name>AFFIX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>maffixes</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AFFIX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>Affix</name> <operator>=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>Affix</name></name> <operator>+</operator> <name><name>Conf</name><operator>-&gt;</operator><name>naffixes</name></name></expr>;</expr_stmt>

    <comment type="block">/* This affix rule can be applied for words with any ending */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>mask</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>mask</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>Affix</name><operator>-&gt;</operator><name>issimple</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>Affix</name><operator>-&gt;</operator><name>isregis</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* This affix rule will use regis to search word ending */</comment>
    <if type="elseif">else if <condition>(<expr><call><name>RS_isRegis</name><argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>Affix</name><operator>-&gt;</operator><name>issimple</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>Affix</name><operator>-&gt;</operator><name>isregis</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RS_compile</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>Affix</name><operator>-&gt;</operator><name>reg</name><operator>.</operator><name>regis</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>type</name> <operator>==</operator> <name>FF_SUFFIX</name><operator>)</operator></expr></argument>,
                   <argument><expr><ternary><condition><expr><operator>*</operator><name>mask</name></expr> ?</condition><then> <expr><name>mask</name></expr> </then><else>: <expr><name>VoidString</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* This affix rule will use regex_t to search word ending */</comment>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>masklen</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>wmasklen</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>err</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>pg_wchar</name>   <modifier>*</modifier></type><name>wmask</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>tmask</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>Affix</name><operator>-&gt;</operator><name>issimple</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>Affix</name><operator>-&gt;</operator><name>isregis</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>tmask</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>tmpalloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>FF_SUFFIX</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>tmask</name></expr></argument>, <argument><expr><literal type="string">"%s$"</literal></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>tmask</name></expr></argument>, <argument><expr><literal type="string">"^%s"</literal></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>masklen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>wmask</name> <operator>=</operator> <operator>(</operator><name>pg_wchar</name> <operator>*</operator><operator>)</operator> <call><name>tmpalloc</name><argument_list>(<argument><expr><operator>(</operator><name>masklen</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_wchar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>wmasklen</name> <operator>=</operator> <call><name>pg_mb2wchar_with_len</name><argument_list>(<argument><expr><name>tmask</name></expr></argument>, <argument><expr><name>wmask</name></expr></argument>, <argument><expr><name>masklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>pg_regcomp</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>Affix</name><operator>-&gt;</operator><name>reg</name><operator>.</operator><name>regex</name></name><operator>)</operator></expr></argument>, <argument><expr><name>wmask</name></expr></argument>, <argument><expr><name>wmasklen</name></expr></argument>,
                         <argument><expr><name>REG_ADVANCED</name> <operator>|</operator> <name>REG_NOSUB</name></expr></argument>,
                         <argument><expr><name>DEFAULT_COLLATION_OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type>        <name><name>errstr</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>pg_regerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>Affix</name><operator>-&gt;</operator><name>reg</name><operator>.</operator><name>regex</name></name><operator>)</operator></expr></argument>, <argument><expr><name>errstr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errstr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_REGULAR_EXPRESSION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid regular expression: %s"</literal></expr></argument>, <argument><expr><name>errstr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>Affix</name><operator>-&gt;</operator><name>flagflags</name></name> <operator>=</operator> <name>flagflags</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>Affix</name><operator>-&gt;</operator><name>flagflags</name></name> <operator>&amp;</operator> <name>FF_COMPOUNDONLY</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>Affix</name><operator>-&gt;</operator><name>flagflags</name></name> <operator>&amp;</operator> <name>FF_COMPOUNDPERMITFLAG</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>Affix</name><operator>-&gt;</operator><name>flagflags</name></name> <operator>&amp;</operator> <name>FF_COMPOUNDFLAG</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>Affix</name><operator>-&gt;</operator><name>flagflags</name></name> <operator>|=</operator> <name>FF_COMPOUNDFLAG</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>Affix</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <call><name>cpstrdup</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Affix</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>Affix</name><operator>-&gt;</operator><name>find</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>find</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>find</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>cpstrdup</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>find</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>VoidString</name></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>Affix</name><operator>-&gt;</operator><name>replen</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>Affix</name><operator>-&gt;</operator><name>repl</name></name> <operator>=</operator> <call><name>cpstrdup</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>Affix</name><operator>-&gt;</operator><name>repl</name></name> <operator>=</operator> <name>VoidString</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>naffixes</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parsing states for parse_affentry() and friends */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAE_WAIT_MASK</name></cpp:macro>    <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAE_INMASK</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAE_WAIT_FIND</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAE_INFIND</name></cpp:macro>        <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAE_WAIT_REPL</name></cpp:macro>    <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAE_INREPL</name></cpp:macro>        <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAE_WAIT_TYPE</name></cpp:macro>    <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAE_WAIT_FLAG</name></cpp:macro>    <cpp:value>7</cpp:value></cpp:define>

<comment type="block">/*
 * Parse next space-separated field of an .affix file line.
 *
 * *str is the input pointer (will be advanced past field)
 * next is where to copy the field value to, with null termination
 *
 * The buffer at "next" must be of size BUFSIZ; we truncate the input to fit.
 *
 * Returns TRUE if we found a field, FALSE if not.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>get_nextfield</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>next</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>state</name> <init>= <expr><name>PAE_WAIT_MASK</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>avail</name> <init>= <expr><name>BUFSIZ</name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><operator>*</operator><operator>*</operator><name>str</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>PAE_WAIT_MASK</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>, <argument><expr><literal type="char">'#'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>t_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>            <name>clen</name> <init>= <expr><call><name>pg_mblen</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&lt;</operator> <name>avail</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>COPYCHAR</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>next</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>avail</name> <operator>-=</operator> <name>clen</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>state</name> <operator>=</operator> <name>PAE_INMASK</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else                    <comment type="block">/* state == PAE_INMASK */</comment>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>t_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>next</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>            <name>clen</name> <init>= <expr><call><name>pg_mblen</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&lt;</operator> <name>avail</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>COPYCHAR</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>next</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>avail</name> <operator>-=</operator> <name>clen</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>str</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><operator>*</operator><name>next</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>state</name> <operator>==</operator> <name>PAE_INMASK</name><operator>)</operator></expr>;</return>    <comment type="block">/* OK if we got a nonempty field */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Parses entry of an .affix file of MySpell or Hunspell format.
 *
 * An .affix file entry has the following format:
 * - header
 *     &lt;type&gt;  &lt;flag&gt;  &lt;cross_flag&gt;  &lt;flag_count&gt;
 * - fields after header:
 *     &lt;type&gt;  &lt;flag&gt;  &lt;find&gt;  &lt;replace&gt;    &lt;mask&gt;
 *
 * str is the input line
 * field values are returned to type etc, which must be buffers of size BUFSIZ.
 *
 * Returns number of fields found; any omitted fields are set to empty strings.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_ooaffentry</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>flag</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>find</name></decl></parameter>,
                 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>repl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>mask</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>state</name> <init>= <expr><name>PAE_WAIT_TYPE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>fields_read</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>valid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <operator>*</operator><name>flag</name> <operator>=</operator> <operator>*</operator><name>find</name> <operator>=</operator> <operator>*</operator><name>repl</name> <operator>=</operator> <operator>*</operator><name>mask</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>*</operator><name>str</name></expr>)</condition>
    <block>{<block_content>
        <switch>switch <condition>(<expr><name>state</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>PAE_WAIT_TYPE</name></expr>:</case>
                <expr_stmt><expr><name>valid</name> <operator>=</operator> <call><name>get_nextfield</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>state</name> <operator>=</operator> <name>PAE_WAIT_FLAG</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>PAE_WAIT_FLAG</name></expr>:</case>
                <expr_stmt><expr><name>valid</name> <operator>=</operator> <call><name>get_nextfield</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>state</name> <operator>=</operator> <name>PAE_WAIT_FIND</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>PAE_WAIT_FIND</name></expr>:</case>
                <expr_stmt><expr><name>valid</name> <operator>=</operator> <call><name>get_nextfield</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>find</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>state</name> <operator>=</operator> <name>PAE_WAIT_REPL</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>PAE_WAIT_REPL</name></expr>:</case>
                <expr_stmt><expr><name>valid</name> <operator>=</operator> <call><name>get_nextfield</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>state</name> <operator>=</operator> <name>PAE_WAIT_MASK</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>PAE_WAIT_MASK</name></expr>:</case>
                <expr_stmt><expr><name>valid</name> <operator>=</operator> <call><name>get_nextfield</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>        <comment type="block">/* force loop exit */</comment>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized state in parse_ooaffentry: %d"</literal></expr></argument>,
                     <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
        <if_stmt><if>if <condition>(<expr><name>valid</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>fields_read</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <break>break;</break></block_content></block></else></if_stmt>                <comment type="block">/* early EOL */</comment>
        <if_stmt><if>if <condition>(<expr><name>state</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>                <comment type="block">/* got all fields */</comment>
    </block_content>}</block></while>

    <return>return <expr><name>fields_read</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parses entry of an .affix file of Ispell format
 *
 * An .affix file entry has the following format:
 * &lt;mask&gt;  &gt;  [-&lt;find&gt;,]&lt;replace&gt;
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>parse_affentry</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>mask</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>find</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>repl</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>state</name> <init>= <expr><name>PAE_WAIT_MASK</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>pmask</name> <init>= <expr><name>mask</name></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>pfind</name> <init>= <expr><name>find</name></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>prepl</name> <init>= <expr><name>repl</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>mask</name> <operator>=</operator> <operator>*</operator><name>find</name> <operator>=</operator> <operator>*</operator><name>repl</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>*</operator><name>str</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>PAE_WAIT_MASK</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'#'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>t_isspace</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>COPYCHAR</name><argument_list>(<argument><expr><name>pmask</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pmask</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>state</name> <operator>=</operator> <name>PAE_INMASK</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>state</name> <operator>==</operator> <name>PAE_INMASK</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>pmask</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>state</name> <operator>=</operator> <name>PAE_WAIT_FIND</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>t_isspace</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>COPYCHAR</name><argument_list>(<argument><expr><name>pmask</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pmask</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>state</name> <operator>==</operator> <name>PAE_WAIT_FIND</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>state</name> <operator>=</operator> <name>PAE_INFIND</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>t_isalpha</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>t_iseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr> <comment type="block">/* english 's */</comment> )</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>COPYCHAR</name><argument_list>(<argument><expr><name>prepl</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>prepl</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>state</name> <operator>=</operator> <name>PAE_INREPL</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>t_isspace</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"syntax error"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>state</name> <operator>==</operator> <name>PAE_INFIND</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>pfind</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>state</name> <operator>=</operator> <name>PAE_WAIT_REPL</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>t_isalpha</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>COPYCHAR</name><argument_list>(<argument><expr><name>pfind</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pfind</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>t_isspace</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"syntax error"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>state</name> <operator>==</operator> <name>PAE_WAIT_REPL</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <break>break;</break>            <comment type="block">/* void repl */</comment>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>t_isalpha</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>COPYCHAR</name><argument_list>(<argument><expr><name>prepl</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>prepl</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>state</name> <operator>=</operator> <name>PAE_INREPL</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>t_isspace</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"syntax error"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>state</name> <operator>==</operator> <name>PAE_INREPL</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'#'</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>prepl</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>t_isalpha</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>COPYCHAR</name><argument_list>(<argument><expr><name>prepl</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>prepl</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>t_isspace</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"syntax error"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized state in parse_affentry: %d"</literal></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>str</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><operator>*</operator><name>pmask</name> <operator>=</operator> <operator>*</operator><name>pfind</name> <operator>=</operator> <operator>*</operator><name>prepl</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><operator>*</operator><name>mask</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>find</name> <operator>||</operator> <operator>*</operator><name>repl</name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sets a Hunspell options depending on flag type.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setCompoundAffixFlagValue</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><name>CompoundAffixFlag</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
                          <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>flagMode</name></name> <operator>==</operator> <name>FM_NUM</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>next</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid affix flag \"%s\""</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>i</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>i</name></expr></argument> &gt;</argument_list></name> <name>FLAGNUM_MAXSIZE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"affix flag \"%s\" is out of range"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>flag</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>flag</name><operator>.</operator><name>s</name></name> <operator>=</operator> <call><name>cpstrdup</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>flagMode</name></name> <operator>=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>flagMode</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Sets up a correspondence for the affix parameter with the affix flag.
 *
 * Conf: current dictionary.
 * s: affix flag in string.
 * val: affix parameter.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addCompoundAffixFlagValue</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CompoundAffixFlag</name> <modifier>*</modifier></type><name>newValue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>sbuf</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>sflag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>clen</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>&amp;&amp;</operator> <call><name>t_isspace</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>s</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"syntax error"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Get flag without \n */</comment>
    <expr_stmt><expr><name>sflag</name> <operator>=</operator> <name>sbuf</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>t_isspace</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>clen</name> <operator>=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>COPYCHAR</name><argument_list>(<argument><expr><name>sflag</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sflag</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><operator>*</operator><name>sflag</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <comment type="block">/* Resize array or allocate memory for array CompoundAffixFlag */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>nCompoundAffixFlag</name></name> <operator>&gt;=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>mCompoundAffixFlag</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>mCompoundAffixFlag</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>mCompoundAffixFlag</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>CompoundAffixFlags</name></name> <operator>=</operator> <operator>(</operator><name>CompoundAffixFlag</name> <operator>*</operator><operator>)</operator>
                <call><name>repalloc</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>Conf</name><operator>-&gt;</operator><name>CompoundAffixFlags</name></name></expr></argument>,
                         <argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>mCompoundAffixFlag</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CompoundAffixFlag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>mCompoundAffixFlag</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>CompoundAffixFlags</name></name> <operator>=</operator> <operator>(</operator><name>CompoundAffixFlag</name> <operator>*</operator><operator>)</operator>
                <call><name>tmpalloc</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>mCompoundAffixFlag</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CompoundAffixFlag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>newValue</name> <operator>=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>CompoundAffixFlags</name></name> <operator>+</operator> <name><name>Conf</name><operator>-&gt;</operator><name>nCompoundAffixFlag</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>setCompoundAffixFlagValue</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>newValue</name></expr></argument>, <argument><expr><name>sbuf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>usecompound</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>nCompoundAffixFlag</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns a set of affix parameters which correspondence to the set of affix
 * flags s.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>getCompoundAffixFlagValue</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>flag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CompoundAffixFlag</name> <modifier>*</modifier></type><name>found</name></decl>,
                <decl><type ref="prev"/><name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>sflag</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>flagcur</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>nCompoundAffixFlag</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>flagcur</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>*</operator><name>flagcur</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>getNextFlagFromString</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flagcur</name></expr></argument>, <argument><expr><name>sflag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setCompoundAffixFlagValue</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>sflag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>found</name> <operator>=</operator> <operator>(</operator><name>CompoundAffixFlag</name> <operator>*</operator><operator>)</operator>
            <call><name>bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>Conf</name><operator>-&gt;</operator><name>CompoundAffixFlags</name></name></expr></argument>,
                    <argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>nCompoundAffixFlag</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CompoundAffixFlag</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                    <argument><expr><name>cmpcmdflag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>found</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>flag</name> <operator>|=</operator> <name><name>found</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>flag</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns a flag set using the s parameter.
 *
 * If Conf-&gt;useFlagAliases is true then the s parameter is index of the
 * Conf-&gt;AffixData array and function returns its entry.
 * Else function returns the s parameter.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getAffixFlagSet</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>useFlagAliases</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>curaffix</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>curaffix</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>end</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid affix alias \"%s\""</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>curaffix</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>curaffix</name> <operator>&lt;=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>nAffixData</name></name></expr>)</condition><block type="pseudo"><block_content>

            <comment type="block">/*
             * Do not subtract 1 from curaffix because empty string was added
             * in NIImportOOAffixes
             */</comment>
            <return>return <expr><name><name>Conf</name><operator>-&gt;</operator><name>AffixData</name><index>[<expr><name>curaffix</name></expr>]</index></name></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><name>VoidString</name></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>s</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Import an affix file that follows MySpell or Hunspell format.
 *
 * Conf: current dictionary.
 * filename: path to the .affix file.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>NIImportOOAffixes</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>type</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>ptype</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>sflag</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>mask</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>pmask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>find</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>pfind</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>repl</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>prepl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isSuffix</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>naffix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>curaffix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>sflaglen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>flagflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tsearch_readline_state</name></type> <name>trst</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>recoded</name></decl>;</decl_stmt>

    <comment type="block">/* read file to find any flag */</comment>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>usecompound</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>useFlagAliases</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>flagMode</name></name> <operator>=</operator> <name>FM_CHAR</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tsearch_readline_begin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trst</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open affix file \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>recoded</name> <operator>=</operator> <call><name>tsearch_readline</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trst</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>recoded</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>t_isspace</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>t_iseq</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>, <argument><expr><literal type="char">'#'</literal></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>, <argument><expr><literal type="string">"COMPOUNDFLAG"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>addCompoundAffixFlagValue</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>recoded</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"COMPOUNDFLAG"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>FF_COMPOUNDFLAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>, <argument><expr><literal type="string">"COMPOUNDBEGIN"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>addCompoundAffixFlagValue</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>recoded</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"COMPOUNDBEGIN"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>FF_COMPOUNDBEGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>, <argument><expr><literal type="string">"COMPOUNDLAST"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>addCompoundAffixFlagValue</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>recoded</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"COMPOUNDLAST"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>FF_COMPOUNDLAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <comment type="block">/* COMPOUNDLAST and COMPOUNDEND are synonyms */</comment>
        <if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>, <argument><expr><literal type="string">"COMPOUNDEND"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>addCompoundAffixFlagValue</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>recoded</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"COMPOUNDEND"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>FF_COMPOUNDLAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>, <argument><expr><literal type="string">"COMPOUNDMIDDLE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>addCompoundAffixFlagValue</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>recoded</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"COMPOUNDMIDDLE"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>FF_COMPOUNDMIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>, <argument><expr><literal type="string">"ONLYINCOMPOUND"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>addCompoundAffixFlagValue</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>recoded</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"ONLYINCOMPOUND"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>FF_COMPOUNDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>, <argument><expr><literal type="string">"COMPOUNDPERMITFLAG"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>addCompoundAffixFlagValue</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>,
                                      <argument><expr><name>recoded</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"COMPOUNDPERMITFLAG"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>FF_COMPOUNDPERMITFLAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>, <argument><expr><literal type="string">"COMPOUNDFORBIDFLAG"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>addCompoundAffixFlagValue</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>,
                                      <argument><expr><name>recoded</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"COMPOUNDFORBIDFLAG"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>FF_COMPOUNDFORBIDFLAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>, <argument><expr><literal type="string">"FLAG"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>s</name> <init>= <expr><name>recoded</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"FLAG"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>&amp;&amp;</operator> <call><name>t_isspace</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"long"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>flagMode</name></name> <operator>=</operator> <name>FM_LONG</name></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"num"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>flagMode</name></name> <operator>=</operator> <name>FM_NUM</name></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Ispell dictionary supports only "</literal>
                                    <literal type="string">"\"default\", \"long\", "</literal>
                                    <literal type="string">"and \"num\" flag values"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>tsearch_readline_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>nCompoundAffixFlag</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>Conf</name><operator>-&gt;</operator><name>CompoundAffixFlags</name></name></expr></argument>, <argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>nCompoundAffixFlag</name></name></expr></argument>,
              <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CompoundAffixFlag</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmpcmdflag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tsearch_readline_begin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trst</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open affix file \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>recoded</name> <operator>=</operator> <call><name>tsearch_readline</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trst</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>fields_read</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>recoded</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>t_isspace</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>t_iseq</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>, <argument><expr><literal type="char">'#'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>nextline</name>;</goto></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>fields_read</name> <operator>=</operator> <call><name>parse_ooaffentry</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>sflag</name></expr></argument>, <argument><expr><name>find</name></expr></argument>, <argument><expr><name>repl</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>ptype</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>ptype</name> <operator>=</operator> <call><name>lowerstr_ctx</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* First try to parse AF parameter (alias compression) */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><literal type="string">"af"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* First line is the number of aliases */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>Conf</name><operator>-&gt;</operator><name>useFlagAliases</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>useFlagAliases</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>naffix</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>sflag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>naffix</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid number of flag vector aliases"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/* Also reserve place for empty flag set */</comment>
                <expr_stmt><expr><name>naffix</name><operator>++</operator></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>AffixData</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>naffix</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>lenAffixData</name></name> <operator>=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>nAffixData</name></name> <operator>=</operator> <name>naffix</name></expr>;</expr_stmt>

                <comment type="block">/* Add empty flag set into AffixData */</comment>
                <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>AffixData</name><index>[<expr><name>curaffix</name></expr>]</index></name> <operator>=</operator> <name>VoidString</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>curaffix</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="block">/* Other lines is aliases */</comment>
            <else>else
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>curaffix</name> <operator>&lt;</operator> <name>naffix</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>AffixData</name><index>[<expr><name>curaffix</name></expr>]</index></name> <operator>=</operator> <call><name>cpstrdup</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>sflag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>curaffix</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
            <goto>goto <name>nextline</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Else try to parse prefixes and suffixes */</comment>
        <if_stmt><if>if <condition>(<expr><name>fields_read</name> <operator>&lt;</operator> <literal type="number">4</literal> <operator>||</operator>
            <operator>(</operator><call><name>STRNCMP</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><literal type="string">"sfx"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><literal type="string">"pfx"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>nextline</name>;</goto></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>sflaglen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>sflag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>sflaglen</name> <operator>==</operator> <literal type="number">0</literal>
            <operator>||</operator> <operator>(</operator><name>sflaglen</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>Conf</name><operator>-&gt;</operator><name>flagMode</name></name> <operator>==</operator> <name>FM_CHAR</name><operator>)</operator>
            <operator>||</operator> <operator>(</operator><name>sflaglen</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>Conf</name><operator>-&gt;</operator><name>flagMode</name></name> <operator>==</operator> <name>FM_LONG</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>nextline</name>;</goto></block_content></block></if></if_stmt>

        <comment type="block">/*--------
         * Affix header. For example:
         * SFX \ N 1
         *--------
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>fields_read</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>isSuffix</name> <operator>=</operator> <operator>(</operator><call><name>STRNCMP</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><literal type="string">"sfx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name>find</name></expr></argument>, <argument><expr><literal type="char">'y'</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>t_iseq</name><argument_list>(<argument><expr><name>find</name></expr></argument>, <argument><expr><literal type="char">'Y'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>flagflags</name> <operator>=</operator> <name>FF_CROSSPRODUCT</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>flagflags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <comment type="block">/*--------
         * Affix fields. For example:
         * SFX \   0    Y/L [^Y]
         *--------
         */</comment>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>aflg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Get flags after '/' (flags are case sensitive) */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ptr</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>repl</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>aflg</name> <operator>|=</operator> <call><name>getCompoundAffixFlagValue</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>,
                                                  <argument><expr><call><name>getAffixFlagSet</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>,
                                                                  <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* Get lowercased version of string before '/' */</comment>
            <expr_stmt><expr><name>prepl</name> <operator>=</operator> <call><name>lowerstr_ctx</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ptr</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>prepl</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>pfind</name> <operator>=</operator> <call><name>lowerstr_ctx</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>find</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pmask</name> <operator>=</operator> <call><name>lowerstr_ctx</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name>find</name></expr></argument>, <argument><expr><literal type="char">'0'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>pfind</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name>repl</name></expr></argument>, <argument><expr><literal type="char">'0'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>prepl</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>NIAddAffix</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>sflag</name></expr></argument>, <argument><expr><name>flagflags</name> <operator>|</operator> <name>aflg</name></expr></argument>, <argument><expr><name>pmask</name></expr></argument>, <argument><expr><name>pfind</name></expr></argument>, <argument><expr><name>prepl</name></expr></argument>,
                       <argument><expr><ternary><condition><expr><name>isSuffix</name></expr> ?</condition><then> <expr><name>FF_SUFFIX</name></expr> </then><else>: <expr><name>FF_PREFIX</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>prepl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pfind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

<label><name>nextline</name>:</label>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>tsearch_readline_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ptype</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * import affixes
 *
 * Note caller must already have applied get_tsearch_config_filename
 *
 * This function is responsible for parsing ispell ("old format") affix files.
 * If we realize that the file contains new-format commands, we pass off the
 * work to NIImportOOAffixes(), which will re-read the whole file.
 */</comment>
<function><type><name>void</name></type>
<name>NIImportAffixes</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>pstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>flag</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>mask</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>find</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>repl</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>suffixes</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>prefixes</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>flagflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tsearch_readline_state</name></type> <name>trst</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>oldformat</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>recoded</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tsearch_readline_begin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trst</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open affix file \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>usecompound</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>useFlagAliases</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>flagMode</name></name> <operator>=</operator> <name>FM_CHAR</name></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>recoded</name> <operator>=</operator> <call><name>tsearch_readline</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trst</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>pstr</name> <operator>=</operator> <call><name>lowerstr</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Skip comments and empty lines */</comment>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pstr</name> <operator>==</operator> <literal type="char">'#'</literal> <operator>||</operator> <operator>*</operator><name>pstr</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>nextline</name>;</goto></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>pstr</name></expr></argument>, <argument><expr><literal type="string">"compoundwords"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Find case-insensitive L flag in non-lowercased string */</comment>
            <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>findchar2</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>, <argument><expr><literal type="char">'l'</literal></expr></argument>, <argument><expr><literal type="char">'L'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition>
            <block>{<block_content>
                <while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>t_isspace</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
                <while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>&amp;&amp;</operator> <call><name>t_isspace</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

                <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>&amp;&amp;</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>addCompoundAffixFlagValue</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>FF_COMPOUNDFLAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>usecompound</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>oldformat</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <goto>goto <name>nextline</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>pstr</name></expr></argument>, <argument><expr><literal type="string">"suffixes"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>suffixes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>prefixes</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>oldformat</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <goto>goto <name>nextline</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>pstr</name></expr></argument>, <argument><expr><literal type="string">"prefixes"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>suffixes</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>prefixes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>oldformat</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <goto>goto <name>nextline</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>pstr</name></expr></argument>, <argument><expr><literal type="string">"flag"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>s</name> <operator>=</operator> <name>recoded</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>    <comment type="block">/* we need non-lowercased string */</comment>
            <expr_stmt><expr><name>flagflags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>&amp;&amp;</operator> <call><name>t_isspace</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>flagflags</name> <operator>|=</operator> <name>FF_CROSSPRODUCT</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'~'</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>flagflags</name> <operator>|=</operator> <name>FF_COMPOUNDONLY</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * An old-format flag is a single ASCII character; we expect it to
             * be followed by EOL, whitespace, or ':'.  Otherwise this is a
             * new-format flag command.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>&amp;&amp;</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>COPYCHAR</name><argument_list>(<argument><expr><name>flag</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>flag</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

                <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'#'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">':'</literal> <operator>||</operator>
                    <call><name>t_isspace</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>oldformat</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <goto>goto <name>nextline</name>;</goto>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <goto>goto <name>isnewformat</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>, <argument><expr><literal type="string">"COMPOUNDFLAG"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
            <call><name>STRNCMP</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>, <argument><expr><literal type="string">"COMPOUNDMIN"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
            <call><name>STRNCMP</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>, <argument><expr><literal type="string">"PFX"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
            <call><name>STRNCMP</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>, <argument><expr><literal type="string">"SFX"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>isnewformat</name>;</goto></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>suffixes</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>prefixes</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>nextline</name>;</goto></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_affentry</name><argument_list>(<argument><expr><name>pstr</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>find</name></expr></argument>, <argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>nextline</name>;</goto></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>NIAddAffix</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>flagflags</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>find</name></expr></argument>, <argument><expr><name>repl</name></expr></argument>, <argument><expr><ternary><condition><expr><name>suffixes</name></expr> ?</condition><then> <expr><name>FF_SUFFIX</name></expr> </then><else>: <expr><name>FF_PREFIX</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>nextline</name>:</label>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>recoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>tsearch_readline_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>

<label><name>isnewformat</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>oldformat</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"affix file contains both old-style and new-style commands"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>tsearch_readline_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>NIImportOOAffixes</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Merges two affix flag sets and stores a new affix flag set into
 * Conf-&gt;AffixData.
 *
 * Returns index of a new affix flag set.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>MergeAffix</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>a1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>a2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

    <comment type="block">/* Do not merge affix flags if one of affix flags is empty */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>Conf</name><operator>-&gt;</operator><name>AffixData</name><index>[<expr><name>a1</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>a2</name></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>Conf</name><operator>-&gt;</operator><name>AffixData</name><index>[<expr><name>a2</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>a1</name></expr>;</return></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>nAffixData</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>lenAffixData</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>lenAffixData</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>AffixData</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>AffixData</name></name></expr></argument>,
                                             <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>Conf</name><operator>-&gt;</operator><name>lenAffixData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>AffixData</name></name> <operator>+</operator> <name><name>Conf</name><operator>-&gt;</operator><name>nAffixData</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>flagMode</name></name> <operator>==</operator> <name>FM_NUM</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <call><name>cpalloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>AffixData</name><index>[<expr><name>a1</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator>
                       <call><name>strlen</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>AffixData</name><index>[<expr><name>a2</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator>
                       <literal type="number">1</literal> <comment type="block">/* comma */</comment> <operator>+</operator> <literal type="number">1</literal></expr></argument> <comment type="block">/* \0 */</comment> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"%s,%s"</literal></expr></argument>, <argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>AffixData</name><index>[<expr><name>a1</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>AffixData</name><index>[<expr><name>a2</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <call><name>cpalloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>AffixData</name><index>[<expr><name>a1</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator>
                       <call><name>strlen</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>AffixData</name><index>[<expr><name>a2</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator>
                       <literal type="number">1</literal></expr></argument> <comment type="block">/* \0 */</comment> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>AffixData</name><index>[<expr><name>a1</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>AffixData</name><index>[<expr><name>a2</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>nAffixData</name></name><operator>++</operator></expr>;</expr_stmt>

    <return>return <expr><name><name>Conf</name><operator>-&gt;</operator><name>nAffixData</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns a set of affix parameters which correspondence to the set of affix
 * flags with the given index.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>makeCompoundFlags</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>affix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>str</name> <init>= <expr><name><name>Conf</name><operator>-&gt;</operator><name>AffixData</name><index>[<expr><name>affix</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <return>return <expr><operator>(</operator><call><name>getCompoundAffixFlagValue</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>FF_COMPOUNDFLAGMASK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Makes a prefix tree for the given level.
 *
 * Conf: current dictionary.
 * low: lower index of the Conf-&gt;Spell array.
 * high: upper index of the Conf-&gt;Spell array.
 * level: current prefix tree level.
 */</comment>
<function><type><specifier>static</specifier> <name>SPNode</name> <modifier>*</modifier></type>
<name>mkSPNode</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>low</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>high</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nchar</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>lastchar</name> <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SPNode</name>       <modifier>*</modifier></type><name>rs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SPNodeData</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>lownew</name> <init>= <expr><name>low</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>low</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>high</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>p</name><operator>.</operator><name>d</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <name>level</name> <operator>&amp;&amp;</operator> <name>lastchar</name> <operator>!=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>word</name><index>[<expr><name>level</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>nchar</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>lastchar</name> <operator>=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>word</name><index>[<expr><name>level</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt></block_content></block></for>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>nchar</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>rs</name> <operator>=</operator> <operator>(</operator><name>SPNode</name> <operator>*</operator><operator>)</operator> <call><name>cpalloc0</name><argument_list>(<argument><expr><name>SPNHDRSZ</name> <operator>+</operator> <name>nchar</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SPNodeData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rs</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <name>nchar</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>rs</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>lastchar</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>low</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>high</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>p</name><operator>.</operator><name>d</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <name>level</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>lastchar</name> <operator>!=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>word</name><index>[<expr><name>level</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>lastchar</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Next level of the prefix tree */</comment>
                    <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <call><name>mkSPNode</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>lownew</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>lownew</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>data</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>lastchar</name> <operator>=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>word</name><index>[<expr><name>level</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>word</name><operator>)</operator><operator>)</operator><index>[<expr><name>level</name></expr>]</index></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>p</name><operator>.</operator><name>d</name><operator>.</operator><name>len</name></name> <operator>==</operator> <name>level</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>bool</name></type>        <name>clearCompoundOnly</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>isword</name></name> <operator>&amp;&amp;</operator> <name><name>data</name><operator>-&gt;</operator><name>affix</name></name> <operator>!=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>p</name><operator>.</operator><name>d</name><operator>.</operator><name>affix</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * MergeAffix called a few times. If one of word is
                     * allowed to be in compound word and another isn't, then
                     * clear FF_COMPOUNDONLY flag.
                     */</comment>

                    <expr_stmt><expr><name>clearCompoundOnly</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>FF_COMPOUNDONLY</name> <operator>&amp;</operator> <name><name>data</name><operator>-&gt;</operator><name>compoundflag</name></name>
                                         <operator>&amp;</operator> <call><name>makeCompoundFlags</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>p</name><operator>.</operator><name>d</name><operator>.</operator><name>affix</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>
                        ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>affix</name></name> <operator>=</operator> <call><name>MergeAffix</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>affix</name></name></expr></argument>, <argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>p</name><operator>.</operator><name>d</name><operator>.</operator><name>affix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>affix</name></name> <operator>=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>p</name><operator>.</operator><name>d</name><operator>.</operator><name>affix</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>isword</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>compoundflag</name></name> <operator>=</operator> <call><name>makeCompoundFlags</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>affix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>compoundflag</name></name> <operator>&amp;</operator> <name>FF_COMPOUNDONLY</name><operator>)</operator> <operator>&amp;&amp;</operator>
                    <operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>compoundflag</name></name> <operator>&amp;</operator> <name>FF_COMPOUNDFLAG</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>compoundflag</name></name> <operator>|=</operator> <name>FF_COMPOUNDFLAG</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>clearCompoundOnly</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>compoundflag</name></name> <operator>&amp;=</operator> <operator>~</operator><name>FF_COMPOUNDONLY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt></block_content></block></for>

    <comment type="block">/* Next level of the prefix tree */</comment>
    <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <call><name>mkSPNode</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>lownew</name></expr></argument>, <argument><expr><name>high</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Builds the Conf-&gt;Dictionary tree and AffixData from the imported dictionary
 * and affixes.
 */</comment>
<function><type><name>void</name></type>
<name>NISortDictionary</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>naffix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>curaffix</name></decl>;</decl_stmt>

    <comment type="block">/* compress affixes */</comment>

    <comment type="block">/*
     * If we use flag aliases then we need to use Conf-&gt;AffixData filled in
     * the NIImportOOAffixes().
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>useFlagAliases</name></name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>Conf</name><operator>-&gt;</operator><name>nspell</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>p</name><operator>.</operator><name>flag</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>curaffix</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>p</name><operator>.</operator><name>flag</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>p</name><operator>.</operator><name>flag</name></name> <operator>==</operator> <name>end</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid affix alias \"%s\""</literal></expr></argument>,
                                    <argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>p</name><operator>.</operator><name>flag</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * If Conf-&gt;Spell[i]-&gt;p.flag is empty, then get empty value of
                 * Conf-&gt;AffixData (0 index).
                 */</comment>
                <expr_stmt><expr><name>curaffix</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>p</name><operator>.</operator><name>d</name><operator>.</operator><name>affix</name></name> <operator>=</operator> <name>curaffix</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>p</name><operator>.</operator><name>d</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <comment type="block">/* Otherwise fill Conf-&gt;AffixData here */</comment>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Count the number of different flags used in the dictionary */</comment>
        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>Conf</name><operator>-&gt;</operator><name>Spell</name></name></expr></argument>, <argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>nspell</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SPELL</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
              <argument><expr><name>cmpspellaffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>naffix</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>Conf</name><operator>-&gt;</operator><name>nspell</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal>
                <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>p</name><operator>.</operator><name>flag</name></name></expr></argument>, <argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>p</name><operator>.</operator><name>flag</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>naffix</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/*
         * Fill in Conf-&gt;AffixData with the affixes that were used in the
         * dictionary. Replace textual flag-field of Conf-&gt;Spell entries with
         * indexes into Conf-&gt;AffixData array.
         */</comment>
        <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>AffixData</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>naffix</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>curaffix</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>Conf</name><operator>-&gt;</operator><name>nspell</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal>
                <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>p</name><operator>.</operator><name>flag</name></name></expr></argument>, <argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>AffixData</name><index>[<expr><name>curaffix</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>curaffix</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>curaffix</name> <operator>&lt;</operator> <name>naffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>AffixData</name><index>[<expr><name>curaffix</name></expr>]</index></name> <operator>=</operator> <call><name>cpstrdup</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>,
                                                     <argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>p</name><operator>.</operator><name>flag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>p</name><operator>.</operator><name>d</name><operator>.</operator><name>affix</name></name> <operator>=</operator> <name>curaffix</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>p</name><operator>.</operator><name>d</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>Spell</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>lenAffixData</name></name> <operator>=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>nAffixData</name></name> <operator>=</operator> <name>naffix</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Start build a prefix tree */</comment>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>Conf</name><operator>-&gt;</operator><name>Spell</name></name></expr></argument>, <argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>nspell</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SPELL</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmpspell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>Dictionary</name></name> <operator>=</operator> <call><name>mkSPNode</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>nspell</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Makes a prefix tree for the given level using the repl string of an affix
 * rule. Affixes with empty replace string do not include in the prefix tree.
 * This affixes are included by mkVoidAffix().
 *
 * Conf: current dictionary.
 * low: lower index of the Conf-&gt;Affix array.
 * high: upper index of the Conf-&gt;Affix array.
 * level: current prefix tree level.
 * type: FF_SUFFIX or FF_PREFIX.
 */</comment>
<function><type><specifier>static</specifier> <name>AffixNode</name> <modifier>*</modifier></type>
<name>mkANode</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>low</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>high</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nchar</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8</name></type>        <name>lastchar</name> <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AffixNode</name>  <modifier>*</modifier></type><name>rs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AffixNodeData</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>lownew</name> <init>= <expr><name>low</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>naff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AFFIX</name>      <modifier>*</modifier><modifier>*</modifier></type><name>aff</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>low</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>high</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>Affix</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>replen</name> <operator>&gt;</operator> <name>level</name> <operator>&amp;&amp;</operator> <name>lastchar</name> <operator>!=</operator> <call><name>GETCHAR</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>Affix</name></name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>nchar</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>lastchar</name> <operator>=</operator> <call><name>GETCHAR</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>Affix</name></name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt></block_content></block></for>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>nchar</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>aff</name> <operator>=</operator> <operator>(</operator><name>AFFIX</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>tmpalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AFFIX</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>high</name> <operator>-</operator> <name>low</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>naff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>rs</name> <operator>=</operator> <operator>(</operator><name>AffixNode</name> <operator>*</operator><operator>)</operator> <call><name>cpalloc0</name><argument_list>(<argument><expr><name>ANHRDSZ</name> <operator>+</operator> <name>nchar</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AffixNodeData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rs</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <name>nchar</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>rs</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>lastchar</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>low</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>high</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>Affix</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>replen</name> <operator>&gt;</operator> <name>level</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>lastchar</name> <operator>!=</operator> <call><name>GETCHAR</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>Affix</name></name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>lastchar</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Next level of the prefix tree */</comment>
                    <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <call><name>mkANode</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>lownew</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>naff</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>naff</name></name> <operator>=</operator> <name>naff</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>aff</name></name> <operator>=</operator> <operator>(</operator><name>AFFIX</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>cpalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AFFIX</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>naff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>aff</name></name></expr></argument>, <argument><expr><name>aff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AFFIX</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>naff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>naff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>data</name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name>lownew</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>lastchar</name> <operator>=</operator> <call><name>GETCHAR</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>Affix</name></name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <call><name>GETCHAR</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>Affix</name></name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>Affix</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>replen</name> <operator>==</operator> <name>level</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>                    <comment type="block">/* affix stopped */</comment>
                <expr_stmt><expr><name><name>aff</name><index>[<expr><name>naff</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>Affix</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt></block_content></block></for>

    <comment type="block">/* Next level of the prefix tree */</comment>
    <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <call><name>mkANode</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>lownew</name></expr></argument>, <argument><expr><name>high</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>naff</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>naff</name></name> <operator>=</operator> <name>naff</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>aff</name></name> <operator>=</operator> <operator>(</operator><name>AFFIX</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>cpalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AFFIX</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>naff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>aff</name></name></expr></argument>, <argument><expr><name>aff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AFFIX</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>naff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>naff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>aff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Makes the root void node in the prefix tree. The root void node is created
 * for affixes which have empty replace string ("repl" field).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mkVoidAffix</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>issuffix</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startsuffix</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>start</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>issuffix</name><operator>)</operator></expr> ?</condition><then> <expr><name>startsuffix</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>end</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>issuffix</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>Conf</name><operator>-&gt;</operator><name>naffixes</name></name></expr> </then><else>: <expr><name>startsuffix</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AffixNode</name>  <modifier>*</modifier></type><name>Affix</name> <init>= <expr><operator>(</operator><name>AffixNode</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>ANHRDSZ</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AffixNodeData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>Affix</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Affix</name><operator>-&gt;</operator><name>isvoid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>issuffix</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>Affix</name><operator>-&gt;</operator><name>data</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>Suffix</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>Suffix</name></name> <operator>=</operator> <name>Affix</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>Affix</name><operator>-&gt;</operator><name>data</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>Prefix</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>Prefix</name></name> <operator>=</operator> <name>Affix</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Count affixes with empty replace string */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>Affix</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>replen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

    <comment type="block">/* There is not affixes with empty replace string */</comment>
    <if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>Affix</name><operator>-&gt;</operator><name>data</name><operator>-&gt;</operator><name>aff</name></name> <operator>=</operator> <operator>(</operator><name>AFFIX</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>cpalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AFFIX</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Affix</name><operator>-&gt;</operator><name>data</name><operator>-&gt;</operator><name>naff</name></name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name>cnt</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>Affix</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>replen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>Affix</name><operator>-&gt;</operator><name>data</name><operator>-&gt;</operator><name>aff</name><index>[<expr><name>cnt</name></expr>]</index></name> <operator>=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>Affix</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Checks if the affixflag is used by dictionary. Conf-&gt;AffixData does not
 * contain affixflag if this flag is not used actually by the .dict file.
 *
 * Conf: current dictionary.
 * affixflag: affix flag.
 *
 * Returns true if the Conf-&gt;AffixData array contains affixflag, otherwise
 * returns false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isAffixInUse</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>affixflag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>Conf</name><operator>-&gt;</operator><name>nAffixData</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IsAffixFlagInUse</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>affixflag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Builds Conf-&gt;Prefix and Conf-&gt;Suffix trees from the imported affixes.
 */</comment>
<function><type><name>void</name></type>
<name>NISortAffixes</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>AFFIX</name>       <modifier>*</modifier></type><name>Affix</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CMPDAffix</name>  <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>firstsuffix</name> <init>= <expr><name><name>Conf</name><operator>-&gt;</operator><name>naffixes</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>naffixes</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Store compound affixes in the Conf-&gt;CompoundAffix array */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>naffixes</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>Conf</name><operator>-&gt;</operator><name>Affix</name></name></expr></argument>, <argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>naffixes</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AFFIX</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmpaffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>CompoundAffix</name></name> <operator>=</operator> <name>ptr</name> <operator>=</operator> <operator>(</operator><name>CMPDAffix</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CMPDAffix</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>Conf</name><operator>-&gt;</operator><name>naffixes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>affix</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>Conf</name><operator>-&gt;</operator><name>naffixes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>Affix</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>AFFIX</name> <operator>*</operator><operator>)</operator> <name><name>Conf</name><operator>-&gt;</operator><name>Affix</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>Affix</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>FF_SUFFIX</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>firstsuffix</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>firstsuffix</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>Affix</name><operator>-&gt;</operator><name>flagflags</name></name> <operator>&amp;</operator> <name>FF_COMPOUNDFLAG</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>Affix</name><operator>-&gt;</operator><name>replen</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <call><name>isAffixInUse</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name><name>Affix</name><operator>-&gt;</operator><name>flag</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name><name>Conf</name><operator>-&gt;</operator><name>CompoundAffix</name></name> <operator>||</operator>
                <name><name>ptr</name><operator>-&gt;</operator><name>issuffix</name></name> <operator>!=</operator> <operator>(</operator><name>ptr</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>issuffix</name> <operator>||</operator>
                <call><name>strbncmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>affix</name></expr></argument>,
                         <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>Affix</name><operator>-&gt;</operator><name>repl</name></name></expr></argument>,
                         <argument><expr><operator>(</operator><name>ptr</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>len</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* leave only unique and minimals suffixes */</comment>
                <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>affix</name></name> <operator>=</operator> <name><name>Affix</name><operator>-&gt;</operator><name>repl</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>Affix</name><operator>-&gt;</operator><name>replen</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>issuffix</name></name> <operator>=</operator> <operator>(</operator><name><name>Affix</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>FF_SUFFIX</name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>affix</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>CompoundAffix</name></name> <operator>=</operator> <operator>(</operator><name>CMPDAffix</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>CompoundAffix</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CMPDAffix</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>ptr</name> <operator>-</operator> <name><name>Conf</name><operator>-&gt;</operator><name>CompoundAffix</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Start build a prefix tree */</comment>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>Prefix</name></name> <operator>=</operator> <call><name>mkANode</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>firstsuffix</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FF_PREFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>Conf</name><operator>-&gt;</operator><name>Suffix</name></name> <operator>=</operator> <call><name>mkANode</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>firstsuffix</name></expr></argument>, <argument><expr><name><name>Conf</name><operator>-&gt;</operator><name>naffixes</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FF_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mkVoidAffix</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>firstsuffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mkVoidAffix</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>firstsuffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AffixNodeData</name> <modifier>*</modifier></type>
<name>FindAffixes</name><parameter_list>(<parameter><decl><type><name>AffixNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wrdlen</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>level</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>AffixNodeData</name> <modifier>*</modifier></type><name>StopLow</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>StopHigh</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>StopMiddle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8</name></type> <name>symbol</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>isvoid</name></name></expr>)</condition>
    <block>{<block_content>                            <comment type="block">/* search void affixes */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>data</name><operator>-&gt;</operator><name>naff</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name><name>node</name><operator>-&gt;</operator><name>data</name></name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>data</name><operator>-&gt;</operator><name>node</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <while>while <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>level</name> <operator>&lt;</operator> <name>wrdlen</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>StopLow</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>StopHigh</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>node</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>StopLow</name> <operator>&lt;</operator> <name>StopHigh</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>StopMiddle</name> <operator>=</operator> <name>StopLow</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>StopHigh</name> <operator>-</operator> <name>StopLow</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>symbol</name> <operator>=</operator> <call><name>GETWCHAR</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>wrdlen</name></expr></argument>, <argument><expr><operator>*</operator><name>level</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>StopMiddle</name><operator>-&gt;</operator><name>val</name></name> <operator>==</operator> <name>symbol</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>(</operator><operator>*</operator><name>level</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>StopMiddle</name><operator>-&gt;</operator><name>naff</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>StopMiddle</name></expr>;</return></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>StopMiddle</name><operator>-&gt;</operator><name>node</name></name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>StopMiddle</name><operator>-&gt;</operator><name>val</name></name> <operator>&lt;</operator> <name>symbol</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>StopLow</name> <operator>=</operator> <name>StopMiddle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>StopHigh</name> <operator>=</operator> <name>StopMiddle</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>StopLow</name> <operator>&gt;=</operator> <name>StopHigh</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>CheckAffix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>AFFIX</name> <modifier>*</modifier></type><name>Affix</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flagflags</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>newword</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>baselen</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/*
     * Check compound allow flags
     */</comment>

    <if_stmt><if>if <condition>(<expr><name>flagflags</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>Affix</name><operator>-&gt;</operator><name>flagflags</name></name> <operator>&amp;</operator> <name>FF_COMPOUNDONLY</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>flagflags</name> <operator>&amp;</operator> <name>FF_COMPOUNDBEGIN</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>Affix</name><operator>-&gt;</operator><name>flagflags</name></name> <operator>&amp;</operator> <name>FF_COMPOUNDFORBIDFLAG</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>Affix</name><operator>-&gt;</operator><name>flagflags</name></name> <operator>&amp;</operator> <name>FF_COMPOUNDBEGIN</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name><name>Affix</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>FF_SUFFIX</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>flagflags</name> <operator>&amp;</operator> <name>FF_COMPOUNDMIDDLE</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>Affix</name><operator>-&gt;</operator><name>flagflags</name></name> <operator>&amp;</operator> <name>FF_COMPOUNDMIDDLE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
            <operator>(</operator><name><name>Affix</name><operator>-&gt;</operator><name>flagflags</name></name> <operator>&amp;</operator> <name>FF_COMPOUNDFORBIDFLAG</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>flagflags</name> <operator>&amp;</operator> <name>FF_COMPOUNDLAST</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>Affix</name><operator>-&gt;</operator><name>flagflags</name></name> <operator>&amp;</operator> <name>FF_COMPOUNDFORBIDFLAG</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>Affix</name><operator>-&gt;</operator><name>flagflags</name></name> <operator>&amp;</operator> <name>FF_COMPOUNDLAST</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name><name>Affix</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>FF_PREFIX</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * make replace pattern of affix
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>Affix</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>FF_SUFFIX</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>newword</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>newword</name> <operator>+</operator> <name>len</name> <operator>-</operator> <name><name>Affix</name><operator>-&gt;</operator><name>replen</name></name></expr></argument>, <argument><expr><name><name>Affix</name><operator>-&gt;</operator><name>find</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>baselen</name></expr>)</condition><block type="pseudo"><block_content>            <comment type="block">/* store length of non-changed part of word */</comment>
            <expr_stmt><expr><operator>*</operator><name>baselen</name> <operator>=</operator> <name>len</name> <operator>-</operator> <name><name>Affix</name><operator>-&gt;</operator><name>replen</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * if prefix is an all non-changed part's length then all word
         * contains only prefix and suffix, so out
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>baselen</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>baselen</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>Affix</name><operator>-&gt;</operator><name>find</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name><name>Affix</name><operator>-&gt;</operator><name>replen</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>newword</name></expr></argument>, <argument><expr><name><name>Affix</name><operator>-&gt;</operator><name>find</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>newword</name></expr></argument>, <argument><expr><name>word</name> <operator>+</operator> <name><name>Affix</name><operator>-&gt;</operator><name>replen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * check resulting word
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>Affix</name><operator>-&gt;</operator><name>issimple</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>newword</name></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>Affix</name><operator>-&gt;</operator><name>isregis</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>RS_execute</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>Affix</name><operator>-&gt;</operator><name>reg</name><operator>.</operator><name>regis</name></name><operator>)</operator></expr></argument>, <argument><expr><name>newword</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>newword</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>err</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>pg_wchar</name>   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type>        <name>data_len</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>newword_len</name></decl>;</decl_stmt>

        <comment type="block">/* Convert data string to wide characters */</comment>
        <expr_stmt><expr><name>newword_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>newword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>pg_wchar</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>newword_len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_wchar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>data_len</name> <operator>=</operator> <call><name>pg_mb2wchar_with_len</name><argument_list>(<argument><expr><name>newword</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>newword_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>err</name> <operator>=</operator> <call><name>pg_regexec</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>Affix</name><operator>-&gt;</operator><name>reg</name><operator>.</operator><name>regex</name></name><operator>)</operator></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>data_len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>newword</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>addToResult</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>forms</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>cur</name> <operator>-</operator> <name>forms</name> <operator>&gt;=</operator> <name>MAX_NORM</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>forms</name> <operator>==</operator> <name>cur</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>cur</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>cur</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>cur</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>NormalizeSubWord</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>AffixNodeData</name> <modifier>*</modifier></type><name>suffix</name> <init>= <expr><name>NULL</name></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>prefix</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>slevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>plevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>wrdlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>,
                <decl><type ref="prev"/><name>swrdlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>forms</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>newword</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>MAXNORMLEN</name></expr>]</index></name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>pnewword</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>MAXNORMLEN</name></expr>]</index></name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AffixNode</name>  <modifier>*</modifier></type><name>snode</name> <init>= <expr><name><name>Conf</name><operator>-&gt;</operator><name>Suffix</name></name></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>pnode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>wrdlen</name> <operator>&gt;</operator> <name>MAXNORMLEN</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cur</name> <operator>=</operator> <name>forms</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MAX_NORM</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>cur</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>


    <comment type="block">/* Check that the word itself is normal form */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>FindWord</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>VoidString</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>cur</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cur</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>cur</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Find all other NORMAL forms of the 'word' (check only prefix) */</comment>
    <expr_stmt><expr><name>pnode</name> <operator>=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>Prefix</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>plevel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>pnode</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>FindAffixes</name><argument_list>(<argument><expr><name>pnode</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wrdlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>plevel</name></expr></argument>, <argument><expr><name>FF_PREFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>prefix</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>prefix</name><operator>-&gt;</operator><name>naff</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>CheckAffix</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>wrdlen</name></expr></argument>, <argument><expr><name><name>prefix</name><operator>-&gt;</operator><name>aff</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>newword</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* prefix success */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>FindWord</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>newword</name></expr></argument>, <argument><expr><name><name>prefix</name><operator>-&gt;</operator><name>aff</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>flag</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>cur</name> <operator>+=</operator> <call><name>addToResult</name><argument_list>(<argument><expr><name>forms</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>newword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>pnode</name> <operator>=</operator> <name><name>prefix</name><operator>-&gt;</operator><name>node</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * Find all other NORMAL forms of the 'word' (check suffix and then
     * prefix)
     */</comment>
    <while>while <condition>(<expr><name>snode</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>baselen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* find possible suffix */</comment>
        <expr_stmt><expr><name>suffix</name> <operator>=</operator> <call><name>FindAffixes</name><argument_list>(<argument><expr><name>snode</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wrdlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slevel</name></expr></argument>, <argument><expr><name>FF_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>suffix</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <comment type="block">/* foreach suffix check affix */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>suffix</name><operator>-&gt;</operator><name>naff</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>CheckAffix</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>wrdlen</name></expr></argument>, <argument><expr><name><name>suffix</name><operator>-&gt;</operator><name>aff</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>newword</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>baselen</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* suffix success */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>FindWord</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>newword</name></expr></argument>, <argument><expr><name><name>suffix</name><operator>-&gt;</operator><name>aff</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>flag</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>cur</name> <operator>+=</operator> <call><name>addToResult</name><argument_list>(<argument><expr><name>forms</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>newword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/* now we will look changed word with prefixes */</comment>
                <expr_stmt><expr><name>pnode</name> <operator>=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>Prefix</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>plevel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>swrdlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>newword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <while>while <condition>(<expr><name>pnode</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>FindAffixes</name><argument_list>(<argument><expr><name>pnode</name></expr></argument>, <argument><expr><name>newword</name></expr></argument>, <argument><expr><name>swrdlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>plevel</name></expr></argument>, <argument><expr><name>FF_PREFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>prefix</name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>prefix</name><operator>-&gt;</operator><name>naff</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name>CheckAffix</name><argument_list>(<argument><expr><name>newword</name></expr></argument>, <argument><expr><name>swrdlen</name></expr></argument>, <argument><expr><name><name>prefix</name><operator>-&gt;</operator><name>aff</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>pnewword</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>baselen</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/* prefix success */</comment>
                            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ff</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>prefix</name><operator>-&gt;</operator><name>aff</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>flagflags</name> <operator>&amp;</operator> <name><name>suffix</name><operator>-&gt;</operator><name>aff</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>flagflags</name> <operator>&amp;</operator> <name>FF_CROSSPRODUCT</name><operator>)</operator></expr> ?</condition><then>
                            <expr><name>VoidString</name></expr> </then><else>: <expr><name><name>prefix</name><operator>-&gt;</operator><name>aff</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>flag</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><call><name>FindWord</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>pnewword</name></expr></argument>, <argument><expr><name>ff</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>cur</name> <operator>+=</operator> <call><name>addToResult</name><argument_list>(<argument><expr><name>forms</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>pnewword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                    <expr_stmt><expr><name>pnode</name> <operator>=</operator> <name><name>prefix</name><operator>-&gt;</operator><name>node</name></name></expr>;</expr_stmt>
                </block_content>}</block></while>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name>snode</name> <operator>=</operator> <name><name>suffix</name><operator>-&gt;</operator><name>node</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>cur</name> <operator>==</operator> <name>forms</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>forms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><operator>(</operator><name>forms</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>SplitVar</name>
<block>{
    <decl_stmt><decl><type><name>int</name></type>            <name>nstem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>lenstem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>stem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>SplitVar</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
}</block></struct></type> <name>SplitVar</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>CheckCompoundAffixes</name><parameter_list>(<parameter><decl><type><name>CMPDAffix</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>CheckInPlace</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>issuffix</name></decl>;</decl_stmt>

    <comment type="block">/* in case CompoundAffix is null: */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>CheckInPlace</name></expr>)</condition>
    <block>{<block_content>
        <while>while <condition>(<expr><name><operator>(</operator><operator>*</operator><name>ptr</name><operator>)</operator><operator>-&gt;</operator><name>affix</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name><operator>(</operator><operator>*</operator><name>ptr</name><operator>)</operator><operator>-&gt;</operator><name>len</name></name> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>ptr</name><operator>)</operator><operator>-&gt;</operator><name>affix</name></name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>ptr</name><operator>)</operator><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>len</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>ptr</name><operator>)</operator><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>issuffix</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>ptr</name><operator>)</operator><operator>-&gt;</operator><name>issuffix</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>(</operator><operator>*</operator><name>ptr</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
                <return>return <expr><ternary><condition><expr><operator>(</operator><name>issuffix</name><operator>)</operator></expr> ?</condition><then> <expr><name>len</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>ptr</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>affbegin</name></decl>;</decl_stmt>

        <while>while <condition>(<expr><name><operator>(</operator><operator>*</operator><name>ptr</name><operator>)</operator><operator>-&gt;</operator><name>affix</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name><operator>(</operator><operator>*</operator><name>ptr</name><operator>)</operator><operator>-&gt;</operator><name>len</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>affbegin</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>ptr</name><operator>)</operator><operator>-&gt;</operator><name>affix</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>len</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>ptr</name><operator>)</operator><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <operator>(</operator><name>affbegin</name> <operator>-</operator> <name>word</name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>issuffix</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>ptr</name><operator>)</operator><operator>-&gt;</operator><name>issuffix</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>(</operator><operator>*</operator><name>ptr</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
                <return>return <expr><ternary><condition><expr><operator>(</operator><name>issuffix</name><operator>)</operator></expr> ?</condition><then> <expr><name>len</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>ptr</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SplitVar</name> <modifier>*</modifier></type>
<name>CopyVar</name><parameter_list>(<parameter><decl><type><name>SplitVar</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>makedup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SplitVar</name>   <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>SplitVar</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SplitVar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>lenstem</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>lenstem</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>stem</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>v</name><operator>-&gt;</operator><name>lenstem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nstem</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>nstem</name></name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nstem</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>stem</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>makedup</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>stem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>s</name><operator>-&gt;</operator><name>stem</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>lenstem</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>stem</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>v</name><operator>-&gt;</operator><name>lenstem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nstem</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddStem</name><parameter_list>(<parameter><decl><type><name>SplitVar</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>nstem</name></name> <operator>&gt;=</operator> <name><name>v</name><operator>-&gt;</operator><name>lenstem</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>lenstem</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>stem</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>stem</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>v</name><operator>-&gt;</operator><name>lenstem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>stem</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>nstem</name></name></expr>]</index></name> <operator>=</operator> <name>word</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nstem</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SplitVar</name> <modifier>*</modifier></type>
<name>SplitToVariants</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><name>SPNode</name> <modifier>*</modifier></type><name>snode</name></decl></parameter>, <parameter><decl><type><name>SplitVar</name> <modifier>*</modifier></type><name>orig</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wordlen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startpos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minpos</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>SplitVar</name>   <modifier>*</modifier></type><name>var</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SPNodeData</name> <modifier>*</modifier></type><name>StopLow</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>StopHigh</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>StopMiddle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SPNode</name>       <modifier>*</modifier></type><name>node</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>snode</name><operator>)</operator></expr> ?</condition><then> <expr><name>snode</name></expr> </then><else>: <expr><name><name>Conf</name><operator>-&gt;</operator><name>Dictionary</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>level</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>snode</name><operator>)</operator></expr> ?</condition><then> <expr><name>minpos</name></expr> </then><else>: <expr><name>startpos</name></expr></else></ternary></expr></init></decl>;</decl_stmt>    <comment type="block">/* recursive
                                                         * minpos==level */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>lenaff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CMPDAffix</name>  <modifier>*</modifier></type><name>caff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>notprobed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>compoundflag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>notprobed</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>wordlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>notprobed</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>wordlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>CopyVar</name><argument_list>(<argument><expr><name>orig</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>level</name> <operator>&lt;</operator> <name>wordlen</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* find word with epenthetic or/and compound affix */</comment>
        <expr_stmt><expr><name>caff</name> <operator>=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>CompoundAffix</name></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>level</name> <operator>&gt;</operator> <name>startpos</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>lenaff</name> <operator>=</operator> <call><name>CheckCompoundAffixes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>caff</name></expr></argument>, <argument><expr><name>word</name> <operator>+</operator> <name>level</name></expr></argument>, <argument><expr><name>wordlen</name> <operator>-</operator> <name>level</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>node</name><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * there is one of compound affixes, so check word for existings
             */</comment>
            <decl_stmt><decl><type><name>char</name></type>        <name><name>buf</name><index>[<expr><name>MAXNORMLEN</name></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>subres</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>lenaff</name> <operator>=</operator> <name>level</name> <operator>-</operator> <name>startpos</name> <operator>+</operator> <name>lenaff</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>notprobed</name><index>[<expr><name>startpos</name> <operator>+</operator> <name>lenaff</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>level</name> <operator>+</operator> <name>lenaff</name> <operator>-</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name>minpos</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>lenaff</name> <operator>&gt;=</operator> <name>MAXNORMLEN</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>        <comment type="block">/* skip too big value */</comment>
            <if_stmt><if>if <condition>(<expr><name>lenaff</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>word</name> <operator>+</operator> <name>startpos</name></expr></argument>, <argument><expr><name>lenaff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><name>lenaff</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>compoundflag</name> <operator>=</operator> <name>FF_COMPOUNDBEGIN</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>level</name> <operator>==</operator> <name>wordlen</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>compoundflag</name> <operator>=</operator> <name>FF_COMPOUNDLAST</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>compoundflag</name> <operator>=</operator> <name>FF_COMPOUNDMIDDLE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><name>subres</name> <operator>=</operator> <call><name>NormalizeSubWord</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>compoundflag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>subres</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Yes, it was a word from dictionary */</comment>
                <decl_stmt><decl><type><name>SplitVar</name>   <modifier>*</modifier></type><name>new</name> <init>= <expr><call><name>CopyVar</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>SplitVar</name>   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>var</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>sptr</name> <init>= <expr><name>subres</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>notprobed</name><index>[<expr><name>startpos</name> <operator>+</operator> <name>lenaff</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

                <while>while <condition>(<expr><operator>*</operator><name>sptr</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>AddStem</name><argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><operator>*</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>sptr</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></while>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>subres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <while>while <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></while>
                <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <call><name>SplitToVariants</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>new</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wordlen</name></expr></argument>, <argument><expr><name>startpos</name> <operator>+</operator> <name>lenaff</name></expr></argument>, <argument><expr><name>startpos</name> <operator>+</operator> <name>lenaff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>new</name><operator>-&gt;</operator><name>stem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>StopLow</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>StopHigh</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>node</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>StopLow</name> <operator>&lt;</operator> <name>StopHigh</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>StopMiddle</name> <operator>=</operator> <name>StopLow</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>StopHigh</name> <operator>-</operator> <name>StopLow</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>StopMiddle</name><operator>-&gt;</operator><name>val</name></name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>word</name><operator>)</operator><operator>)</operator><index>[<expr><name>level</name></expr>]</index></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>StopMiddle</name><operator>-&gt;</operator><name>val</name></name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>word</name><operator>)</operator><operator>)</operator><index>[<expr><name>level</name></expr>]</index></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>StopLow</name> <operator>=</operator> <name>StopMiddle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>StopHigh</name> <operator>=</operator> <name>StopMiddle</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></while>

        <if_stmt><if>if <condition>(<expr><name>StopLow</name> <operator>&lt;</operator> <name>StopHigh</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>startpos</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>compoundflag</name> <operator>=</operator> <name>FF_COMPOUNDBEGIN</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>level</name> <operator>==</operator> <name>wordlen</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>compoundflag</name> <operator>=</operator> <name>FF_COMPOUNDLAST</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>compoundflag</name> <operator>=</operator> <name>FF_COMPOUNDMIDDLE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/* find infinitive */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>StopMiddle</name><operator>-&gt;</operator><name>isword</name></name> <operator>&amp;&amp;</operator>
                <operator>(</operator><name><name>StopMiddle</name><operator>-&gt;</operator><name>compoundflag</name></name> <operator>&amp;</operator> <name>compoundflag</name><operator>)</operator> <operator>&amp;&amp;</operator>
                <name><name>notprobed</name><index>[<expr><name>level</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* ok, we found full compoundallowed word */</comment>
                <if_stmt><if>if <condition>(<expr><name>level</name> <operator>&gt;</operator> <name>minpos</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* and its length more than minimal */</comment>
                    <if_stmt><if>if <condition>(<expr><name>wordlen</name> <operator>==</operator> <name>level</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* well, it was last word */</comment>
                        <expr_stmt><expr><call><name>AddStem</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><call><name>pnstrdup</name><argument_list>(<argument><expr><name>word</name> <operator>+</operator> <name>startpos</name></expr></argument>, <argument><expr><name>wordlen</name> <operator>-</operator> <name>startpos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>notprobed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><name>var</name></expr>;</return>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="block">/* then we will search more big word at the same point */</comment>
                        <decl_stmt><decl><type><name>SplitVar</name>   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>var</name></expr></init></decl>;</decl_stmt>

                        <while>while <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></while>
                        <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <call><name>SplitToVariants</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wordlen</name></expr></argument>, <argument><expr><name>startpos</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* we can find next word */</comment>
                        <expr_stmt><expr><name>level</name><operator>++</operator></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>AddStem</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><call><name>pnstrdup</name><argument_list>(<argument><expr><name>word</name> <operator>+</operator> <name>startpos</name></expr></argument>, <argument><expr><name>level</name> <operator>-</operator> <name>startpos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>Conf</name><operator>-&gt;</operator><name>Dictionary</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>startpos</name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>StopMiddle</name><operator>-&gt;</operator><name>node</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>node</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>level</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>AddStem</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><call><name>pnstrdup</name><argument_list>(<argument><expr><name>word</name> <operator>+</operator> <name>startpos</name></expr></argument>, <argument><expr><name>wordlen</name> <operator>-</operator> <name>startpos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>notprobed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>var</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>addNorm</name><parameter_list>(<parameter><decl><type><name>TSLexeme</name> <modifier>*</modifier><modifier>*</modifier></type><name>lres</name></decl></parameter>, <parameter><decl><type><name>TSLexeme</name> <modifier>*</modifier><modifier>*</modifier></type><name>lcur</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>NVariant</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>lres</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>lcur</name> <operator>=</operator> <operator>*</operator><name>lres</name> <operator>=</operator> <operator>(</operator><name>TSLexeme</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MAX_NORM</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TSLexeme</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>lcur</name> <operator>-</operator> <operator>*</operator><name>lres</name> <operator>&lt;</operator> <name>MAX_NORM</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>lcur</name><operator>)</operator><operator>-&gt;</operator><name>lexeme</name></name> <operator>=</operator> <name>word</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>lcur</name><operator>)</operator><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>lcur</name><operator>)</operator><operator>-&gt;</operator><name>nvariant</name></name> <operator>=</operator> <name>NVariant</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>lcur</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>lcur</name><operator>)</operator><operator>-&gt;</operator><name>lexeme</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>TSLexeme</name> <modifier>*</modifier></type>
<name>NINormalizeWord</name><parameter_list>(<parameter><decl><type><name>IspellDict</name> <modifier>*</modifier></type><name>Conf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TSLexeme</name>   <modifier>*</modifier></type><name>lcur</name> <init>= <expr><name>NULL</name></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>lres</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16</name></type>        <name>NVariant</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>NormalizeSubWord</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>res</name></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>lcur</name> <operator>-</operator> <name>lres</name><operator>)</operator> <operator>&lt;</operator> <name>MAX_NORM</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>addNorm</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lres</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lcur</name></expr></argument>, <argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NVariant</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>Conf</name><operator>-&gt;</operator><name>usecompound</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>wordlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SplitVar</name>   <modifier>*</modifier></type><name>ptr</name></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>SplitToVariants</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wordlen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <while>while <condition>(<expr><name>var</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>nstem</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>subres</name> <init>= <expr><call><name>NormalizeSubWord</name><argument_list>(<argument><expr><name>Conf</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>stem</name><index>[<expr><name><name>var</name><operator>-&gt;</operator><name>nstem</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>FF_COMPOUNDLAST</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>subres</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>subptr</name> <init>= <expr><name>subres</name></expr></init></decl>;</decl_stmt>

                    <while>while <condition>(<expr><operator>*</operator><name>subptr</name></expr>)</condition>
                    <block>{<block_content>
                        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>var</name><operator>-&gt;</operator><name>nstem</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>addNorm</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lres</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lcur</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>subptr</name> <operator>==</operator> <name>subres</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>var</name><operator>-&gt;</operator><name>stem</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>stem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NVariant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></for>

                        <expr_stmt><expr><call><name>addNorm</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lres</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lcur</name></expr></argument>, <argument><expr><operator>*</operator><name>subptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NVariant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>subptr</name><operator>++</operator></expr>;</expr_stmt>
                        <expr_stmt><expr><name>NVariant</name><operator>++</operator></expr>;</expr_stmt>
                    </block_content>}</block></while>

                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>subres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>stem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>stem</name><index>[<expr><name><name>var</name><operator>-&gt;</operator><name>nstem</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>var</name><operator>-&gt;</operator><name>nstem</name></name> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>stem</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>stem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>stem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>var</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>lres</name></expr>;</return>
</block_content>}</block></function>
</unit>
