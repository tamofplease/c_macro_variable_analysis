<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/parser/parse_coerce.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * parse_coerce.c
 *        handle type coercions/conversions for parser
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/parser/parse_coerce.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_cast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>coerce_type_typmod</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                   <parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>targetTypMod</name></decl></parameter>,
                   <parameter><decl><type><name>CoercionForm</name></type> <name>cformat</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>,
                   <parameter><decl><type><name>bool</name></type> <name>isExplicit</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hideInputCoercion</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>hide_coercion_node</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>build_coercion_expression</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                          <parameter><decl><type><name>CoercionPathType</name></type> <name>pathtype</name></decl></parameter>,
                          <parameter><decl><type><name>Oid</name></type> <name>funcId</name></decl></parameter>,
                          <parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>targetTypMod</name></decl></parameter>,
                          <parameter><decl><type><name>CoercionForm</name></type> <name>cformat</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>,
                          <parameter><decl><type><name>bool</name></type> <name>isExplicit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>coerce_record_to_complex</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                         <parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>,
                         <parameter><decl><type><name>CoercionContext</name></type> <name>ccontext</name></decl></parameter>,
                         <parameter><decl><type><name>CoercionForm</name></type> <name>cformat</name></decl></parameter>,
                         <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_complex_array</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>typeIsOfTypedTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>reltypeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>reloftypeId</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * coerce_to_target_type()
 *        Convert an expression to a target type and typmod.
 *
 * This is the general-purpose entry point for arbitrary type coercion
 * operations.  Direct use of the component operations can_coerce_type,
 * coerce_type, and coerce_type_typmod should be restricted to special
 * cases (eg, when the conversion is expected to succeed).
 *
 * Returns the possibly-transformed expression tree, or NULL if the type
 * conversion is not possible.  (We do this, rather than ereport'ing directly,
 * so that callers can generate custom error messages indicating context.)
 *
 * pstate - parse state (can be NULL, see coerce_type)
 * expr - input expression tree (already transformed by transformExpr)
 * exprtype - result type of expr
 * targettype - desired result type
 * targettypmod - desired result typmod
 * ccontext, cformat - context indicators to control coercions
 * location - parse location of the coercion request, or -1 if unknown/implicit
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>coerce_to_target_type</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>exprtype</name></decl></parameter>,
                      <parameter><decl><type><name>Oid</name></type> <name>targettype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>targettypmod</name></decl></parameter>,
                      <parameter><decl><type><name>CoercionContext</name></type> <name>ccontext</name></decl></parameter>,
                      <parameter><decl><type><name>CoercionForm</name></type> <name>cformat</name></decl></parameter>,
                      <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>origexpr</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>can_coerce_type</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>exprtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targettype</name></expr></argument>, <argument><expr><name>ccontext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If the input has a CollateExpr at the top, strip it off, perform the
     * coercion, and put a new one back on.  This is annoying since it
     * duplicates logic in coerce_type, but if we don't do this then it's too
     * hard to tell whether coerce_type actually changed anything, and we
     * *must* know that to avoid possibly calling hide_coercion_node on
     * something that wasn't generated by coerce_type.  Note that if there are
     * multiple stacked CollateExprs, we just discard all but the topmost.
     */</comment>
    <expr_stmt><expr><name>origexpr</name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>coerce_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>exprtype</name></expr></argument>,
                         <argument><expr><name>targettype</name></expr></argument>, <argument><expr><name>targettypmod</name></expr></argument>,
                         <argument><expr><name>ccontext</name></expr></argument>, <argument><expr><name>cformat</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If the target is a fixed-length type, it may need a length coercion as
     * well as a type coercion.  If we find ourselves adding both, force the
     * inner coercion node to implicit display form.
     */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>coerce_type_typmod</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
                                <argument><expr><name>targettype</name></expr></argument>, <argument><expr><name>targettypmod</name></expr></argument>,
                                <argument><expr><name>cformat</name></expr></argument>, <argument><expr><name>location</name></expr></argument>,
                                <argument><expr><operator>(</operator><name>cformat</name> <operator>!=</operator> <name>COERCE_IMPLICIT_CAST</name><operator>)</operator></expr></argument>,
                                <argument><expr><operator>(</operator><name>result</name> <operator>!=</operator> <name>expr</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/* Do not need to do that on local Coordinator */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>expr</name> <operator>!=</operator> <name>origexpr</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Reinstall top CollateExpr */</comment>
        <decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>coll</name> <init>= <expr><operator>(</operator><name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>origexpr</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>newcoll</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>newcoll</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>result</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newcoll</name><operator>-&gt;</operator><name>collOid</name></name> <operator>=</operator> <name><name>coll</name><operator>-&gt;</operator><name>collOid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newcoll</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>coll</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newcoll</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * coerce_type()
 *        Convert an expression to a different type.
 *
 * The caller should already have determined that the coercion is possible;
 * see can_coerce_type.
 *
 * Normally, no coercion to a typmod (length) is performed here.  The caller
 * must call coerce_type_typmod as well, if a typmod constraint is wanted.
 * (But if the target type is a domain, it may internally contain a
 * typmod constraint, which will be applied inside coerce_to_domain.)
 * In some cases pg_cast specifies a type coercion function that also
 * applies length conversion, and in those cases only, the result will
 * already be properly coerced to the specified typmod.
 *
 * pstate is only used in the case that we are able to resolve the type of
 * a previously UNKNOWN Param.  It is okay to pass pstate = NULL if the
 * caller does not want type information updated for Params.
 *
 * Note: this function must not modify the given expression tree, only add
 * decoration on top of it.  See transformSetOperationTree, for example.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>coerce_type</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
            <parameter><decl><type><name>Oid</name></type> <name>inputTypeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>targetTypeMod</name></decl></parameter>,
            <parameter><decl><type><name>CoercionContext</name></type> <name>ccontext</name></decl></parameter>, <parameter><decl><type><name>CoercionForm</name></type> <name>cformat</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CoercionPathType</name></type> <name>pathtype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>funcId</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>==</operator> <name>inputTypeId</name> <operator>||</operator>
        <name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* no conversion needed */</comment>
        <return>return <expr><name>node</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>==</operator> <name>ANYOID</name> <operator>||</operator>
        <name>targetTypeId</name> <operator>==</operator> <name>ANYELEMENTOID</name> <operator>||</operator>
        <name>targetTypeId</name> <operator>==</operator> <name>ANYNONARRAYOID</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Assume can_coerce_type verified that implicit coercion is okay.
         *
         * Note: by returning the unmodified node here, we are saying that
         * it's OK to treat an UNKNOWN constant as a valid input for a
         * function accepting ANY, ANYELEMENT, or ANYNONARRAY.  This should be
         * all right, since an UNKNOWN value is still a perfectly valid Datum.
         *
         * NB: we do NOT want a RelabelType here: the exposed type of the
         * function argument must be its actual type, not the polymorphic
         * pseudotype.
         */</comment>
        <return>return <expr><name>node</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>==</operator> <name>ANYARRAYOID</name> <operator>||</operator>
        <name>targetTypeId</name> <operator>==</operator> <name>ANYENUMOID</name> <operator>||</operator>
        <name>targetTypeId</name> <operator>==</operator> <name>ANYRANGEOID</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Assume can_coerce_type verified that implicit coercion is okay.
         *
         * These cases are unlike the ones above because the exposed type of
         * the argument must be an actual array, enum, or range type.  In
         * particular the argument must *not* be an UNKNOWN constant.  If it
         * is, we just fall through; below, we'll call anyarray_in,
         * anyenum_in, or anyrange_in, which will produce an error.  Also, if
         * what we have is a domain over array, enum, or range, we have to
         * relabel it to its base type.
         *
         * Note: currently, we can't actually see a domain-over-enum here,
         * since the other functions in this file will not match such a
         * parameter to ANYENUM.  But that should get changed eventually.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>baseTypeId</name> <init>= <expr><call><name>getBaseType</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>baseTypeId</name> <operator>!=</operator> <name>inputTypeId</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>makeRelabelType</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                 <argument><expr><name>baseTypeId</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                                                 <argument><expr><name>InvalidOid</name></expr></argument>,
                                                 <argument><expr><name>cformat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
                <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>r</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* Not a domain type, so return it as-is */</comment>
            <return>return <expr><name>node</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>==</operator> <name>UNKNOWNOID</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Input is a string constant with previously undetermined type. Apply
         * the target type's typinput function to it to produce a constant of
         * the target type.
         *
         * NOTE: this case cannot be folded together with the other
         * constant-input case, since the typinput function does not
         * necessarily behave the same as a type conversion function. For
         * example, int4's typinput function will reject "1.2", whereas
         * float-to-int type conversion will round to integer.
         *
         * XXX if the typinput function is not immutable, we really ought to
         * postpone evaluation of the function call until runtime. But there
         * is no way to represent a typinput function call as an expression
         * tree, because C-string values are not Datums. (XXX This *is*
         * possible as of 7.3, do we want to do it?)
         */</comment>
        <decl_stmt><decl><type><name>Const</name>       <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Const</name>       <modifier>*</modifier></type><name>newcon</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>baseTypeId</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>baseTypeMod</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>inputTypeMod</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Type</name></type>        <name>baseType</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ParseCallbackState</name></type> <name>pcbstate</name></decl>;</decl_stmt>

        <comment type="block">/*
         * If the target type is a domain, we want to call its base type's
         * input routine, not domain_in().  This is to avoid premature failure
         * when the domain applies a typmod: existing input routines follow
         * implicit-coercion semantics for length checks, which is not always
         * what we want here.  The needed check will be applied properly
         * inside coerce_to_domain().
         */</comment>
        <expr_stmt><expr><name>baseTypeMod</name> <operator>=</operator> <name>targetTypeMod</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>baseTypeId</name> <operator>=</operator> <call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>baseTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * For most types we pass typmod -1 to the input routine, because
         * existing input routines follow implicit-coercion semantics for
         * length checks, which is not always what we want here.  Any length
         * constraint will be applied later by our caller.  An exception
         * however is the INTERVAL type, for which we *must* pass the typmod
         * or it won't be able to obey the bizarre SQL-spec input rules. (Ugly
         * as sin, but so is this part of the spec...)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>baseTypeId</name> <operator>==</operator> <name>INTERVALOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>inputTypeMod</name> <operator>=</operator> <name>baseTypeMod</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>inputTypeMod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>baseType</name> <operator>=</operator> <call><name>typeidType</name><argument_list>(<argument><expr><name>baseTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>consttype</name></name> <operator>=</operator> <name>baseTypeId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>consttypmod</name></name> <operator>=</operator> <name>inputTypeMod</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>constcollid</name></name> <operator>=</operator> <call><name>typeTypeCollation</name><argument_list>(<argument><expr><name>baseType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>constlen</name></name> <operator>=</operator> <call><name>typeLen</name><argument_list>(<argument><expr><name>baseType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>constbyval</name></name> <operator>=</operator> <call><name>typeByVal</name><argument_list>(<argument><expr><name>baseType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * We use the original literal's location regardless of the position
         * of the coercion.  This is a change from pre-9.2 behavior, meant to
         * simplify life for pg_stat_statements.
         */</comment>
        <expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * Set up to point at the constant's text if the input routine throws
         * an error.
         */</comment>
        <expr_stmt><expr><call><name>setup_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We assume here that UNKNOWN's internal representation is the same
         * as CSTRING.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>stringTypeDatum</name><argument_list>(<argument><expr><name>baseType</name></expr></argument>,
                                                 <argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                                 <argument><expr><name>inputTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>stringTypeDatum</name><argument_list>(<argument><expr><name>baseType</name></expr></argument>,
                                                 <argument><expr><name>NULL</name></expr></argument>,
                                                 <argument><expr><name>inputTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * If it's a varlena value, force it to be in non-expanded
         * (non-toasted) format; this avoids any possible dependency on
         * external values and improves consistency of representation.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>&amp;&amp;</operator> <name><name>newcon</name><operator>-&gt;</operator><name>constlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator>
                <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name><name>newcon</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RANDOMIZE_ALLOCATED_MEMORY</name></cpp:ifdef>

        <comment type="block">/*
         * For pass-by-reference data types, repeat the conversion to see if
         * the input function leaves any uninitialized bytes in the result. We
         * can only detect that reliably if RANDOMIZE_ALLOCATED_MEMORY is
         * enabled, so we don't bother testing otherwise.  The reason we don't
         * want any instability in the input function is that comparison of
         * Const nodes relies on bytewise comparison of the datums, so if the
         * input function leaves garbage then subexpressions that should be
         * identical may not get recognized as such.  See pgsql-hackers
         * discussion of 2008-04-04.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>newcon</name><operator>-&gt;</operator><name>constbyval</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Datum</name></type>        <name>val2</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>val2</name> <operator>=</operator> <call><name>stringTypeDatum</name><argument_list>(<argument><expr><name>baseType</name></expr></argument>,
                                   <argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>inputTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>newcon</name><operator>-&gt;</operator><name>constlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>val2</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>val2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>datumIsEqual</name><argument_list>(<argument><expr><name><name>newcon</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>, <argument><expr><name>val2</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>newcon</name><operator>-&gt;</operator><name>constlen</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"type %s has unstable input conversion for \"%s\""</literal></expr></argument>,
                     <argument><expr><call><name>typeTypeName</name><argument_list>(<argument><expr><name>baseType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>cancel_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newcon</name></expr>;</expr_stmt>

        <comment type="block">/* If target is a domain, apply constraints. */</comment>
        <if_stmt><if>if <condition>(<expr><name>baseTypeId</name> <operator>!=</operator> <name>targetTypeId</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>coerce_to_domain</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
                                      <argument><expr><name>baseTypeId</name></expr></argument>, <argument><expr><name>baseTypeMod</name></expr></argument>,
                                      <argument><expr><name>targetTypeId</name></expr></argument>,
                                      <argument><expr><name>cformat</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>baseType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <name>pstate</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_coerce_param_hook</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Allow the CoerceParamHook to decide what happens.  It can return a
         * transformed node (very possibly the same Param node), or return
         * NULL to indicate we should proceed with normal coercion.
         */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>pstate</name><operator>-&gt;</operator><name>p_coerce_param_hook</name></name>) <argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                                 <argument><expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                 <argument><expr><name>targetTypeId</name></expr></argument>,
                                                 <argument><expr><name>targetTypeMod</name></expr></argument>,
                                                 <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If we have a COLLATE clause, we have to push the coercion
         * underneath the COLLATE.  This is really ugly, but there is little
         * choice because the above hacks on Consts and Params wouldn't happen
         * otherwise.  This kluge has consequences in coerce_to_target_type.
         */</comment>
        <decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>coll</name> <init>= <expr><operator>(</operator><name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>newcoll</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>newcoll</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
            <call><name>coerce_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>coll</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>,
                        <argument><expr><name>inputTypeId</name></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><name>targetTypeMod</name></expr></argument>,
                        <argument><expr><name>ccontext</name></expr></argument>, <argument><expr><name>cformat</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newcoll</name><operator>-&gt;</operator><name>collOid</name></name> <operator>=</operator> <name><name>coll</name><operator>-&gt;</operator><name>collOid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newcoll</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>coll</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newcoll</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pathtype</name> <operator>=</operator> <call><name>find_coercion_pathway</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><name>inputTypeId</name></expr></argument>, <argument><expr><name>ccontext</name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>funcId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>pathtype</name> <operator>!=</operator> <name>COERCION_PATH_NONE</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>pathtype</name> <operator>!=</operator> <name>COERCION_PATH_RELABELTYPE</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Generate an expression tree representing run-time application
             * of the conversion function.  If we are dealing with a domain
             * target type, the conversion function will yield the base type,
             * and we need to extract the correct typmod to use from the
             * domain's typtypmod.
             */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>baseTypeId</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name></type>        <name>baseTypeMod</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>baseTypeMod</name> <operator>=</operator> <name>targetTypeMod</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>baseTypeId</name> <operator>=</operator> <call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>baseTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>build_coercion_expression</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>pathtype</name></expr></argument>, <argument><expr><name>funcId</name></expr></argument>,
                                               <argument><expr><name>baseTypeId</name></expr></argument>, <argument><expr><name>baseTypeMod</name></expr></argument>,
                                               <argument><expr><name>cformat</name></expr></argument>, <argument><expr><name>location</name></expr></argument>,
                                               <argument><expr><operator>(</operator><name>cformat</name> <operator>!=</operator> <name>COERCE_IMPLICIT_CAST</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If domain, coerce to the domain type and relabel with domain
             * type ID.  We can skip the internal length-coercion step if the
             * selected coercion function was a type-and-length coercion.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>!=</operator> <name>baseTypeId</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>coerce_to_domain</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>baseTypeId</name></expr></argument>, <argument><expr><name>baseTypeMod</name></expr></argument>,
                                          <argument><expr><name>targetTypeId</name></expr></argument>,
                                          <argument><expr><name>cformat</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                          <argument><expr><call><name>exprIsLengthCoercion</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
                                                               <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * We don't need to do a physical conversion, but we do need to
             * attach a RelabelType node so that the expression will be seen
             * to have the intended type when inspected by higher-level code.
             *
             * Also, domains may have value restrictions beyond the base type
             * that must be accounted for.  If the destination is a domain
             * then we won't need a RelabelType node.
             */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>coerce_to_domain</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>,
                                      <argument><expr><name>cformat</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>node</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * XXX could we label result with exprTypmod(node) instead of
                 * default -1 typmod, to save a possible length-coercion
                 * later? Would work if both types have same interpretation of
                 * typmod, which is likely but not certain.
                 */</comment>
                <decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>makeRelabelType</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>result</name></expr></argument>,
                                                 <argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                                                 <argument><expr><name>InvalidOid</name></expr></argument>,
                                                 <argument><expr><name>cformat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>r</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator>
        <call><name>ISCOMPLEX</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Coerce a RECORD to a specific complex type */</comment>
        <return>return <expr><call><name>coerce_record_to_complex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>,
                                        <argument><expr><name>ccontext</name></expr></argument>, <argument><expr><name>cformat</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator>
        <call><name>ISCOMPLEX</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Coerce a specific complex type to RECORD */</comment>
        <comment type="block">/* NB: we do NOT want a RelabelType here */</comment>
        <return>return <expr><name>node</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>==</operator> <name>RECORDARRAYOID</name> <operator>&amp;&amp;</operator>
        <call><name>is_complex_array</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Coerce record[] to a specific complex array type */</comment>
        <comment type="block">/* not implemented yet ... */</comment>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>==</operator> <name>RECORDARRAYOID</name> <operator>&amp;&amp;</operator>
        <call><name>is_complex_array</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Coerce a specific complex array type to record[] */</comment>
        <comment type="block">/* NB: we do NOT want a RelabelType here */</comment>
        <return>return <expr><name>node</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>typeInheritsFrom</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call>
        <operator>||</operator> <call><name>typeIsOfTypedTable</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Input class type is a subclass of target, so generate an
         * appropriate runtime conversion (removing unneeded columns and
         * possibly rearranging the ones that are wanted).
         */</comment>
        <decl_stmt><decl><type><name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ConvertRowtypeExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name>targetTypeId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>convertformat</name></name> <operator>=</operator> <name>cformat</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>r</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* If we get here, caller blew it */</comment>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to find conversion function from %s to %s"</literal></expr></argument>,
         <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>                <comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * can_coerce_type()
 *        Can input_typeids be coerced to target_typeids?
 *
 * We must be told the context (CAST construct, assignment, implicit coercion)
 * as this determines the set of available casts.
 */</comment>
<function><type><name>bool</name></type>
<name>can_coerce_type</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>input_typeids</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>target_typeids</name></decl></parameter>,
                <parameter><decl><type><name>CoercionContext</name></type> <name>ccontext</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>have_generics</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* run through argument list... */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>inputTypeId</name> <init>= <expr><name><name>input_typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>targetTypeId</name> <init>= <expr><name><name>target_typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CoercionPathType</name></type> <name>pathtype</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>funcId</name></decl>;</decl_stmt>

        <comment type="block">/* no problem if same type */</comment>
        <if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>==</operator> <name>targetTypeId</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* accept if target is ANY */</comment>
        <if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>==</operator> <name>ANYOID</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* accept if target is polymorphic, for now */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>have_generics</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>    <comment type="block">/* do more checking later */</comment>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If input is an untyped string constant, assume we can convert it to
         * anything.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * If pg_cast shows that we can coerce, accept.  This test now covers
         * both binary-compatible and coercion-function cases.
         */</comment>
        <expr_stmt><expr><name>pathtype</name> <operator>=</operator> <call><name>find_coercion_pathway</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><name>inputTypeId</name></expr></argument>, <argument><expr><name>ccontext</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>funcId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>pathtype</name> <operator>!=</operator> <name>COERCION_PATH_NONE</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * If input is RECORD and target is a composite type, assume we can
         * coerce (may need tighter checking here)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator>
            <call><name>ISCOMPLEX</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * If input is a composite type and target is RECORD, accept
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator>
            <call><name>ISCOMPLEX</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>                    <comment type="block">/* not implemented yet */</comment>

        <comment type="block">/*
         * If input is record[] and target is a composite array type, assume
         * we can coerce (may need tighter checking here)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>==</operator> <name>RECORDARRAYOID</name> <operator>&amp;&amp;</operator>
            <call><name>is_complex_array</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * If input is a composite array type and target is record[], accept
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>==</operator> <name>RECORDARRAYOID</name> <operator>&amp;&amp;</operator>
            <call><name>is_complex_array</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * If input is a class type that inherits from target, accept
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>typeInheritsFrom</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call>
            <operator>||</operator> <call><name>typeIsOfTypedTable</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Else, cannot coerce at this argument position
         */</comment>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></for>

    <comment type="block">/* If we found any generic argument types, cross-check them */</comment>
    <if_stmt><if>if <condition>(<expr><name>have_generics</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_generic_type_consistency</name><argument_list>(<argument><expr><name>input_typeids</name></expr></argument>, <argument><expr><name>target_typeids</name></expr></argument>,
                                            <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Create an expression tree to represent coercion to a domain type.
 *
 * 'arg': input expression
 * 'baseTypeId': base type of domain, if known (pass InvalidOid if caller
 *        has not bothered to look this up)
 * 'baseTypeMod': base type typmod of domain, if known (pass -1 if caller
 *        has not bothered to look this up)
 * 'typeId': target type to coerce to
 * 'cformat': coercion format
 * 'location': coercion request location
 * 'hideInputCoercion': if true, hide the input coercion under this one.
 * 'lengthCoercionDone': if true, caller already accounted for length,
 *        ie the input is already of baseTypMod as well as baseTypeId.
 *
 * If the target type isn't a domain, the given 'arg' is returned as-is.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>coerce_to_domain</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>baseTypeId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>baseTypeMod</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>,
                 <parameter><decl><type><name>CoercionForm</name></type> <name>cformat</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>,
                 <parameter><decl><type><name>bool</name></type> <name>hideInputCoercion</name></decl></parameter>,
                 <parameter><decl><type><name>bool</name></type> <name>lengthCoercionDone</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <comment type="block">/* Get the base type if it hasn't been supplied */</comment>
    <if_stmt><if>if <condition>(<expr><name>baseTypeId</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>baseTypeId</name> <operator>=</operator> <call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>baseTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If it isn't a domain, return the node as it was passed in */</comment>
    <if_stmt><if>if <condition>(<expr><name>baseTypeId</name> <operator>==</operator> <name>typeId</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>arg</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Suppress display of nested coercion steps */</comment>
    <if_stmt><if>if <condition>(<expr><name>hideInputCoercion</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>hide_coercion_node</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If the domain applies a typmod to its base type, build the appropriate
     * coercion step.  Mark it implicit for display purposes, because we don't
     * want it shown separately by ruleutils.c; but the isExplicit flag passed
     * to the conversion function depends on the manner in which the domain
     * coercion is invoked, so that the semantics of implicit and explicit
     * coercion differ.  (Is that really the behavior we want?)
     *
     * NOTE: because we apply this as part of the fixed expression structure,
     * ALTER DOMAIN cannot alter the typtypmod.  But it's unclear that that
     * would be safe to do anyway, without lots of knowledge about what the
     * base type thinks the typmod means.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lengthCoercionDone</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>baseTypeMod</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>coerce_type_typmod</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>baseTypeId</name></expr></argument>, <argument><expr><name>baseTypeMod</name></expr></argument>,
                                     <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>, <argument><expr><name>location</name></expr></argument>,
                                     <argument><expr><operator>(</operator><name>cformat</name> <operator>!=</operator> <name>COERCE_IMPLICIT_CAST</name><operator>)</operator></expr></argument>,
                                     <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Now build the domain coercion node.  This represents run-time checking
     * of any constraints currently attached to the domain.  This also ensures
     * that the expression is properly labeled as to result type.
     */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name>typeId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>resulttypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* currently, always -1 for domains */</comment>
    <comment type="block">/* resultcollid will be set by parse_collate.c */</comment>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>coercionformat</name></name> <operator>=</operator> <name>cformat</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * coerce_type_typmod()
 *        Force a value to a particular typmod, if meaningful and possible.
 *
 * This is applied to values that are going to be stored in a relation
 * (where we have an atttypmod for the column) as well as values being
 * explicitly CASTed (where the typmod comes from the target type spec).
 *
 * The caller must have already ensured that the value is of the correct
 * type, typically by applying coerce_type.
 *
 * cformat determines the display properties of the generated node (if any),
 * while isExplicit may affect semantics.  If hideInputCoercion is true
 * *and* we generate a node, the input node is forced to IMPLICIT display
 * form, so that only the typmod coercion node will be visible when
 * displaying the expression.
 *
 * NOTE: this does not need to work on domain types, because any typmod
 * coercion for a domain is considered to be part of the type coercion
 * needed to produce the domain value in the first place.  So, no getBaseType.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>coerce_type_typmod</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>targetTypMod</name></decl></parameter>,
                   <parameter><decl><type><name>CoercionForm</name></type> <name>cformat</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>,
                   <parameter><decl><type><name>bool</name></type> <name>isExplicit</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hideInputCoercion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CoercionPathType</name></type> <name>pathtype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>funcId</name></decl>;</decl_stmt>

    <comment type="block">/*
     * A negative typmod is assumed to mean that no coercion is wanted. Also,
     * skip coercion if already done.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>targetTypMod</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>targetTypMod</name> <operator>==</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>pathtype</name> <operator>=</operator> <call><name>find_typmod_coercion_function</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>funcId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>pathtype</name> <operator>!=</operator> <name>COERCION_PATH_NONE</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Suppress display of nested coercion steps */</comment>
        <if_stmt><if>if <condition>(<expr><name>hideInputCoercion</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>hide_coercion_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>build_coercion_expression</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>pathtype</name></expr></argument>, <argument><expr><name>funcId</name></expr></argument>,
                                         <argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><name>targetTypMod</name></expr></argument>,
                                         <argument><expr><name>cformat</name></expr></argument>, <argument><expr><name>location</name></expr></argument>,
                                         <argument><expr><name>isExplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Mark a coercion node as IMPLICIT so it will never be displayed by
 * ruleutils.c.  We use this when we generate a nest of coercion nodes
 * to implement what is logically one conversion; the inner nodes are
 * forced to IMPLICIT_CAST format.  This does not change their semantics,
 * only display behavior.
 *
 * It is caller error to call this on something that doesn't have a
 * CoercionForm field.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>hide_coercion_node</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>funcformat</name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>relabelformat</name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CoerceViaIO</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>coerceformat</name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ArrayCoerceExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>coerceformat</name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ConvertRowtypeExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>ConvertRowtypeExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>convertformat</name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>row_format</name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>coercionformat</name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * build_coercion_expression()
 *        Construct an expression tree for applying a pg_cast entry.
 *
 * This is used for both type-coercion and length-coercion operations,
 * since there is no difference in terms of the calling convention.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>build_coercion_expression</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                          <parameter><decl><type><name>CoercionPathType</name></type> <name>pathtype</name></decl></parameter>,
                          <parameter><decl><type><name>Oid</name></type> <name>funcId</name></decl></parameter>,
                          <parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>targetTypMod</name></decl></parameter>,
                          <parameter><decl><type><name>CoercionForm</name></type> <name>cformat</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>,
                          <parameter><decl><type><name>bool</name></type> <name>isExplicit</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>nargs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>funcId</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procstruct</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>procstruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * These Asserts essentially check that function is a legal coercion
         * function.  We can't make the seemingly obvious tests on prorettype
         * and proargtypes[0], even in the COERCION_PATH_FUNC case, because of
         * various binary-compatibility cases.
         */</comment>
        <comment type="block">/* Assert(targetTypeId == procstruct-&gt;prorettype); */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>procstruct</name><operator>-&gt;</operator><name>proretset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>procstruct</name><operator>-&gt;</operator><name>proisagg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>procstruct</name><operator>-&gt;</operator><name>proiswindow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nargs</name> <operator>=</operator> <name><name>procstruct</name><operator>-&gt;</operator><name>pronargs</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>nargs</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Assert(procstruct-&gt;proargtypes.values[0] == exprType(node)); */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>||</operator> <name><name>procstruct</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>INT4OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">3</literal> <operator>||</operator> <name><name>procstruct</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>BOOLOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>pathtype</name> <operator>==</operator> <name>COERCION_PATH_FUNC</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We build an ordinary FuncExpr with special arguments */</comment>
        <decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Const</name>       <modifier>*</modifier></type><name>cons</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>funcId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Pass target typmod as an int4 constant */</comment>
            <expr_stmt><expr><name>cons</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
                             <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                             <argument><expr><name>InvalidOid</name></expr></argument>,
                             <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                             <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>targetTypMod</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>false</name></expr></argument>,
                             <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>cons</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Pass it a boolean isExplicit parameter, too */</comment>
            <expr_stmt><expr><name>cons</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>BOOLOID</name></expr></argument>,
                             <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                             <argument><expr><name>InvalidOid</name></expr></argument>,
                             <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                             <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>isExplicit</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>false</name></expr></argument>,
                             <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>cons</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>fexpr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>funcId</name></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><name>args</name></expr></argument>,
                             <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>cformat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fexpr</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>pathtype</name> <operator>==</operator> <name>COERCION_PATH_ARRAYCOERCE</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We need to build an ArrayCoerceExpr */</comment>
        <decl_stmt><decl><type><name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>acoerce</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ArrayCoerceExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>acoerce</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>acoerce</name><operator>-&gt;</operator><name>elemfuncid</name></name> <operator>=</operator> <name>funcId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>acoerce</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name>targetTypeId</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Label the output as having a particular typmod only if we are
         * really invoking a length-coercion function, ie one with more than
         * one argument.
         */</comment>
        <expr_stmt><expr><name><name>acoerce</name><operator>-&gt;</operator><name>resulttypmod</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>nargs</name> <operator>&gt;=</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><name>targetTypMod</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
        <comment type="block">/* resultcollid will be set by parse_collate.c */</comment>
        <expr_stmt><expr><name><name>acoerce</name><operator>-&gt;</operator><name>isExplicit</name></name> <operator>=</operator> <name>isExplicit</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>acoerce</name><operator>-&gt;</operator><name>coerceformat</name></name> <operator>=</operator> <name>cformat</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>acoerce</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

        <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>acoerce</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>pathtype</name> <operator>==</operator> <name>COERCION_PATH_COERCEVIAIO</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We need to build a CoerceViaIO node */</comment>
        <decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>iocoerce</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CoerceViaIO</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>funcId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name>targetTypeId</name></expr>;</expr_stmt>
        <comment type="block">/* resultcollid will be set by parse_collate.c */</comment>
        <expr_stmt><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>coerceformat</name></name> <operator>=</operator> <name>cformat</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

        <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>iocoerce</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported pathtype %d in build_coercion_expression"</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>pathtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>            <comment type="block">/* keep compiler quiet */</comment>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * coerce_record_to_complex
 *        Coerce a RECORD to a specific composite type.
 *
 * Currently we only support this for inputs that are RowExprs or whole-row
 * Vars.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>coerce_record_to_complex</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                         <parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>,
                         <parameter><decl><type><name>CoercionContext</name></type> <name>ccontext</name></decl></parameter>,
                         <parameter><decl><type><name>CoercionForm</name></type> <name>cformat</name></decl></parameter>,
                         <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>rowexpr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>newargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ucolno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Since the RowExpr must be of type RECORD, we needn't worry about it
         * containing any dropped columns.
         */</comment>
        <expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
             <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>rtindex</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>varno</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>sublevels_up</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>varlevelsup</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>vlocation</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>GetRTEByRangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>sublevels_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>expandRTE</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>sublevels_up</name></expr></argument>, <argument><expr><name>vlocation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANNOT_COERCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cast type %s to %s"</literal></expr></argument>,
                        <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>RECORDOID</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_coercion_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>newargs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ucolno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>cexpr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>exprtype</name></decl>;</decl_stmt>

        <comment type="block">/* Fill in NULLs for dropped columns in rowtype */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * can't use atttypid here, but it doesn't really matter what type
             * the Const claims to be.
             */</comment>
            <expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>,
                              <argument><expr><call><name>makeNullConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>arg</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANNOT_COERCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cast type %s to %s"</literal></expr></argument>,
                            <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>RECORDOID</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Input has too few columns."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_coercion_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>exprtype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>cexpr</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                      <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>exprtype</name></expr></argument>,
                                      <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr></argument>,
                                      <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>atttypmod</name></expr></argument>,
                                      <argument><expr><name>ccontext</name></expr></argument>,
                                      <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
                                      <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cexpr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANNOT_COERCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cast type %s to %s"</literal></expr></argument>,
                            <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>RECORDOID</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot cast type %s to %s in column %d."</literal></expr></argument>,
                               <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>exprtype</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>ucolno</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_coercion_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>cexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ucolno</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>arg</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANNOT_COERCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cast type %s to %s"</literal></expr></argument>,
                        <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>RECORDOID</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Input has too many columns."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_coercion_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rowexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>newargs</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_typeid</name></name> <operator>=</operator> <name>targetTypeId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_format</name></name> <operator>=</operator> <name>cformat</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>    <comment type="block">/* not needed for named target type */</comment>
    <expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rowexpr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * coerce_to_boolean()
 *        Coerce an argument of a construct that requires boolean input
 *        (AND, OR, NOT, etc).  Also check that input is not a set.
 *
 * Returns the possibly-transformed node tree.
 *
 * As with coerce_type, pstate may be NULL if no special unknown-Param
 * processing is wanted.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>coerce_to_boolean</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constructName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>inputTypeId</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>!=</operator> <name>BOOLOID</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>newnode</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>inputTypeId</name></expr></argument>,
                                        <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                                        <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
                                        <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
                                        <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>newnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
            <comment type="block">/* translator: first %s is name of a SQL construct, eg WHERE */</comment>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument of %s must be type %s, not type %s"</literal></expr></argument>,
                            <argument><expr><name>constructName</name></expr></argument>, <argument><expr><literal type="string">"boolean"</literal></expr></argument>,
                            <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <name>newnode</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>expression_returns_set</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/* translator: %s is name of a SQL construct, eg WHERE */</comment>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument of %s must not return a set"</literal></expr></argument>,
                        <argument><expr><name>constructName</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * coerce_to_specific_type_typmod()
 *        Coerce an argument of a construct that requires a specific data type,
 *        with a specific typmod.  Also check that input is not a set.
 *
 * Returns the possibly-transformed node tree.
 *
 * As with coerce_type, pstate may be NULL if no special unknown-Param
 * processing is wanted.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>coerce_to_specific_type_typmod</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                               <parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>targetTypmod</name></decl></parameter>,
                               <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constructName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>inputTypeId</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>!=</operator> <name>targetTypeId</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>newnode</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>inputTypeId</name></expr></argument>,
                                        <argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><name>targetTypmod</name></expr></argument>,
                                        <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
                                        <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
                                        <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>newnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
            <comment type="block">/* translator: first %s is name of a SQL construct, eg LIMIT */</comment>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument of %s must be type %s, not type %s"</literal></expr></argument>,
                            <argument><expr><name>constructName</name></expr></argument>,
                            <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <name>newnode</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>expression_returns_set</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/* translator: %s is name of a SQL construct, eg LIMIT */</comment>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument of %s must not return a set"</literal></expr></argument>,
                        <argument><expr><name>constructName</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * coerce_to_specific_type()
 *        Coerce an argument of a construct that requires a specific data type.
 *        Also check that input is not a set.
 *
 * Returns the possibly-transformed node tree.
 *
 * As with coerce_type, pstate may be NULL if no special unknown-Param
 * processing is wanted.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>coerce_to_specific_type</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                        <parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constructName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>coerce_to_specific_type_typmod</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                                          <argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                                          <argument><expr><name>constructName</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * parser_coercion_errposition - report coercion error location, if possible
 *
 * We prefer to point at the coercion request (CAST, ::, etc) if possible;
 * but there may be no such location in the case of an implicit coercion.
 * In that case point at the input expression.
 *
 * XXX possibly this is more generally useful than coercion errors;
 * if so, should rename and place with parser_errposition.
 */</comment>
<function><type><name>int</name></type>
<name>parser_coercion_errposition</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
                            <parameter><decl><type><name>int</name></type> <name>coerce_location</name></decl></parameter>,
                            <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>input_expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>coerce_location</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>coerce_location</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>input_expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * select_common_type()
 *        Determine the common supertype of a list of input expressions.
 *        This is used for determining the output type of CASE, UNION,
 *        and similar constructs.
 *
 * 'exprs' is a *nonempty* list of expressions.  Note that earlier items
 * in the list will be preferred if there is doubt.
 * 'context' is a phrase to use in the error message if we fail to select
 * a usable type.  Pass NULL to have the routine return InvalidOid
 * rather than throwing an error on failure.
 * 'which_expr': if not NULL, receives a pointer to the particular input
 * expression from which the result type was taken.
 */</comment>
<function><type><name>Oid</name></type>
<name>select_common_type</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
                   <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>which_expr</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>pexpr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>ptype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TYPCATEGORY</name></type> <name>pcategory</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>pispreferred</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>exprs</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ptype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>pexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If all input types are valid and exactly the same, just pick that type.
     * This is the only way that we will resolve the result as being a domain
     * type; otherwise domains are smashed to their base types for comparison.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>lc</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>nexpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>ntype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>nexpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>ntype</name> <operator>!=</operator> <name>ptype</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block>
        <if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>            <comment type="block">/* got to the end of the list? */</comment>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>which_expr</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>which_expr</name> <operator>=</operator> <name>pexpr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>ptype</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Nope, so set up for the full algorithm.  Note that at this point, lc
     * points to the first list item with type different from pexpr's; we need
     * not re-examine any items the previous loop advanced over.
     */</comment>
    <expr_stmt><expr><name>ptype</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>get_type_category_preferred</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pcategory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pispreferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>lc</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>nexpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>ntype</name> <init>= <expr><call><name>getBaseType</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>nexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* move on to next one if no new information... */</comment>
        <if_stmt><if>if <condition>(<expr><name>ntype</name> <operator>!=</operator> <name>UNKNOWNOID</name> <operator>&amp;&amp;</operator> <name>ntype</name> <operator>!=</operator> <name>ptype</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>TYPCATEGORY</name></type> <name>ncategory</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>nispreferred</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>get_type_category_preferred</name><argument_list>(<argument><expr><name>ntype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ncategory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nispreferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* so far, only unknowns so take anything... */</comment>
                <expr_stmt><expr><name>pexpr</name> <operator>=</operator> <name>nexpr</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>ptype</name> <operator>=</operator> <name>ntype</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pcategory</name> <operator>=</operator> <name>ncategory</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pispreferred</name> <operator>=</operator> <name>nispreferred</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>ncategory</name> <operator>!=</operator> <name>pcategory</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * both types in different categories? then not much hope...
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                <comment type="block">/*------
                  translator: first %s is name of a SQL construct, eg CASE */</comment>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s types %s and %s cannot be matched"</literal></expr></argument>,
                                <argument><expr><name>context</name></expr></argument>,
                                <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>ntype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>nexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><operator>!</operator><name>pispreferred</name> <operator>&amp;&amp;</operator>
                     <call><name>can_coerce_type</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ntype</name></expr></argument>, <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                     <operator>!</operator><call><name>can_coerce_type</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ntype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptype</name></expr></argument>, <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * take new type if can coerce to it implicitly but not the
                 * other way; but if we have a preferred type, stay on it.
                 */</comment>
                <expr_stmt><expr><name>pexpr</name> <operator>=</operator> <name>nexpr</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>ptype</name> <operator>=</operator> <name>ntype</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pcategory</name> <operator>=</operator> <name>ncategory</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pispreferred</name> <operator>=</operator> <name>nispreferred</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * If all the inputs were UNKNOWN type --- ie, unknown-type literals ---
     * then resolve as type TEXT.  This situation comes up with constructs
     * like SELECT (CASE WHEN foo THEN 'bar' ELSE 'baz' END); SELECT 'foo'
     * UNION SELECT 'bar'; It might seem desirable to leave the construct's
     * output type as UNKNOWN, but that really doesn't work, because we'd
     * probably end up needing a runtime coercion from UNKNOWN to something
     * else, and we usually won't have it.  We need to coerce the unknown
     * literals while they are still literals, so a decision has to be made
     * now.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ptype</name> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>which_expr</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>which_expr</name> <operator>=</operator> <name>pexpr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>ptype</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * coerce_to_common_type()
 *        Coerce an expression to the given type.
 *
 * This is used following select_common_type() to coerce the individual
 * expressions to the desired type.  'context' is a phrase to use in the
 * error message if we fail to coerce.
 *
 * As with coerce_type, pstate may be NULL if no special unknown-Param
 * processing is wanted.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>coerce_to_common_type</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                      <parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>inputTypeId</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>==</operator> <name>targetTypeId</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* no work */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>can_coerce_type</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>inputTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targetTypeId</name></expr></argument>, <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>coerce_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>inputTypeId</name></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                           <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>, <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANNOT_COERCE</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/* translator: first %s is name of a SQL construct, eg CASE */</comment>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s could not convert type %s to %s"</literal></expr></argument>,
                        <argument><expr><name>context</name></expr></argument>,
                        <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check_generic_type_consistency()
 *        Are the actual arguments potentially compatible with a
 *        polymorphic function?
 *
 * The argument consistency rules are:
 *
 * 1) All arguments declared ANYELEMENT must have the same datatype.
 * 2) All arguments declared ANYARRAY must have the same datatype,
 *      which must be a varlena array type.
 * 3) All arguments declared ANYRANGE must have the same datatype,
 *      which must be a range type.
 * 4) If there are arguments of both ANYELEMENT and ANYARRAY, make sure the
 *      actual ANYELEMENT datatype is in fact the element type for the actual
 *      ANYARRAY datatype.
 * 5) Similarly, if there are arguments of both ANYELEMENT and ANYRANGE,
 *      make sure the actual ANYELEMENT datatype is in fact the subtype for
 *      the actual ANYRANGE type.
 * 6) ANYENUM is treated the same as ANYELEMENT except that if it is used
 *      (alone or in combination with plain ANYELEMENT), we add the extra
 *      condition that the ANYELEMENT type must be an enum.
 * 7) ANYNONARRAY is treated the same as ANYELEMENT except that if it is used,
 *      we add the extra condition that the ANYELEMENT type must not be an array.
 *      (This is a no-op if used in combination with ANYARRAY or ANYENUM, but
 *      is an extra restriction if not.)
 *
 * Domains over arrays match ANYARRAY, and are immediately flattened to their
 * base type.  (Thus, for example, we will consider it a match if one ANYARRAY
 * argument is a domain over int4[] while another one is just int4[].)    Also
 * notice that such a domain does *not* match ANYNONARRAY.
 *
 * Similarly, domains over ranges match ANYRANGE, and are immediately
 * flattened to their base type.
 *
 * Note that domains aren't currently considered to match ANYENUM,
 * even if their base type would match.
 *
 * If we have UNKNOWN input (ie, an untyped literal) for any polymorphic
 * argument, assume it is okay.
 *
 * If an input is of type ANYARRAY (ie, we know it's an array, but not
 * what element type), we will accept it as a match to an argument declared
 * ANYARRAY, so long as we don't have to determine an element type ---
 * that is, so long as there is no use of ANYELEMENT.  This is mostly for
 * backwards compatibility with the pre-7.4 behavior of ANYARRAY.
 *
 * We do not ereport here, but just return FALSE if a rule is violated.
 */</comment>
<function><type><name>bool</name></type>
<name>check_generic_type_consistency</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>actual_arg_types</name></decl></parameter>,
                               <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>declared_arg_types</name></decl></parameter>,
                               <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>elem_typeid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>array_typeid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>array_typelem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>range_typeid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>range_typelem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>have_anyelement</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>have_anynonarray</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>have_anyenum</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Loop through the arguments to see if we have any that are polymorphic.
     * If so, require the actual types to be consistent.
     */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>decl_type</name> <init>= <expr><name><name>declared_arg_types</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>actual_type</name> <init>= <expr><name><name>actual_arg_types</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYELEMENTOID</name> <operator>||</operator>
            <name>decl_type</name> <operator>==</operator> <name>ANYNONARRAYOID</name> <operator>||</operator>
            <name>decl_type</name> <operator>==</operator> <name>ANYENUMOID</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>have_anyelement</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYNONARRAYOID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>have_anynonarray</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYENUMOID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>have_anyenum</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>actual_type</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>actual_type</name> <operator>!=</operator> <name>elem_typeid</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>elem_typeid</name> <operator>=</operator> <name>actual_type</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYARRAYOID</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>actual_type</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>actual_type</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* flatten domains */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>actual_type</name> <operator>!=</operator> <name>array_typeid</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>array_typeid</name> <operator>=</operator> <name>actual_type</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYRANGEOID</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>actual_type</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>actual_type</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* flatten domains */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>range_typeid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>actual_type</name> <operator>!=</operator> <name>range_typeid</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>range_typeid</name> <operator>=</operator> <name>actual_type</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Get the element type based on the array type, if we have one */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>array_typeid</name> <operator>==</operator> <name>ANYARRAYOID</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Special case for ANYARRAY input: okay iff no ANYELEMENT */</comment>
            <if_stmt><if>if <condition>(<expr><name>have_anyelement</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>array_typelem</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typelem</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>        <comment type="block">/* should be an array, but isn't */</comment>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * if we don't have an element type yet, use the one we just got
             */</comment>
            <expr_stmt><expr><name>elem_typeid</name> <operator>=</operator> <name>array_typelem</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>array_typelem</name> <operator>!=</operator> <name>elem_typeid</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* otherwise, they better match */</comment>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Get the element type based on the range type, if we have one */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>range_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>range_typelem</name> <operator>=</operator> <call><name>get_range_subtype</name><argument_list>(<argument><expr><name>range_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>range_typelem</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>        <comment type="block">/* should be a range, but isn't */</comment>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * if we don't have an element type yet, use the one we just got
             */</comment>
            <expr_stmt><expr><name>elem_typeid</name> <operator>=</operator> <name>range_typelem</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>range_typelem</name> <operator>!=</operator> <name>elem_typeid</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* otherwise, they better match */</comment>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>have_anynonarray</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* require the element type to not be an array or domain over array */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>type_is_array_domain</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>have_anyenum</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* require the element type to be an enum */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>type_is_enum</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Looks valid */</comment>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * enforce_generic_type_consistency()
 *        Make sure a polymorphic function is legally callable, and
 *        deduce actual argument and result types.
 *
 * If any polymorphic pseudotype is used in a function's arguments or
 * return type, we make sure the actual data types are consistent with
 * each other.  The argument consistency rules are shown above for
 * check_generic_type_consistency().
 *
 * If we have UNKNOWN input (ie, an untyped literal) for any polymorphic
 * argument, we attempt to deduce the actual type it should have.  If
 * successful, we alter that position of declared_arg_types[] so that
 * make_fn_arguments will coerce the literal to the right thing.
 *
 * Rules are applied to the function's return type (possibly altering it)
 * if it is declared as a polymorphic type:
 *
 * 1) If return type is ANYARRAY, and any argument is ANYARRAY, use the
 *      argument's actual type as the function's return type.
 * 2) Similarly, if return type is ANYRANGE, and any argument is ANYRANGE,
 *      use the argument's actual type as the function's return type.
 * 3) If return type is ANYARRAY, no argument is ANYARRAY, but any argument is
 *      ANYELEMENT, use the actual type of the argument to determine the
 *      function's return type, i.e. the element type's corresponding array
 *      type.  (Note: similar behavior does not exist for ANYRANGE, because it's
 *      impossible to determine the range type from the subtype alone.)
 * 4) If return type is ANYARRAY, but no argument is ANYARRAY or ANYELEMENT,
 *      generate an error.  Similarly, if return type is ANYRANGE, but no
 *      argument is ANYRANGE, generate an error.  (These conditions are
 *      prevented by CREATE FUNCTION and therefore are not expected here.)
 * 5) If return type is ANYELEMENT, and any argument is ANYELEMENT, use the
 *      argument's actual type as the function's return type.
 * 6) If return type is ANYELEMENT, no argument is ANYELEMENT, but any argument
 *      is ANYARRAY or ANYRANGE, use the actual type of the argument to determine
 *      the function's return type, i.e. the array type's corresponding element
 *      type or the range type's corresponding subtype (or both, in which case
 *      they must match).
 * 7) If return type is ANYELEMENT, no argument is ANYELEMENT, ANYARRAY, or
 *      ANYRANGE, generate an error.  (This condition is prevented by CREATE
 *      FUNCTION and therefore is not expected here.)
 * 8) ANYENUM is treated the same as ANYELEMENT except that if it is used
 *      (alone or in combination with plain ANYELEMENT), we add the extra
 *      condition that the ANYELEMENT type must be an enum.
 * 9) ANYNONARRAY is treated the same as ANYELEMENT except that if it is used,
 *      we add the extra condition that the ANYELEMENT type must not be an array.
 *      (This is a no-op if used in combination with ANYARRAY or ANYENUM, but
 *      is an extra restriction if not.)
 *
 * Domains over arrays or ranges match ANYARRAY or ANYRANGE arguments,
 * respectively, and are immediately flattened to their base type. (In
 * particular, if the return type is also ANYARRAY or ANYRANGE, we'll set it
 * to the base type not the domain type.)
 *
 * When allow_poly is false, we are not expecting any of the actual_arg_types
 * to be polymorphic, and we should not return a polymorphic result type
 * either.  When allow_poly is true, it is okay to have polymorphic "actual"
 * arg types, and we can return ANYARRAY, ANYRANGE, or ANYELEMENT as the
 * result.  (This case is currently used only to check compatibility of an
 * aggregate's declaration with the underlying transfn.)
 *
 * A special case is that we could see ANYARRAY as an actual_arg_type even
 * when allow_poly is false (this is possible only because pg_statistic has
 * columns shown as anyarray in the catalogs).  We allow this to match a
 * declared ANYARRAY argument, but only if there is no ANYELEMENT argument
 * or result (since we can't determine a specific element type to match to
 * ANYELEMENT).  Note this means that functions taking ANYARRAY had better
 * behave sanely if applied to the pg_statistic columns; they can't just
 * assume that successive inputs are of the same actual element type.
 */</comment>
<function><type><name>Oid</name></type>
<name>enforce_generic_type_consistency</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>actual_arg_types</name></decl></parameter>,
                                 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>declared_arg_types</name></decl></parameter>,
                                 <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>,
                                 <parameter><decl><type><name>Oid</name></type> <name>rettype</name></decl></parameter>,
                                 <parameter><decl><type><name>bool</name></type> <name>allow_poly</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>have_generics</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>have_unknowns</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>elem_typeid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>array_typeid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>range_typeid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>array_typelem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>range_typelem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>have_anyelement</name> <init>= <expr><operator>(</operator><name>rettype</name> <operator>==</operator> <name>ANYELEMENTOID</name> <operator>||</operator>
                                   <name>rettype</name> <operator>==</operator> <name>ANYNONARRAYOID</name> <operator>||</operator>
                                   <name>rettype</name> <operator>==</operator> <name>ANYENUMOID</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>have_anynonarray</name> <init>= <expr><operator>(</operator><name>rettype</name> <operator>==</operator> <name>ANYNONARRAYOID</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>have_anyenum</name> <init>= <expr><operator>(</operator><name>rettype</name> <operator>==</operator> <name>ANYENUMOID</name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Loop through the arguments to see if we have any that are polymorphic.
     * If so, require the actual types to be consistent.
     */</comment>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>decl_type</name> <init>= <expr><name><name>declared_arg_types</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>actual_type</name> <init>= <expr><name><name>actual_arg_types</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYELEMENTOID</name> <operator>||</operator>
            <name>decl_type</name> <operator>==</operator> <name>ANYNONARRAYOID</name> <operator>||</operator>
            <name>decl_type</name> <operator>==</operator> <name>ANYENUMOID</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>have_generics</name> <operator>=</operator> <name>have_anyelement</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYNONARRAYOID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>have_anynonarray</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYENUMOID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>have_anyenum</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>actual_type</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>have_unknowns</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>allow_poly</name> <operator>&amp;&amp;</operator> <name>decl_type</name> <operator>==</operator> <name>actual_type</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>        <comment type="block">/* no new information here */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>actual_type</name> <operator>!=</operator> <name>elem_typeid</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"arguments declared \"anyelement\" are not all alike"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
                                   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>elem_typeid</name> <operator>=</operator> <name>actual_type</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYARRAYOID</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>have_generics</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>actual_type</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>have_unknowns</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>allow_poly</name> <operator>&amp;&amp;</operator> <name>decl_type</name> <operator>==</operator> <name>actual_type</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>        <comment type="block">/* no new information here */</comment>
            <expr_stmt><expr><name>actual_type</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* flatten domains */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>actual_type</name> <operator>!=</operator> <name>array_typeid</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"arguments declared \"anyarray\" are not all alike"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
                                   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>array_typeid</name> <operator>=</operator> <name>actual_type</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYRANGEOID</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>have_generics</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>actual_type</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>have_unknowns</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>allow_poly</name> <operator>&amp;&amp;</operator> <name>decl_type</name> <operator>==</operator> <name>actual_type</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>        <comment type="block">/* no new information here */</comment>
            <expr_stmt><expr><name>actual_type</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* flatten domains */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>range_typeid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>actual_type</name> <operator>!=</operator> <name>range_typeid</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"arguments declared \"anyrange\" are not all alike"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
                                   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>range_typeid</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>range_typeid</name> <operator>=</operator> <name>actual_type</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Fast Track: if none of the arguments are polymorphic, return the
     * unmodified rettype.  We assume it can't be polymorphic either.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_generics</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>rettype</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Get the element type based on the array type, if we have one */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>array_typeid</name> <operator>==</operator> <name>ANYARRAYOID</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>have_anyelement</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Special case for ANYARRAY input: okay iff no ANYELEMENT */</comment>
            <expr_stmt><expr><name>array_typelem</name> <operator>=</operator> <name>ANYELEMENTOID</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>array_typelem</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typelem</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument declared %s is not an array but type %s"</literal></expr></argument>,
                                <argument><expr><literal type="string">"anyarray"</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * if we don't have an element type yet, use the one we just got
             */</comment>
            <expr_stmt><expr><name>elem_typeid</name> <operator>=</operator> <name>array_typelem</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>array_typelem</name> <operator>!=</operator> <name>elem_typeid</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* otherwise, they better match */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument declared %s is not consistent with argument declared %s"</literal></expr></argument>,
                            <argument><expr><literal type="string">"anyarray"</literal></expr></argument>, <argument><expr><literal type="string">"anyelement"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
                               <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Get the element type based on the range type, if we have one */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>range_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>range_typeid</name> <operator>==</operator> <name>ANYRANGEOID</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>have_anyelement</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Special case for ANYRANGE input: okay iff no ANYELEMENT */</comment>
            <expr_stmt><expr><name>range_typelem</name> <operator>=</operator> <name>ANYELEMENTOID</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>range_typelem</name> <operator>=</operator> <call><name>get_range_subtype</name><argument_list>(<argument><expr><name>range_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>range_typelem</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument declared %s is not a range type but type %s"</literal></expr></argument>,
                                <argument><expr><literal type="string">"anyrange"</literal></expr></argument>,
                                <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>range_typeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * if we don't have an element type yet, use the one we just got
             */</comment>
            <expr_stmt><expr><name>elem_typeid</name> <operator>=</operator> <name>range_typelem</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>range_typelem</name> <operator>!=</operator> <name>elem_typeid</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* otherwise, they better match */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument declared %s is not consistent with argument declared %s"</literal></expr></argument>,
                            <argument><expr><literal type="string">"anyrange"</literal></expr></argument>, <argument><expr><literal type="string">"anyelement"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
                               <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>range_typeid</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>allow_poly</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>elem_typeid</name> <operator>=</operator> <name>ANYELEMENTOID</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>array_typeid</name> <operator>=</operator> <name>ANYARRAYOID</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>range_typeid</name> <operator>=</operator> <name>ANYRANGEOID</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Only way to get here is if all the generic args are UNKNOWN */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine polymorphic type because input has type %s"</literal></expr></argument>,
                            <argument><expr><literal type="string">"unknown"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>have_anynonarray</name> <operator>&amp;&amp;</operator> <name>elem_typeid</name> <operator>!=</operator> <name>ANYELEMENTOID</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* require the element type to not be an array or domain over array */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>type_is_array_domain</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type matched to anynonarray is an array type: %s"</literal></expr></argument>,
                            <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>have_anyenum</name> <operator>&amp;&amp;</operator> <name>elem_typeid</name> <operator>!=</operator> <name>ANYELEMENTOID</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* require the element type to be an enum */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>type_is_enum</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type matched to anyenum is not an enum type: %s"</literal></expr></argument>,
                            <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If we had any unknown inputs, re-scan to assign correct types
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>have_unknowns</name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>decl_type</name> <init>= <expr><name><name>declared_arg_types</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>actual_type</name> <init>= <expr><name><name>actual_arg_types</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>actual_type</name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYELEMENTOID</name> <operator>||</operator>
                <name>decl_type</name> <operator>==</operator> <name>ANYNONARRAYOID</name> <operator>||</operator>
                <name>decl_type</name> <operator>==</operator> <name>ANYENUMOID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>declared_arg_types</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>elem_typeid</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYARRAYOID</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>array_typeid</name> <operator>=</operator> <call><name>get_array_type</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find array type for data type %s"</literal></expr></argument>,
                                        <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>declared_arg_types</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>array_typeid</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYRANGEOID</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>range_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find range type for data type %s"</literal></expr></argument>,
                                    <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>declared_arg_types</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>range_typeid</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if we return ANYARRAY use the appropriate argument type */</comment>
    <if_stmt><if>if <condition>(<expr><name>rettype</name> <operator>==</operator> <name>ANYARRAYOID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>array_typeid</name> <operator>=</operator> <call><name>get_array_type</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find array type for data type %s"</literal></expr></argument>,
                                <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>array_typeid</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if we return ANYRANGE use the appropriate argument type */</comment>
    <if_stmt><if>if <condition>(<expr><name>rettype</name> <operator>==</operator> <name>ANYRANGEOID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>range_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find range type for data type %s"</literal></expr></argument>,
                            <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>range_typeid</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if we return ANYELEMENT use the appropriate argument type */</comment>
    <if_stmt><if>if <condition>(<expr><name>rettype</name> <operator>==</operator> <name>ANYELEMENTOID</name> <operator>||</operator>
        <name>rettype</name> <operator>==</operator> <name>ANYNONARRAYOID</name> <operator>||</operator>
        <name>rettype</name> <operator>==</operator> <name>ANYENUMOID</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>elem_typeid</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* we don't return a generic type; send back the original return type */</comment>
    <return>return <expr><name>rettype</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * resolve_generic_type()
 *        Deduce an individual actual datatype on the assumption that
 *        the rules for polymorphic types are being followed.
 *
 * declared_type is the declared datatype we want to resolve.
 * context_actual_type is the actual input datatype to some argument
 * that has declared datatype context_declared_type.
 *
 * If declared_type isn't polymorphic, we just return it.  Otherwise,
 * context_declared_type must be polymorphic, and we deduce the correct
 * return type based on the relationship of the two polymorphic types.
 */</comment>
<function><type><name>Oid</name></type>
<name>resolve_generic_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>declared_type</name></decl></parameter>,
                     <parameter><decl><type><name>Oid</name></type> <name>context_actual_type</name></decl></parameter>,
                     <parameter><decl><type><name>Oid</name></type> <name>context_declared_type</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>declared_type</name> <operator>==</operator> <name>ANYARRAYOID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>context_declared_type</name> <operator>==</operator> <name>ANYARRAYOID</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Use actual type, but it must be an array; or if it's a domain
             * over array, use the base array type.
             */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>context_base_type</name> <init>= <expr><call><name>getBaseType</name><argument_list>(<argument><expr><name>context_actual_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>array_typelem</name> <init>= <expr><call><name>get_element_type</name><argument_list>(<argument><expr><name>context_base_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typelem</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument declared %s is not an array but type %s"</literal></expr></argument>,
                                <argument><expr><literal type="string">"anyarray"</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>context_base_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>context_base_type</name></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>context_declared_type</name> <operator>==</operator> <name>ANYELEMENTOID</name> <operator>||</operator>
                 <name>context_declared_type</name> <operator>==</operator> <name>ANYNONARRAYOID</name> <operator>||</operator>
                 <name>context_declared_type</name> <operator>==</operator> <name>ANYENUMOID</name> <operator>||</operator>
                 <name>context_declared_type</name> <operator>==</operator> <name>ANYRANGEOID</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Use the array type corresponding to actual type */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>array_typeid</name> <init>= <expr><call><name>get_array_type</name><argument_list>(<argument><expr><name>context_actual_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find array type for data type %s"</literal></expr></argument>,
                                <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>context_actual_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>array_typeid</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>declared_type</name> <operator>==</operator> <name>ANYELEMENTOID</name> <operator>||</operator>
             <name>declared_type</name> <operator>==</operator> <name>ANYNONARRAYOID</name> <operator>||</operator>
             <name>declared_type</name> <operator>==</operator> <name>ANYENUMOID</name> <operator>||</operator>
             <name>declared_type</name> <operator>==</operator> <name>ANYRANGEOID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>context_declared_type</name> <operator>==</operator> <name>ANYARRAYOID</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Use the element type corresponding to actual type */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>context_base_type</name> <init>= <expr><call><name>getBaseType</name><argument_list>(<argument><expr><name>context_actual_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>array_typelem</name> <init>= <expr><call><name>get_element_type</name><argument_list>(<argument><expr><name>context_base_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typelem</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument declared %s is not an array but type %s"</literal></expr></argument>,
                                <argument><expr><literal type="string">"anyarray"</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>context_base_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>array_typelem</name></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>context_declared_type</name> <operator>==</operator> <name>ANYRANGEOID</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Use the element type corresponding to actual type */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>context_base_type</name> <init>= <expr><call><name>getBaseType</name><argument_list>(<argument><expr><name>context_actual_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>range_typelem</name> <init>= <expr><call><name>get_range_subtype</name><argument_list>(<argument><expr><name>context_base_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>range_typelem</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument declared %s is not a range type but type %s"</literal></expr></argument>,
                                <argument><expr><literal type="string">"anyrange"</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>context_base_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>range_typelem</name></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>context_declared_type</name> <operator>==</operator> <name>ANYELEMENTOID</name> <operator>||</operator>
                 <name>context_declared_type</name> <operator>==</operator> <name>ANYNONARRAYOID</name> <operator>||</operator>
                 <name>context_declared_type</name> <operator>==</operator> <name>ANYENUMOID</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Use the actual type; it doesn't matter if array or not */</comment>
            <return>return <expr><name>context_actual_type</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* declared_type isn't polymorphic, so return it as-is */</comment>
        <return>return <expr><name>declared_type</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* If we get here, declared_type is polymorphic and context isn't */</comment>
    <comment type="block">/* NB: this is a calling-code logic error, not a user error */</comment>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not determine polymorphic type because context isn't polymorphic"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>InvalidOid</name></expr>;</return>            <comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>


<comment type="block">/* TypeCategory()
 *        Assign a category to the specified type OID.
 *
 * NB: this must not return TYPCATEGORY_INVALID.
 */</comment>
<function><type><name>TYPCATEGORY</name></type>
<name>TypeCategory</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name>typcategory</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>typispreferred</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>get_type_category_preferred</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typcategory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typispreferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>typcategory</name> <operator>!=</operator> <name>TYPCATEGORY_INVALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>TYPCATEGORY</name><operator>)</operator> <name>typcategory</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* IsPreferredType()
 *        Check if this type is a preferred type for the given category.
 *
 * If category is TYPCATEGORY_INVALID, then we'll return TRUE for preferred
 * types of any category; otherwise, only for preferred types of that
 * category.
 */</comment>
<function><type><name>bool</name></type>
<name>IsPreferredType</name><parameter_list>(<parameter><decl><type><name>TYPCATEGORY</name></type> <name>category</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name>typcategory</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>typispreferred</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>get_type_category_preferred</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typcategory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typispreferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>category</name> <operator>==</operator> <name>typcategory</name> <operator>||</operator> <name>category</name> <operator>==</operator> <name>TYPCATEGORY_INVALID</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>typispreferred</name></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* IsBinaryCoercible()
 *        Check if srctype is binary-coercible to targettype.
 *
 * This notion allows us to cheat and directly exchange values without
 * going through the trouble of calling a conversion function.  Note that
 * in general, this should only be an implementation shortcut.  Before 7.4,
 * this was also used as a heuristic for resolving overloaded functions and
 * operators, but that's basically a bad idea.
 *
 * As of 7.3, binary coercibility isn't hardwired into the code anymore.
 * We consider two types binary-coercible if there is an implicitly
 * invokable, no-function-needed pg_cast entry.  Also, a domain is always
 * binary-coercible to its base type, though *not* vice versa (in the other
 * direction, one must apply domain constraint checks before accepting the
 * value as legitimate).  We also need to special-case various polymorphic
 * types.
 *
 * This function replaces IsBinaryCompatible(), which was an inherently
 * symmetric test.  Since the pg_cast entries aren't necessarily symmetric,
 * the order of the operands is now significant.
 */</comment>
<function><type><name>bool</name></type>
<name>IsBinaryCoercible</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>srctype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>targettype</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_cast</name></type> <name>castForm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <comment type="block">/* Fast path if same type */</comment>
    <if_stmt><if>if <condition>(<expr><name>srctype</name> <operator>==</operator> <name>targettype</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Anything is coercible to ANY or ANYELEMENT */</comment>
    <if_stmt><if>if <condition>(<expr><name>targettype</name> <operator>==</operator> <name>ANYOID</name> <operator>||</operator> <name>targettype</name> <operator>==</operator> <name>ANYELEMENTOID</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If srctype is a domain, reduce to its base type */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>srctype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>srctype</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>srctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Somewhat-fast path for domain -&gt; base type case */</comment>
    <if_stmt><if>if <condition>(<expr><name>srctype</name> <operator>==</operator> <name>targettype</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Also accept any array type as coercible to ANYARRAY */</comment>
    <if_stmt><if>if <condition>(<expr><name>targettype</name> <operator>==</operator> <name>ANYARRAYOID</name></expr>)</condition><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>type_is_array</name><argument_list>(<argument><expr><name>srctype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Also accept any non-array type as coercible to ANYNONARRAY */</comment>
    <if_stmt><if>if <condition>(<expr><name>targettype</name> <operator>==</operator> <name>ANYNONARRAYOID</name></expr>)</condition><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>type_is_array</name><argument_list>(<argument><expr><name>srctype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Also accept any enum type as coercible to ANYENUM */</comment>
    <if_stmt><if>if <condition>(<expr><name>targettype</name> <operator>==</operator> <name>ANYENUMOID</name></expr>)</condition><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>type_is_enum</name><argument_list>(<argument><expr><name>srctype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Also accept any range type as coercible to ANYRANGE */</comment>
    <if_stmt><if>if <condition>(<expr><name>targettype</name> <operator>==</operator> <name>ANYRANGEOID</name></expr>)</condition><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>type_is_range</name><argument_list>(<argument><expr><name>srctype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Also accept any composite type as coercible to RECORD */</comment>
    <if_stmt><if>if <condition>(<expr><name>targettype</name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>ISCOMPLEX</name><argument_list>(<argument><expr><name>srctype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Also accept any composite array type as coercible to RECORD[] */</comment>
    <if_stmt><if>if <condition>(<expr><name>targettype</name> <operator>==</operator> <name>RECORDARRAYOID</name></expr>)</condition><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>is_complex_array</name><argument_list>(<argument><expr><name>srctype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Else look in pg_cast */</comment>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>CASTSOURCETARGET</name></expr></argument>,
                            <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>srctype</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* no cast */</comment>
    <expr_stmt><expr><name>castForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_cast</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name><name>castForm</name><operator>-&gt;</operator><name>castmethod</name></name> <operator>==</operator> <name>COERCION_METHOD_BINARY</name> <operator>&amp;&amp;</operator>
              <name><name>castForm</name><operator>-&gt;</operator><name>castcontext</name></name> <operator>==</operator> <name>COERCION_CODE_IMPLICIT</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * find_coercion_pathway
 *        Look for a coercion pathway between two types.
 *
 * Currently, this deals only with scalar-type cases; it does not consider
 * polymorphic types nor casts between composite types.  (Perhaps fold
 * those in someday?)
 *
 * ccontext determines the set of available casts.
 *
 * The possible result codes are:
 *    COERCION_PATH_NONE: failed to find any coercion pathway
 *                *funcid is set to InvalidOid
 *    COERCION_PATH_FUNC: apply the coercion function returned in *funcid
 *    COERCION_PATH_RELABELTYPE: binary-compatible cast, no function needed
 *                *funcid is set to InvalidOid
 *    COERCION_PATH_ARRAYCOERCE: need an ArrayCoerceExpr node
 *                *funcid is set to the element cast function, or InvalidOid
 *                if the array elements are binary-compatible
 *    COERCION_PATH_COERCEVIAIO: need a CoerceViaIO node
 *                *funcid is set to InvalidOid
 *
 * Note: COERCION_PATH_RELABELTYPE does not necessarily mean that no work is
 * needed to do the coercion; if the target is a domain then we may need to
 * apply domain constraint checking.  If you want to check for a zero-effort
 * conversion then use IsBinaryCoercible().
 */</comment>
<function><type><name>CoercionPathType</name></type>
<name>find_coercion_pathway</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sourceTypeId</name></decl></parameter>,
                      <parameter><decl><type><name>CoercionContext</name></type> <name>ccontext</name></decl></parameter>,
                      <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CoercionPathType</name></type> <name>result</name> <init>= <expr><name>COERCION_PATH_NONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>funcid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

    <comment type="block">/* Perhaps the types are domains; if so, look at their base types */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>sourceTypeId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>sourceTypeId</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>sourceTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>targetTypeId</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Domains are always coercible to and from their base type */</comment>
    <if_stmt><if>if <condition>(<expr><name>sourceTypeId</name> <operator>==</operator> <name>targetTypeId</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>COERCION_PATH_RELABELTYPE</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Look in pg_cast */</comment>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>CASTSOURCETARGET</name></expr></argument>,
                            <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>sourceTypeId</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_cast</name></type> <name>castForm</name> <init>= <expr><operator>(</operator><name>Form_pg_cast</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CoercionContext</name></type> <name>castcontext</name></decl>;</decl_stmt>

        <comment type="block">/* convert char value for castcontext to CoercionContext enum */</comment>
        <switch>switch <condition>(<expr><name><name>castForm</name><operator>-&gt;</operator><name>castcontext</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>COERCION_CODE_IMPLICIT</name></expr>:</case>
                <expr_stmt><expr><name>castcontext</name> <operator>=</operator> <name>COERCION_IMPLICIT</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>COERCION_CODE_ASSIGNMENT</name></expr>:</case>
                <expr_stmt><expr><name>castcontext</name> <operator>=</operator> <name>COERCION_ASSIGNMENT</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>COERCION_CODE_EXPLICIT</name></expr>:</case>
                <expr_stmt><expr><name>castcontext</name> <operator>=</operator> <name>COERCION_EXPLICIT</name></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized castcontext: %d"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>castForm</name><operator>-&gt;</operator><name>castcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>castcontext</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <comment type="block">/* keep compiler quiet */</comment>
                <break>break;</break>
        </block_content>}</block></switch>

        <comment type="block">/* Rely on ordering of enum for correct behavior here */</comment>
        <if_stmt><if>if <condition>(<expr><name>ccontext</name> <operator>&gt;=</operator> <name>castcontext</name></expr>)</condition>
        <block>{<block_content>
            <switch>switch <condition>(<expr><name><name>castForm</name><operator>-&gt;</operator><name>castmethod</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>COERCION_METHOD_FUNCTION</name></expr>:</case>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>COERCION_PATH_FUNC</name></expr>;</expr_stmt>
                    <expr_stmt><expr><operator>*</operator><name>funcid</name> <operator>=</operator> <name><name>castForm</name><operator>-&gt;</operator><name>castfunc</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>COERCION_METHOD_INOUT</name></expr>:</case>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>COERCION_PATH_COERCEVIAIO</name></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>COERCION_METHOD_BINARY</name></expr>:</case>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>COERCION_PATH_RELABELTYPE</name></expr>;</expr_stmt>
                    <break>break;</break>
                <default>default:</default>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized castmethod: %d"</literal></expr></argument>,
                         <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>castForm</name><operator>-&gt;</operator><name>castmethod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * If there's no pg_cast entry, perhaps we are dealing with a pair of
         * array types.  If so, and if the element types have a suitable cast,
         * report that we can coerce with an ArrayCoerceExpr.
         *
         * Note that the source type can be a domain over array, but not the
         * target, because ArrayCoerceExpr won't check domain constraints.
         *
         * Hack: disallow coercions to oidvector and int2vector, which
         * otherwise tend to capture coercions that should go to "real" array
         * types.  We want those types to be considered "real" arrays for many
         * purposes, but not this one.  (Also, ArrayCoerceExpr isn't
         * guaranteed to produce an output that meets the restrictions of
         * these datatypes, such as being 1-dimensional.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>!=</operator> <name>OIDVECTOROID</name> <operator>&amp;&amp;</operator> <name>targetTypeId</name> <operator>!=</operator> <name>INT2VECTOROID</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>targetElem</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>sourceElem</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>targetElem</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
                <operator>(</operator><name>sourceElem</name> <operator>=</operator> <call><name>get_base_element_type</name><argument_list>(<argument><expr><name>sourceTypeId</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>CoercionPathType</name></type> <name>elempathtype</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>elemfuncid</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>elempathtype</name> <operator>=</operator> <call><name>find_coercion_pathway</name><argument_list>(<argument><expr><name>targetElem</name></expr></argument>,
                                                     <argument><expr><name>sourceElem</name></expr></argument>,
                                                     <argument><expr><name>ccontext</name></expr></argument>,
                                                     <argument><expr><operator>&amp;</operator><name>elemfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>elempathtype</name> <operator>!=</operator> <name>COERCION_PATH_NONE</name> <operator>&amp;&amp;</operator>
                    <name>elempathtype</name> <operator>!=</operator> <name>COERCION_PATH_ARRAYCOERCE</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>funcid</name> <operator>=</operator> <name>elemfuncid</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>elempathtype</name> <operator>==</operator> <name>COERCION_PATH_COERCEVIAIO</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>COERCION_PATH_COERCEVIAIO</name></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>COERCION_PATH_ARRAYCOERCE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If we still haven't found a possibility, consider automatic casting
         * using I/O functions.  We allow assignment casts to string types and
         * explicit casts from string types to be handled this way. (The
         * CoerceViaIO mechanism is a lot more general than that, but this is
         * all we want to allow in the absence of a pg_cast entry.) It would
         * probably be better to insist on explicit casts in both directions,
         * but this is a compromise to preserve something of the pre-8.3
         * behavior that many types had implicit (yipes!) casts to text.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>COERCION_PATH_NONE</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>ccontext</name> <operator>&gt;=</operator> <name>COERCION_ASSIGNMENT</name> <operator>&amp;&amp;</operator>
                <call><name>TypeCategory</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPCATEGORY_STRING</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>COERCION_PATH_COERCEVIAIO</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>ccontext</name> <operator>&gt;=</operator> <name>COERCION_EXPLICIT</name> <operator>&amp;&amp;</operator>
                     <call><name>TypeCategory</name><argument_list>(<argument><expr><name>sourceTypeId</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPCATEGORY_STRING</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>COERCION_PATH_COERCEVIAIO</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * find_typmod_coercion_function -- does the given type need length coercion?
 *
 * If the target type possesses a pg_cast function from itself to itself,
 * it must need length coercion.
 *
 * "bpchar" (ie, char(N)) and "numeric" are examples of such types.
 *
 * If the given type is a varlena array type, we do not look for a coercion
 * function associated directly with the array type, but instead look for
 * one associated with the element type.  An ArrayCoerceExpr node must be
 * used to apply such a function.
 *
 * We use the same result enum as find_coercion_pathway, but the only possible
 * result codes are:
 *    COERCION_PATH_NONE: no length coercion needed
 *    COERCION_PATH_FUNC: apply the function returned in *funcid
 *    COERCION_PATH_ARRAYCOERCE: apply the function using ArrayCoerceExpr
 */</comment>
<function><type><name>CoercionPathType</name></type>
<name>find_typmod_coercion_function</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>,
                              <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CoercionPathType</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Type</name></type>        <name>targetType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typeForm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>funcid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>COERCION_PATH_FUNC</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>targetType</name> <operator>=</operator> <call><name>typeidType</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>typeForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check for a varlena array type */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>typeForm</name><operator>-&gt;</operator><name>typelem</name></name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator> <name><name>typeForm</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Yes, switch our attention to the element type */</comment>
        <expr_stmt><expr><name>typeId</name> <operator>=</operator> <name><name>typeForm</name><operator>-&gt;</operator><name>typelem</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>COERCION_PATH_ARRAYCOERCE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Look in pg_cast */</comment>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>CASTSOURCETARGET</name></expr></argument>,
                            <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_cast</name></type> <name>castForm</name> <init>= <expr><operator>(</operator><name>Form_pg_cast</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><operator>*</operator><name>funcid</name> <operator>=</operator> <name><name>castForm</name><operator>-&gt;</operator><name>castfunc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>funcid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>COERCION_PATH_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * is_complex_array
 *        Is this type an array of composite?
 *
 * Note: this will not return true for record[]; check for RECORDARRAYOID
 * separately if needed.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_complex_array</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>elemtype</name> <init>= <expr><call><name>get_element_type</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><operator>(</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elemtype</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ISCOMPLEX</name><argument_list>(<argument><expr><name>elemtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Check whether reltypeId is the row type of a typed table of type
 * reloftypeId.  (This is conceptually similar to the subtype
 * relationship checked by typeInheritsFrom().)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>typeIsOfTypedTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>reltypeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>reloftypeId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name> <init>= <expr><call><name>typeidTypeRelid</name><argument_list>(<argument><expr><name>reltypeId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>relid</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>reltup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>reltup</name><operator>-&gt;</operator><name>reloftype</name></name> <operator>==</operator> <name>reloftypeId</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
