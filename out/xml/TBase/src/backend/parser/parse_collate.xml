<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/parser/parse_collate.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * parse_collate.c
 *        Routines for assigning collation information.
 *
 * We choose to handle collation analysis in a post-pass over the output
 * of expression parse analysis.  This is because we need more state to
 * perform this processing than is needed in the finished tree.  If we
 * did it on-the-fly while building the tree, all that state would have
 * to be kept in expression node trees permanently.  This way, the extra
 * storage is just local variables in this recursive routine.
 *
 * The info that is actually saved in the finished tree is:
 * 1. The output collation of each expression node, or InvalidOid if it
 * returns a noncollatable data type.  This can also be InvalidOid if the
 * result type is collatable but the collation is indeterminate.
 * 2. The collation to be used in executing each function.  InvalidOid means
 * that there are no collatable inputs or their collation is indeterminate.
 * This value is only stored in node types that might call collation-using
 * functions.
 *
 * You might think we could get away with storing only one collation per
 * node, but the two concepts really need to be kept distinct.  Otherwise
 * it's too confusing when a function produces a collatable output type but
 * has no collatable inputs or produces noncollatable output from collatable
 * inputs.
 *
 * Cases with indeterminate collation might result in an error being thrown
 * at runtime.  If we knew exactly which functions require collation
 * information, we could throw those errors at parse time instead.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/parser/parse_collate.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Collation strength (the SQL standard calls this "derivation").  Order is
 * chosen to allow comparisons to work usefully.  Note: the standard doesn't
 * seem to distinguish between NONE and CONFLICT.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
    <decl><name>COLLATE_NONE</name></decl>,                <comment type="block">/* expression is of a noncollatable datatype */</comment>
    <decl><name>COLLATE_IMPLICIT</name></decl>,            <comment type="block">/* collation was derived implicitly */</comment>
    <decl><name>COLLATE_CONFLICT</name></decl>,            <comment type="block">/* we had a conflict of implicit collations */</comment>
    <decl><name>COLLATE_EXPLICIT</name></decl>            <comment type="block">/* collation was derived explicitly */</comment>
}</block></enum></type> <name>CollateStrength</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>            <comment type="block">/* parse state (for error reporting) */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>collation</name></decl>;</decl_stmt>        <comment type="block">/* OID of current collation, if any */</comment>
    <decl_stmt><decl><type><name>CollateStrength</name></type> <name>strength</name></decl>;</decl_stmt>    <comment type="block">/* strength of current collation choice */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>location</name></decl>;</decl_stmt>        <comment type="block">/* location of expr that set collation */</comment>
    <comment type="block">/* Remaining fields are only valid when strength == COLLATE_CONFLICT */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>collation2</name></decl>;</decl_stmt>        <comment type="block">/* OID of conflicting collation */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>location2</name></decl>;</decl_stmt>        <comment type="block">/* location of expr that set collation2 */</comment>
}</block></struct></type> <name>assign_collations_context</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>assign_query_collations_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>assign_collations_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                         <parameter><decl><type><name>assign_collations_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>merge_collation_state</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
                      <parameter><decl><type><name>CollateStrength</name></type> <name>strength</name></decl></parameter>,
                      <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>,
                      <parameter><decl><type><name>Oid</name></type> <name>collation2</name></decl></parameter>,
                      <parameter><decl><type><name>int</name></type> <name>location2</name></decl></parameter>,
                      <parameter><decl><type><name>assign_collations_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_aggregate_collations</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name></decl></parameter>,
                            <parameter><decl><type><name>assign_collations_context</name> <modifier>*</modifier></type><name>loccontext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_ordered_set_collations</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name></decl></parameter>,
                              <parameter><decl><type><name>assign_collations_context</name> <modifier>*</modifier></type><name>loccontext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_hypothetical_collations</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name></decl></parameter>,
                               <parameter><decl><type><name>assign_collations_context</name> <modifier>*</modifier></type><name>loccontext</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * assign_query_collations()
 *        Mark all expressions in the given Query with collation information.
 *
 * This should be applied to each Query after completion of parse analysis
 * for expressions.  Note that we do not recurse into sub-Queries, since
 * those should have been processed when built.
 */</comment>
<function><type><name>void</name></type>
<name>assign_query_collations</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * We just use query_tree_walker() to visit all the contained expressions.
     * We can skip the rangetable and CTE subqueries, though, since RTEs and
     * subqueries had better have been processed already (else Vars referring
     * to them would not get created with the right collation).
     */</comment>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
                             <argument><expr><name>assign_query_collations_walker</name></expr></argument>,
                             <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>pstate</name></expr></argument>,
                             <argument><expr><name>QTW_IGNORE_RANGE_TABLE</name> <operator>|</operator>
                             <name>QTW_IGNORE_CTE_SUBQUERIES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Walker for assign_query_collations
 *
 * Each expression found by query_tree_walker is processed independently.
 * Note that query_tree_walker may pass us a whole List, such as the
 * targetlist, in which case each subexpression must be processed
 * independently --- we don't want to bleat if two different targetentries
 * have different collations.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>assign_query_collations_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Need do nothing for empty subexpressions */</comment>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We don't want to recurse into a set-operations tree; it's already been
     * fully processed in transformSetOperationStmt.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>assign_list_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * assign_list_collations()
 *        Mark all nodes in the list of expressions with collation information.
 *
 * The list member expressions are processed independently; they do not have
 * to share a common collation.
 */</comment>
<function><type><name>void</name></type>
<name>assign_list_collations</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>exprs</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * assign_expr_collations()
 *        Mark all nodes in the given expression tree with collation information.
 *
 * This is exported for the benefit of various utility commands that process
 * expressions without building a complete Query.  It should be applied after
 * calling transformExpr() plus any expression-modifying operations such as
 * coerce_to_boolean().
 */</comment>
<function><type><name>void</name></type>
<name>assign_expr_collations</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>assign_collations_context</name></type> <name>context</name></decl>;</decl_stmt>

    <comment type="block">/* initialize context for tree walk */</comment>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>collation</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>strength</name></name> <operator>=</operator> <name>COLLATE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* and away we go */</comment>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>assign_collations_walker</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * select_common_collation()
 *        Identify a common collation for a list of expressions.
 *
 * The expressions should all return the same datatype, else this is not
 * terribly meaningful.
 *
 * none_ok means that it is permitted to return InvalidOid, indicating that
 * no common collation could be identified, even for collatable datatypes.
 * Otherwise, an error is thrown for conflict of implicit collations.
 *
 * In theory, none_ok = true reflects the rules of SQL standard clause "Result
 * of data type combinations", none_ok = false reflects the rules of clause
 * "Collation determination" (in some cases invoked via "Grouping
 * operations").
 */</comment>
<function><type><name>Oid</name></type>
<name>select_common_collation</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>none_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>assign_collations_context</name></type> <name>context</name></decl>;</decl_stmt>

    <comment type="block">/* initialize context for tree walk */</comment>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>collation</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>strength</name></name> <operator>=</operator> <name>COLLATE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* and away we go */</comment>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>assign_collations_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>exprs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* deal with collation conflict */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>strength</name></name> <operator>==</operator> <name>COLLATE_CONFLICT</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>none_ok</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_COLLATION_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collation mismatch between implicit collations \"%s\" and \"%s\""</literal></expr></argument>,
                        <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>collation</name></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>collation2</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You can choose the collation by applying the COLLATE clause to one or both expressions."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>location2</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Note: if strength is still COLLATE_NONE, we'll return InvalidOid, but
     * that's okay because it must mean none of the expressions returned
     * collatable datatypes.
     */</comment>
    <return>return <expr><name><name>context</name><operator>.</operator><name>collation</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * assign_collations_walker()
 *        Recursive guts of collation processing.
 *
 * Nodes with no children (eg, Vars, Consts, Params) must have been marked
 * when built.  All upper-level nodes are marked here.
 *
 * Note: if this is invoked directly on a List, it will attempt to infer a
 * common collation for all the list members.  In particular, it will throw
 * error if there are conflicting explicit collations for different members.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>assign_collations_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>assign_collations_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>assign_collations_context</name></type> <name>loccontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>collation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CollateStrength</name></type> <name>strength</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>location</name></decl>;</decl_stmt>

    <comment type="block">/* Need do nothing for empty subexpressions */</comment>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Prepare for recursion.  For most node types, though not all, the first
     * thing we do is recurse to process all nodes below this one. Each level
     * of the tree has its own local context.
     */</comment>
    <expr_stmt><expr><name><name>loccontext</name><operator>.</operator><name>pstate</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>pstate</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>loccontext</name><operator>.</operator><name>collation</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>loccontext</name><operator>.</operator><name>strength</name></name> <operator>=</operator> <name>COLLATE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>loccontext</name><operator>.</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <comment type="block">/* Set these fields just to suppress uninitialized-value warnings: */</comment>
    <expr_stmt><expr><name><name>loccontext</name><operator>.</operator><name>collation2</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>loccontext</name><operator>.</operator><name>location2</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Recurse if appropriate, then determine the collation for this node.
     *
     * Note: the general cases are at the bottom of the switch, after various
     * special cases.
     */</comment>
    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_CollateExpr</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/*
                 * COLLATE sets an explicitly derived collation, regardless of
                 * what the child state is.  But we must recurse to set up
                 * collation info below here.
                 */</comment>
                <decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
                                              <argument><expr><name>assign_collations_walker</name></expr></argument>,
                                              <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>loccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>collation</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>collOid</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>strength</name> <operator>=</operator> <name>COLLATE_EXPLICIT</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>location</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_FieldSelect</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/*
                 * For FieldSelect, the result has the field's declared
                 * collation, independently of what happened in the arguments.
                 * (The immediate argument must be composite and thus not
                 * collatable, anyhow.)  The field's collation was already
                 * looked up and saved in the node.
                 */</comment>
                <decl_stmt><decl><type><name>FieldSelect</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* ... but first, recurse */</comment>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
                                              <argument><expr><name>assign_collations_walker</name></expr></argument>,
                                              <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>loccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>resultcollid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Node's result type is collatable. */</comment>
                    <comment type="block">/* Pass up field's collation as an implicit choice. */</comment>
                    <expr_stmt><expr><name>collation</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>resultcollid</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>strength</name> <operator>=</operator> <name>COLLATE_IMPLICIT</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Node's result type isn't collatable. */</comment>
                    <expr_stmt><expr><name>collation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>strength</name> <operator>=</operator> <name>COLLATE_NONE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>location</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* won't be used */</comment>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_RowExpr</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/*
                 * RowExpr is a special case because the subexpressions are
                 * independent: we don't want to complain if some of them have
                 * incompatible explicit collations.
                 */</comment>
                <decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>assign_list_collations</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Since the result is always composite and therefore never
                 * has a collation, we can just stop here: this node has no
                 * impact on the collation of its parent.
                 */</comment>
                <return>return <expr><name>false</name></expr>;</return>    <comment type="block">/* done */</comment>
            </block_content>}</block>
        <case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/*
                 * For RowCompare, we have to find the common collation of
                 * each pair of input columns and build a list.  If we can't
                 * find a common collation, we just put InvalidOid into the
                 * list, which may or may not cause an error at runtime.
                 */</comment>
                <decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>colls</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

                <macro><name>forboth</name><argument_list>(<argument>l</argument>, <argument>expr-&gt;largs</argument>, <argument>r</argument>, <argument>expr-&gt;rargs</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>le</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>re</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Oid</name></type>            <name>coll</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>coll</name> <operator>=</operator> <call><name>select_common_collation</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
                                                   <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>le</name></expr></argument>, <argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>,
                                                   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>colls</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>colls</name></expr></argument>, <argument><expr><name>coll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>inputcollids</name></name> <operator>=</operator> <name>colls</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Since the result is always boolean and therefore never has
                 * a collation, we can just stop here: this node has no impact
                 * on the collation of its parent.
                 */</comment>
                <return>return <expr><name>false</name></expr>;</return>    <comment type="block">/* done */</comment>
            </block_content>}</block>
        <case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/*
                 * If the domain declaration included a non-default COLLATE
                 * spec, then use that collation as the output collation of
                 * the coercion.  Otherwise allow the input collation to
                 * bubble up.  (The input should be of the domain's base type,
                 * therefore we don't need to worry about it not being
                 * collatable when the domain is.)
                 */</comment>
                <decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>typcollation</name> <init>= <expr><call><name>get_typcollation</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="block">/* ... but first, recurse */</comment>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
                                              <argument><expr><name>assign_collations_walker</name></expr></argument>,
                                              <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>loccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typcollation</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Node's result type is collatable. */</comment>
                    <if_stmt><if>if <condition>(<expr><name>typcollation</name> <operator>==</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* Collation state bubbles up from child. */</comment>
                        <expr_stmt><expr><name>collation</name> <operator>=</operator> <name><name>loccontext</name><operator>.</operator><name>collation</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>strength</name> <operator>=</operator> <name><name>loccontext</name><operator>.</operator><name>strength</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>location</name> <operator>=</operator> <name><name>loccontext</name><operator>.</operator><name>location</name></name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="block">/* Use domain's collation as an implicit choice. */</comment>
                        <expr_stmt><expr><name>collation</name> <operator>=</operator> <name>typcollation</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>strength</name> <operator>=</operator> <name>COLLATE_IMPLICIT</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Node's result type isn't collatable. */</comment>
                    <expr_stmt><expr><name>collation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>strength</name> <operator>=</operator> <name>COLLATE_NONE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>location</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* won't be used */</comment>
                </block_content>}</block></else></if_stmt>

                <comment type="block">/*
                 * Save the state into the expression node.  We know it
                 * doesn't care about input collation.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>strength</name> <operator>==</operator> <name>COLLATE_CONFLICT</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>exprSetCollation</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>exprSetCollation</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_TargetEntry</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
                                          <argument><expr><name>assign_collations_walker</name></expr></argument>,
                                          <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>loccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * TargetEntry can have only one child, and should bubble that
             * state up to its parent.  We can't use the general-case code
             * below because exprType and friends don't work on TargetEntry.
             */</comment>
            <expr_stmt><expr><name>collation</name> <operator>=</operator> <name><name>loccontext</name><operator>.</operator><name>collation</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>strength</name> <operator>=</operator> <name><name>loccontext</name><operator>.</operator><name>strength</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>location</name> <operator>=</operator> <name><name>loccontext</name><operator>.</operator><name>location</name></name></expr>;</expr_stmt>

            <comment type="block">/*
             * Throw error if the collation is indeterminate for a TargetEntry
             * that is a sort/group target.  We prefer to do this now, instead
             * of leaving the comparison functions to fail at runtime, because
             * we can give a syntax error pointer to help locate the problem.
             * There are some cases where there might not be a failure, for
             * example if the planner chooses to use hash aggregation instead
             * of sorting for grouping; but it seems better to predictably
             * throw an error.  (Compare transformSetOperationTree, which will
             * throw error for indeterminate collation of set-op columns, even
             * though the planner might be able to implement the set-op
             * without sorting.)
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>strength</name> <operator>==</operator> <name>COLLATE_CONFLICT</name> <operator>&amp;&amp;</operator>
                <operator>(</operator><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>ressortgroupref</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_COLLATION_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collation mismatch between implicit collations \"%s\" and \"%s\""</literal></expr></argument>,
                                <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name><name>loccontext</name><operator>.</operator><name>collation</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name><name>loccontext</name><operator>.</operator><name>collation2</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You can choose the collation by applying the COLLATE clause to one or both expressions."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
                                            <argument><expr><name><name>loccontext</name><operator>.</operator><name>location2</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>T_InferenceElem</name></expr>:</case>
        <case>case <expr><name>T_RangeTblRef</name></expr>:</case>
        <case>case <expr><name>T_JoinExpr</name></expr>:</case>
        <case>case <expr><name>T_FromExpr</name></expr>:</case>
        <case>case <expr><name>T_OnConflictExpr</name></expr>:</case>
        <case>case <expr><name>T_SortGroupClause</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
                                          <argument><expr><name>assign_collations_walker</name></expr></argument>,
                                          <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>loccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * When we're invoked on a query's jointree, we don't need to do
             * anything with join nodes except recurse through them to process
             * WHERE/ON expressions.  So just stop here.  Likewise, we don't
             * need to do anything when invoked on sort/group lists.
             */</comment>
            <return>return <expr><name>false</name></expr>;</return>
        <case>case <expr><name>T_Query</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/*
                 * We get here when we're invoked on the Query belonging to a
                 * SubLink.  Act as though the Query returns its first output
                 * column, which indeed is what it does for EXPR_SUBLINK and
                 * ARRAY_SUBLINK cases.  In the cases where the SubLink
                 * returns boolean, this info will be ignored.  Special case:
                 * in EXISTS, the Query might return no columns, in which case
                 * we need do nothing.
                 *
                 * We needn't recurse, since the Query is already processed.
                 */</comment>
                <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>qtree</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tent</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>qtree</name><operator>-&gt;</operator><name>targetList</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>tent</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name><name>qtree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>tent</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>collation</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* collation doesn't change if it's converted to array */</comment>
                <expr_stmt><expr><name>strength</name> <operator>=</operator> <name>COLLATE_IMPLICIT</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_List</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
                                          <argument><expr><name>assign_collations_walker</name></expr></argument>,
                                          <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>loccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * When processing a list, collation state just bubbles up from
             * the list elements.
             */</comment>
            <expr_stmt><expr><name>collation</name> <operator>=</operator> <name><name>loccontext</name><operator>.</operator><name>collation</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>strength</name> <operator>=</operator> <name><name>loccontext</name><operator>.</operator><name>strength</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>location</name> <operator>=</operator> <name><name>loccontext</name><operator>.</operator><name>location</name></name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_Var</name></expr>:</case>
        <case>case <expr><name>T_Const</name></expr>:</case>
        <case>case <expr><name>T_Param</name></expr>:</case>
        <case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
        <case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
        <case>case <expr><name>T_SetToDefault</name></expr>:</case>
        <case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>

            <comment type="block">/*
             * General case for childless expression nodes.  These should
             * already have a collation assigned; it is not this function's
             * responsibility to look into the catalogs for base-case
             * information.
             */</comment>
            <expr_stmt><expr><name>collation</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Note: in most cases, there will be an assigned collation
             * whenever type_is_collatable(exprType(node)); but an exception
             * occurs for a Var referencing a subquery output column for which
             * a unique collation was not determinable.  That may lead to a
             * runtime failure if a collation-sensitive function is applied to
             * the Var.
             */</comment>

            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>strength</name> <operator>=</operator> <name>COLLATE_IMPLICIT</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>strength</name> <operator>=</operator> <name>COLLATE_NONE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <block>{<block_content>
                <comment type="block">/*
                 * General case for most expression nodes with children. First
                 * recurse, then figure out what to assign to this node.
                 */</comment>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>typcollation</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * For most node types, we want to treat all the child
                 * expressions alike; but there are a few exceptions, hence
                 * this inner switch.
                 */</comment>
                <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>T_Aggref</name></expr>:</case>
                        <block>{<block_content>
                            <comment type="block">/*
                             * Aggref is messy enough that we give it its own
                             * function, in fact three of them.  The FILTER
                             * clause is independent of the rest of the
                             * aggregate, however, so it can be processed
                             * separately.
                             */</comment>
                            <decl_stmt><decl><type><name>Aggref</name>       <modifier>*</modifier></type><name>aggref</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                            <switch>switch <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggkind</name></name></expr>)</condition>
                            <block>{<block_content>
                                <case>case <expr><name>AGGKIND_NORMAL</name></expr>:</case>
                                    <expr_stmt><expr><call><name>assign_aggregate_collations</name><argument_list>(<argument><expr><name>aggref</name></expr></argument>,
                                                                <argument><expr><operator>&amp;</operator><name>loccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <break>break;</break>
                                <case>case <expr><name>AGGKIND_ORDERED_SET</name></expr>:</case>
                                    <expr_stmt><expr><call><name>assign_ordered_set_collations</name><argument_list>(<argument><expr><name>aggref</name></expr></argument>,
                                                                  <argument><expr><operator>&amp;</operator><name>loccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <break>break;</break>
                                <case>case <expr><name>AGGKIND_HYPOTHETICAL</name></expr>:</case>
                                    <expr_stmt><expr><call><name>assign_hypothetical_collations</name><argument_list>(<argument><expr><name>aggref</name></expr></argument>,
                                                                   <argument><expr><operator>&amp;</operator><name>loccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <break>break;</break>
                                <default>default:</default>
                                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized aggkind: %d"</literal></expr></argument>,
                                         <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggkind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></switch>

                            <expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
                                                   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>
                        <break>break;</break>
                    <case>case <expr><name>T_WindowFunc</name></expr>:</case>
                        <block>{<block_content>
                            <comment type="block">/*
                             * WindowFunc requires special processing only for
                             * its aggfilter clause, as for aggregates.
                             */</comment>
                            <decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>wfunc</name> <init>= <expr><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>assign_collations_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>wfunc</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
                                                            <argument><expr><operator>&amp;</operator><name>loccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
                                                   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>wfunc</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>
                        <break>break;</break>
                    <case>case <expr><name>T_CaseExpr</name></expr>:</case>
                        <block>{<block_content>
                            <comment type="block">/*
                             * CaseExpr is a special case because we do not
                             * want to recurse into the test expression (if
                             * any).  It was already marked with collations
                             * during transformCaseExpr, and furthermore its
                             * collation is not relevant to the result of the
                             * CASE --- only the output expressions are.
                             */</comment>
                            <decl_stmt><decl><type><name>CaseExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

                            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>expr-&gt;args</argument>)</argument_list></macro>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>when</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>CaseWhen</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                <comment type="block">/*
                                 * The condition expressions mustn't affect
                                 * the CASE's result collation either; but
                                 * since they are known to yield boolean, it's
                                 * safe to recurse directly on them --- they
                                 * won't change loccontext.
                                 */</comment>
                                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>assign_collations_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>when</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
                                                                <argument><expr><operator>&amp;</operator><name>loccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>assign_collations_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>when</name><operator>-&gt;</operator><name>result</name></name></expr></argument>,
                                                                <argument><expr><operator>&amp;</operator><name>loccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block>
                            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>assign_collations_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>,
                                                            <argument><expr><operator>&amp;</operator><name>loccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>
                        <break>break;</break>
                    <default>default:</default>

                        <comment type="block">/*
                         * Normal case: all child expressions contribute
                         * equally to loccontext.
                         */</comment>
                        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
                                                      <argument><expr><name>assign_collations_walker</name></expr></argument>,
                                                      <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>loccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>

                <comment type="block">/*
                 * Now figure out what collation to assign to this node.
                 */</comment>
                <expr_stmt><expr><name>typcollation</name> <operator>=</operator> <call><name>get_typcollation</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typcollation</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Node's result is collatable; what about its input? */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>loccontext</name><operator>.</operator><name>strength</name></name> <operator>&gt;</operator> <name>COLLATE_NONE</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* Collation state bubbles up from children. */</comment>
                        <expr_stmt><expr><name>collation</name> <operator>=</operator> <name><name>loccontext</name><operator>.</operator><name>collation</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>strength</name> <operator>=</operator> <name><name>loccontext</name><operator>.</operator><name>strength</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>location</name> <operator>=</operator> <name><name>loccontext</name><operator>.</operator><name>location</name></name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="block">/*
                         * Collatable output produced without any collatable
                         * input.  Use the type's collation (which is usually
                         * DEFAULT_COLLATION_OID, but might be different for a
                         * domain).
                         */</comment>
                        <expr_stmt><expr><name>collation</name> <operator>=</operator> <name>typcollation</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>strength</name> <operator>=</operator> <name>COLLATE_IMPLICIT</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Node's result type isn't collatable. */</comment>
                    <expr_stmt><expr><name>collation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>strength</name> <operator>=</operator> <name>COLLATE_NONE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>location</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* won't be used */</comment>
                </block_content>}</block></else></if_stmt>

                <comment type="block">/*
                 * Save the result collation into the expression node. If the
                 * state is COLLATE_CONFLICT, we'll set the collation to
                 * InvalidOid, which might result in an error at runtime.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>strength</name> <operator>==</operator> <name>COLLATE_CONFLICT</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>exprSetCollation</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>exprSetCollation</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <comment type="block">/*
                 * Likewise save the input collation, which is the one that
                 * any function called by this node should use.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>loccontext</name><operator>.</operator><name>strength</name></name> <operator>==</operator> <name>COLLATE_CONFLICT</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>exprSetInputCollation</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>exprSetInputCollation</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>loccontext</name><operator>.</operator><name>collation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/*
     * Now, merge my information into my parent's state.
     */</comment>
    <expr_stmt><expr><call><name>merge_collation_state</name><argument_list>(<argument><expr><name>collation</name></expr></argument>,
                          <argument><expr><name>strength</name></expr></argument>,
                          <argument><expr><name>location</name></expr></argument>,
                          <argument><expr><name><name>loccontext</name><operator>.</operator><name>collation2</name></name></expr></argument>,
                          <argument><expr><name><name>loccontext</name><operator>.</operator><name>location2</name></name></expr></argument>,
                          <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Merge collation state of a subexpression into the context for its parent.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>merge_collation_state</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
                      <parameter><decl><type><name>CollateStrength</name></type> <name>strength</name></decl></parameter>,
                      <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>,
                      <parameter><decl><type><name>Oid</name></type> <name>collation2</name></decl></parameter>,
                      <parameter><decl><type><name>int</name></type> <name>location2</name></decl></parameter>,
                      <parameter><decl><type><name>assign_collations_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/*
     * If the collation strength for this node is different from what's
     * already in *context, then this node either dominates or is dominated by
     * earlier siblings.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>strength</name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>strength</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Override previous parent state */</comment>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>strength</name></name> <operator>=</operator> <name>strength</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
        <comment type="block">/* Bubble up error info if applicable */</comment>
        <if_stmt><if>if <condition>(<expr><name>strength</name> <operator>==</operator> <name>COLLATE_CONFLICT</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>collation2</name></name> <operator>=</operator> <name>collation2</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>location2</name></name> <operator>=</operator> <name>location2</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>strength</name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>strength</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Merge, or detect error if there's a collation conflict */</comment>
        <switch>switch <condition>(<expr><name>strength</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>COLLATE_NONE</name></expr>:</case>
                <comment type="block">/* Nothing + nothing is still nothing */</comment>
                <break>break;</break>
            <case>case <expr><name>COLLATE_IMPLICIT</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>collation</name> <operator>!=</operator> <name><name>context</name><operator>-&gt;</operator><name>collation</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * Non-default implicit collation always beats default.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>collation</name></name> <operator>==</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* Override previous parent state */</comment>
                        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>strength</name></name> <operator>=</operator> <name>strength</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>collation</name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * Oops, we have a conflict.  We cannot throw error
                         * here, since the conflict could be resolved by a
                         * later sibling CollateExpr, or the parent might not
                         * care about collation anyway.  Return enough info to
                         * throw the error later, if needed.
                         */</comment>
                        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>strength</name></name> <operator>=</operator> <name>COLLATE_CONFLICT</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>collation2</name></name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>location2</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>COLLATE_CONFLICT</name></expr>:</case>
                <comment type="block">/* We're still conflicted ... */</comment>
                <break>break;</break>
            <case>case <expr><name>COLLATE_EXPLICIT</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>collation</name> <operator>!=</operator> <name><name>context</name><operator>-&gt;</operator><name>collation</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * Oops, we have a conflict of explicit COLLATE clauses.
                     * Here we choose to throw error immediately; that is what
                     * the SQL standard says to do, and there's no good reason
                     * to be less strict.
                     */</comment>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_COLLATION_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collation mismatch between explicit collations \"%s\" and \"%s\""</literal></expr></argument>,
                                    <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>collation</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Aggref is a special case because expressions used only for ordering
 * shouldn't be taken to conflict with each other or with regular args,
 * indeed shouldn't affect the aggregate's result collation at all.
 * We handle this by applying assign_expr_collations() to them rather than
 * passing down our loccontext.
 *
 * Note that we recurse to each TargetEntry, not directly to its contained
 * expression, so that the case above for T_TargetEntry will complain if we
 * can't resolve a collation for an ORDER BY item (whether or not it is also
 * a normal aggregate arg).
 *
 * We need not recurse into the aggorder or aggdistinct lists, because those
 * contain only SortGroupClause nodes which we need not process.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_aggregate_collations</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name></decl></parameter>,
                            <parameter><decl><type><name>assign_collations_context</name> <modifier>*</modifier></type><name>loccontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* Plain aggregates have no direct args */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdirectargs</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Process aggregated args, holding resjunk ones at arm's length */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>aggref-&gt;args</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name><name>loccontext</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>assign_collations_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tle</name></expr></argument>, <argument><expr><name>loccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * For ordered-set aggregates, it's somewhat unclear how best to proceed.
 * The spec-defined inverse distribution functions have only one sort column
 * and don't return collatable types, but this is clearly too restrictive in
 * the general case.  Our solution is to consider that the aggregate's direct
 * arguments contribute normally to determination of the aggregate's own
 * collation, while aggregated arguments contribute only when the aggregate
 * is designed to have exactly one aggregated argument (i.e., it has a single
 * aggregated argument and is non-variadic).  If it can have more than one
 * aggregated argument, we process the aggregated arguments as independent
 * sort columns.  This avoids throwing error for something like
 *        agg(...) within group (order by x collate "foo", y collate "bar")
 * while also guaranteeing that variadic aggregates don't change in behavior
 * depending on how many sort columns a particular call happens to have.
 *
 * Otherwise this is much like the plain-aggregate case.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_ordered_set_collations</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name></decl></parameter>,
                              <parameter><decl><type><name>assign_collations_context</name> <modifier>*</modifier></type><name>loccontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>merge_sort_collations</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* Merge sort collations to parent only if there can be only one */</comment>
    <expr_stmt><expr><name>merge_sort_collations</name> <operator>=</operator> <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
                             <call><name>get_func_variadictype</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOid</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Direct args, if any, are normal children of the Aggref node */</comment>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>assign_collations_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>,
                                    <argument><expr><name>loccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Process aggregated args appropriately */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>aggref-&gt;args</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>merge_sort_collations</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>assign_collations_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tle</name></expr></argument>, <argument><expr><name>loccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name><name>loccontext</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Hypothetical-set aggregates are even more special: per spec, we need to
 * unify the collations of each pair of hypothetical and aggregated args.
 * And we need to force the choice of collation down into the sort column
 * to ensure that the sort happens with the chosen collation.  Other than
 * that, the behavior is like regular ordered-set aggregates.  Note that
 * hypothetical direct arguments contribute to the aggregate collation
 * only when their partner aggregated arguments do.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_hypothetical_collations</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name></decl></parameter>,
                               <parameter><decl><type><name>assign_collations_context</name> <modifier>*</modifier></type><name>loccontext</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>h_cell</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>s_cell</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>merge_sort_collations</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>extra_args</name></decl>;</decl_stmt>

    <comment type="block">/* Merge sort collations to parent only if there can be only one */</comment>
    <expr_stmt><expr><name>merge_sort_collations</name> <operator>=</operator> <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
                             <call><name>get_func_variadictype</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOid</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Process any non-hypothetical direct args */</comment>
    <expr_stmt><expr><name>extra_args</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>extra_args</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>extra_args</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>assign_collations_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>h_cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>loccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>h_cell</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>h_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Scan hypothetical args and aggregated args in parallel */</comment>
    <while>while <condition>(<expr><name>h_cell</name> <operator>&amp;&amp;</operator> <name>s_cell</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>h_arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>h_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>s_tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>s_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>assign_collations_context</name></type> <name>paircontext</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Assign collations internally in this pair of expressions, then
         * choose a common collation for them.  This should match
         * select_common_collation(), but we can't use that function as-is
         * because we need access to the whole collation state so we can
         * bubble it up to the aggregate function's level.
         */</comment>
        <expr_stmt><expr><name><name>paircontext</name><operator>.</operator><name>pstate</name></name> <operator>=</operator> <name><name>loccontext</name><operator>-&gt;</operator><name>pstate</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>paircontext</name><operator>.</operator><name>collation</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>paircontext</name><operator>.</operator><name>strength</name></name> <operator>=</operator> <name>COLLATE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>paircontext</name><operator>.</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <comment type="block">/* Set these fields just to suppress uninitialized-value warnings: */</comment>
        <expr_stmt><expr><name><name>paircontext</name><operator>.</operator><name>collation2</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>paircontext</name><operator>.</operator><name>location2</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>assign_collations_walker</name><argument_list>(<argument><expr><name>h_arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>paircontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>assign_collations_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>s_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>paircontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* deal with collation conflict */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>paircontext</name><operator>.</operator><name>strength</name></name> <operator>==</operator> <name>COLLATE_CONFLICT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_COLLATION_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collation mismatch between implicit collations \"%s\" and \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name><name>paircontext</name><operator>.</operator><name>collation</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name><name>paircontext</name><operator>.</operator><name>collation2</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You can choose the collation by applying the COLLATE clause to one or both expressions."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>paircontext</name><operator>.</operator><name>pstate</name></name></expr></argument>,
                                        <argument><expr><name><name>paircontext</name><operator>.</operator><name>location2</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * At this point paircontext.collation can be InvalidOid only if the
         * type is not collatable; no need to do anything in that case.  If we
         * do have to change the sort column's collation, do it by inserting a
         * RelabelType node into the sort column TLE.
         *
         * XXX This is pretty grotty for a couple of reasons:
         * assign_collations_walker isn't supposed to be changing the
         * expression structure like this, and a parse-time change of
         * collation ought to be signaled by a CollateExpr not a RelabelType
         * (the use of RelabelType for collation marking is supposed to be a
         * planner/executor thing only).  But we have no better alternative.
         * In particular, injecting a CollateExpr could result in the
         * expression being interpreted differently after dump/reload, since
         * we might be effectively promoting an implicit collation to
         * explicit.  This kluge is relying on ruleutils.c not printing a
         * COLLATE clause for a RelabelType, and probably on some other
         * fragile behaviors.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>paircontext</name><operator>.</operator><name>collation</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <name><name>paircontext</name><operator>.</operator><name>collation</name></name> <operator>!=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>s_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>s_tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
                <call><name>makeRelabelType</name><argument_list>(<argument><expr><name><name>s_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
                                <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>s_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>s_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name><name>paircontext</name><operator>.</operator><name>collation</name></name></expr></argument>,
                                <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If appropriate, merge this column's collation state up to the
         * aggregate function.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>merge_sort_collations</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>merge_collation_state</name><argument_list>(<argument><expr><name><name>paircontext</name><operator>.</operator><name>collation</name></name></expr></argument>,
                                  <argument><expr><name><name>paircontext</name><operator>.</operator><name>strength</name></name></expr></argument>,
                                  <argument><expr><name><name>paircontext</name><operator>.</operator><name>location</name></name></expr></argument>,
                                  <argument><expr><name><name>paircontext</name><operator>.</operator><name>collation2</name></name></expr></argument>,
                                  <argument><expr><name><name>paircontext</name><operator>.</operator><name>location2</name></name></expr></argument>,
                                  <argument><expr><name>loccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>h_cell</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>h_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>s_cell</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>s_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>h_cell</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>s_cell</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
