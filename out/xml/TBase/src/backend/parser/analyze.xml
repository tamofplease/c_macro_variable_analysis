<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/parser/analyze.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<comment type="block">/*-------------------------------------------------------------------------
 *
 * analyze.c
 *      transform the raw parse tree into a query tree
 *
 * For optimizable statements, we are careful to obtain a suitable lock on
 * each referenced table, and other modules of the backend preserve or
 * re-obtain these locks before depending on the results.  It is therefore
 * okay to do significant semantic analysis of these statements.  For
 * utility commands, no locks are obtained here (and if they were, we could
 * not be sure we'd still have them at execution).  Hence the general rule
 * for utility commands is to just dump them into a Query node untransformed.
 * DECLARE CURSOR, EXPLAIN, and CREATE TABLE AS are exceptions because they
 * contain optimizable statements, which we should transform.
 *
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *    src/backend/parser/analyze.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_cte.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_param.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_target.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxcnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/poolmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/xc_maintenance_mode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datamask.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pgxcship.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"audit/audit_fga.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/* GUC to enable transform insert into multi-values to copy from */</comment>
<decl_stmt><decl><type><name>bool</name></type>   <name>g_transform_insert_to_copy</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Hook for plugins to get control at end of parse analysis */</comment>
<decl_stmt><decl><type><name>post_parse_analyze_hook_type</name></type> <name>post_parse_analyze_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformOptionalSelectInto</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformDeleteStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>DeleteStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformInsertStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>InsertStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transformInsertRow</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprlist</name></decl></parameter>,
                   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmtcols</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>icolumns</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attrnos</name></decl></parameter>,
                   <parameter><decl><type><name>bool</name></type> <name>strip_indirection</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>OnConflictExpr</name> <modifier>*</modifier></type><name>transformOnConflictClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
                          <parameter><decl><type><name>OnConflictClause</name> <modifier>*</modifier></type><name>onConflictClause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>count_rowexpr_columns</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformSelectStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformValuesClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformSetOperationStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformSetOperationTree</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
                          <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>determineRecursiveColTypes</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
                           <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>larg</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nrtargetlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformUpdateStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>UpdateStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transformReturningList</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transformUpdateTargetList</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
                          <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformDeclareCursorStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
                           <parameter><decl><type><name>DeclareCursorStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformExplainStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
                     <parameter><decl><type><name>ExplainStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformCreateTableAsStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
                           <parameter><decl><type><name>CreateTableAsStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformExecDirectStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ExecDirectStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformLockingClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>,
                       <parameter><decl><type><name>LockingClause</name> <modifier>*</modifier></type><name>lc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pushedDown</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RAW_EXPRESSION_COVERAGE_TEST</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>test_raw_expression_coverage</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * parse_analyze
 *        Analyze a raw parse tree and transform it to Query form.
 *
 * Optionally, information about $n parameter types can be supplied.
 * References to $n indexes not defined by paramTypes[] are disallowed.
 *
 * The result is a Query node.  Optimizable statements require considerable
 * transformation, while utility-type statements are simply hung off
 * a dummy CMD_UTILITY Query node.
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>parse_analyze</name><parameter_list>(<parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourceText</name></decl></parameter>,
              <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>paramTypes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numParams</name></decl></parameter>,
              <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sourceText</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* required as of 8.4 */</comment>

    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>sourceText</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>numParams</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>parse_fixed_parameters</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>paramTypes</name></expr></argument>, <argument><expr><name>numParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_queryEnv</name></name> <operator>=</operator> <name>queryEnv</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>transformTopLevelStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>post_parse_analyze_hook</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call>(<modifier>*</modifier><name>post_parse_analyze_hook</name>) <argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * parse_analyze_varparams
 *
 * This variant is used when it's okay to deduce information about $n
 * symbol datatypes from context.  The passed-in paramTypes[] array can
 * be modified or enlarged (via repalloc).
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>parse_analyze_varparams</name><parameter_list>(<parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourceText</name></decl></parameter>,
                        <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>paramTypes</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sourceText</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* required as of 8.4 */</comment>

    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>sourceText</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>parse_variable_parameters</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>paramTypes</name></expr></argument>, <argument><expr><name>numParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>transformTopLevelStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* make sure all is well with parameter types */</comment>
    <expr_stmt><expr><call><name>check_variable_parameters</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>post_parse_analyze_hook</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call>(<modifier>*</modifier><name>post_parse_analyze_hook</name>) <argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * parse_sub_analyze
 *        Entry point for recursively analyzing a sub-statement.
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>parse_sub_analyze</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>, <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>parentParseState</name></decl></parameter>,
                  <parameter><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>parentCTE</name></decl></parameter>,
                  <parameter><decl><type><name>bool</name></type> <name>locked_from_parent</name></decl></parameter>,
                  <parameter><decl><type><name>bool</name></type> <name>resolve_unknowns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>parentParseState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_parent_cte</name></name> <operator>=</operator> <name>parentCTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_locked_from_parent</name></name> <operator>=</operator> <name>locked_from_parent</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_resolve_unknowns</name></name> <operator>=</operator> <name>resolve_unknowns</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>transformStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformTopLevelStmt -
 *      transform a Parse tree into a Query tree.
 *
 * This function is just responsible for transferring statement location data
 * from the RawStmt into the finished Query.
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>transformTopLevelStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <comment type="block">/* We're at top level, so allow SELECT INTO */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformOptionalSelectInto</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>parseTree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name><name>parseTree</name><operator>-&gt;</operator><name>stmt_location</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name><name>parseTree</name><operator>-&gt;</operator><name>stmt_len</name></name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformOptionalSelectInto -
 *      If SELECT has INTO, convert it to CREATE TABLE AS.
 *
 * The only thing we do here that we don't do in transformStmt() is to
 * convert SELECT ... INTO into CREATE TABLE AS.  Since utility statements
 * aren't allowed within larger statements, this is only allowed at the top
 * of the parse tree, and so we only try it before entering the recursive
 * transformStmt() processing.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformOptionalSelectInto</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>, <argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>SelectStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* If it's a set-operation tree, drill down to leftmost SelectStmt */</comment>
        <while>while <condition>(<expr><name>stmt</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>op</name></name> <operator>!=</operator> <name>SETOP_NONE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>stmt</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>larg</name></name></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>stmt</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator><name><name>stmt</name><operator>-&gt;</operator><name>larg</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>stmt</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>intoClause</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>CreateTableAsStmt</name> <modifier>*</modifier></type><name>ctas</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CreateTableAsStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>ctas</name><operator>-&gt;</operator><name>query</name></name> <operator>=</operator> <name>parseTree</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctas</name><operator>-&gt;</operator><name>into</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>intoClause</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctas</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctas</name><operator>-&gt;</operator><name>is_select_into</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Remove the intoClause from the SelectStmt.  This makes it safe
             * for transformSelectStmt to complain if it finds intoClause set
             * (implying that the INTO appeared in a disallowed place).
             */</comment>
            <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>intoClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>parseTree</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>ctas</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><call><name>transformStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformStmt -
 *      recursively transform a Parse tree into a Query tree.
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>transformStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We apply RAW_EXPRESSION_COVERAGE_TEST testing to basic DML statements;
     * we can't just run it on everything because raw_expression_tree_walker()
     * doesn't claim to handle utility statements.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RAW_EXPRESSION_COVERAGE_TEST</name></cpp:ifdef>
    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_SelectStmt</name></expr>:</case>
        <case>case <expr><name>T_InsertStmt</name></expr>:</case>
        <case>case <expr><name>T_UpdateStmt</name></expr>:</case>
        <case>case <expr><name>T_DeleteStmt</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>test_raw_expression_coverage</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* RAW_EXPRESSION_COVERAGE_TEST */</comment>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
            <comment type="block">/*
             * Optimizable statements
             */</comment>
        <case>case <expr><name>T_InsertStmt</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformInsertStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>InsertStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_DeleteStmt</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformDeleteStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>DeleteStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_UpdateStmt</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformUpdateStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>UpdateStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SelectStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>SelectStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>valuesLists</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformValuesClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_NONE</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformSelectStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformSetOperationStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block>
            <break>break;</break>

            <comment type="block">/*
             * Special cases
             */</comment>
        <case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformDeclareCursorStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                                <argument><expr><operator>(</operator><name>DeclareCursorStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ExplainStmt</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformExplainStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                          <argument><expr><operator>(</operator><name>ExplainStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <case>case <expr><name>T_ExecDirectStmt</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformExecDirectStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                             <argument><expr><operator>(</operator><name>ExecDirectStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformCreateTableAsStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                                <argument><expr><operator>(</operator><name>CreateTableAsStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>

            <comment type="block">/*
             * other statements don't require any transformation; just return
             * the original parsetree with a Query node plastered on top.
             */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/* Mark as original query until we learn differently */</comment>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>querySource</name></name> <operator>=</operator> <name>QSRC_ORIGINAL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * analyze_requires_snapshot
 *        Returns true if a snapshot must be set before doing parse analysis
 *        on the given raw parse tree.
 *
 * Classification here should match transformStmt().
 */</comment>
<function><type><name>bool</name></type>
<name>analyze_requires_snapshot</name><parameter_list>(<parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name><name>parseTree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
            <comment type="block">/*
             * Optimizable statements
             */</comment>
        <case>case <expr><name>T_InsertStmt</name></expr>:</case>
        <case>case <expr><name>T_DeleteStmt</name></expr>:</case>
        <case>case <expr><name>T_UpdateStmt</name></expr>:</case>
        <case>case <expr><name>T_SelectStmt</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>

            <comment type="block">/*
             * Special cases
             */</comment>
        <case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
        <case>case <expr><name>T_ExplainStmt</name></expr>:</case>
        <case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
            <comment type="block">/* yes, because we must analyze the contained statement */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <case>case <expr><name>T_ExecDirectStmt</name></expr>:</case>

            <comment type="block">/*
             * We will parse/analyze/plan inner query, which probably will
             * need a snapshot. Ensure it is set.
             */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <default>default:</default>
            <comment type="block">/* other utility statements don't have any real parse analysis */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformDeleteStmt -
 *      transforms a Delete Statement
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformDeleteStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>DeleteStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>qry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_DELETE</name></expr>;</expr_stmt>

    <comment type="block">/* process the WITH clause independently of all else */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasRecursive</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>withClause</name><operator>-&gt;</operator><name>recursive</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>cteList</name></name> <operator>=</operator> <call><name>transformWithClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasModifyingCTE</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* set up range table with just the result rel */</comment>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>=</operator> <call><name>setTargetTable</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
                                         <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>,
                                         <argument><expr><name>true</name></expr></argument>,
                                         <argument><expr><name>ACL_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* grab the namespace item made by setTargetTable */</comment>
    <expr_stmt><expr><name>nsitem</name> <operator>=</operator> <operator>(</operator><name>ParseNamespaceItem</name> <operator>*</operator><operator>)</operator> <call><name>llast</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* there's no DISTINCT in DELETE */</comment>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <comment type="block">/* subqueries in USING cannot access the result relation */</comment>
    <expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_only</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/*
     * The USING clause is non-standard SQL syntax, and is equivalent in
     * functionality to the FROM list that can be specified for UPDATE. The
     * USING keyword is used rather than FROM because FROM is already a
     * keyword in the DELETE syntax.
     */</comment>
    <expr_stmt><expr><call><name>transformFromClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>usingClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* remaining clauses can reference the result relation normally */</comment>
    <expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_only</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_ok</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>transformWhereClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>,
                                <argument><expr><name>EXPR_KIND_WHERE</name></expr></argument>, <argument><expr><literal type="string">"WHERE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>returningList</name></name> <operator>=</operator> <call><name>transformReturningList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* done building the range table and jointree */</comment>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasWindowFuncs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasTargetSRFs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>parseCheckAggregates</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Determine whether tables of different groups are allowed to insert.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_table_allowed_insert</name><parameter_list>(<parameter><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>to</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>from_nodelist</name> <init>= <expr><name><name>from</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>to_nodelist</name> <init>= <expr><name><name>to</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>diff</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* necessary check, will never happened. */</comment>
	<if_stmt><if>if <condition>(<expr><name>from</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>to</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"is_reptable_allow_insert, invalid params %s:%s"</literal></expr></argument>,
			<argument><expr><ternary><condition><expr><name>from</name></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">"from is null"</literal></expr></else></ternary></expr></argument>,
			<argument><expr><ternary><condition><expr><name>to</name></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">"to is null"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* step1: From table must be replication table. */</comment>
	<if_stmt><if>if <condition>(
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
		<expr><operator>(</operator><name><name>from</name><operator>-&gt;</operator><name>coldGroupId</name></name> <operator>!=</operator> <name><name>to</name><operator>-&gt;</operator><name>coldGroupId</name></name><operator>)</operator> <operator>||</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<operator>(</operator><operator>(</operator><name><name>from</name><operator>-&gt;</operator><name>groupId</name></name> <operator>!=</operator> <name><name>to</name><operator>-&gt;</operator><name>groupId</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>IsRelationReplicated</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* step2: Data distribution nodes have intersections */</comment>
	<expr_stmt><expr><name>diff</name> <operator>=</operator> <call><name>list_difference_int</name><argument_list>(<argument><expr><name>to_nodelist</name></expr></argument>, <argument><expr><name>from_nodelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* stemp3: Insertions are allowed if there is an intersection of data distribution nodes. */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>to_nodelist</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformInsertStmt -
 *      transform an Insert Statement
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformInsertStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>InsertStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>qry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>selectStmt</name> <init>= <expr><operator>(</operator><name>SelectStmt</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>selectStmt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>exprList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isGeneralSelect</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>sub_rtable</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>sub_namespace</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>icolumns</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>attrnos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>icols</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>attnos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isOnConflictUpdate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AclMode</name></type>        <name>targetPerms</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type> <name>ncolumns</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* There can't be any outer WITH to worry about */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_ctenamespace</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_INSERT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_is_insert</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>isSingleValues</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>isMultiValues</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>ninsert_columns</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* process the WITH clause independently of all else */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasRecursive</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>withClause</name><operator>-&gt;</operator><name>recursive</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>cteList</name></name> <operator>=</operator> <call><name>transformWithClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasModifyingCTE</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>override</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>override</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>isOnConflictUpdate</name> <operator>=</operator> <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>onConflictClause</name></name> <operator>&amp;&amp;</operator>
                          <name><name>stmt</name><operator>-&gt;</operator><name>onConflictClause</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/*
     * We have three cases to deal with: DEFAULT VALUES (selectStmt == NULL),
     * VALUES list, or general SELECT input.  We special-case VALUES, both for
     * efficiency and so we can handle DEFAULT specifications.
     *
     * The grammar allows attaching ORDER BY, LIMIT, FOR UPDATE, or WITH to a
     * VALUES clause.  If we have any of those, treat it as a general SELECT;
     * so it will work, but you can't use DEFAULT items together with those.
     */</comment>
    <expr_stmt><expr><name>isGeneralSelect</name> <operator>=</operator> <operator>(</operator><name>selectStmt</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>selectStmt</name><operator>-&gt;</operator><name>valuesLists</name></name> <operator>==</operator> <name>NIL</name> <operator>||</operator>
                                      <name><name>selectStmt</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator>
                                      <name><name>selectStmt</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
                                      <name><name>selectStmt</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
                                      <name><name>selectStmt</name><operator>-&gt;</operator><name>lockingClause</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator>
                                      <name><name>selectStmt</name><operator>-&gt;</operator><name>withClause</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/*
     * If a non-nil rangetable/namespace was passed in, and we are doing
     * INSERT/SELECT, arrange to pass the rangetable/namespace down to the
     * SELECT.  This can only happen if we are inside a CREATE RULE, and in
     * that case we want the rule's OLD and NEW rtable entries to appear as
     * part of the SELECT's rtable, not as outer references for it.  (Kluge!)
     * The SELECT's joinlist is not affected however.  We must do this before
     * adding the target table to the INSERT's rtable.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>isGeneralSelect</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>sub_rtable</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sub_namespace</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>sub_rtable</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>        <comment type="block">/* not used, but keep compiler quiet */</comment>
        <expr_stmt><expr><name>sub_namespace</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Must get write lock on INSERT target table before scanning SELECT, else
     * we will grab the wrong kind of initial lock if the target table is also
     * mentioned in the SELECT part.  Note that the target table is not added
     * to the joinlist or namespace.
     */</comment>
    <expr_stmt><expr><name>targetPerms</name> <operator>=</operator> <name>ACL_INSERT</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>isOnConflictUpdate</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>targetPerms</name> <operator>|=</operator> <name>ACL_UPDATE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>=</operator> <call><name>setTargetTable</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
                                         <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>targetPerms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Validate stmt-&gt;cols list, or build default list if no list given */</comment>
    <expr_stmt><expr><name>icolumns</name> <operator>=</operator> <call><name>checkInsertTargets</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cols</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attrnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>icolumns</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>attrnos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Determine which variant of INSERT we have.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>selectStmt</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We have INSERT ... DEFAULT VALUES.  We can handle this case by
         * emitting an empty targetlist --- all columns will be defaulted when
         * the planner expands the targetlist.
         */</comment>
        <expr_stmt><expr><name>exprList</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>isGeneralSelect</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We make the sub-pstate a child of the outer pstate so that it can
         * see any Param definitions supplied from above.  Since the outer
         * pstate's rtable and namespace are presently empty, there are no
         * side-effects of exposing names the sub-SELECT shouldn't be able to
         * see.
         */</comment>
        <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>sub_pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>selectQuery</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<comment type="block">/* prevent insert into cold_hot table select ... */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>target_rel_loc_info</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name><operator>-&gt;</operator><name>rd_locator_info</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>from_rel_loc_info</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>target_rel_loc_info</name> <operator>&amp;&amp;</operator> <name><name>target_rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name></expr>)</condition>
			<block>{<block_content>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>selectStmt-&gt;fromClause</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeVar</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						
						<if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>!=</operator> <name>relid</name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<expr_stmt><expr><name>from_rel_loc_info</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name></name></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_table_allowed_insert</name><argument_list>(<argument><expr><name>from_rel_loc_info</name></expr></argument>, <argument><expr><name>target_rel_loc_info</name></expr></argument>)</argument_list></call></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><literal type="string">"shard table could not be inserted from any other tables in different group"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							
							<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * Process the source SELECT.
         *
         * It is important that this be handled just like a standalone SELECT;
         * otherwise the behavior of SELECT within INSERT might be different
         * from a stand-alone SELECT. (Indeed, Postgres up through 6.5 had
         * bugs of just that nature...)
         *
         * The sole exception is that we prevent resolving unknown-type
         * outputs as TEXT.  This does not change the semantics since if the
         * column type matters semantically, it would have been resolved to
         * something else anyway.  Doing this lets us resolve such outputs as
         * the target column's type, which we handle below.
         */</comment>
        <expr_stmt><expr><name><name>sub_pstate</name><operator>-&gt;</operator><name>p_rtable</name></name> <operator>=</operator> <name>sub_rtable</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sub_pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>    <comment type="block">/* sub_rtable has no joins */</comment>
        <expr_stmt><expr><name><name>sub_pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <name>sub_namespace</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sub_pstate</name><operator>-&gt;</operator><name>p_resolve_unknowns</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>selectQuery</name> <operator>=</operator> <call><name>transformStmt</name><argument_list>(<argument><expr><name>sub_pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>selectStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>sub_pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* The grammar should have produced a SELECT */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>selectQuery</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <name><name>selectQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected non-SELECT command in INSERT ... SELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Make the source be a subquery in the INSERT's rangetable, and add
         * it to the INSERT's joinlist.
         */</comment>
        <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                            <argument><expr><name>selectQuery</name></expr></argument>,
                                            <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"*SELECT*"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><name>false</name></expr></argument>,
                                            <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* assume new rte is at end */</comment>
        <expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name> <operator>==</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>rtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*----------
         * Generate an expression list for the INSERT that selects all the
         * non-resjunk columns from the subquery.  (INSERT's tlist must be
         * separate from the subquery's tlist because we may add columns,
         * insert datatype coercions, etc.)
         *
         * HACK: unknown-type constants and params in the SELECT's targetlist
         * are copied up as-is rather than being referenced as subquery
         * outputs.  This is to ensure that when we try to coerce them to
         * the target column's datatype, the right things happen (see
         * special cases in coerce_type).  Otherwise, this fails:
         *        INSERT INTO foo SELECT 'bar', ... FROM baz
         *----------
         */</comment>
        <expr_stmt><expr><name>exprList</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>selectQuery-&gt;targetList</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>&amp;&amp;</operator>
                <operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
                <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>expr</name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>Var</name>           <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>makeVarFromTargetEntry</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>exprList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>exprList</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <comment type="block">/* Prepare row for assignment to target table */</comment>
        <expr_stmt><expr><name>exprList</name> <operator>=</operator> <call><name>transformInsertRow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>exprList</name></expr></argument>,
                                      <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cols</name></name></expr></argument>,
                                      <argument><expr><name>icolumns</name></expr></argument>, <argument><expr><name>attrnos</name></expr></argument>,
                                      <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>selectStmt</name><operator>-&gt;</operator><name>valuesLists</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Process INSERT ... VALUES with multiple VALUES sublists. We
         * generate a VALUES RTE holding the transformed expression lists, and
         * build up a targetlist containing Vars that reference the VALUES
         * RTE.
         */</comment>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>exprsLists</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>coltypes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>coltypmods</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>colcollations</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>sublist_length</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>lateral</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>selectStmt</name><operator>-&gt;</operator><name>intoClause</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
        <comment type="block">/* prevent insert into cold_hot table select ... */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name><operator>-&gt;</operator><name>rd_locator_info</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>rel_loc_info</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call> 
                    <operator>||</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"table in cold-hot group or key-value group could not join with other tables."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/*
         * transform 'insert into values' into 'COPY FROM', only handle
         * distributed relation(by hash/shard/replication) without
         * on conflict/returning/with clause/triggers.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>g_transform_insert_to_copy</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator>
            <operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>onConflictClause</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>returningList</name></name> <operator>&amp;&amp;</operator>
            <operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>explain_stmt</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name><operator>-&gt;</operator><name>rd_locator_info</name></name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_HASH</name> <operator>||</operator>
                    <name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name> <operator>||</operator>
                    <name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_REPLICATED</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>isMultiValues</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                    <comment type="block">/* has triggers? */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgxc_check_triggers_shippability</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasUnshippableTriggers</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * put values into memory, then copy to remote datanode
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>isMultiValues</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>qry</name><operator>-&gt;</operator><name>hasUnshippableTriggers</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>  <name>copy_from</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>   <name>ndatarows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>   <name>column_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>  <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>data_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>ncolumns</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            
            <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>cols</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>ncolumns</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Generate default column list */</comment>
                <decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>attr</name> <init>= <expr><name><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>attr_count</name> <init>= <expr><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>attr</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
                        <continue>continue;</continue></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>ncolumns</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>ninsert_columns</name></name> <operator>=</operator> <name>ncolumns</name></expr>;</expr_stmt>
            
            <comment type="block">/* 
             * if in extend PROTOCOL, let bind handle it 
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>IsExtendedQuery</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <goto>goto <name>TRANSFORM_VALUELISTS</name>;</goto>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>exprList</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

            <comment type="block">/* transform all values into memory */</comment>
            <expr_stmt><expr><name>ndatarows</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>selectStmt</name><operator>-&gt;</operator><name>valuesLists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>data_list</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndatarows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndatarows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>data_list</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            
            <expr_stmt><expr><name>column_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>selectStmt-&gt;valuesLists</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>sublist</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                
                <expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <comment type="block">/*
                 * number of values does not match insert columns, unexpected case,
                 * do not copy from
                 */</comment>
                <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>ncolumns</name> <operator>!=</operator> <name>count</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>copy_from</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>sublist</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>A_Const</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="block">/* we can just handle simple case, the value must be const */</comment>
                    <switch>switch<condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><name>T_A_Const</name></expr>:</case>
                            <break>break;</break>
                        <case>case <expr><name>T_TypeCast</name></expr>:</case>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>TypeCast</name> <modifier>*</modifier></type><name>cast</name> <init>= <expr><operator>(</operator><name>TypeCast</name> <operator>*</operator><operator>)</operator><name>v</name></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>cast</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator><name><name>cast</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <expr_stmt><expr><name>copy_from</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>
                            <break>break;</break>
                        </block_content>}</block>
                        <default>default:</default>
                            <block>{<block_content>
                                <expr_stmt><expr><name>copy_from</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                                <break>break;</break>
                            </block_content>}</block>
                    </block_content>}</block></switch>

                    <comment type="block">/* COPY_FROM could not read from file */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>copy_from</name></expr>)</condition>
                    <block>{<block_content>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>

                    <comment type="block">/* A_Const */</comment>
                    <switch>switch<condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><name>T_Integer</name></expr>:</case>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>StringInfoData</name></type> <name>data</name></decl>;</decl_stmt>
                                <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><literal type="string">"%ld"</literal></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>ival</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>data_list</name><index>[<expr><name>column_index</name></expr>]</index><index>[<expr><name>index</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name>count</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>column_index</name><operator>++</operator></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                                <break>break;</break>
                            </block_content>}</block>
                        <case>case <expr><name>T_Float</name></expr>:</case>
                        <case>case <expr><name>T_String</name></expr>:</case>
                        <case>case <expr><name>T_BitString</name></expr>:</case>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>data_list</name><index>[<expr><name>column_index</name></expr>]</index><index>[<expr><name>index</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name>count</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>column_index</name><operator>++</operator></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                                <break>break;</break>
                            </block_content>}</block>
                        <case>case <expr><name>T_Null</name></expr>:</case>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>data_list</name><index>[<expr><name>column_index</name></expr>]</index><index>[<expr><name>index</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name>count</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>column_index</name><operator>++</operator></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                                <break>break;</break>
                            </block_content>}</block>
                        <default>default:</default>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown value type %d"</literal></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></switch>
                </block_content>}</block>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>copy_from</name></expr>)</condition>
                <block>{<block_content>
                    <break>break;</break>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* sanity check */</comment>
                    <if_stmt><if>if <condition>(<expr><name>index</name> <operator>!=</operator> <name>count</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"insert columns mismatched, expected %d, result %d"</literal></expr></argument>,
                                     <argument><expr><name>count</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block>

            <if_stmt><if>if <condition>(<expr><name>copy_from</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>ndatarows</name> <operator>!=</operator> <name>column_index</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"datarow count mismatched, expected %d, result %d"</literal></expr></argument>,
                                 <argument><expr><name>ndatarows</name></expr></argument>, <argument><expr><name>column_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>copy_filename</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>copy_filename</name></name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"Insert_into to Copy_from(Simple Protocl)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>ndatarows</name></name> <operator>=</operator> <name>ndatarows</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>data_list</name></name> <operator>=</operator> <name>data_list</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>isMultiValues</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <goto>goto <name>TRANSFORM_VALUELISTS</name>;</goto>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<label><name>TRANSFORM_VALUELISTS</name>:</label>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>selectStmt-&gt;valuesLists</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>sublist</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * Do basic expression transformation (same as a ROW() expr, but
             * allow SetToDefault at top level)
             */</comment>
            <expr_stmt><expr><name>sublist</name> <operator>=</operator> <call><name>transformExpressionList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>sublist</name></expr></argument>,
                                              <argument><expr><name>EXPR_KIND_VALUES</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * All the sublists must be the same length, *after*
             * transformation (which might expand '*' into multiple items).
             * The VALUES RTE can't handle anything different.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>sublist_length</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Remember post-transformation length of first sublist */</comment>
                <expr_stmt><expr><name>sublist_length</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>sublist_length</name> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"VALUES lists must all be the same length"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                            <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sublist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><call><name>IsExtendedQuery</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>qry</name><operator>-&gt;</operator><name>isMultiValues</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>qry</name><operator>-&gt;</operator><name>hasUnshippableTriggers</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
				 * simple insert if all values are params or can be pushed down
                 *
                 * if not simple insert, do not transform insert into to copy from
                 */</comment>
                <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
                <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>sublist</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					    <operator>!</operator><call><name>pgxc_is_expr_shippable</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name><operator>*</operator><operator>)</operator><name>node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>isMultiValues</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="block">/*
             * Prepare row for assignment to target table.  We process any
             * indirection on the target column specs normally but then strip
             * off the resulting field/array assignment nodes, since we don't
             * want the parsed statement to contain copies of those in each
             * VALUES row.  (It's annoying to have to transform the
             * indirection specs over and over like this, but avoiding it
             * would take some really messy refactoring of
             * transformAssignmentIndirection.)
             */</comment>
            <expr_stmt><expr><name>sublist</name> <operator>=</operator> <call><name>transformInsertRow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>sublist</name></expr></argument>,
                                         <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cols</name></name></expr></argument>,
                                         <argument><expr><name>icolumns</name></expr></argument>, <argument><expr><name>attrnos</name></expr></argument>,
                                         <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * We must assign collations now because assign_query_collations
             * doesn't process rangetable entries.  We just assign all the
             * collations independently in each row, and don't worry about
             * whether they are consistent vertically.  The outer INSERT query
             * isn't going to care about the collations of the VALUES columns,
             * so it's not worth the effort to identify a common collation for
             * each one here.  (But note this does have one user-visible
             * consequence: INSERT ... VALUES won't complain about conflicting
             * explicit COLLATEs in a column, whereas the same VALUES
             * construct in another context would complain.)
             */</comment>
            <expr_stmt><expr><call><name>assign_list_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>exprsLists</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>exprsLists</name></expr></argument>, <argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/* number of insert columns must be same as valueslist */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsExtendedQuery</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>qry</name><operator>-&gt;</operator><name>isMultiValues</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>qry</name><operator>-&gt;</operator><name>hasUnshippableTriggers</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>ncolumns</name> <operator>!=</operator> <name>sublist_length</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>isMultiValues</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * Construct column type/typmod/collation lists for the VALUES RTE.
         * Every expression in each column has been coerced to the type/typmod
         * of the corresponding target column or subfield, so it's sufficient
         * to look at the exprType/exprTypmod of the first row.  We don't care
         * about the collation labeling, so just fill in InvalidOid for that.
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>(List *) linitial(exprsLists)</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>val</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>coltypes</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>coltypmods</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>, <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>colcollations</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <comment type="block">/*
         * Ordinarily there can't be any current-level Vars in the expression
         * lists, because the namespace was empty ... but if we're inside
         * CREATE RULE, then NEW/OLD references might appear.  In that case we
         * have to mark the VALUES RTE as LATERAL.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
            <call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>exprsLists</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>lateral</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Generate the VALUES RTE
         */</comment>
        <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForValues</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>exprsLists</name></expr></argument>,
                                          <argument><expr><name>coltypes</name></expr></argument>, <argument><expr><name>coltypmods</name></expr></argument>, <argument><expr><name>colcollations</name></expr></argument>,
                                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lateral</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* assume new rte is at end */</comment>
        <expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name> <operator>==</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>rtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Generate list of Vars referencing the RTE
         */</comment>
        <expr_stmt><expr><call><name>expandRTE</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exprList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Re-apply any indirection on the target column specs to the Vars
         */</comment>
        <expr_stmt><expr><name>exprList</name> <operator>=</operator> <call><name>transformInsertRow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>exprList</name></expr></argument>,
                                      <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cols</name></name></expr></argument>,
                                      <argument><expr><name>icolumns</name></expr></argument>, <argument><expr><name>attrnos</name></expr></argument>,
                                      <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Process INSERT ... VALUES with a single VALUES sublist.  We treat
         * this case separately for efficiency.  The sublist is just computed
         * directly as the Query's targetlist, with no VALUES RTE.  So it
         * works just like a SELECT without any FROM.
         */</comment>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>valuesLists</name> <init>= <expr><name><name>selectStmt</name><operator>-&gt;</operator><name>valuesLists</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>valuesLists</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>selectStmt</name><operator>-&gt;</operator><name>intoClause</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Do basic expression transformation (same as a ROW() expr, but allow
         * SetToDefault at top level)
         */</comment>
        <expr_stmt><expr><name>exprList</name> <operator>=</operator> <call><name>transformExpressionList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                           <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>valuesLists</name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><name>EXPR_KIND_VALUES_SINGLE</name></expr></argument>,
                                           <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Prepare row for assignment to target table */</comment>
        <expr_stmt><expr><name>exprList</name> <operator>=</operator> <call><name>transformInsertRow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>exprList</name></expr></argument>,
                                      <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cols</name></name></expr></argument>,
                                      <argument><expr><name>icolumns</name></expr></argument>, <argument><expr><name>attrnos</name></expr></argument>,
                                      <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if<condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>partcol</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>att_no</name></decl>;</decl_stmt>
            
            <decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>cl1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cl2</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Node</name>        <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>allareconst</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>partcol</name> <operator>=</operator> <call><name>RelationGetPartitionColumnIndex</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <macro><name>forboth</name><argument_list>(<argument>cl1</argument>,<argument>exprList</argument>,<argument>cl2</argument>, <argument>attrnos</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>cl1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>att_no</name> <operator>=</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>cl2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if<condition>(<expr><name>att_no</name> <operator>==</operator> <name>partcol</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>,<argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>allareconst</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>isSingleValues</name></name> <operator>=</operator> <name>allareconst</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>        
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Generate query's target list using the computed list of expressions.
     * Also, mark all the target columns as needing insert permissions.
     */</comment>
    <expr_stmt><expr><name>rte</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_target_rangetblentry</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>icols</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>icolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>attnos</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>attrnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>exprList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attr_num</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>ResTarget</name></expr></argument>, <argument><expr><name>icols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>attr_num</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name><operator>)</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>attnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>expr</name></expr></argument>,
                              <argument><expr><name>attr_num</name></expr></argument>,
                              <argument><expr><name><name>col</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                              <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name></expr></argument>,
                                           <argument><expr><name>attr_num</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>icols</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>icols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>attnos</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>attnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Process ON CONFLICT, if any. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>onConflictClause</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>onConflict</name></name> <operator>=</operator> <call><name>transformOnConflictClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                                    <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>onConflictClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If we have a RETURNING clause, we need to add the target relation to
     * the query namespace before processing it, so that Var references in
     * RETURNING will work.  Also, remove any namespace entries added in a
     * sub-SELECT or VALUES list.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_rangetblentry</name></name></expr></argument>,
                      <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>returningList</name></name> <operator>=</operator> <call><name>transformReturningList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                                    <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* done building the range table and jointree */</comment>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasTargetSRFs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare an INSERT row for assignment to the target table.
 *
 * exprlist: transformed expressions for source values; these might come from
 * a VALUES row, or be Vars referencing a sub-SELECT or VALUES RTE output.
 * stmtcols: original target-columns spec for INSERT (we just test for NIL)
 * icolumns: effective target-columns spec (list of ResTarget)
 * attrnos: integer column numbers (must be same length as icolumns)
 * strip_indirection: if true, remove any field/array assignment nodes
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>transformInsertRow</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprlist</name></decl></parameter>,
                   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmtcols</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>icolumns</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attrnos</name></decl></parameter>,
                   <parameter><decl><type><name>bool</name></type> <name>strip_indirection</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>icols</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>attnos</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Check length of expr list.  It must not have more expressions than
     * there are target columns.  We allow fewer, but only if no explicit
     * columns list was given (the remaining columns are implicitly
     * defaulted).  Note we must check this *after* transformation because
     * that could expand '*' into multiple items.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>exprlist</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>icolumns</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INSERT has more expressions than target columns"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                    <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>exprlist</name></expr></argument>,
                                                          <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>icolumns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>stmtcols</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
        <call><name>list_length</name><argument_list>(<argument><expr><name>exprlist</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>icolumns</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We can get here for cases like INSERT ... SELECT (a,b,c) FROM ...
         * where the user accidentally created a RowExpr instead of separate
         * columns.  Add a suitable hint if that seems to be the problem,
         * because the main error message is quite misleading for this case.
         * (If there's no stmtcols, you'll get something about data type
         * mismatch, which is less misleading so we don't worry about giving a
         * hint in that case.)
         */</comment>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INSERT has more target columns than expressions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <operator>(</operator><ternary><condition><expr><operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>exprlist</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
                   <call><name>count_rowexpr_columns</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>exprlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator>
                   <call><name>list_length</name><argument_list>(<argument><expr><name>icolumns</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then>
                  <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The insertion source is a row expression containing the same number of columns expected by the INSERT. Did you accidentally use extra parentheses?"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                    <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>icolumns</name></expr></argument>,
                                                          <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>exprlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Prepare columns for assignment to target table.
     */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>icols</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>icolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>attnos</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>attrnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>exprlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>ResTarget</name></expr></argument>, <argument><expr><name>icols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformAssignedExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>,
                                     <argument><expr><name>EXPR_KIND_INSERT_TARGET</name></expr></argument>,
                                     <argument><expr><name><name>col</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                                     <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>attnos</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name><name>col</name><operator>-&gt;</operator><name>indirection</name></name></expr></argument>,
                                     <argument><expr><name><name>col</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>strip_indirection</name></expr>)</condition>
        <block>{<block_content>
            <while>while <condition>(<expr><name>expr</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FieldStore</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>FieldStore</name> <modifier>*</modifier></type><name>fstore</name> <init>= <expr><operator>(</operator><name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>ArrayRef</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ArrayRef</name>   <modifier>*</modifier></type><name>aref</name> <init>= <expr><operator>(</operator><name>ArrayRef</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>aref</name><operator>-&gt;</operator><name>refassgnexpr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>expr</name> <operator>=</operator> <name><name>aref</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></else></if_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>icols</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>icols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>attnos</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>attnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformOnConflictClause -
 *      transforms an OnConflictClause in an INSERT
 */</comment>
<function><type><specifier>static</specifier> <name>OnConflictExpr</name> <modifier>*</modifier></type>
<name>transformOnConflictClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
                          <parameter><decl><type><name>OnConflictClause</name> <modifier>*</modifier></type><name>onConflictClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>arbiterElems</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>arbiterWhere</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>arbiterConstraint</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>onConflictSet</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>onConflictWhere</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>exclRte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>exclRelIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>exclRelTlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OnConflictExpr</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <comment type="block">/* Process the arbiter clause, ON CONFLICT ON (...) */</comment>
    <expr_stmt><expr><call><name>transformOnConflictArbiter</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>onConflictClause</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arbiterElems</name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name>arbiterWhere</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arbiterConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Process DO UPDATE */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>onConflictClause</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>targetrel</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Var</name>           <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>attno</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>targetrel</name><operator>-&gt;</operator><name>rd_partdesc</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot be applied to partitioned table \"%s\""</literal></expr></argument>,
							<argument><expr><literal type="string">"ON CONFLICT DO UPDATE"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>targetrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * All INSERT expressions have been parsed, get ready for potentially
         * existing SET statements that need to be processed like an UPDATE.
         */</comment>
        <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_is_insert</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Add range table entry for the EXCLUDED pseudo relation; relkind is
         * set to composite to signal that we're not dealing with an actual
         * relation.
         */</comment>
        <expr_stmt><expr><name>exclRte</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                                <argument><expr><name>targetrel</name></expr></argument>,
                                                <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"excluded"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
                                                <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>exclRte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>exclRelIndex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Build a targetlist representing the columns of the EXCLUDED pseudo
         * relation.  Have to be careful to use resnos that correspond to
         * attnos of the underlying relation.
         */</comment>
        <for>for <control>(<init><expr><name>attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attno</name> <operator>&lt;</operator> <name><name>targetrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnatts</name></name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><name><name>targetrel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * can't use atttypid here, but it doesn't really matter what
                 * type the Const claims to be.
                 */</comment>
                <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>name</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>exclRelIndex</name></expr></argument>, <argument><expr><name>attno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                              <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
                              <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
                              <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
                                 <argument><expr><name>attno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                                 <argument><expr><name>name</name></expr></argument>,
                                 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* don't require select access yet */</comment>
            <expr_stmt><expr><name>exclRelTlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>exclRelTlist</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/*
         * Add a whole-row-Var entry to support references to "EXCLUDED.*".
         * Like the other entries in exclRelTlist, its resno must match the
         * Var's varattno, else the wrong things happen while resolving
         * references in setrefs.c.  This is against normal conventions for
         * targetlists, but it's okay since we don't use this as a real tlist.
         */</comment>
        <expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>exclRelIndex</name></expr></argument>, <argument><expr><name>InvalidAttrNumber</name></expr></argument>,
                      <argument><expr><name><name>targetrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>,
                      <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>, <argument><expr><name>InvalidAttrNumber</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>exclRelTlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>exclRelTlist</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Add EXCLUDED and the target RTE to the namespace, so that they can
         * be used in the UPDATE statement.
         */</comment>
        <expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>exclRte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_rangetblentry</name></name></expr></argument>,
                      <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>onConflictSet</name> <operator>=</operator>
            <call><name>transformUpdateTargetList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>onConflictClause</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>onConflictWhere</name> <operator>=</operator> <call><name>transformWhereClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                               <argument><expr><name><name>onConflictClause</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>,
                                               <argument><expr><name>EXPR_KIND_WHERE</name></expr></argument>, <argument><expr><literal type="string">"WHERE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Finally, build ON CONFLICT DO [NOTHING | UPDATE] expression */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>OnConflictExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name><name>onConflictClause</name><operator>-&gt;</operator><name>action</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>arbiterElems</name></name> <operator>=</operator> <name>arbiterElems</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>arbiterWhere</name></name> <operator>=</operator> <name>arbiterWhere</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>constraint</name></name> <operator>=</operator> <name>arbiterConstraint</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>onConflictSet</name></name> <operator>=</operator> <name>onConflictSet</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>onConflictWhere</name></name> <operator>=</operator> <name>onConflictWhere</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>exclRelIndex</name></name> <operator>=</operator> <name>exclRelIndex</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>exclRelTlist</name></name> <operator>=</operator> <name>exclRelTlist</name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * count_rowexpr_columns -
 *      get number of columns contained in a ROW() expression;
 *      return -1 if expression isn't a RowExpr or a Var referencing one.
 *
 * This is currently used only for hint purposes, so we aren't terribly
 * tense about recognizing all possible cases.  The Var case is interesting
 * because that's what we'll get in the INSERT ... SELECT (...) case.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>count_rowexpr_columns</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Var</name>           <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attnum</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>GetRTEByRangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Subselect-in-FROM: examine sub-select's output expr */</comment>
                <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>ste</name> <init>= <expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                                    <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>ste</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ste</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ste</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * transformSelectStmt -
 *      transforms a Select Statement
 *
 * Note: this covers only cases with no set operations and no VALUES lists;
 * see below for the other cases.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformSelectStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>qry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

    <comment type="block">/* process the WITH clause independently of all else */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasRecursive</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>withClause</name><operator>-&gt;</operator><name>recursive</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>cteList</name></name> <operator>=</operator> <call><name>transformWithClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasModifyingCTE</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Complain if we get called from someplace where INTO is not allowed */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>intoClause</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SELECT ... INTO is not allowed here"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                    <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>intoClause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* make FOR UPDATE/FOR SHARE info available to addRangeTableEntry */</comment>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_locking_clause</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>lockingClause</name></name></expr>;</expr_stmt>

    <comment type="block">/* make WINDOW info available for window functions, too */</comment>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_windowdefs</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>windowClause</name></name></expr>;</expr_stmt>

    <comment type="block">/* process the FROM clause */</comment>
    <expr_stmt><expr><call><name>transformFromClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>fromClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* transform targetlist */</comment>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>transformTargetList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                          <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* mark column origins */</comment>
    <expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* transform WHERE */</comment>
    <expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>transformWhereClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>,
                                <argument><expr><name>EXPR_KIND_WHERE</name></expr></argument>, <argument><expr><literal type="string">"WHERE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* initial processing of HAVING clause is much like WHERE clause */</comment>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>=</operator> <call><name>transformWhereClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>havingClause</name></name></expr></argument>,
                                           <argument><expr><name>EXPR_KIND_HAVING</name></expr></argument>, <argument><expr><literal type="string">"HAVING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Transform sorting/grouping stuff.  Do ORDER BY first because both
     * transformGroupClause and transformDistinctClause need the results. Note
     * that these functions can also change the targetList, so it's passed to
     * them by reference.
     */</comment>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>=</operator> <call><name>transformSortClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                          <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                          <argument><expr><name>EXPR_KIND_ORDER_BY</name></expr></argument>,
                                          <argument><expr><name>false</name></expr></argument> <comment type="block">/* allow SQL92 rules */</comment> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <call><name>transformGroupClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                            <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                            <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>,
                                            <argument><expr><name>EXPR_KIND_GROUP_BY</name></expr></argument>,
                                            <argument><expr><name>false</name></expr></argument> <comment type="block">/* allow SQL92 rules */</comment> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We had SELECT DISTINCT */</comment>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>=</operator> <call><name>transformDistinctClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                                      <argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                                      <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>,
                                                      <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* We had SELECT DISTINCT ON */</comment>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>=</operator> <call><name>transformDistinctOnClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                                        <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>,
                                                        <argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                                        <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* transform LIMIT */</comment>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <call><name>transformLimitClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>,
                                            <argument><expr><name>EXPR_KIND_OFFSET</name></expr></argument>, <argument><expr><literal type="string">"OFFSET"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <call><name>transformLimitClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>,
                                           <argument><expr><name>EXPR_KIND_LIMIT</name></expr></argument>, <argument><expr><literal type="string">"LIMIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* transform window clauses after we have seen all window functions */</comment>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>=</operator> <call><name>transformWindowDefinitions</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                                   <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_windowdefs</name></name></expr></argument>,
                                                   <argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* resolve any still-unresolved output columns as being type text */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_resolve_unknowns</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>resolveTargetListUnknowns</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasWindowFuncs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasTargetSRFs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name> <operator>||</operator> <name><name>qry</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator> <name><name>qry</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator> <name><name>qry</name><operator>-&gt;</operator><name>havingQual</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>parseCheckAggregates</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>stmt-&gt;lockingClause</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><call><name>transformLockingClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>,
                               <argument><expr><operator>(</operator><name>LockingClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformValuesClause -
 *      transforms a VALUES clause that's being used as a standalone SELECT
 *
 * We build a Query containing a VALUES RTE, rather as if one had written
 *            SELECT * FROM (VALUES ...) AS "*VALUES*"
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformValuesClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>qry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>exprsLists</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>coltypes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>coltypmods</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>colcollations</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>      <modifier>*</modifier><modifier>*</modifier></type><name>colexprs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>sublist_length</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>lateral</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rtindex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

    <comment type="block">/* Most SELECT stuff doesn't apply in a VALUES clause */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>intoClause</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>targetList</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>havingClause</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* process the WITH clause independently of all else */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasRecursive</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>withClause</name><operator>-&gt;</operator><name>recursive</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>cteList</name></name> <operator>=</operator> <call><name>transformWithClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasModifyingCTE</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * For each row of VALUES, transform the raw expressions.
     *
     * Note that the intermediate representation we build is column-organized
     * not row-organized.  That simplifies the type and collation processing
     * below.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;valuesLists</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>sublist</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Do basic expression transformation (same as a ROW() expr, but here
         * we disallow SetToDefault)
         */</comment>
        <expr_stmt><expr><name>sublist</name> <operator>=</operator> <call><name>transformExpressionList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>sublist</name></expr></argument>,
                                          <argument><expr><name>EXPR_KIND_VALUES</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * All the sublists must be the same length, *after* transformation
         * (which might expand '*' into multiple items).  The VALUES RTE can't
         * handle anything different.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>sublist_length</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Remember post-transformation length of first sublist */</comment>
            <expr_stmt><expr><name>sublist_length</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* and allocate array for per-column lists */</comment>
            <expr_stmt><expr><name>colexprs</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>sublist_length</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>sublist_length</name> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"VALUES lists must all be the same length"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                        <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sublist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Build per-column expression lists */</comment>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>sublist</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>col</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>colexprs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>colexprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block>

        <comment type="block">/* Release sub-list's cells to save memory */</comment>
        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Now resolve the common types of the columns, and coerce everything to
     * those types.  Then identify the common typmod and common collation, if
     * any, of each column.
     *
     * We must do collation processing now because (1) assign_query_collations
     * doesn't process rangetable entries, and (2) we need to label the VALUES
     * RTE with column collations for use in the outer query.  We don't
     * consider conflict of implicit collations to be an error here; instead
     * the column will just show InvalidOid as its collation, and you'll get a
     * failure later if that results in failure to resolve a collation.
     *
     * Note we modify the per-column expression lists in-place.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sublist_length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>coltype</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>coltypmod</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>colcoll</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>coltype</name> <operator>=</operator> <call><name>select_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>colexprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"VALUES"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>colexprs[i]</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>col</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>coltype</name></expr></argument>, <argument><expr><literal type="string">"VALUES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>col</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>coltypmod</name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* As soon as we see a non-matching typmod, fall back to -1 */</comment>
                <if_stmt><if>if <condition>(<expr><name>coltypmod</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>coltypmod</name> <operator>!=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>coltypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block>

        <expr_stmt><expr><name>colcoll</name> <operator>=</operator> <call><name>select_common_collation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>colexprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>coltypes</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>, <argument><expr><name>coltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>coltypmods</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>, <argument><expr><name>coltypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>colcollations</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>, <argument><expr><name>colcoll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Finally, rearrange the coerced expressions into row-organized lists.
     */</comment>
    <expr_stmt><expr><name>exprsLists</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>colexprs[<literal type="number">0</literal>]</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>col</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>sublist</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>sublist</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>exprsLists</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>exprsLists</name></expr></argument>, <argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>colexprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sublist_length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <macro><name>forboth</name><argument_list>(<argument>lc</argument>, <argument>colexprs[i]</argument>, <argument>lc2</argument>, <argument>exprsLists</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>col</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>sublist</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* sublist pointer in exprsLists won't need adjustment */</comment>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>sublist</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>colexprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Ordinarily there can't be any current-level Vars in the expression
     * lists, because the namespace was empty ... but if we're inside CREATE
     * RULE, then NEW/OLD references might appear.  In that case we have to
     * mark the VALUES RTE as LATERAL.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
        <call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>exprsLists</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>lateral</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Generate the VALUES RTE
     */</comment>
    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForValues</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>exprsLists</name></expr></argument>,
                                      <argument><expr><name>coltypes</name></expr></argument>, <argument><expr><name>coltypmods</name></expr></argument>, <argument><expr><name>colcollations</name></expr></argument>,
                                      <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lateral</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* assume new rte is at end */</comment>
    <expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name> <operator>==</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Generate a targetlist as though expanding "*"
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>expandRelAttrs</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The grammar allows attaching ORDER BY, LIMIT, and FOR UPDATE to a
     * VALUES, so cope.
     */</comment>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>=</operator> <call><name>transformSortClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                          <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                          <argument><expr><name>EXPR_KIND_ORDER_BY</name></expr></argument>,
                                          <argument><expr><name>false</name></expr></argument> <comment type="block">/* allow SQL92 rules */</comment> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <call><name>transformLimitClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>,
                                            <argument><expr><name>EXPR_KIND_OFFSET</name></expr></argument>, <argument><expr><literal type="string">"OFFSET"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <call><name>transformLimitClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>,
                                           <argument><expr><name>EXPR_KIND_LIMIT</name></expr></argument>, <argument><expr><literal type="string">"LIMIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>lockingClause</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/*------
          translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot be applied to VALUES"</literal></expr></argument>,
                        <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>LockingClause</name> <operator>*</operator><operator>)</operator>
                                      <call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>lockingClause</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformSetOperationStmt -
 *      transforms a set-operations tree
 *
 * A set-operation tree is just a SELECT, but with UNION/INTERSECT/EXCEPT
 * structure to it.  We must transform each leaf SELECT and build up a top-
 * level Query that contains the leaf SELECTs as subqueries in its rangetable.
 * The tree of set operations is converted into the setOperations field of
 * the top-level Query.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformSetOperationStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>qry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>leftmostSelect</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>leftmostRTI</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>leftmostQuery</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>sostmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>sortClause</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>limitOffset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>limitCount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>lockingClause</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WithClause</name> <modifier>*</modifier></type><name>withClause</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>left_tlist</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>lct</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>lcm</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>lcc</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>targetvars</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>targetnames</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>sv_namespace</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>sv_rtable_length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>jrte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>tllen</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Find leftmost leaf SelectStmt.  We currently only need to do this in
     * order to deliver a suitable error message if there's an INTO clause
     * there, implying the set-op tree is in a context that doesn't allow
     * INTO.  (transformSetOperationTree would throw error anyway, but it
     * seems worth the trouble to throw a different error for non-leftmost
     * INTO, so we produce that error in transformSetOperationTree.)
     */</comment>
    <expr_stmt><expr><name>leftmostSelect</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>larg</name></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>leftmostSelect</name> <operator>&amp;&amp;</operator> <name><name>leftmostSelect</name><operator>-&gt;</operator><name>op</name></name> <operator>!=</operator> <name>SETOP_NONE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>leftmostSelect</name> <operator>=</operator> <name><name>leftmostSelect</name><operator>-&gt;</operator><name>larg</name></name></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leftmostSelect</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>leftmostSelect</name></expr></argument>, <argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
           <name><name>leftmostSelect</name><operator>-&gt;</operator><name>larg</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>leftmostSelect</name><operator>-&gt;</operator><name>intoClause</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SELECT ... INTO is not allowed here"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                    <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>leftmostSelect</name><operator>-&gt;</operator><name>intoClause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We need to extract ORDER BY and other top-level clauses here and not
     * let transformSetOperationTree() see them --- else it'll just recurse
     * right back here!
     */</comment>
    <expr_stmt><expr><name>sortClause</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>sortClause</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>limitOffset</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>limitOffset</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>limitCount</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>limitCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>lockingClause</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>lockingClause</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>withClause</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>lockingClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* We don't support FOR UPDATE/SHARE with set ops at the moment. */</comment>
    <if_stmt><if>if <condition>(<expr><name>lockingClause</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/*------
          translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed with UNION/INTERSECT/EXCEPT"</literal></expr></argument>,
                        <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>LockingClause</name> <operator>*</operator><operator>)</operator>
                                      <call><name>linitial</name><argument_list>(<argument><expr><name>lockingClause</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Process the WITH clause independently of all else */</comment>
    <if_stmt><if>if <condition>(<expr><name>withClause</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasRecursive</name></name> <operator>=</operator> <name><name>withClause</name><operator>-&gt;</operator><name>recursive</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>cteList</name></name> <operator>=</operator> <call><name>transformWithClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>withClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasModifyingCTE</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Recursively transform the components of the tree.
     */</comment>
    <expr_stmt><expr><name>sostmt</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>SetOperationStmt</name></expr></argument>,
                      <argument><expr><call><name>transformSetOperationTree</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sostmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sostmt</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Re-find leftmost SELECT (now it's a sub-query in rangetable)
     */</comment>
    <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>sostmt</name><operator>-&gt;</operator><name>larg</name></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>larg</name></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>leftmostRTI</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>leftmostQuery</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>leftmostRTI</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subquery</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leftmostQuery</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Generate dummy targetlist for outer query using column names of
     * leftmost select and common datatypes/collations of topmost set
     * operation.  Also make lists of the dummy vars and their names for use
     * in parsing ORDER BY.
     *
     * Note: we use leftmostRTI as the varno of the dummy variables. It
     * shouldn't matter too much which RT index they have, as long as they
     * have one that corresponds to a real RT entry; else funny things may
     * happen when the tree is mashed by rule rewriting.
     */</comment>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>targetvars</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>targetnames</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>left_tlist</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>leftmostQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>forthree</name><argument_list>(<argument>lct</argument>, <argument>sostmt-&gt;colTypes</argument>,
             <argument>lcm</argument>, <argument>sostmt-&gt;colTypmods</argument>,
             <argument>lcc</argument>, <argument>sostmt-&gt;colCollations</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>colType</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>colTypmod</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lcm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>colCollation</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lcc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>lefttle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>left_tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>colName</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Var</name>           <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>lefttle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>colName</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>lefttle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>leftmostRTI</name></expr></argument>,
                      <argument><expr><name><name>lefttle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
                      <argument><expr><name>colType</name></expr></argument>,
                      <argument><expr><name>colTypmod</name></expr></argument>,
                      <argument><expr><name>colCollation</name></expr></argument>,
                      <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>lefttle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
                              <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
                              <argument><expr><name>colName</name></expr></argument>,
                              <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>targetvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targetvars</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>targetnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targetnames</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>left_tlist</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>left_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * As a first step towards supporting sort clauses that are expressions
     * using the output columns, generate a namespace entry that makes the
     * output columns visible.  A Join RTE node is handy for this, since we
     * can easily control the Vars generated upon matches.
     *
     * Note: we don't yet do anything useful with such cases, but at least
     * "ORDER BY upper(foo)" will draw the right error message rather than
     * "foo not found".
     */</comment>
    <expr_stmt><expr><name>sv_rtable_length</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>jrte</name> <operator>=</operator> <call><name>addRangeTableEntryForJoin</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                     <argument><expr><name>targetnames</name></expr></argument>,
                                     <argument><expr><name>JOIN_INNER</name></expr></argument>,
                                     <argument><expr><name>targetvars</name></expr></argument>,
                                     <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>sv_namespace</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <comment type="block">/* add jrte to column namespace only */</comment>
    <expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>jrte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * For now, we don't support resjunk sort clauses on the output of a
     * setOperation tree --- you can only use the SQL92-spec options of
     * selecting an output column by name or number.  Enforce by checking that
     * transformSortClause doesn't add any items to tlist.
     */</comment>
    <expr_stmt><expr><name>tllen</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>=</operator> <call><name>transformSortClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                          <argument><expr><name>sortClause</name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                          <argument><expr><name>EXPR_KIND_ORDER_BY</name></expr></argument>,
                                          <argument><expr><name>false</name></expr></argument> <comment type="block">/* allow SQL92 rules */</comment> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* restore namespace, remove jrte from rtable */</comment>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <name>sv_namespace</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name> <operator>=</operator> <call><name>list_truncate</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>, <argument><expr><name>sv_rtable_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>tllen</name> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid UNION/INTERSECT/EXCEPT ORDER BY clause"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Only result column names can be used, not expressions or functions."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Add the expression/function to every SELECT, or move the UNION into a FROM clause."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                    <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tllen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <call><name>transformLimitClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>limitOffset</name></expr></argument>,
                                            <argument><expr><name>EXPR_KIND_OFFSET</name></expr></argument>, <argument><expr><literal type="string">"OFFSET"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <call><name>transformLimitClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>limitCount</name></expr></argument>,
                                           <argument><expr><name>EXPR_KIND_LIMIT</name></expr></argument>, <argument><expr><literal type="string">"LIMIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasWindowFuncs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasTargetSRFs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name> <operator>||</operator> <name><name>qry</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator> <name><name>qry</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator> <name><name>qry</name><operator>-&gt;</operator><name>havingQual</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>parseCheckAggregates</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>lockingClause</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><call><name>transformLockingClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>,
                               <argument><expr><operator>(</operator><name>LockingClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformSetOperationTree
 *        Recursively transform leaves and internal nodes of a set-op tree
 *
 * In addition to returning the transformed node, if targetlist isn't NULL
 * then we return a list of its non-resjunk TargetEntry nodes.  For a leaf
 * set-op node these are the actual targetlist entries; otherwise they are
 * dummy entries created to carry the type, typmod, collation, and location
 * (for error messages) of each output column of the set-op node.  This info
 * is needed only during the internal recursion of this function, so outside
 * callers pass NULL for targetlist.  Note: the reason for passing the
 * actual targetlist entries of a leaf node is so that upper levels can
 * replace UNKNOWN Consts with properly-coerced constants.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformSetOperationTree</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
                          <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isLeaf</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>stmt</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Guard against stack overflow due to overly complex set-expressions */</comment>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Validity-check both leaf and internal SELECTs for disallowed ops.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>intoClause</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INTO is only allowed on first SELECT of UNION/INTERSECT/EXCEPT"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                    <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>intoClause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We don't support FOR UPDATE/SHARE with set ops at the moment. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>lockingClause</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/*------
          translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed with UNION/INTERSECT/EXCEPT"</literal></expr></argument>,
                        <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>LockingClause</name> <operator>*</operator><operator>)</operator>
                                      <call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>lockingClause</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If an internal node of a set-op tree has ORDER BY, LIMIT, FOR UPDATE,
     * or WITH clauses attached, we need to treat it like a leaf node to
     * generate an independent sub-Query tree.  Otherwise, it can be
     * represented by a SetOperationStmt node underneath the parent Query.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_NONE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>larg</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>rarg</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>isLeaf</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>larg</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>rarg</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>||</operator>
            <name><name>stmt</name><operator>-&gt;</operator><name>lockingClause</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>isLeaf</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>isLeaf</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>isLeaf</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Process leaf SELECT */</comment>
        <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>selectQuery</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>selectName</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier><name>rte</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tl</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Transform SelectStmt into a Query.
         *
         * This works the same as SELECT transformation normally would, except
         * that we prevent resolving unknown-type outputs as TEXT.  This does
         * not change the subquery's semantics since if the column type
         * matters semantically, it would have been resolved to something else
         * anyway.  Doing this lets us resolve such outputs using
         * select_common_type(), below.
         *
         * Note: previously transformed sub-queries don't affect the parsing
         * of this sub-query, because they are not in the toplevel pstate's
         * namespace list.
         */</comment>
        <expr_stmt><expr><name>selectQuery</name> <operator>=</operator> <call><name>parse_sub_analyze</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Check for bogus references to Vars on the current query level (but
         * upper-level references are okay). Normally this can't happen
         * because the namespace will be empty, but it could happen if we are
         * inside a rule.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>selectQuery</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"UNION/INTERSECT/EXCEPT member statement cannot refer to other relations of same query level"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                            <argument><expr><call><name>locate_var_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>selectQuery</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Extract a list of the non-junk TLEs for upper-level processing.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>targetlist</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>targetlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
            <macro><name>foreach</name><argument_list>(<argument>tl</argument>, <argument>selectQuery-&gt;targetList</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>targetlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Make the leaf query be a subquery in the top-level rangetable.
         */</comment>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>selectName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>selectName</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"*SELECT* %d"</literal></expr></argument>,
                 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                            <argument><expr><name>selectQuery</name></expr></argument>,
                                            <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><name>selectName</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><name>false</name></expr></argument>,
                                            <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Return a RangeTblRef to replace the SelectStmt in the set-op tree.
         */</comment>
        <expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* assume new rte is at end */</comment>
        <expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name> <operator>==</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtr</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Process an internal node (set operation node) */</comment>
        <decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>ltargetlist</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>rtargetlist</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ltl</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rtl</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>context</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_UNION</name></expr> ?</condition><then> <expr><literal type="string">"UNION"</literal></expr> </then><else>:
                   <expr><operator>(</operator><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_INTERSECT</name></expr> ?</condition><then> <expr><literal type="string">"INTERSECT"</literal></expr> </then><else>:
                    <expr><literal type="string">"EXCEPT"</literal></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>all</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>all</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * Recursively transform the left child node.
         */</comment>
        <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <call><name>transformSetOperationTree</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>,
                                             <argument><expr><name>false</name></expr></argument>,
                                             <argument><expr><operator>&amp;</operator><name>ltargetlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If we are processing a recursive union query, now is the time to
         * examine the non-recursive term's output columns and mark the
         * containing CTE as having those result columns.  We should do this
         * only at the topmost setop of the CTE, of course.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>isTopLevel</name> <operator>&amp;&amp;</operator>
            <name><name>pstate</name><operator>-&gt;</operator><name>p_parent_cte</name></name> <operator>&amp;&amp;</operator>
            <name><name>pstate</name><operator>-&gt;</operator><name>p_parent_cte</name><operator>-&gt;</operator><name>cterecursive</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>determineRecursiveColTypes</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>ltargetlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Recursively transform the right child node.
         */</comment>
        <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <call><name>transformSetOperationTree</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
                                             <argument><expr><name>false</name></expr></argument>,
                                             <argument><expr><operator>&amp;</operator><name>rtargetlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Verify that the two children have the same number of non-junk
         * columns, and determine the types of the merged output columns.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>ltargetlist</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rtargetlist</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"each %s query must have the same number of columns"</literal></expr></argument>,
                            <argument><expr><name>context</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                        <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtargetlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>targetlist</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>targetlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>colTypes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>colTypmods</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>colCollations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>groupClauses</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <macro><name>forboth</name><argument_list>(<argument>ltl</argument>, <argument>ltargetlist</argument>, <argument>rtl</argument>, <argument>rtargetlist</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>ltle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ltl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>rtle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rtl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>lcolnode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ltle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>rcolnode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rtle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>lcoltype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>lcolnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>rcoltype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>rcolnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name></type>        <name>lcoltypmod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>lcolnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name></type>        <name>rcoltypmod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>rcolnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>bestexpr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>bestlocation</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>rescoltype</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name></type>        <name>rescoltypmod</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>rescolcoll</name></decl>;</decl_stmt>

            <comment type="block">/* select common type, same as CASE et al */</comment>
            <expr_stmt><expr><name>rescoltype</name> <operator>=</operator> <call><name>select_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                            <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>lcolnode</name></expr></argument>, <argument><expr><name>rcolnode</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><name>context</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>bestexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>bestlocation</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><name>bestexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* if same type and same typmod, use typmod; else default */</comment>
            <if_stmt><if>if <condition>(<expr><name>lcoltype</name> <operator>==</operator> <name>rcoltype</name> <operator>&amp;&amp;</operator> <name>lcoltypmod</name> <operator>==</operator> <name>rcoltypmod</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>rescoltypmod</name> <operator>=</operator> <name>lcoltypmod</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>rescoltypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/*
             * Verify the coercions are actually possible.  If not, we'd fail
             * later anyway, but we want to fail now while we have sufficient
             * context to produce an error cursor position.
             *
             * For all non-UNKNOWN-type cases, we verify coercibility but we
             * don't modify the child's expression, for fear of changing the
             * child query's semantics.
             *
             * If a child expression is an UNKNOWN-type Const or Param, we
             * want to replace it with the coerced expression.  This can only
             * happen when the child is a leaf set-op node.  It's safe to
             * replace the expression because if the child query's semantics
             * depended on the type of this output column, it'd have already
             * coerced the UNKNOWN to something else.  We want to do this
             * because (a) we want to verify that a Const is valid for the
             * target type, or resolve the actual type of an UNKNOWN Param,
             * and (b) we want to avoid unnecessary discrepancies between the
             * output type of the child query and the resolved target type.
             * Such a discrepancy would disable optimization in the planner.
             *
             * If it's some other UNKNOWN-type node, eg a Var, we do nothing
             * (knowing that coerce_to_common_type would fail).  The planner
             * is sometimes able to fold an UNKNOWN Var to a constant before
             * it has to coerce the type, so failing now would just break
             * cases that might work.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>lcoltype</name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>lcolnode</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>lcolnode</name></expr></argument>,
                                                 <argument><expr><name>rescoltype</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>lcolnode</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator>
                     <call><name>IsA</name><argument_list>(<argument><expr><name>lcolnode</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>lcolnode</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>lcolnode</name></expr></argument>,
                                                 <argument><expr><name>rescoltype</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ltle</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>lcolnode</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>rcoltype</name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>rcolnode</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rcolnode</name></expr></argument>,
                                                 <argument><expr><name>rescoltype</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rcolnode</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator>
                     <call><name>IsA</name><argument_list>(<argument><expr><name>rcolnode</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>rcolnode</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rcolnode</name></expr></argument>,
                                                 <argument><expr><name>rescoltype</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rtle</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>rcolnode</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Select common collation.  A common collation is required for
             * all set operators except UNION ALL; see SQL:2008 7.13 &lt;query
             * expression&gt; Syntax Rule 15c.  (If we fail to identify a common
             * collation for a UNION ALL column, the curCollations element
             * will be set to InvalidOid, which may result in a runtime error
             * if something at a higher query level wants to use the column's
             * collation.)
             */</comment>
            <expr_stmt><expr><name>rescolcoll</name> <operator>=</operator> <call><name>select_common_collation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                                 <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>lcolnode</name></expr></argument>, <argument><expr><name>rcolnode</name></expr></argument>)</argument_list></call></expr></argument>,
                                                 <argument><expr><operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_UNION</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>-&gt;</operator><name>all</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* emit results */</comment>
            <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>colTypes</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>, <argument><expr><name>rescoltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>colTypmods</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>colTypmods</name></name></expr></argument>, <argument><expr><name>rescoltypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>colCollations</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>colCollations</name></name></expr></argument>, <argument><expr><name>rescolcoll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * For all cases except UNION ALL, identify the grouping operators
             * (and, if available, sorting operators) that will be used to
             * eliminate duplicates.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>!=</operator> <name>SETOP_UNION</name> <operator>||</operator> <operator>!</operator><name><name>op</name><operator>-&gt;</operator><name>all</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grpcl</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>sortop</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>eqop</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>        <name>hashable</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ParseCallbackState</name></type> <name>pcbstate</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>setup_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>,
                                                  <argument><expr><name>bestlocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* determine the eqop and optional sortop */</comment>
                <expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name>rescoltype</name></expr></argument>,
                                         <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>sortop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqop</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>cancel_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* we don't have a tlist yet, so can't assign sortgrouprefs */</comment>
                <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>eqop</name></name> <operator>=</operator> <name>eqop</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>sortop</name></name> <operator>=</operator> <name>sortop</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* OK with or without sortop */</comment>
                <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>hashable</name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>groupClauses</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>groupClauses</name></name></expr></argument>, <argument><expr><name>grpcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Construct a dummy tlist entry to return.  We use a SetToDefault
             * node for the expression, since it carries exactly the fields
             * needed, but any other expression node type would do as well.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>targetlist</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>SetToDefault</name> <modifier>*</modifier></type><name>rescolnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SetToDefault</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>restle</name></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>rescolnode</name><operator>-&gt;</operator><name>typeId</name></name> <operator>=</operator> <name>rescoltype</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rescolnode</name><operator>-&gt;</operator><name>typeMod</name></name> <operator>=</operator> <name>rescoltypmod</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rescolnode</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name>rescolcoll</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rescolnode</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>bestlocation</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>restle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>rescolnode</name></expr></argument>,
                                         <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* no need to set resno */</comment>
                                         <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>targetlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetlist</name></expr></argument>, <argument><expr><name>restle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>op</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process the outputs of the non-recursive term of a recursive union
 * to set up the parent CTE's columns
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>determineRecursiveColTypes</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>larg</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nrtargetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>leftmostRTI</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>leftmostQuery</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>targetList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>left_tlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>nrtl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>next_resno</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Find leftmost leaf SELECT
     */</comment>
    <expr_stmt><expr><name>node</name> <operator>=</operator> <name>larg</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>larg</name></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>leftmostRTI</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>leftmostQuery</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>leftmostRTI</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subquery</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leftmostQuery</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Generate dummy targetlist using column names of leftmost select and
     * dummy result expressions of the non-recursive term.
     */</comment>
    <expr_stmt><expr><name>targetList</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>left_tlist</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>leftmostQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>next_resno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>nrtl</argument>, <argument>nrtargetlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>nrtle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>nrtl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>lefttle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>left_tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>colName</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>lefttle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>colName</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>lefttle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name><name>nrtle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
                              <argument><expr><name>next_resno</name><operator>++</operator></expr></argument>,
                              <argument><expr><name>colName</name></expr></argument>,
                              <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>left_tlist</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>left_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Now build CTE's output column info using dummy targetlist */</comment>
    <expr_stmt><expr><call><name>analyzeCTETargetList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_parent_cte</name></name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * transformUpdateStmt -
 *      transforms an update statement
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformUpdateStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>UpdateStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>qry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UPDATE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_is_insert</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* process the WITH clause independently of all else */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasRecursive</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>withClause</name><operator>-&gt;</operator><name>recursive</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>cteList</name></name> <operator>=</operator> <call><name>transformWithClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasModifyingCTE</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>=</operator> <call><name>setTargetTable</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
                                         <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>,
                                         <argument><expr><name>true</name></expr></argument>,
                                         <argument><expr><name>ACL_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* grab the namespace item made by setTargetTable */</comment>
    <expr_stmt><expr><name>nsitem</name> <operator>=</operator> <operator>(</operator><name>ParseNamespaceItem</name> <operator>*</operator><operator>)</operator> <call><name>llast</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* subqueries in FROM cannot access the result relation */</comment>
    <expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_only</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/*
     * the FROM clause is non-standard SQL syntax. We used to be able to do
     * this with REPLACE in POSTQUEL so we keep the feature.
     */</comment>
    <expr_stmt><expr><call><name>transformFromClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>fromClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* remaining clauses can reference the result relation normally */</comment>
    <expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_only</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_ok</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>transformWhereClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>,
                                <argument><expr><name>EXPR_KIND_WHERE</name></expr></argument>, <argument><expr><literal type="string">"WHERE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>returningList</name></name> <operator>=</operator> <call><name>transformReturningList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now we are done with SELECT-like processing, and can get on with
     * transforming the target list to match the UPDATE target columns.
     */</comment>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>transformUpdateTargetList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasTargetSRFs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformUpdateTargetList -
 *    handle SET clause in UPDATE/INSERT ... ON CONFLICT UPDATE
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>transformUpdateTargetList</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>origTlist</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>target_rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>orig_tl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tl</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rd_locator_info</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name><operator>-&gt;</operator><name>rd_locator_info</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>transformTargetList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>origTlist</name></expr></argument>,
                                <argument><expr><name>EXPR_KIND_UPDATE_SOURCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Prepare to assign non-conflicting resnos to resjunk attributes */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name> <operator>&lt;=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnatts</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnatts</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Prepare non-junk columns for assignment to target table */</comment>
    <expr_stmt><expr><name>target_rte</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_target_rangetblentry</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>orig_tl</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>origTlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>tl</argument>, <argument>tlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>origTarget</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>attrno</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Resjunk nodes need no additional processing, but be sure they
             * have resnos that do not match any target columns; else rewriter
             * or planner might get confused.  They don't need a resname
             * either.
             */</comment>
            <expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>orig_tl</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"UPDATE target count mismatch --- internal error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>origTarget</name> <operator>=</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>ResTarget</name></expr></argument>, <argument><expr><name>orig_tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>attrno</name> <operator>=</operator> <call><name>attnameAttNum</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>,
                               <argument><expr><name><name>origTarget</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>attrno</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
                            <argument><expr><name><name>origTarget</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>origTarget</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/* could not update distributed columns */</comment>
        <if_stmt><if>if<condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><operator>(</operator><name>rd_locator_info</name> <operator>&amp;&amp;</operator> <name><name>rd_locator_info</name><operator>-&gt;</operator><name>partAttrNum</name></name> <operator>!=</operator> <name>InvalidAttrNumber</name> <operator>&amp;&amp;</operator> <name><name>rd_locator_info</name><operator>-&gt;</operator><name>partAttrNum</name></name> <operator>==</operator> <name>attrno</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>bool</name></type> <name>updated</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Oid</name></type> <name>resultrel</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Oid</name></type> <name>varrel</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aliasname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>aliasname</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    
                    <expr_stmt><expr><name>resultrel</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>varrel</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>resultrel</name> <operator>==</operator> <name>varrel</name> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>attrno</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>aliasname</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>aliasname</name></expr></argument>, <argument><expr><literal type="string">"excluded"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>updated</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                    
                </block_content>}</block></if></if_stmt>
                
                <if_stmt><if>if <condition>(<expr><name>updated</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Distributed column or partition column \"%s\" can't be updated in current version"</literal></expr></argument>, <argument><expr><name><name>origTarget</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RelationGetPartitionColumnIndex</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>attrno</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Distributed column or partition column \"%s\" can't be updated in current version"</literal></expr></argument>, <argument><expr><name><name>origTarget</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>updateTargetListEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>, <argument><expr><name><name>origTarget</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                              <argument><expr><name>attrno</name></expr></argument>,
                              <argument><expr><name><name>origTarget</name><operator>-&gt;</operator><name>indirection</name></name></expr></argument>,
                              <argument><expr><name><name>origTarget</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Mark the target column as requiring update permissions */</comment>
        <expr_stmt><expr><name><name>target_rte</name><operator>-&gt;</operator><name>updatedCols</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>target_rte</name><operator>-&gt;</operator><name>updatedCols</name></name></expr></argument>,
                                                 <argument><expr><name>attrno</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>orig_tl</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>orig_tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <if_stmt><if>if <condition>(<expr><name>orig_tl</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"UPDATE target count mismatch --- internal error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformReturningList -
 *    handle a RETURNING clause in INSERT/UPDATE/DELETE
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>transformReturningList</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>rlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_next_resno</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>returningList</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>                <comment type="block">/* nothing to do */</comment>

    <comment type="block">/*
     * We need to assign resnos starting at one in the RETURNING list. Save
     * and restore the main tlist's value of p_next_resno, just in case
     * someone looks at it later (probably won't happen).
     */</comment>
    <expr_stmt><expr><name>save_next_resno</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* transform RETURNING identically to a SELECT targetlist */</comment>
    <expr_stmt><expr><name>rlist</name> <operator>=</operator> <call><name>transformTargetList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>returningList</name></expr></argument>, <argument><expr><name>EXPR_KIND_RETURNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Complain if the nonempty tlist expanded to nothing (which is possible
     * if it contains only a star-expansion of a zero-column table).  If we
     * allow this, the parsed Query will look like it didn't have RETURNING,
     * with results that would probably surprise the user.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>rlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RETURNING must have at least one column"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                    <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* mark column origins */</comment>
    <expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* resolve any still-unresolved output columns as being type text */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_resolve_unknowns</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>resolveTargetListUnknowns</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* restore state */</comment>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name> <operator>=</operator> <name>save_next_resno</name></expr>;</expr_stmt>

    <return>return <expr><name>rlist</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * transformDeclareCursorStmt -
 *    transform a DECLARE CURSOR Statement
 *
 * DECLARE CURSOR is like other utility statements in that we emit it as a
 * CMD_UTILITY Query node; however, we must first transform the contained
 * query.  We used to postpone that until execution, but it's really necessary
 * to do it during the normal parse analysis phase to ensure that side effects
 * of parser hooks happen at the expected time.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformDeclareCursorStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>DeclareCursorStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Don't allow both SCROLL and NO SCROLL to be specified
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_SCROLL</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_NO_SCROLL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_CURSOR_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot specify both SCROLL and NO SCROLL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Transform contained query, not allowing SELECT INTO */</comment>
    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>transformStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>query</name></expr>;</expr_stmt>

    <comment type="block">/* Grammar should not have allowed anything but SELECT */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected non-SELECT command in DECLARE CURSOR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We also disallow data-modifying WITH in a cursor.  (This could be
     * allowed, but the semantics of when the updates occur might be
     * surprising.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DECLARE CURSOR must not contain data-modifying statements in WITH"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* FOR UPDATE and WITH HOLD are not compatible */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_HOLD</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/*------
          translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DECLARE CURSOR WITH HOLD ... %s is not supported"</literal></expr></argument>,
                        <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RowMarkClause</name> <operator>*</operator><operator>)</operator>
                                      <call><name>linitial</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Holdable cursors must be READ ONLY."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* FOR UPDATE and SCROLL are not compatible */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_SCROLL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/*------
          translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DECLARE SCROLL CURSOR ... %s is not supported"</literal></expr></argument>,
                        <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RowMarkClause</name> <operator>*</operator><operator>)</operator>
                                      <call><name>linitial</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Scrollable cursors must be READ ONLY."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* FOR UPDATE and INSENSITIVE are not compatible */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_INSENSITIVE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/*------
          translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DECLARE INSENSITIVE CURSOR ... %s is not supported"</literal></expr></argument>,
                        <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RowMarkClause</name> <operator>*</operator><operator>)</operator>
                                      <call><name>linitial</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Insensitive cursors must be READ ONLY."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* represent the command as a utility Query */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * transformExplainStmt -
 *    transform an EXPLAIN Statement
 *
 * EXPLAIN is like other utility statements in that we emit it as a
 * CMD_UTILITY Query node; however, we must first transform the contained
 * query.  We used to postpone that until execution, but it's really necessary
 * to do it during the normal parse analysis phase to ensure that side effects
 * of parser hooks happen at the expected time.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformExplainStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ExplainStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <comment type="block">/* transform contained query, allowing SELECT INTO */</comment>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>transformOptionalSelectInto</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* represent the command as a utility Query */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * transformCreateTableAsStmt -
 *    transform a CREATE TABLE AS, SELECT ... INTO, or CREATE MATERIALIZED VIEW
 *    Statement
 *
 * As with DECLARE CURSOR and EXPLAIN, transform the contained statement now.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformCreateTableAsStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CreateTableAsStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>

    <comment type="block">/* transform contained query, not allowing SELECT INTO */</comment>
    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>transformStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>query</name></expr>;</expr_stmt>

    <comment type="block">/* additional work needed for CREATE MATERIALIZED VIEW */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>OBJECT_MATVIEW</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Prohibit a data-modifying CTE in the query used to create a
         * materialized view. It's not sufficiently clear what the user would
         * want to happen if the MV is refreshed or incrementally maintained.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialized views must not use data-modifying statements in WITH"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Check whether any temporary database objects are used in the
         * creation query. It would be hard to refresh data or incrementally
         * maintain it if a source disappeared.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>isQueryUsingTempRelation</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialized views must not use temporary tables or views"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * A materialized view would either need to save parameters for use in
         * maintaining/loading the data or prohibit them entirely.  The latter
         * seems safer and more sane.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>query_contains_extern_params</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialized views may not be defined using bound parameters"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * For now, we disallow unlogged materialized views, because it seems
         * like a bad idea for them to just go to empty after a crash. (If we
         * could mark them as unpopulated, that would be better, but that
         * requires catalog changes which crash recovery can't presently
         * handle.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialized views cannot be UNLOGGED"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * At runtime, we'll need a copy of the parsed-but-not-rewritten Query
         * for purposes of creating the view's ON SELECT rule.  We stash that
         * in the IntoClause because that's where intorel_startup() can
         * conveniently get it from.
         */</comment>
        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>viewQuery</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* represent the command as a utility Query */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<comment type="block">/*
 * transformExecDirectStmt -
 *    transform an EXECUTE DIRECT Statement
 *
 * Handling is depends if we should execute on nodes or on Coordinator.
 * To execute on nodes we return CMD_UTILITY query having one T_RemoteQuery node
 * with the inner statement as a sql_command.
 * If statement is to run on Coordinator we should parse inner statement and
 * analyze resulting query tree.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformExecDirectStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ExecDirectStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Query</name>        <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>query</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>        <modifier>*</modifier></type><name>nodelist</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>node_names</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQuery</name>    <modifier>*</modifier></type><name>step</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_local</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>        <modifier>*</modifier></type><name>raw_parsetree_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>raw_parsetree_item</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>nodename</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nodeIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>nodetype</name></decl>;</decl_stmt>

    <comment type="block">/* Support not available on Datanodes */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"EXECUTE DIRECT cannot be executed on a Datanode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Support for EXECUTE DIRECT on multiple nodes is not available yet"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>IS_PGXC_COORDINATOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* There is a single element here */</comment>
    <expr_stmt><expr><name>nodename</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <expr_stmt><expr><name>nodetype</name> <operator>=</operator> <name>PGXC_NODE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nodeIndex</name> <operator>=</operator> <call><name>PGXCNodeGetNodeIdFromName</name><argument_list>(<argument><expr><name>nodename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nodetype</name> <operator>==</operator> <name>PGXC_NODE_NONE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC Node %s: object not defined"</literal></expr></argument>,
                        <argument><expr><name>nodename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>nodeoid</name> <operator>=</operator> <call><name>get_pgxc_nodeoid</name><argument_list>(<argument><expr><name>nodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC Node %s: object not defined"</literal></expr></argument>,
                        <argument><expr><name>nodename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Get node type and index */</comment>
    <expr_stmt><expr><name>nodetype</name> <operator>=</operator> <call><name>get_pgxc_nodetype</name><argument_list>(<argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nodeIndex</name> <operator>=</operator> <call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name>nodeoid</name></expr></argument>, <argument><expr><call><name>get_pgxc_nodetype</name><argument_list>(<argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Check if node is requested is the self-node or not */</comment>
    <if_stmt><if>if <condition>(<expr><name>nodetype</name> <operator>==</operator> <name>PGXC_NODE_COORDINATOR</name> <operator>&amp;&amp;</operator> <name>nodeIndex</name> <operator>==</operator> <name>PGXCNodeId</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>is_local</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Transform the query into a raw parse list */</comment>
    <expr_stmt><expr><name>raw_parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* EXECUTE DIRECT can just be executed with a single query */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>raw_parsetree_list</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"EXECUTE DIRECT cannot execute multiple queries"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Analyze the Raw parse tree
     * EXECUTE DIRECT is restricted to one-step usage
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>raw_parsetree_item</argument>, <argument>raw_parsetree_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RawStmt</name>   <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>raw_parsetree_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result_list</name> <init>= <expr><call><name>pg_analyze_and_rewrite</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>result_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Default list of parameters to set */</comment>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_nodes</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <name>COMBINE_TYPE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>sort</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>read_only</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>force_autocommit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>cursor</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* This is needed by executor */</comment>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nodetype</name> <operator>==</operator> <name>PGXC_NODE_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_COORDS</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_DATANODES</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>reduce_level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>base_tlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>outer_alias</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>inner_alias</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>outer_reduce_level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>inner_reduce_level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>outer_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>inner_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>inner_statement</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>outer_statement</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>join_condition</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* Change the list of nodes that will be executed for the query and others */</comment>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>force_autocommit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <name>COMBINE_TYPE_SAME</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>read_only</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>=</operator> <name>EXEC_DIRECT_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Set up EXECUTE DIRECT flag */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_local</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>=</operator> <name>EXEC_DIRECT_LOCAL_UTILITY</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>=</operator> <name>EXEC_DIRECT_LOCAL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <switch>switch<condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>CMD_UTILITY</name></expr>:</case>
                <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>=</operator> <name>EXEC_DIRECT_UTILITY</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>CMD_SELECT</name></expr>:</case>
                <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>=</operator> <name>EXEC_DIRECT_SELECT</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>CMD_INSERT</name></expr>:</case>
                <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>=</operator> <name>EXEC_DIRECT_INSERT</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
                <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>=</operator> <name>EXEC_DIRECT_UPDATE</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>CMD_DELETE</name></expr>:</case>
                <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>=</operator> <name>EXEC_DIRECT_DELETE</name></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Build Execute Node list, there is a unique node for the time being */</comment>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><name>nodeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_local</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>step</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Reset the queryId since the caller would do that anyways.
     */</comment>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>queryId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Produce a string representation of a LockClauseStrength value.
 * This should only be applied to valid values (not LCS_NONE).
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>LCS_asString</name><parameter_list>(<parameter><decl><type><name>LockClauseStrength</name></type> <name>strength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name>strength</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>LCS_NONE</name></expr>:</case>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LCS_FORKEYSHARE</name></expr>:</case>
            <return>return <expr><literal type="string">"FOR KEY SHARE"</literal></expr>;</return>
        <case>case <expr><name>LCS_FORSHARE</name></expr>:</case>
            <return>return <expr><literal type="string">"FOR SHARE"</literal></expr>;</return>
        <case>case <expr><name>LCS_FORNOKEYUPDATE</name></expr>:</case>
            <return>return <expr><literal type="string">"FOR NO KEY UPDATE"</literal></expr>;</return>
        <case>case <expr><name>LCS_FORUPDATE</name></expr>:</case>
            <return>return <expr><literal type="string">"FOR UPDATE"</literal></expr>;</return>
    </block_content>}</block></switch>
    <return>return <expr><literal type="string">"FOR some"</literal></expr>;</return>            <comment type="block">/* shouldn't happen */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Check for features that are not supported with FOR [KEY] UPDATE/SHARE.
 *
 * exported so planner can check again after rewriting, query pullup, etc
 */</comment>
<function><type><name>void</name></type>
<name>CheckSelectLocking</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>, <parameter><decl><type><name>LockClauseStrength</name></type> <name>strength</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>strength</name> <operator>!=</operator> <name>LCS_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* else caller error */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/*------
          translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed with UNION/INTERSECT/EXCEPT"</literal></expr></argument>,
                        <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/*------
          translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed with DISTINCT clause"</literal></expr></argument>,
                        <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/*------
          translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed with GROUP BY clause"</literal></expr></argument>,
                        <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/*------
          translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed with HAVING clause"</literal></expr></argument>,
                        <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/*------
          translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed with aggregate functions"</literal></expr></argument>,
                        <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/*------
          translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed with window functions"</literal></expr></argument>,
                        <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/*------
          translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed with set-returning functions in the target list"</literal></expr></argument>,
                        <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Transform a FOR [KEY] UPDATE/SHARE clause
 *
 * This basically involves replacing names by integer relids.
 *
 * NB: if you need to change this, see also markQueryForLocking()
 * in rewriteHandler.c, and isLockedRefname() in parse_relation.c.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformLockingClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>, <parameter><decl><type><name>LockingClause</name> <modifier>*</modifier></type><name>lc</name></decl></parameter>,
                       <parameter><decl><type><name>bool</name></type> <name>pushedDown</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>lockedRels</name> <init>= <expr><name><name>lc</name><operator>-&gt;</operator><name>lockedRels</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name></type>        <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LockingClause</name> <modifier>*</modifier></type><name>allrels</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CheckSelectLocking</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* make a clause we can pass down to subqueries to select all rels */</comment>
    <expr_stmt><expr><name>allrels</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>LockingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>allrels</name><operator>-&gt;</operator><name>lockedRels</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>    <comment type="block">/* indicates all rels */</comment>
    <expr_stmt><expr><name><name>allrels</name><operator>-&gt;</operator><name>strength</name></name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>allrels</name><operator>-&gt;</operator><name>waitPolicy</name></name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>lockedRels</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* all regular tables used in query */</comment>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>rt</argument>, <argument>qry-&gt;rtable</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
            <switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>RTE_RELATION</name></expr>:</case>
                    <expr_stmt><expr><call><name>applyLockingClause</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>, <argument><expr><name><name>lc</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr></argument>,
                                       <argument><expr><name>pushedDown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>|=</operator> <name>ACL_SELECT_FOR_UPDATE</name></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
                    <expr_stmt><expr><call><name>applyLockingClause</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>, <argument><expr><name><name>lc</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr></argument>,
                                       <argument><expr><name>pushedDown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * FOR UPDATE/SHARE of subquery is propagated to all of
                     * subquery's rels, too.  We could do this later (based on
                     * the marking of the subquery RTE) but it is convenient
                     * to have local knowledge in each query level about which
                     * rels need to be opened with RowShareLock.
                     */</comment>
                    <expr_stmt><expr><call><name>transformLockingClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>,
                                           <argument><expr><name>allrels</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                <default>default:</default>
                    <comment type="block">/* ignore JOIN, SPECIAL, FUNCTION, VALUES, CTE RTEs */</comment>
                    <break>break;</break>
            </block_content>}</block></switch>
        </block_content>}</block>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* just the named tables */</comment>
        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>lockedRels</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>thisrel</name> <init>= <expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* For simplicity we insist on unqualified alias names here */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>thisrel</name><operator>-&gt;</operator><name>catalogname</name></name> <operator>||</operator> <name><name>thisrel</name><operator>-&gt;</operator><name>schemaname</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                <comment type="block">/*------
                  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s must specify unqualified relation names"</literal></expr></argument>,
                                <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>thisrel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <macro><name>foreach</name><argument_list>(<argument>rt</argument>, <argument>qry-&gt;rtable</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name><name>thisrel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><name>RTE_RELATION</name></expr>:</case>
                            <expr_stmt><expr><call><name>applyLockingClause</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>,
                                               <argument><expr><name><name>lc</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr></argument>, <argument><expr><name>pushedDown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>|=</operator> <name>ACL_SELECT_FOR_UPDATE</name></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
                            <expr_stmt><expr><call><name>applyLockingClause</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>,
                                               <argument><expr><name><name>lc</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr></argument>, <argument><expr><name>pushedDown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <comment type="block">/* see comment above */</comment>
                            <expr_stmt><expr><call><name>transformLockingClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>,
                                                   <argument><expr><name>allrels</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><name>RTE_JOIN</name></expr>:</case>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <comment type="block">/*------
                              translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot be applied to a join"</literal></expr></argument>,
                                            <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>thisrel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <comment type="block">/*------
                              translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot be applied to a function"</literal></expr></argument>,
                                            <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>thisrel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <comment type="block">/*------
                              translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot be applied to a table function"</literal></expr></argument>,
                                            <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>thisrel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><name>RTE_VALUES</name></expr>:</case>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <comment type="block">/*------
                              translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot be applied to VALUES"</literal></expr></argument>,
                                            <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>thisrel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><name>RTE_CTE</name></expr>:</case>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <comment type="block">/*------
                              translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot be applied to a WITH query"</literal></expr></argument>,
                                            <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>thisrel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <comment type="block">/*------
                              translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot be applied to a named tuplestore"</literal></expr></argument>,
                                            <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>thisrel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <default>default:</default>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized RTE type: %d"</literal></expr></argument>,
                                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                    </block_content>}</block></switch>
                    <break>break;</break>        <comment type="block">/* out of foreach loop */</comment>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <if_stmt><if>if <condition>(<expr><name>rt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                <comment type="block">/*------
                  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" in %s clause not found in FROM clause"</literal></expr></argument>,
                                <argument><expr><name><name>thisrel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>,
                                <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>thisrel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Record locking info for a single rangetable item
 */</comment>
<function><type><name>void</name></type>
<name>applyLockingClause</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>,
                   <parameter><decl><type><name>LockClauseStrength</name></type> <name>strength</name></decl></parameter>, <parameter><decl><type><name>LockWaitPolicy</name></type> <name>waitPolicy</name></decl></parameter>,
                   <parameter><decl><type><name>bool</name></type> <name>pushedDown</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RowMarkClause</name> <modifier>*</modifier></type><name>rc</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>strength</name> <operator>!=</operator> <name>LCS_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* else caller error */</comment>

    <comment type="block">/* If it's an explicit clause, make sure hasForUpdate gets set */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pushedDown</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasForUpdate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check for pre-existing entry for same rtindex */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>get_parse_rowmark</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If the same RTE is specified with more than one locking strength,
         * use the strongest.  (Reasonable, since you can't take both a shared
         * and exclusive lock at the same time; it'll end up being exclusive
         * anyway.)
         *
         * Similarly, if the same RTE is specified with more than one lock
         * wait policy, consider that NOWAIT wins over SKIP LOCKED, which in
         * turn wins over waiting for the lock (the default).  This is a bit
         * more debatable but raising an error doesn't seem helpful. (Consider
         * for instance SELECT FOR UPDATE NOWAIT from a view that internally
         * contains a plain FOR UPDATE spec.)  Having NOWAIT win over SKIP
         * LOCKED is reasonable since the former throws an error in case of
         * coming across a locked tuple, which may be undesirable in some
         * cases but it seems better than silently returning inconsistent
         * results.
         *
         * And of course pushedDown becomes false if any clause is explicit.
         */</comment>
        <expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>strength</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>, <argument><expr><name>strength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>waitPolicy</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr></argument>, <argument><expr><name>waitPolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>pushedDown</name></name> <operator>&amp;=</operator> <name>pushedDown</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Make a new RowMarkClause */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RowMarkClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>strength</name></name> <operator>=</operator> <name>strength</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>waitPolicy</name></name> <operator>=</operator> <name>waitPolicy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>pushedDown</name></name> <operator>=</operator> <name>pushedDown</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Coverage testing for raw_expression_tree_walker().
 *
 * When enabled, we run raw_expression_tree_walker() over every DML statement
 * submitted to parse analysis.  Without this provision, that function is only
 * applied in limited cases involving CTEs, and we don't really want to have
 * to test everything inside as well as outside a CTE.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RAW_EXPRESSION_COVERAGE_TEST</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>test_raw_expression_coverage</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>raw_expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
                                      <argument><expr><name>test_raw_expression_coverage</name></expr></argument>,
                                      <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* RAW_EXPRESSION_COVERAGE_TEST */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>transformInsertValuesIntoCopyFrom</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>plantree_list</name></decl></parameter>, <parameter><decl><type><name>InsertStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>success</name></decl></parameter>,
                                            <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>transform_string</name></decl></parameter>, <parameter><decl><type><name>Query</name>    <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>stmt_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CopyStmt</name>   <modifier>*</modifier></type><name>copy</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CopyStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* copy from */</comment>
    <expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>is_from</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> 

    <expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <name>transform_string</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>data_list</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>data_list</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>ninsert_columns</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>ndatarows</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>ndatarows</name></name></expr>;</expr_stmt>

    <comment type="block">/* insert into xxx(c2,c4,c6) to copy xxx(c2,c4,c6) */</comment>
    <expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>attlist</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <comment type="block">/*
     * INSERT will expand the targetlist according to the target relation's
     * physical targetlist.
     * insert into xxx(c3,c2,c4)----&gt; insert into xxx(c1,c2,c3,c4)
     * we transform any form of 'insert into' to copy xxx from ...
     *
     * if we write the values of insert_into into file, we also need this form
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>cols</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>stmt-&gt;cols</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ResTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><operator>(</operator><name>ResTarget</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>Value</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>attlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>copy</name><operator>-&gt;</operator><name>attlist</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>insert_into</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    
    <block>{<block_content>
        <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>planstmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>planstmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>planstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>planstmt</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>planstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>copy</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>planstmt</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>stmt_location</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>planstmt</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>stmt_len</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>stmt_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmt_list</name></expr></argument>, <argument><expr><name>planstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>success</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>success</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>stmt_list</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
