<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/nodes/readfuncs.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * readfuncs.c
 *      Reader functions for Postgres tree nodes.
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 *
 * IDENTIFICATION
 *      src/backend/nodes/readfuncs.c
 *
 * NOTES
 *      Path nodes do not have any readfuncs support, because we never
 *      have occasion to read them in.  (There was once code here that
 *      claimed to read them, but it was broken as well as unused.)  We
 *      never read executor state trees, either.
 *
 *      Parse location fields are written out by outfuncs.c, but only for
 *      possible debugging use.  When reading a location field, we discard
 *      the stored value and set the location field to -1 (ie, "unknown").
 *      This is because nodes coming from a stored rule should not be thought
 *      to have a known location in the current query's text.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/extensible.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/readfuncs.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"audit/audit_fga.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"audit/audit.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 * When we sending query plans between nodes we need to send OIDs of various
 * objects - relations, data types, functions, etc.
 * On different nodes OIDs of these objects may differ, so we need to send an
 * identifier, depending on object type, allowing to lookup OID on target node.
 * On the other hand we want to save space when storing rules, or in other cases
 * when we need to encode and decode nodes on the same node.
 * For now default format is not portable, as it is in original Postgres code.
 * Later we may want to add extra parameter in stringToNode() function
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>portable_input</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<function><type><name>bool</name></type>
<name>set_portable_input</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>old_portable_input</name> <init>= <expr><name>portable_input</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>portable_input</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
    <return>return <expr><name>old_portable_input</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* XCP */</comment>

<comment type="block">/*
 * Macros to simplify reading of different kinds of fields.  Use these
 * wherever possible to reduce the chance for silly typos.  Note that these
 * hard-wire conventions about the names of the local variables in a Read
 * routine.
 */</comment>

<comment type="block">/* Macros for declaring appropriate local variables */</comment>

<comment type="block">/* A few guys need only local_node */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_LOCALS_NO_FIELDS</name><parameter_list>(<parameter><type><name>nodeTypeName</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>nodeTypeName *local_node = makeNode(nodeTypeName)</cpp:value></cpp:define>

<comment type="block">/* And a few guys need only the pg_strtok support fields */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_TEMP_LOCALS</name><parameter_list>()</parameter_list></cpp:macro>    \
    <cpp:value>char       *token;        \
    int            length</cpp:value></cpp:define>

<comment type="block">/* ... but most need both */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_LOCALS</name><parameter_list>(<parameter><type><name>nodeTypeName</name></type></parameter>)</parameter_list></cpp:macro>            \
    <cpp:value>READ_LOCALS_NO_FIELDS(nodeTypeName);    \
    READ_TEMP_LOCALS()</cpp:value></cpp:define>

<comment type="block">/* Read an integer field (anything written as ":fldname %d") */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_INT_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
    token = pg_strtok(&amp;length);        <comment type="block">/* get field value */</comment> \
    local_node-&gt;fldname = atoi(token)</cpp:value></cpp:define>

<comment type="block">/* Read an unsigned integer field (anything written as ":fldname %u") */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_UINT_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
    token = pg_strtok(&amp;length);        <comment type="block">/* get field value */</comment> \
    local_node-&gt;fldname = atoui(token)</cpp:value></cpp:define>

<comment type="block">/* Read an integer field (anything written as ":fldname %d") */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_INT64_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>token = pg_strtok(&amp;length);		<comment type="block">/* skip :fldname */</comment> \
	token = pg_strtok(&amp;length);		<comment type="block">/* get field value */</comment> \
	local_node-&gt;fldname = atoll(token)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<comment type="block">/* Read a long integer field (anything written as ":fldname %ld") */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_LONG_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
    token = pg_strtok(&amp;length);        <comment type="block">/* get field value */</comment> \
    local_node-&gt;fldname = atol(token)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Read an OID field (don't hard-wire assumption that OID is same as uint) */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_OID_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>(AssertMacro(!portable_input),     <comment type="block">/* only allow to read OIDs within a node */</comment> \
     token = pg_strtok(&amp;length),    <comment type="block">/* skip :fldname */</comment> \
     token = pg_strtok(&amp;length),    <comment type="block">/* get field value */</comment> \
     local_node-&gt;fldname = atooid(token))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_OID_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
    token = pg_strtok(&amp;length);        <comment type="block">/* get field value */</comment> \
    local_node-&gt;fldname = atooid(token)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Read a char field (ie, one ascii character) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_CHAR_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
    token = pg_strtok(&amp;length);        <comment type="block">/* get field value */</comment> \
    <comment type="block">/* avoid overhead of calling debackslash() for one char */</comment> \
    local_node-&gt;fldname = (length == 0) ? '\0' : (token[0] == '\\' ? token[1] : token[0])</cpp:value></cpp:define>

<comment type="block">/* Read an enumerated-type field that was written as an integer code */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_ENUM_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>enumtype</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
    token = pg_strtok(&amp;length);        <comment type="block">/* get field value */</comment> \
    local_node-&gt;fldname = (enumtype) atoi(token)</cpp:value></cpp:define>

<comment type="block">/* Read a float field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_FLOAT_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
    token = pg_strtok(&amp;length);        <comment type="block">/* get field value */</comment> \
    local_node-&gt;fldname = atof(token)</cpp:value></cpp:define>

<comment type="block">/* Read a boolean field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_BOOL_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
    token = pg_strtok(&amp;length);        <comment type="block">/* get field value */</comment> \
    local_node-&gt;fldname = strtobool(token)</cpp:value></cpp:define>

<comment type="block">/* Read a character-string field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_STRING_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
    token = pg_strtok(&amp;length);        <comment type="block">/* get field value */</comment> \
    local_node-&gt;fldname = nullable_string(token, length)</cpp:value></cpp:define>

<comment type="block">/* Read a parse location field (and throw away the value, per notes above) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_LOCATION_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
    token = pg_strtok(&amp;length);        <comment type="block">/* get field value */</comment> \
    (void) token;                <comment type="block">/* in case not used elsewhere */</comment> \
    local_node-&gt;fldname = -1</cpp:value></cpp:define>    <comment type="block">/* set field to "unknown" */</comment>

<comment type="block">/* Read a Node field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_NODE_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
        (void) token;                <comment type="block">/* in case not used elsewhere */</comment> \
        local_node-&gt;fldname = nodeRead(NULL, 0); \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Read a bitmapset field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_BITMAPSET_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
    (void) token;                <comment type="block">/* in case not used elsewhere */</comment> \
    local_node-&gt;fldname = _readBitmapset()</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<comment type="block">/*
 * Macros to read an identifier and lookup the OID
 * The identifier depends on object type.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSP_OID</name><parameter_list>(<parameter><type><name>nspname</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>LookupNamespaceNoError(nspname)</cpp:value></cpp:define>

<comment type="block">/* Read relation identifier and lookup the OID */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_RELID_INTERNAL</name><parameter_list>(<parameter><type><name>relid</name></type></parameter>, <parameter><type><name>warn</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        char       *nspname; <comment type="block">/* namespace name */</comment> \
        char       *relname; <comment type="block">/* relation name */</comment> \
        token = pg_strtok(&amp;length); <comment type="block">/* get nspname */</comment> \
        nspname = nullable_string(token, length); \
        token = pg_strtok(&amp;length); <comment type="block">/* get relname */</comment> \
        relname = nullable_string(token, length); \
        if (relname) \
        { \
            relid = get_relname_relid(relname, \
                                                    NSP_OID(nspname)); \
            if (!OidIsValid((relid)) &amp;&amp; (warn)) \
                elog(WARNING, "could not find OID for relation %s.%s", nspname,\
                        relname); \
        } \
        else \
            relid = InvalidOid; \
    } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_RELID_FIELD_NOWARN</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        Oid relid; \
        token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
        READ_RELID_INTERNAL(relid, false); \
        local_node-&gt;fldname = relid; \
    } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_RELID_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        Oid relid; \
        token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
        READ_RELID_INTERNAL(relid, true); \
        local_node-&gt;fldname = relid; \
    } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_RELID_LIST_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
        token = pg_strtok(&amp;length);     <comment type="block">/* skip '(' */</comment> \
        if (length &gt; 0 ) \
        { \
            Assert(token[0] == '('); \
            for (;;) \
            { \
                Oid relid; \
                READ_RELID_INTERNAL(relid, true); \
                local_node-&gt;fldname = lappend_oid(local_node-&gt;fldname, relid); \
                token = pg_strtok(&amp;length); \
                if (token[0] == ')') \
                break; \
            } \
        } \
        else \
            local_node-&gt;fldname = NIL; \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Read data type identifier and lookup the OID */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_TYPID_INTERNAL</name><parameter_list>(<parameter><type><name>typid</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        char       *nspname; <comment type="block">/* namespace name */</comment> \
        char       *typname; <comment type="block">/* data type name */</comment> \
        token = pg_strtok(&amp;length); <comment type="block">/* get nspname */</comment> \
        nspname = nullable_string(token, length); \
        token = pg_strtok(&amp;length); <comment type="block">/* get typname */</comment> \
        typname = nullable_string(token, length); \
        if (typname) \
        { \
            typid = get_typname_typid(typname, \
                                        NSP_OID(nspname)); \
            if (!OidIsValid((typid))) \
                elog(WARNING, "could not find OID for type %s.%s", nspname,\
                        typname); \
        } \
        else \
            typid = InvalidOid; \
    } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_TYPID_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        Oid typid; \
        token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
        READ_TYPID_INTERNAL(typid); \
        local_node-&gt;fldname = typid; \
    } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_TYPID_LIST_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
        token = pg_strtok(&amp;length);     <comment type="block">/* skip '(' */</comment> \
        if (length &gt; 0 ) \
        { \
            Assert(token[0] == '('); \
            for (;;) \
            { \
                Oid typid; \
                READ_TYPID_INTERNAL(typid); \
                local_node-&gt;fldname = lappend_oid(local_node-&gt;fldname, typid); \
                token = pg_strtok(&amp;length); \
                if (token[0] == ')') \
                break; \
            } \
        } \
        else \
            local_node-&gt;fldname = NIL; \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Read function identifier and lookup the OID */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_FUNCID_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        char       *nspname; <comment type="block">/* namespace name */</comment> \
        char       *funcname; <comment type="block">/* function name */</comment> \
        int         nargs; <comment type="block">/* number of arguments */</comment> \
        Oid           *argtypes; <comment type="block">/* argument types */</comment> \
        token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
        token = pg_strtok(&amp;length); <comment type="block">/* get nspname */</comment> \
        nspname = nullable_string(token, length); \
        token = pg_strtok(&amp;length); <comment type="block">/* get funcname */</comment> \
        funcname = nullable_string(token, length); \
        token = pg_strtok(&amp;length); <comment type="block">/* get nargs */</comment> \
        nargs = atoi(token); \
        if (funcname) \
        { \
            int    i; \
            argtypes = palloc(nargs * sizeof(Oid)); \
            for (i = 0; i &lt; nargs; i++) \
            { \
                char *typnspname; <comment type="block">/* argument type namespace */</comment> \
                char *typname; <comment type="block">/* argument type name */</comment> \
                token = pg_strtok(&amp;length); <comment type="block">/* get type nspname */</comment> \
                typnspname = nullable_string(token, length); \
                token = pg_strtok(&amp;length); <comment type="block">/* get type name */</comment> \
                typname = nullable_string(token, length); \
                argtypes[i] = get_typname_typid(typname, \
                                                NSP_OID(typnspname)); \
            } \
            local_node-&gt;fldname = get_funcid(funcname, \
                                             buildoidvector(argtypes, nargs), \
                                             NSP_OID(nspname)); \
        } \
        else \
            local_node-&gt;fldname = InvalidOid; \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Read operator identifier and lookup the OID */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_OPERID_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        char       *nspname; <comment type="block">/* namespace name */</comment> \
        char       *oprname; <comment type="block">/* operator name */</comment> \
        char       *leftnspname; <comment type="block">/* left type namespace */</comment> \
        char       *leftname; <comment type="block">/* left type name */</comment> \
        Oid            oprleft; <comment type="block">/* left type */</comment> \
        char       *rightnspname; <comment type="block">/* right type namespace */</comment> \
        char       *rightname; <comment type="block">/* right type name */</comment> \
        Oid            oprright; <comment type="block">/* right type */</comment> \
        token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
        token = pg_strtok(&amp;length); <comment type="block">/* get nspname */</comment> \
        nspname = nullable_string(token, length); \
        token = pg_strtok(&amp;length); <comment type="block">/* get operator name */</comment> \
        oprname = nullable_string(token, length); \
        token = pg_strtok(&amp;length); <comment type="block">/* left type namespace */</comment> \
        leftnspname = nullable_string(token, length); \
        token = pg_strtok(&amp;length); <comment type="block">/* left type name */</comment> \
        leftname = nullable_string(token, length); \
        token = pg_strtok(&amp;length); <comment type="block">/* right type namespace */</comment> \
        rightnspname = nullable_string(token, length); \
        token = pg_strtok(&amp;length); <comment type="block">/* right type name */</comment> \
        rightname = nullable_string(token, length); \
        if (oprname) \
        { \
            if (leftname) \
                oprleft = get_typname_typid(leftname, \
                                            NSP_OID(leftnspname)); \
            else \
                oprleft = InvalidOid; \
            if (rightname) \
                oprright = get_typname_typid(rightname, \
                                             NSP_OID(rightnspname)); \
            else \
                oprright = InvalidOid; \
            local_node-&gt;fldname = get_operid(oprname, \
                                             oprleft, \
                                             oprright, \
                                             NSP_OID(nspname)); \
        } \
        else \
            local_node-&gt;fldname = InvalidOid; \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Read collation identifier and lookup the OID */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_COLLID_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        char       *nspname; <comment type="block">/* namespace name */</comment> \
        char       *collname; <comment type="block">/* collation name */</comment> \
        int         collencoding; <comment type="block">/* collation encoding */</comment> \
        token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
        token = pg_strtok(&amp;length); <comment type="block">/* get nspname */</comment> \
        nspname = nullable_string(token, length); \
        token = pg_strtok(&amp;length); <comment type="block">/* get collname */</comment> \
        collname = nullable_string(token, length); \
        token = pg_strtok(&amp;length); <comment type="block">/* get collencoding */</comment> \
        collencoding = atoi(token); \
        if (collname) \
            local_node-&gt;fldname = get_collid(collname, \
                                             collencoding, \
                                             NSP_OID(nspname)); \
        else \
            local_node-&gt;fldname = InvalidOid; \
    } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_OPCLASS_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        char *nspname; \
        char *name; \
        token = pg_strtok(&amp;length);         \
        token = pg_strtok(&amp;length); \
        nspname = nullable_string(token, length); \
        token = pg_strtok(&amp;length);  \
        name = nullable_string(token, length); \
        if (nspname) \
        {\
            List *opclassname = list_make1(makeString(nspname)); \
            lappend(opclassname, makeString(name)); \
            local_node-&gt;fldname = get_opclass_oid(BTREE_AM_OID, \
                                                   opclassname, false); \
        } \
        else \
            local_node-&gt;fldname = InvalidOid; \
    } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_CONSTRAINT_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        char *cons_name; \
        char *rel_namespace; \
        char *rel_name; \
        token = pg_strtok(&amp;length);         \
        token = pg_strtok(&amp;length); \
        cons_name = nullable_string(token, length); \
        token = pg_strtok(&amp;length); \
        rel_namespace = nullable_string(token, length); \
        token = pg_strtok(&amp;length); \
        rel_name = nullable_string(token, length); \
        if (cons_name &amp;&amp; rel_name) \
        {\
            Oid nsp_oid = get_namespaceid(rel_namespace); \
            Oid relid =  get_relname_relid(rel_name, nsp_oid); \
            local_node-&gt;fldname = get_relation_constraint_oid(relid, cons_name, false); \
        }\
        else \
            local_node-&gt;fldname = InvalidOid; \
    } while (0)</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Read an attribute number array */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_ATTRNUMBER_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
    local_node-&gt;fldname = readAttrNumberCols(len);</cpp:value></cpp:define>

<comment type="block">/* Read an oid array */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_OID_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
    local_node-&gt;fldname = readOidCols(len);</cpp:value></cpp:define>

<comment type="block">/* Read an int array */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_INT_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
    local_node-&gt;fldname = readIntCols(len);</cpp:value></cpp:define>

<comment type="block">/* Read a bool array */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_BOOL_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>token = pg_strtok(&amp;length);        <comment type="block">/* skip :fldname */</comment> \
    local_node-&gt;fldname = readBoolCols(len);</cpp:value></cpp:define>

<comment type="block">/* Routine exit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_DONE</name><parameter_list>()</parameter_list></cpp:macro> \
    <cpp:value>return local_node</cpp:value></cpp:define>


<comment type="block">/*
 * NOTE: use atoi() to read values written with %d, or atoui() to read
 * values written with %u in outfuncs.c.  An exception is OID values,
 * for which use atooid().  (As of 7.1, outfuncs.c writes OIDs as %u,
 * but this will probably change in the future.)
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>atoui</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((unsigned int) strtoul((x), NULL, 10))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strtobool</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((*(x) == 't') ? true : false)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nullable_string</name><parameter_list>(<parameter><type><name>token</name></type></parameter>,<parameter><type><name>length</name></type></parameter>)</parameter_list></cpp:macro>  \
    <cpp:value>((length) == 0 ? NULL : debackslash(token, length))</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>scanDatum</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>typmod</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * _readBitmapset
 */</comment>
<function><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type>
<name>_readBitmapset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>READ_TEMP_LOCALS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"incomplete Bitmapset structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>length</name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'('</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized token: \"%.*s\""</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"incomplete Bitmapset structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>length</name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'b'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized token: \"%.*s\""</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>val</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unterminated Bitmapset structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>!=</operator> <name>token</name> <operator>+</operator> <name>length</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized integer: \"%.*s\""</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * for use by extensions which define extensible nodes
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>readBitmapset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>_readBitmapset</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _readQuery
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>_readQuery</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>commandType</name></expr></argument>, <argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>querySource</name></expr></argument>, <argument><expr><name>QuerySource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>queryId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <comment type="block">/* not saved in output format */</comment>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>canSetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>resultRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasAggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasWindowFuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasTargetSRFs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasSubLinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasDistinctOn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasRecursive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasModifyingCTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasForUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasRowSecurity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>cteList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>jointree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>override</name></expr></argument>, <argument><expr><name>OverridingKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>groupingSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>havingQual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>windowClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>distinctClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>sortClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>limitOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>limitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>setOperations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>constraintDeps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* withCheckOptions intentionally omitted, see comment in parsenodes.h */</comment>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>stmt_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>stmt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readNotifyStmt
 */</comment>
<function><type><specifier>static</specifier> <name>NotifyStmt</name> <modifier>*</modifier></type>
<name>_readNotifyStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>NotifyStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>conditionname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>payload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readDeclareCursorStmt
 */</comment>
<function><type><specifier>static</specifier> <name>DeclareCursorStmt</name> <modifier>*</modifier></type>
<name>_readDeclareCursorStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DeclareCursorStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>portalname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readWithCheckOption
 */</comment>
<function><type><specifier>static</specifier> <name>WithCheckOption</name> <modifier>*</modifier></type>
<name>_readWithCheckOption</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>WithCheckOption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>WCOKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>polname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>cascaded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSortGroupClause
 */</comment>
<function><type><specifier>static</specifier> <name>SortGroupClause</name> <modifier>*</modifier></type>
<name>_readSortGroupClause</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>tleSortGroupRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_OPERID_FIELD</name><argument_list>(<argument><expr><name>eqop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>eqop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_OPERID_FIELD</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>nulls_first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readGroupingSet
 */</comment>
<function><type><specifier>static</specifier> <name>GroupingSet</name> <modifier>*</modifier></type>
<name>_readGroupingSet</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>GroupingSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>GroupingSetKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readWindowClause
 */</comment>
<function><type><specifier>static</specifier> <name>WindowClause</name> <modifier>*</modifier></type>
<name>_readWindowClause</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>WindowClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>partitionClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>orderClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>frameOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>startOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>endOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>winref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>copiedOrder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readRowMarkClause
 */</comment>
<function><type><specifier>static</specifier> <name>RowMarkClause</name> <modifier>*</modifier></type>
<name>_readRowMarkClause</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RowMarkClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>strength</name></expr></argument>, <argument><expr><name>LockClauseStrength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>waitPolicy</name></expr></argument>, <argument><expr><name>LockWaitPolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>pushedDown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCommonTableExpr
 */</comment>
<function><type><specifier>static</specifier> <name>CommonTableExpr</name> <modifier>*</modifier></type>
<name>_readCommonTableExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CommonTableExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>ctename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>aliascolnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>ctematerialized</name></expr></argument>, <argument><expr><name>CTEMaterialize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>ctequery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>cterecursive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>cterefcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>ctecolnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>ctecoltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>ctecoltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>ctecolcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSetOperationStmt
 */</comment>
<function><type><specifier>static</specifier> <name>SetOperationStmt</name> <modifier>*</modifier></type>
<name>_readSetOperationStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>SetOperation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>larg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colTypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colCollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *    Stuff from primnodes.h.
 */</comment>

<function><type><specifier>static</specifier> <name>Alias</name> <modifier>*</modifier></type>
<name>_readAlias</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>aliasname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RangeVar</name> <modifier>*</modifier></type>
<name>_readRangeVar</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RangeVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>catalogname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* not currently saved in output format */</comment>

    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>inh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>relpersistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>intervalparent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>partitionvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>pubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readTableFunc
 */</comment>
<function><type><specifier>static</specifier> <name>TableFunc</name> <modifier>*</modifier></type>
<name>_readTableFunc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>TableFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>ns_uris</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>ns_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>docexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rowexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>coldefexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>notnulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>ordinalitycol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>IntoClause</name> <modifier>*</modifier></type>
<name>_readIntoClause</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>IntoClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>onCommit</name></expr></argument>, <argument><expr><name>OnCommitAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>tableSpaceName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>viewQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>skipData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readVar
 */</comment>
<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>_readVar</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>vartype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>vartype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>vartypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>varcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>varcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>varlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>varnoold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>varoattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readConst
 */</comment>
<function><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type>
<name>_readConst</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>consttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>consttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>consttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>constcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>constcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>constlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>constbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>constisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* skip :constvalue */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>local_node</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* skip "&lt;&gt;" */</comment>
    <if type="elseif">else
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>scanDatum</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>,
                                               <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>consttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>readDatum</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>constbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readParam
 */</comment>
<function><type><specifier>static</specifier> <name>Param</name> <modifier>*</modifier></type>
<name>_readParam</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>paramkind</name></expr></argument>, <argument><expr><name>ParamKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>paramid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>paramtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>paramtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>paramtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>paramcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>paramcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readAggref
 */</comment>
<function><type><specifier>static</specifier> <name>Aggref</name> <modifier>*</modifier></type>
<name>_readAggref</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_FUNCID_FIELD</name><argument_list>(<argument><expr><name>aggfnoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>aggfnoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>aggtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>aggtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>aggcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>aggcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>aggtranstype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>aggtranstype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_LIST_FIELD</name><argument_list>(<argument><expr><name>aggargtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>aggargtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>aggdirectargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>aggorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>aggdistinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>aggfilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>aggstar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>aggvariadic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>aggkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>agglevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>aggsplit</name></expr></argument>, <argument><expr><name>AggSplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readGroupingFunc
 */</comment>
<function><type><specifier>static</specifier> <name>GroupingFunc</name> <modifier>*</modifier></type>
<name>_readGroupingFunc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>agglevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readWindowFunc
 */</comment>
<function><type><specifier>static</specifier> <name>WindowFunc</name> <modifier>*</modifier></type>
<name>_readWindowFunc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_FUNCID_FIELD</name><argument_list>(<argument><expr><name>winfnoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>winfnoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>wintype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>wintype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>wincollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>wincollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>aggfilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>winref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>winstar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>winagg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readArrayRef
 */</comment>
<function><type><specifier>static</specifier> <name>ArrayRef</name> <modifier>*</modifier></type>
<name>_readArrayRef</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ArrayRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>refarraytype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>refarraytype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>refelemtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>refelemtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>reftypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>refcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>refcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>refupperindexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>reflowerindexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>refexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>refassgnexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readFuncExpr
 */</comment>
<function><type><specifier>static</specifier> <name>FuncExpr</name> <modifier>*</modifier></type>
<name>_readFuncExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_FUNCID_FIELD</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>funcresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>funcresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>funcretset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>funcvariadic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>funcformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>funccollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>funccollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readNamedArgExpr
 */</comment>
<function><type><specifier>static</specifier> <name>NamedArgExpr</name> <modifier>*</modifier></type>
<name>_readNamedArgExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>NamedArgExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>argnumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readOpExpr
 */</comment>
<function><type><specifier>static</specifier> <name>OpExpr</name> <modifier>*</modifier></type>
<name>_readOpExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_OPERID_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_FUNCID_FIELD</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>opresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>opretset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>opcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readDistinctExpr
 */</comment>
<function><type><specifier>static</specifier> <name>DistinctExpr</name> <modifier>*</modifier></type>
<name>_readDistinctExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DistinctExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_OPERID_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_FUNCID_FIELD</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>opresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>opretset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>opcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readNullIfExpr
 */</comment>
<function><type><specifier>static</specifier> <name>NullIfExpr</name> <modifier>*</modifier></type>
<name>_readNullIfExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>NullIfExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_OPERID_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_FUNCID_FIELD</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    <comment type="block">/*
     * The opfuncid is stored in the textual format primarily for debugging
     * and documentation reasons.  We want to always read it as zero to force
     * it to be re-looked-up in the pg_operator entry.  This ensures that
     * stored rules don't have hidden dependencies on operators' functions.
     * (We don't currently support an ALTER OPERATOR command, but might
     * someday.)
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/* Do not invalidate if we have just looked up the value */</comment>
    if (!portable_input)
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    local_node-&gt;opfuncid = InvalidOid;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>opresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>opretset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>opcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readScalarArrayOpExpr
 */</comment>
<function><type><specifier>static</specifier> <name>ScalarArrayOpExpr</name> <modifier>*</modifier></type>
<name>_readScalarArrayOpExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_OPERID_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_FUNCID_FIELD</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>useOr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readBoolExpr
 */</comment>
<function><type><specifier>static</specifier> <name>BoolExpr</name> <modifier>*</modifier></type>
<name>_readBoolExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* do-it-yourself enum representation */</comment>
    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* skip :boolop */</comment>
    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get field value */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"and"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>boolop</name></name> <operator>=</operator> <name>AND_EXPR</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"or"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>boolop</name></name> <operator>=</operator> <name>OR_EXPR</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"not"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>boolop</name></name> <operator>=</operator> <name>NOT_EXPR</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized boolop \"%.*s\""</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSubLink
 */</comment>
<function><type><specifier>static</specifier> <name>SubLink</name> <modifier>*</modifier></type>
<name>_readSubLink</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>subLinkType</name></expr></argument>, <argument><expr><name>SubLinkType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>subLinkId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>testexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>operName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>subselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readFieldSelect
 */</comment>
<function><type><specifier>static</specifier> <name>FieldSelect</name> <modifier>*</modifier></type>
<name>_readFieldSelect</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>fieldnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>resulttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readFieldStore
 */</comment>
<function><type><specifier>static</specifier> <name>FieldStore</name> <modifier>*</modifier></type>
<name>_readFieldStore</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>FieldStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>newvals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>fieldnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readRelabelType
 */</comment>
<function><type><specifier>static</specifier> <name>RelabelType</name> <modifier>*</modifier></type>
<name>_readRelabelType</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>resulttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>relabelformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCoerceViaIO
 */</comment>
<function><type><specifier>static</specifier> <name>CoerceViaIO</name> <modifier>*</modifier></type>
<name>_readCoerceViaIO</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CoerceViaIO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>coerceformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readArrayCoerceExpr
 */</comment>
<function><type><specifier>static</specifier> <name>ArrayCoerceExpr</name> <modifier>*</modifier></type>
<name>_readArrayCoerceExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ArrayCoerceExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_FUNCID_FIELD</name><argument_list>(<argument><expr><name>elemfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>elemfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>resulttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isExplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>coerceformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readConvertRowtypeExpr
 */</comment>
<function><type><specifier>static</specifier> <name>ConvertRowtypeExpr</name> <modifier>*</modifier></type>
<name>_readConvertRowtypeExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ConvertRowtypeExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>convertformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCollateExpr
 */</comment>
<function><type><specifier>static</specifier> <name>CollateExpr</name> <modifier>*</modifier></type>
<name>_readCollateExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>collOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>collOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCaseExpr
 */</comment>
<function><type><specifier>static</specifier> <name>CaseExpr</name> <modifier>*</modifier></type>
<name>_readCaseExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CaseExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>casetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>casetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>casecollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>casecollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>defresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCaseWhen
 */</comment>
<function><type><specifier>static</specifier> <name>CaseWhen</name> <modifier>*</modifier></type>
<name>_readCaseWhen</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CaseWhen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCaseTestExpr
 */</comment>
<function><type><specifier>static</specifier> <name>CaseTestExpr</name> <modifier>*</modifier></type>
<name>_readCaseTestExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>typeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readArrayExpr
 */</comment>
<function><type><specifier>static</specifier> <name>ArrayExpr</name> <modifier>*</modifier></type>
<name>_readArrayExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>array_collid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>array_collid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>element_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>element_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>multidims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readRowExpr
 */</comment>
<function><type><specifier>static</specifier> <name>RowExpr</name> <modifier>*</modifier></type>
<name>_readRowExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>row_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>row_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>row_format</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readRowCompareExpr
 */</comment>
<function><type><specifier>static</specifier> <name>RowCompareExpr</name> <modifier>*</modifier></type>
<name>_readRowCompareExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RowCompareExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>rctype</name></expr></argument>, <argument><expr><name>RowCompareType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>opnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>opfamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>inputcollids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>largs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCoalesceExpr
 */</comment>
<function><type><specifier>static</specifier> <name>CoalesceExpr</name> <modifier>*</modifier></type>
<name>_readCoalesceExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>coalescetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>coalescetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>coalescecollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>coalescecollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readMinMaxExpr
 */</comment>
<function><type><specifier>static</specifier> <name>MinMaxExpr</name> <modifier>*</modifier></type>
<name>_readMinMaxExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>MinMaxExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>minmaxtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>minmaxtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>minmaxcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>minmaxcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>MinMaxOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSQLValueFunction
 */</comment>
<function><type><specifier>static</specifier> <name>SQLValueFunction</name> <modifier>*</modifier></type>
<name>_readSQLValueFunction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SQLValueFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>SQLValueFunctionOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readNextValueExpr
 */</comment>
<function><type><specifier>static</specifier> <name>NextValueExpr</name> <modifier>*</modifier></type>
<name>_readNextValueExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>NextValueExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>READ_RELID_FIELD</name><argument_list>(<argument><expr><name>seqid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>seqid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readXmlExpr
 */</comment>
<function><type><specifier>static</specifier> <name>XmlExpr</name> <modifier>*</modifier></type>
<name>_readXmlExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>XmlExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>XmlExprOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>named_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>xmloption</name></expr></argument>, <argument><expr><name>XmlOptionType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readNullTest
 */</comment>
<function><type><specifier>static</specifier> <name>NullTest</name> <modifier>*</modifier></type>
<name>_readNullTest</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>nulltesttype</name></expr></argument>, <argument><expr><name>NullTestType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>argisrow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readBooleanTest
 */</comment>
<function><type><specifier>static</specifier> <name>BooleanTest</name> <modifier>*</modifier></type>
<name>_readBooleanTest</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>BooleanTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>booltesttype</name></expr></argument>, <argument><expr><name>BoolTestType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCoerceToDomain
 */</comment>
<function><type><specifier>static</specifier> <name>CoerceToDomain</name> <modifier>*</modifier></type>
<name>_readCoerceToDomain</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>resulttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>coercionformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCoerceToDomainValue
 */</comment>
<function><type><specifier>static</specifier> <name>CoerceToDomainValue</name> <modifier>*</modifier></type>
<name>_readCoerceToDomainValue</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CoerceToDomainValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>typeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSetToDefault
 */</comment>
<function><type><specifier>static</specifier> <name>SetToDefault</name> <modifier>*</modifier></type>
<name>_readSetToDefault</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SetToDefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>typeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCurrentOfExpr
 */</comment>
<function><type><specifier>static</specifier> <name>CurrentOfExpr</name> <modifier>*</modifier></type>
<name>_readCurrentOfExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CurrentOfExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>cvarno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>cursor_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>cursor_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readInferenceElem
 */</comment>
<function><type><specifier>static</specifier> <name>InferenceElem</name> <modifier>*</modifier></type>
<name>_readInferenceElem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>InferenceElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>infercollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>READ_OPCLASS_FIELD</name><argument_list>(<argument><expr><name>inferopclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>infercollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>inferopclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readTargetEntry
 */</comment>
<function><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type>
<name>_readTargetEntry</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>resno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>ressortgroupref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_RELID_FIELD_NOWARN</name><argument_list>(<argument><expr><name>resorigtbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resorigtbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>resorigcol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>resjunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readRangeTblRef
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblRef</name> <modifier>*</modifier></type>
<name>_readRangeTblRef</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readJoinExpr
 */</comment>
<function><type><specifier>static</specifier> <name>JoinExpr</name> <modifier>*</modifier></type>
<name>_readJoinExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>JoinType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isNatural</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>larg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>usingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readFromExpr
 */</comment>
<function><type><specifier>static</specifier> <name>FromExpr</name> <modifier>*</modifier></type>
<name>_readFromExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>fromlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readOnConflictExpr
 */</comment>
<function><type><specifier>static</specifier> <name>OnConflictExpr</name> <modifier>*</modifier></type>
<name>_readOnConflictExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>OnConflictExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>action</name></expr></argument>, <argument><expr><name>OnConflictAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arbiterElems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arbiterWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>READ_CONSTRAINT_FIELD</name><argument_list>(<argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflictSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflictWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>exclRelIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>exclRelTlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PartitionPruneStepOp</name> <modifier>*</modifier></type>
<name>_readPartitionPruneStepOp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
   <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PartitionPruneStepOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name><name>step</name><operator>.</operator><name>step_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>opstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>cmpfns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PartitionPruneStepCombine</name> <modifier>*</modifier></type>
<name>_readPartitionPruneStepCombine</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
   <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PartitionPruneStepCombine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name><name>step</name><operator>.</operator><name>step_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>combineOp</name></expr></argument>, <argument><expr><name>PartitionPruneCombineOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>source_stepids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *    Stuff from parsenodes.h.
 */</comment>

<comment type="block">/*
 * _readRangeTblEntry
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>_readRangeTblEntry</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* put alias + eref first to make dump more legible */</comment>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>eref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>rtekind</name></expr></argument>, <argument><expr><name>RTEKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name><name>local_node</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>RTE_RELATION</name></expr>:</case>
            <expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>relkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>local_node</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name><operator>)</operator> <operator>&amp;&amp;</operator>
                        <operator>(</operator><name><name>local_node</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_VIEW</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>READ_RELID_FIELD</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>READ_RELID_FIELD_NOWARN</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>tablesample</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
            <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>security_barrier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTE_JOIN</name></expr>:</case>
            <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>JoinType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>joinaliasvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
            <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>funcordinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
            <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>tablefunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTE_VALUES</name></expr>:</case>
            <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>values_lists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTE_CTE</name></expr>:</case>
            <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>ctename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>ctelevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>self_reference</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
            <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>enrname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>READ_FLOAT_FIELD</name><argument_list>(<argument><expr><name>enrtuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>READ_RELID_FIELD</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <case>case <expr><name>RTE_REMOTE_DUMMY</name></expr>:</case>
            <comment type="block">/* Nothing to do */</comment>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized RTE kind: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>local_node</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>lateral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>inh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>inFromCl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>requiredPerms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* no permission checks on data node */</comment>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* skip :fldname */</comment> \
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* skip field value */</comment> \
        <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>checkAsUser</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>checkAsUser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>selectedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>insertedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>updatedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>securityQuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>intervalparent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isdefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>partvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readRangeTblFunction
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblFunction</name> <modifier>*</modifier></type>
<name>_readRangeTblFunction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RangeTblFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>funcexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>funccolcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>funccolnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>READ_TYPID_LIST_FIELD</name><argument_list>(<argument><expr><name>funccoltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>funccoltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>funccoltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>funccolcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>funcparams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readTableSampleClause
 */</comment>
<function><type><specifier>static</specifier> <name>TableSampleClause</name> <modifier>*</modifier></type>
<name>_readTableSampleClause</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>TableSampleClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_FUNCID_FIELD</name><argument_list>(<argument><expr><name>tsmhandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>tsmhandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>repeatable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ReadCommonPlan
 *    Assign the basic stuff of all nodes that inherit from Plan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReadCommonPlan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>local_node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_TEMP_LOCALS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_FLOAT_FIELD</name><argument_list>(<argument><expr><name>startup_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_FLOAT_FIELD</name><argument_list>(<argument><expr><name>total_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_FLOAT_FIELD</name><argument_list>(<argument><expr><name>plan_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>plan_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallel_aware</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallel_safe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>plan_node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>righttree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>initPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>extParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>allParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isempty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>audit_fga_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<comment type="block">/*
 * _readDefElem
 */</comment>
<function><type><specifier>static</specifier> <name>DefElem</name> <modifier>*</modifier></type>
<name>_readDefElem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>defnamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>defname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>defaction</name></expr></argument>, <argument><expr><name>DefElemAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readPlan
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>_readPlan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS_NO_FIELDS</name><argument_list>(<argument><expr><name>Plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><name>local_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readPlannedStmt
 */</comment>
<function><type><specifier>static</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type>
<name>_readPlannedStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>commandType</name></expr></argument>, <argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>queryId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasReturning</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasModifyingCTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>canSetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>transientPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>dependsOnRole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallelModeNeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>planTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>nonleafResultRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rootResultRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>rewindPlanIDs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>relationOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>invalItems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>nParamExec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>stmt_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>stmt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>haspart_tobe_modify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>partrelindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>partpruning</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readResult
 */</comment>
<function><type><specifier>static</specifier> <name>Result</name> <modifier>*</modifier></type>
<name>_readResult</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>resconstantqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readProjectSet
 */</comment>
<function><type><specifier>static</specifier> <name>ProjectSet</name> <modifier>*</modifier></type>
<name>_readProjectSet</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS_NO_FIELDS</name><argument_list>(<argument><expr><name>ProjectSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readModifyTable
 */</comment>
<function><type><specifier>static</specifier> <name>ModifyTable</name> <modifier>*</modifier></type>
<name>_readModifyTable</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ModifyTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>operation</name></expr></argument>, <argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>canSetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>nominalRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>partColsUpdated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>resultRelIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>rootResultRelIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>plans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>withCheckOptionLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>returningLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>fdwPrivLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>fdwDirectModifyPlans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>epqParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>onConflictAction</name></expr></argument>, <argument><expr><name>OnConflictAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_RELID_LIST_FIELD</name><argument_list>(<argument><expr><name>arbiterIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arbiterIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflictSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflictWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>exclRelRTI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>exclRelTlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>haspartparent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>partrelidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>parentplanidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>partplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>partpruning</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readAppend
 */</comment>
<function><type><specifier>static</specifier> <name>Append</name> <modifier>*</modifier></type>
<name>_readAppend</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Append</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>appendplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readMergeAppend
 */</comment>
<function><type><specifier>static</specifier> <name>MergeAppend</name> <modifier>*</modifier></type>
<name>_readMergeAppend</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>MergeAppend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>mergeplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* skip :sortOperators */</comment>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>sortOperators</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt> <comment type="block">/* namespace name */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>oprname</name></decl>;</decl_stmt> <comment type="block">/* operator name */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>leftnspname</name></decl>;</decl_stmt> <comment type="block">/* left type namespace */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>leftname</name></decl>;</decl_stmt> <comment type="block">/* left type name */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>oprleft</name></decl>;</decl_stmt> <comment type="block">/* left type */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>rightnspname</name></decl>;</decl_stmt> <comment type="block">/* right type namespace */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>rightname</name></decl>;</decl_stmt> <comment type="block">/* right type name */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>oprright</name></decl>;</decl_stmt> <comment type="block">/* right type */</comment>
            <comment type="block">/* token is already set to nspname */</comment>
            <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get operator name */</comment>
            <expr_stmt><expr><name>oprname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* left type namespace */</comment>
            <expr_stmt><expr><name>leftnspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* left type name */</comment>
            <expr_stmt><expr><name>leftname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* right type namespace */</comment>
            <expr_stmt><expr><name>rightnspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* right type name */</comment>
            <expr_stmt><expr><name>rightname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>leftname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprleft</name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>leftname</name></expr></argument>,
                                            <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>leftnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprleft</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>rightname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprright</name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>rightname</name></expr></argument>,
                                             <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>rightnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprright</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_operid</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>,
                                                      <argument><expr><name>oprleft</name></expr></argument>,
                                                      <argument><expr><name>oprright</name></expr></argument>,
                                                      <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* skip :collations */</comment>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>collations</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt> <comment type="block">/* namespace name */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>collname</name></decl>;</decl_stmt> <comment type="block">/* collation name */</comment>
            <decl_stmt><decl><type><name>int</name></type>         <name>collencoding</name></decl>;</decl_stmt> <comment type="block">/* collation encoding */</comment>
            <comment type="block">/* the token is already read */</comment>
            <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get collname */</comment>
            <expr_stmt><expr><name>collname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get nargs */</comment>
            <expr_stmt><expr><name>collencoding</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>collname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>collations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_collid</name><argument_list>(<argument><expr><name>collname</name></expr></argument>,
                                                       <argument><expr><name>collencoding</name></expr></argument>,
                                                       <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>collations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>collations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>READ_BOOL_ARRAY</name><argument_list>(<argument><expr><name>nullsFirst</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readRecursiveUnion
 */</comment>
<function><type><specifier>static</specifier> <name>RecursiveUnion</name> <modifier>*</modifier></type>
<name>_readRecursiveUnion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RecursiveUnion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>wtParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>dupColIdx</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>dupOperators</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LONG_FIELD</name><argument_list>(<argument><expr><name>numGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readBitmapAnd
 */</comment>
<function><type><specifier>static</specifier> <name>BitmapAnd</name> <modifier>*</modifier></type>
<name>_readBitmapAnd</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>BitmapAnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>bitmapplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readBitmapOr
 */</comment>
<function><type><specifier>static</specifier> <name>BitmapOr</name> <modifier>*</modifier></type>
<name>_readBitmapOr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>BitmapOr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isshared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>bitmapplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ReadCommonScan
 *    Assign the basic stuff of all nodes that inherit from Scan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReadCommonScan</name><parameter_list>(<parameter><decl><type><name>Scan</name> <modifier>*</modifier></type><name>local_node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_TEMP_LOCALS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>scanrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>ispartchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>childidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * _readScan
 */</comment>
<function><type><specifier>static</specifier> <name>Scan</name> <modifier>*</modifier></type>
<name>_readScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS_NO_FIELDS</name><argument_list>(<argument><expr><name>Scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><name>local_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSeqScan
 */</comment>
<function><type><specifier>static</specifier> <name>SeqScan</name> <modifier>*</modifier></type>
<name>_readSeqScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS_NO_FIELDS</name><argument_list>(<argument><expr><name>SeqScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><name>local_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSampleScan
 */</comment>
<function><type><specifier>static</specifier> <name>SampleScan</name> <modifier>*</modifier></type>
<name>_readSampleScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SampleScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>tablesample</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readIndexScan
 */</comment>
<function><type><specifier>static</specifier> <name>IndexScan</name> <modifier>*</modifier></type>
<name>_readIndexScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>IndexScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_RELID_FIELD</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indexqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indexqualorig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indexorderby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indexorderbyorig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indexorderbyops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>indexorderdir</name></expr></argument>, <argument><expr><name>ScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readIndexOnlyScan
 */</comment>
<function><type><specifier>static</specifier> <name>IndexOnlyScan</name> <modifier>*</modifier></type>
<name>_readIndexOnlyScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>IndexOnlyScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_RELID_FIELD</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indexqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indexorderby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indextlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>indexorderdir</name></expr></argument>, <argument><expr><name>ScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readBitmapIndexScan
 */</comment>
<function><type><specifier>static</specifier> <name>BitmapIndexScan</name> <modifier>*</modifier></type>
<name>_readBitmapIndexScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>BitmapIndexScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_RELID_FIELD</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isshared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indexqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indexqualorig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readBitmapHeapScan
 */</comment>
<function><type><specifier>static</specifier> <name>BitmapHeapScan</name> <modifier>*</modifier></type>
<name>_readBitmapHeapScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>BitmapHeapScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>bitmapqualorig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readTidScan
 */</comment>
<function><type><specifier>static</specifier> <name>TidScan</name> <modifier>*</modifier></type>
<name>_readTidScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>TidScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>tidquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSubqueryScan
 */</comment>
<function><type><specifier>static</specifier> <name>SubqueryScan</name> <modifier>*</modifier></type>
<name>_readSubqueryScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readFunctionScan
 */</comment>
<function><type><specifier>static</specifier> <name>FunctionScan</name> <modifier>*</modifier></type>
<name>_readFunctionScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>FunctionScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>funcordinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readValuesScan
 */</comment>
<function><type><specifier>static</specifier> <name>ValuesScan</name> <modifier>*</modifier></type>
<name>_readValuesScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ValuesScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>values_lists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readTableFuncScan
 */</comment>
<function><type><specifier>static</specifier> <name>TableFuncScan</name> <modifier>*</modifier></type>
<name>_readTableFuncScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>TableFuncScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>tablefunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCteScan
 */</comment>
<function><type><specifier>static</specifier> <name>CteScan</name> <modifier>*</modifier></type>
<name>_readCteScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CteScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>ctePlanId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>cteParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readWorkTableScan
 */</comment>
<function><type><specifier>static</specifier> <name>WorkTableScan</name> <modifier>*</modifier></type>
<name>_readWorkTableScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>WorkTableScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>wtParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readForeignScan
 */</comment>
<function><type><specifier>static</specifier> <name>ForeignScan</name> <modifier>*</modifier></type>
<name>_readForeignScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ForeignScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>operation</name></expr></argument>, <argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>fs_server</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>fdw_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>fdw_scan_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>fdw_recheck_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>fs_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>fsSystemCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCustomScan
 */</comment>
<function><type><specifier>static</specifier> <name>CustomScan</name> <modifier>*</modifier></type>
<name>_readCustomScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>custom_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CustomScanMethods</name> <modifier>*</modifier></type><name>methods</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_scan_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>custom_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Lookup CustomScanMethods by CustomName */</comment>
    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* skip methods: */</comment>
    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* CustomName */</comment>
    <expr_stmt><expr><name>custom_name</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>methods</name> <operator>=</operator> <call><name>GetCustomScanMethods</name><argument_list>(<argument><expr><name>custom_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>methods</name></name> <operator>=</operator> <name>methods</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ReadCommonJoin
 *    Assign the basic stuff of all nodes that inherit from Join
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReadCommonJoin</name><parameter_list>(<parameter><decl><type><name>Join</name> <modifier>*</modifier></type><name>local_node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_TEMP_LOCALS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>JoinType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>inner_unique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>joinqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>prefetch_inner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * _readJoin
 */</comment>
<function><type><specifier>static</specifier> <name>Join</name> <modifier>*</modifier></type>
<name>_readJoin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS_NO_FIELDS</name><argument_list>(<argument><expr><name>Join</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonJoin</name><argument_list>(<argument><expr><name>local_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readNestLoop
 */</comment>
<function><type><specifier>static</specifier> <name>NestLoop</name> <modifier>*</modifier></type>
<name>_readNestLoop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>NestLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonJoin</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>join</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>nestParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readMergeJoin
 */</comment>
<function><type><specifier>static</specifier> <name>MergeJoin</name> <modifier>*</modifier></type>
<name>_readMergeJoin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numCols</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>MergeJoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonJoin</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>join</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>skip_mark_restore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>mergeclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>numCols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>mergeclauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>mergeFamilies</name></expr></argument>, <argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* skip :mergeCollations */</comment>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>mergeCollations</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numCols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt> <comment type="block">/* namespace name */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>collname</name></decl>;</decl_stmt> <comment type="block">/* collation name */</comment>
            <decl_stmt><decl><type><name>int</name></type>         <name>collencoding</name></decl>;</decl_stmt> <comment type="block">/* collation encoding */</comment>
            <comment type="block">/* the token is already read */</comment>
            <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get collname */</comment>
            <expr_stmt><expr><name>collname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get nargs */</comment>
            <expr_stmt><expr><name>collencoding</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>collname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>mergeCollations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_collid</name><argument_list>(<argument><expr><name>collname</name></expr></argument>,
                                                            <argument><expr><name>collencoding</name></expr></argument>,
                                                            <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>mergeCollations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>mergeCollations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>READ_INT_ARRAY</name><argument_list>(<argument><expr><name>mergeStrategies</name></expr></argument>, <argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_ARRAY</name><argument_list>(<argument><expr><name>mergeNullsFirst</name></expr></argument>, <argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readHashJoin
 */</comment>
<function><type><specifier>static</specifier> <name>HashJoin</name> <modifier>*</modifier></type>
<name>_readHashJoin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>HashJoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonJoin</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>join</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>hashclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readMaterial
 */</comment>
<function><type><specifier>static</specifier> <name>Material</name> <modifier>*</modifier></type>
<name>_readMaterial</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS_NO_FIELDS</name><argument_list>(<argument><expr><name>Material</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSort
 */</comment>
<function><type><specifier>static</specifier> <name>Sort</name> <modifier>*</modifier></type>
<name>_readSort</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Sort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* skip :sortColIdx */</comment>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>sortColIdx</name></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>sortColIdx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* skip :sortOperators */</comment>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>sortOperators</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt> <comment type="block">/* namespace name */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>oprname</name></decl>;</decl_stmt> <comment type="block">/* operator name */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>leftnspname</name></decl>;</decl_stmt> <comment type="block">/* left type namespace */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>leftname</name></decl>;</decl_stmt> <comment type="block">/* left type name */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>oprleft</name></decl>;</decl_stmt> <comment type="block">/* left type */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>rightnspname</name></decl>;</decl_stmt> <comment type="block">/* right type namespace */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>rightname</name></decl>;</decl_stmt> <comment type="block">/* right type name */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>oprright</name></decl>;</decl_stmt> <comment type="block">/* right type */</comment>
            <comment type="block">/* token is already set to nspname */</comment>
            <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get operator name */</comment>
            <expr_stmt><expr><name>oprname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* left type namespace */</comment>
            <expr_stmt><expr><name>leftnspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* left type name */</comment>
            <expr_stmt><expr><name>leftname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* right type namespace */</comment>
            <expr_stmt><expr><name>rightnspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* right type name */</comment>
            <expr_stmt><expr><name>rightname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>leftname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprleft</name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>leftname</name></expr></argument>,
                                            <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>leftnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprleft</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>rightname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprright</name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>rightname</name></expr></argument>,
                                             <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>rightnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprright</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_operid</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>,
                                                      <argument><expr><name>oprleft</name></expr></argument>,
                                                      <argument><expr><name>oprright</name></expr></argument>,
                                                      <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* skip :collations */</comment>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>collations</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt> <comment type="block">/* namespace name */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>collname</name></decl>;</decl_stmt> <comment type="block">/* collation name */</comment>
            <decl_stmt><decl><type><name>int</name></type>         <name>collencoding</name></decl>;</decl_stmt> <comment type="block">/* collation encoding */</comment>
            <comment type="block">/* the token is already read */</comment>
            <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get collname */</comment>
            <expr_stmt><expr><name>collname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get nargs */</comment>
            <expr_stmt><expr><name>collencoding</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>collname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>collations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_collid</name><argument_list>(<argument><expr><name>collname</name></expr></argument>,
                                                       <argument><expr><name>collencoding</name></expr></argument>,
                                                       <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>collations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>collations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* skip :nullsFirst */</comment>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>nullsFirst</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>nullsFirst</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>strtobool</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readGroup
 */</comment>
<function><type><specifier>static</specifier> <name>Group</name> <modifier>*</modifier></type>
<name>_readGroup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>    <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* skip :grpColIdx */</comment>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>grpColIdx</name></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>grpColIdx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* skip :grpOperators */</comment>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>grpOperators</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt> <comment type="block">/* namespace name */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>oprname</name></decl>;</decl_stmt> <comment type="block">/* operator name */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>leftnspname</name></decl>;</decl_stmt> <comment type="block">/* left type namespace */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>leftname</name></decl>;</decl_stmt> <comment type="block">/* left type name */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>oprleft</name></decl>;</decl_stmt> <comment type="block">/* left type */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>rightnspname</name></decl>;</decl_stmt> <comment type="block">/* right type namespace */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>rightname</name></decl>;</decl_stmt> <comment type="block">/* right type name */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>oprright</name></decl>;</decl_stmt> <comment type="block">/* right type */</comment>
            <comment type="block">/* token is already set to nspname */</comment>
            <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get operator name */</comment>
            <expr_stmt><expr><name>oprname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* left type namespace */</comment>
            <expr_stmt><expr><name>leftnspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* left type name */</comment>
            <expr_stmt><expr><name>leftname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* right type namespace */</comment>
            <expr_stmt><expr><name>rightnspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* right type name */</comment>
            <expr_stmt><expr><name>rightname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>leftname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprleft</name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>leftname</name></expr></argument>,
                                            <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>leftnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprleft</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>rightname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprright</name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>rightname</name></expr></argument>,
                                             <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>rightnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprright</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>grpOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_operid</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>,
                                                     <argument><expr><name>oprleft</name></expr></argument>,
                                                     <argument><expr><name>oprright</name></expr></argument>,
                                                     <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>grpOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readAgg
 */</comment>
<function><type><specifier>static</specifier> <name>Agg</name> <modifier>*</modifier></type>
<name>_readAgg</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Agg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>aggstrategy</name></expr></argument>, <argument><expr><name>AggStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>aggsplit</name></expr></argument>, <argument><expr><name>AggSplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>grpColIdx</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* skip :grpOperators */</comment>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>grpOperators</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt> <comment type="block">/* namespace name */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>oprname</name></decl>;</decl_stmt> <comment type="block">/* operator name */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>leftnspname</name></decl>;</decl_stmt> <comment type="block">/* left type namespace */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>leftname</name></decl>;</decl_stmt> <comment type="block">/* left type name */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>oprleft</name></decl>;</decl_stmt> <comment type="block">/* left type */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>rightnspname</name></decl>;</decl_stmt> <comment type="block">/* right type namespace */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>rightname</name></decl>;</decl_stmt> <comment type="block">/* right type name */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>oprright</name></decl>;</decl_stmt> <comment type="block">/* right type */</comment>
            <comment type="block">/* token is already set to nspname */</comment>
            <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get operator name */</comment>
            <expr_stmt><expr><name>oprname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* left type namespace */</comment>
            <expr_stmt><expr><name>leftnspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* left type name */</comment>
            <expr_stmt><expr><name>leftname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* right type namespace */</comment>
            <expr_stmt><expr><name>rightnspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* right type name */</comment>
            <expr_stmt><expr><name>rightname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>leftname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprleft</name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>leftname</name></expr></argument>,
                                            <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>leftnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprleft</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>rightname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprright</name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>rightname</name></expr></argument>,
                                             <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>rightnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprright</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>grpOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_operid</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>,
                                                     <argument><expr><name>oprleft</name></expr></argument>,
                                                     <argument><expr><name>oprright</name></expr></argument>,
                                                     <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>grpOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>grpOperators</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>READ_LONG_FIELD</name><argument_list>(<argument><expr><name>numGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>aggParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>groupingSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>chain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>entrySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hybrid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>noDistinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readWindowAgg
 */</comment>
<function><type><specifier>static</specifier> <name>WindowAgg</name> <modifier>*</modifier></type>
<name>_readWindowAgg</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>WindowAgg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>winref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>partNumCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* skip :partColIdx */</comment>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>partColIdx</name></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>partNumCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>partNumCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>partColIdx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* skip :partOperators */</comment>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>partOperators</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>partNumCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>partNumCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt> <comment type="block">/* namespace name */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>oprname</name></decl>;</decl_stmt> <comment type="block">/* operator name */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>leftnspname</name></decl>;</decl_stmt> <comment type="block">/* left type namespace */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>leftname</name></decl>;</decl_stmt> <comment type="block">/* left type name */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>oprleft</name></decl>;</decl_stmt> <comment type="block">/* left type */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>rightnspname</name></decl>;</decl_stmt> <comment type="block">/* right type namespace */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>rightname</name></decl>;</decl_stmt> <comment type="block">/* right type name */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>oprright</name></decl>;</decl_stmt> <comment type="block">/* right type */</comment>
            <comment type="block">/* token is already set to nspname */</comment>
            <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get operator name */</comment>
            <expr_stmt><expr><name>oprname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* left type namespace */</comment>
            <expr_stmt><expr><name>leftnspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* left type name */</comment>
            <expr_stmt><expr><name>leftname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* right type namespace */</comment>
            <expr_stmt><expr><name>rightnspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* right type name */</comment>
            <expr_stmt><expr><name>rightname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>leftname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprleft</name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>leftname</name></expr></argument>,
                                            <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>leftnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprleft</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>rightname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprright</name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>rightname</name></expr></argument>,
                                             <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>rightnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprright</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>partOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_operid</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>,
                                                      <argument><expr><name>oprleft</name></expr></argument>,
                                                      <argument><expr><name>oprright</name></expr></argument>,
                                                      <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>partOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>ordNumCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* skip :ordColIdx */</comment>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>ordColIdx</name></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>ordNumCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>ordNumCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>ordColIdx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* skip :ordOperators */</comment>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>ordOperators</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>ordNumCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>ordNumCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt> <comment type="block">/* namespace name */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>oprname</name></decl>;</decl_stmt> <comment type="block">/* operator name */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>leftnspname</name></decl>;</decl_stmt> <comment type="block">/* left type namespace */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>leftname</name></decl>;</decl_stmt> <comment type="block">/* left type name */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>oprleft</name></decl>;</decl_stmt> <comment type="block">/* left type */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>rightnspname</name></decl>;</decl_stmt> <comment type="block">/* right type namespace */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>rightname</name></decl>;</decl_stmt> <comment type="block">/* right type name */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>oprright</name></decl>;</decl_stmt> <comment type="block">/* right type */</comment>
            <comment type="block">/* token is already set to nspname */</comment>
            <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get operator name */</comment>
            <expr_stmt><expr><name>oprname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* left type namespace */</comment>
            <expr_stmt><expr><name>leftnspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* left type name */</comment>
            <expr_stmt><expr><name>leftname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* right type namespace */</comment>
            <expr_stmt><expr><name>rightnspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* right type name */</comment>
            <expr_stmt><expr><name>rightname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>leftname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprleft</name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>leftname</name></expr></argument>,
                                            <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>leftnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprleft</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>rightname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprright</name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>rightname</name></expr></argument>,
                                             <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>rightnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprright</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>ordOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_operid</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>,
                                                     <argument><expr><name>oprleft</name></expr></argument>,
                                                     <argument><expr><name>oprright</name></expr></argument>,
                                                     <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>ordOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>frameOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>startOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>endOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readUnique
 */</comment>
<function><type><specifier>static</specifier> <name>Unique</name> <modifier>*</modifier></type>
<name>_readUnique</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Unique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>uniqColIdx</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* skip :uniqOperators */</comment>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>uniqOperators</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt> <comment type="block">/* namespace name */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>oprname</name></decl>;</decl_stmt> <comment type="block">/* operator name */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>leftnspname</name></decl>;</decl_stmt> <comment type="block">/* left type namespace */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>leftname</name></decl>;</decl_stmt> <comment type="block">/* left type name */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>oprleft</name></decl>;</decl_stmt> <comment type="block">/* left type */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>rightnspname</name></decl>;</decl_stmt> <comment type="block">/* right type namespace */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>rightname</name></decl>;</decl_stmt> <comment type="block">/* right type name */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>oprright</name></decl>;</decl_stmt> <comment type="block">/* right type */</comment>
            <comment type="block">/* token is already set to nspname */</comment>
            <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get operator name */</comment>
            <expr_stmt><expr><name>oprname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* left type namespace */</comment>
            <expr_stmt><expr><name>leftnspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* left type name */</comment>
            <expr_stmt><expr><name>leftname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* right type namespace */</comment>
            <expr_stmt><expr><name>rightnspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* right type name */</comment>
            <expr_stmt><expr><name>rightname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>leftname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprleft</name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>leftname</name></expr></argument>,
                                            <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>leftnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprleft</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>rightname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprright</name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>rightname</name></expr></argument>,
                                             <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>rightnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprright</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>uniqOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_operid</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>,
                                                      <argument><expr><name>oprleft</name></expr></argument>,
                                                      <argument><expr><name>oprright</name></expr></argument>,
                                                      <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>uniqOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readGather
 */</comment>
<function><type><specifier>static</specifier> <name>Gather</name> <modifier>*</modifier></type>
<name>_readGather</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Gather</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>num_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>single_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>invisible</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallelWorker_sendTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readGatherMerge
 */</comment>
<function><type><specifier>static</specifier> <name>GatherMerge</name> <modifier>*</modifier></type>
<name>_readGatherMerge</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>GatherMerge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>num_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>sortOperators</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>collations</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_ARRAY</name><argument_list>(<argument><expr><name>nullsFirst</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readHash
 */</comment>
<function><type><specifier>static</specifier> <name>Hash</name> <modifier>*</modifier></type>
<name>_readHash</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_RELID_FIELD</name><argument_list>(<argument><expr><name>skewTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>skewTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>skewColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>skewInherit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSetOp
 */</comment>
<function><type><specifier>static</specifier> <name>SetOp</name> <modifier>*</modifier></type>
<name>_readSetOp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SetOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>SetOpCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>SetOpStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* skip :dupColIdx */</comment>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>dupColIdx</name></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>dupColIdx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* skip :dupOperators */</comment>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>dupOperators</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt> <comment type="block">/* namespace name */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>oprname</name></decl>;</decl_stmt> <comment type="block">/* operator name */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>leftnspname</name></decl>;</decl_stmt> <comment type="block">/* left type namespace */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>leftname</name></decl>;</decl_stmt> <comment type="block">/* left type name */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>oprleft</name></decl>;</decl_stmt> <comment type="block">/* left type */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>rightnspname</name></decl>;</decl_stmt> <comment type="block">/* right type namespace */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>rightname</name></decl>;</decl_stmt> <comment type="block">/* right type name */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>oprright</name></decl>;</decl_stmt> <comment type="block">/* right type */</comment>

            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* get operator namespace */</comment>
            <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get operator name */</comment>
            <expr_stmt><expr><name>oprname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* left type namespace */</comment>
            <expr_stmt><expr><name>leftnspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* left type name */</comment>
            <expr_stmt><expr><name>leftname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* right type namespace */</comment>
            <expr_stmt><expr><name>rightnspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* right type name */</comment>
            <expr_stmt><expr><name>rightname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>leftname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprleft</name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>leftname</name></expr></argument>,
                                            <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>leftnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprleft</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>rightname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprright</name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>rightname</name></expr></argument>,
                                             <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>rightnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprright</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>dupOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_operid</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>,
                                                     <argument><expr><name>oprleft</name></expr></argument>,
                                                     <argument><expr><name>oprright</name></expr></argument>,
                                                     <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>dupOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>flagColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>firstFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LONG_FIELD</name><argument_list>(<argument><expr><name>numGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readLockRows
 */</comment>
<function><type><specifier>static</specifier> <name>LockRows</name> <modifier>*</modifier></type>
<name>_readLockRows</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>LockRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>epqParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readLimit
 */</comment>
<function><type><specifier>static</specifier> <name>Limit</name> <modifier>*</modifier></type>
<name>_readLimit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>limitOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>limitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>skipEarlyFinish</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readNestLoopParam
 */</comment>
<function><type><specifier>static</specifier> <name>NestLoopParam</name> <modifier>*</modifier></type>
<name>_readNestLoopParam</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>NestLoopParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>paramno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>paramval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readPlanRowMark
 */</comment>
<function><type><specifier>static</specifier> <name>PlanRowMark</name> <modifier>*</modifier></type>
<name>_readPlanRowMark</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PlanRowMark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>prti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>rowmarkId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>markType</name></expr></argument>, <argument><expr><name>RowMarkType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>allMarkTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>strength</name></expr></argument>, <argument><expr><name>LockClauseStrength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>waitPolicy</name></expr></argument>, <argument><expr><name>LockWaitPolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readPlanInvalItem
 */</comment>
<function><type><specifier>static</specifier> <name>PlanInvalItem</name> <modifier>*</modifier></type>
<name>_readPlanInvalItem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PlanInvalItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>cacheId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>hashValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSubPlan
 */</comment>
<function><type><specifier>static</specifier> <name>SubPlan</name> <modifier>*</modifier></type>
<name>_readSubPlan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>subLinkType</name></expr></argument>, <argument><expr><name>SubLinkType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>testexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>paramIds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>plan_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>plan_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>firstColType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>firstColType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>firstColTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_COLLID_FIELD</name><argument_list>(<argument><expr><name>firstColCollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>firstColCollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>useHashTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>unknownEqFalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallel_safe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>setParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>parParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_FLOAT_FIELD</name><argument_list>(<argument><expr><name>startup_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_FLOAT_FIELD</name><argument_list>(<argument><expr><name>per_call_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readAlternativeSubPlan
 */</comment>
<function><type><specifier>static</specifier> <name>AlternativeSubPlan</name> <modifier>*</modifier></type>
<name>_readAlternativeSubPlan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlternativeSubPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readExtensibleNode
 */</comment>
<function><type><specifier>static</specifier> <name>ExtensibleNode</name> <modifier>*</modifier></type>
<name>_readExtensibleNode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ExtensibleNodeMethods</name> <modifier>*</modifier></type><name>methods</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtensibleNode</name> <modifier>*</modifier></type><name>local_node</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extnodename</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>READ_TEMP_LOCALS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* skip :extnodename */</comment>
    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get extnodename */</comment>

    <expr_stmt><expr><name>extnodename</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>extnodename</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extnodename has to be supplied"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>methods</name> <operator>=</operator> <call><name>GetExtensibleNodeMethods</name><argument_list>(<argument><expr><name>extnodename</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>local_node</name> <operator>=</operator> <operator>(</operator><name>ExtensibleNode</name> <operator>*</operator><operator>)</operator> <call><name>newNode</name><argument_list>(<argument><expr><name><name>methods</name><operator>-&gt;</operator><name>node_size</name></name></expr></argument>,
                                            <argument><expr><name>T_ExtensibleNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>extnodename</name></name> <operator>=</operator> <name>extnodename</name></expr>;</expr_stmt>

    <comment type="block">/* deserialize the private fields */</comment>
    <expr_stmt><expr><call><name><name>methods</name><operator>-&gt;</operator><name>nodeRead</name></name><argument_list>(<argument><expr><name>local_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * _readRemoteSubplan
 */</comment>
<function><type><specifier>static</specifier> <name>RemoteSubplan</name> <modifier>*</modifier></type>
<name>_readRemoteSubplan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RemoteSubplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>distributionType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>distributionKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>distributionNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>distributionRestrict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>nodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>execOnAll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>sort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT64_FIELD</name><argument_list>(<argument><expr><name>unique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallelWorkerSendTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>initPlanParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * _readRemoteQuery
 */</comment>
<function><type><specifier>static</specifier> <name>RemoteQuery</name> <modifier>*</modifier></type>
<name>_readRemoteQuery</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>exec_direct_type</name></expr></argument>, <argument><expr><name>ExecDirectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>sql_statement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>exec_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>combine_type</name></expr></argument>, <argument><expr><name>CombineType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>sort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>read_only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>force_autocommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>statement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>rq_num_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>local_node</name><operator>-&gt;</operator><name>rq_num_params</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>rq_param_types</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>rq_num_params</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* skip :rq_param_types */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>rq_num_params</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
            <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>rq_param_types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>exec_type</name></expr></argument>, <argument><expr><name>RemoteQueryExecType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>reduce_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>outer_alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>inner_alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>outer_reduce_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>inner_reduce_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>outer_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>inner_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>inner_statement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>outer_statement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>join_condition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>has_row_marks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>has_ins_child_sel_parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>rq_finalise_aggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>rq_sortgroup_colno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>remote_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>base_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>coord_var_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>query_var_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ExecNodes</name> <modifier>*</modifier></type>
<name>_readExecNodes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>primarynodelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>nodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>baselocatortype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>en_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>sec_en_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>READ_RELID_FIELD</name><argument_list>(<argument><expr><name>en_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>en_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>accesstype</name></expr></argument>, <argument><expr><name>RelationAccessType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>AuditFgaPolicy</name> <modifier>*</modifier></type>
<name>_readAuditFgaStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AuditFgaPolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
        <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>policy_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * _readRemoteStmt
 */</comment>
<function><type><specifier>static</specifier> <name>RemoteStmt</name> <modifier>*</modifier></type>
<name>_readRemoteStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RemoteStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>commandType</name></expr></argument>, <argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasReturning</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>planTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>nParamExec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>nParamRemote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>local_node</name><operator>-&gt;</operator><name>nParamRemote</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>remoteparams</name></name> <operator>=</operator> <operator>(</operator><name>RemoteParam</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(
                <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>nParamRemote</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RemoteParam</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>nParamRemote</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RemoteParam</name> <modifier>*</modifier></type><name>rparam</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>local_node</name><operator>-&gt;</operator><name>remoteparams</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* skip  :paramkind */</comment>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rparam</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <operator>(</operator><name>ParamKind</name><operator>)</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* skip  :paramid */</comment>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rparam</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* skip  :paramused */</comment>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rparam</name><operator>-&gt;</operator><name>paramused</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* skip  :paramtype */</comment>
            <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt> <comment type="block">/* namespace name */</comment>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>typname</name></decl>;</decl_stmt> <comment type="block">/* data type name */</comment>
                <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get nspname */</comment>
                <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get typname */</comment>
                <expr_stmt><expr><name>typname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>typname</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>rparam</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>typname</name></expr></argument>,
                                                          <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>rparam</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rparam</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>remoteparams</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>distributionType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>distributionKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>distributionNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>distributionRestrict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallelModeNeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallelWorkerSendTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>haspart_tobe_modify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>partrelindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>partpruning</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * _readSimpleSort
 */</comment>
<function><type><specifier>static</specifier> <name>SimpleSort</name> <modifier>*</modifier></type>
<name>_readSimpleSort</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SimpleSort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* skip :sortColIdx */</comment>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>sortColIdx</name></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>sortColIdx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* skip :sortOperators */</comment>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>sortOperators</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt> <comment type="block">/* namespace name */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>oprname</name></decl>;</decl_stmt> <comment type="block">/* operator name */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>leftnspname</name></decl>;</decl_stmt> <comment type="block">/* left type namespace */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>leftname</name></decl>;</decl_stmt> <comment type="block">/* left type name */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>oprleft</name></decl>;</decl_stmt> <comment type="block">/* left type */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>rightnspname</name></decl>;</decl_stmt> <comment type="block">/* right type namespace */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>rightname</name></decl>;</decl_stmt> <comment type="block">/* right type name */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>oprright</name></decl>;</decl_stmt> <comment type="block">/* right type */</comment>
            <comment type="block">/* token is already set to nspname */</comment>
            <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get operator name */</comment>
            <expr_stmt><expr><name>oprname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* left type namespace */</comment>
            <expr_stmt><expr><name>leftnspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* left type name */</comment>
            <expr_stmt><expr><name>leftname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* right type namespace */</comment>
            <expr_stmt><expr><name>rightnspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* right type name */</comment>
            <expr_stmt><expr><name>rightname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>leftname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprleft</name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>leftname</name></expr></argument>,
                                            <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>leftnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprleft</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>rightname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprright</name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>rightname</name></expr></argument>,
                                             <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>rightnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>oprright</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_operid</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>,
                                                      <argument><expr><name>oprleft</name></expr></argument>,
                                                      <argument><expr><name>oprright</name></expr></argument>,
                                                      <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* skip :sortCollations */</comment>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>sortCollations</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt> <comment type="block">/* namespace name */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>collname</name></decl>;</decl_stmt> <comment type="block">/* collation name */</comment>
            <decl_stmt><decl><type><name>int</name></type>         <name>collencoding</name></decl>;</decl_stmt> <comment type="block">/* collation encoding */</comment>
            <comment type="block">/* the token is already read */</comment>
            <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get collname */</comment>
            <expr_stmt><expr><name>collname</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get nargs */</comment>
            <expr_stmt><expr><name>collencoding</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>collname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>sortCollations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_collid</name><argument_list>(<argument><expr><name>collname</name></expr></argument>,
                                                       <argument><expr><name>collencoding</name></expr></argument>,
                                                       <argument><expr><call><name>NSP_OID</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>sortCollations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>sortCollations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* skip :nullsFirst */</comment>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>nullsFirst</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>nullsFirst</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>strtobool</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * _readPartitionBoundSpec
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionBoundSpec</name> <modifier>*</modifier></type>
<name>_readPartitionBoundSpec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PartitionBoundSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>modulus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>listdatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>lowerdatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>upperdatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readPartitionRangeDatum
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionRangeDatum</name> <modifier>*</modifier></type>
<name>_readPartitionRangeDatum</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>PartitionRangeDatumKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>AuditStmt</name> <modifier>*</modifier></type>
<name>_readAuditStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AuditStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>audit_ison</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>audit_type</name></expr></argument>, <argument><expr><name>AuditType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>audit_mode</name></expr></argument>, <argument><expr><name>AuditMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>action_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>user_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>object_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>object_type</name></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CleanAuditStmt</name> <modifier>*</modifier></type>
<name>_readCleanAuditStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CleanAuditStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>clean_type</name></expr></argument>, <argument><expr><name>CleanAuditType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>user_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>object_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>object_type</name></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>PlaceHolderVar</name> <modifier>*</modifier></type>
<name>_readPlaceHolderVar</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>phexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>phrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>phid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>phlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PlaceHolderInfo</name> <modifier>*</modifier></type>
<name>_readPlaceHolderInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PlaceHolderInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>phid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>ph_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>ph_eval_at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>ph_lateral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>ph_needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>ph_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>PartitionBy</name> <modifier>*</modifier></type>
<name>_readPartitionBy</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PartitionBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>colattr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>intervaltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
    <if_stmt><if>if <condition>(<expr><name>portable_input</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>READ_TYPID_FIELD</name><argument_list>(<argument><expr><name>partdatatype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>partdatatype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>startvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>          
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>       
    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>nPartitions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AddDropPartitions</name> <modifier>*</modifier></type>
<name>_readAddDropPartitions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AddDropPartitions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PartitionForExpr</name> <modifier>*</modifier></type>
<name>_readPartitionForExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PartitionForExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isdefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>router_src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * parseNodeString
 *
 * Given a character string representing a node tree, parseNodeString creates
 * the internal node structure.
 *
 * The string to be read must already have been loaded into pg_strtok().
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>parseNodeString</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>return_value</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>READ_TEMP_LOCALS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCH</name><parameter_list>(<parameter><type><name>tokname</name></type></parameter>, <parameter><type><name>namelen</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>(length == namelen &amp;&amp; memcmp(token, tokname, namelen) == 0)</cpp:value></cpp:define>

    <if_stmt><if>if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"QUERY"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"WITHCHECKOPTION"</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readWithCheckOption</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SORTGROUPCLAUSE"</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSortGroupClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"GROUPINGSET"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGroupingSet</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"WINDOWCLAUSE"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readWindowClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"ROWMARKCLAUSE"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRowMarkClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"COMMONTABLEEXPR"</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCommonTableExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SETOPERATIONSTMT"</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSetOperationStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"ALIAS"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlias</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"RANGEVAR"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRangeVar</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"INTOCLAUSE"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readIntoClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"TABLEFUNC"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTableFunc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"VAR"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readVar</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"CONST"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readConst</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PARAM"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readParam</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"AGGREF"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAggref</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"GROUPINGFUNC"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGroupingFunc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"WINDOWFUNC"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readWindowFunc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"ARRAYREF"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readArrayRef</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"FUNCEXPR"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readFuncExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"NAMEDARGEXPR"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNamedArgExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"OPEXPR"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readOpExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"DISTINCTEXPR"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDistinctExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"NULLIFEXPR"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNullIfExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SCALARARRAYOPEXPR"</literal></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readScalarArrayOpExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"BOOLEXPR"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readBoolExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SUBLINK"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSubLink</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"FIELDSELECT"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readFieldSelect</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"FIELDSTORE"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readFieldStore</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"RELABELTYPE"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRelabelType</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"COERCEVIAIO"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCoerceViaIO</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"ARRAYCOERCEEXPR"</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readArrayCoerceExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"CONVERTROWTYPEEXPR"</literal></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readConvertRowtypeExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"COLLATE"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCollateExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"CASE"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCaseExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"WHEN"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCaseWhen</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"CASETESTEXPR"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCaseTestExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"ARRAY"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readArrayExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"ROW"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRowExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"ROWCOMPARE"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRowCompareExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"COALESCE"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCoalesceExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"MINMAX"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readMinMaxExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SQLVALUEFUNCTION"</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSQLValueFunction</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"NEXTVALUEEXPR"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNextValueExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"XMLEXPR"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readXmlExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"NULLTEST"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNullTest</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"BOOLEANTEST"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readBooleanTest</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"COERCETODOMAIN"</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCoerceToDomain</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"COERCETODOMAINVALUE"</literal></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCoerceToDomainValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SETTODEFAULT"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSetToDefault</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"CURRENTOFEXPR"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCurrentOfExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"NEXTVALUEEXPR"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNextValueExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"INFERENCEELEM"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readInferenceElem</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"TARGETENTRY"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTargetEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"RANGETBLREF"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRangeTblRef</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"JOINEXPR"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readJoinExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"FROMEXPR"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readFromExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"ONCONFLICTEXPR"</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readOnConflictExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PARTITIONPRUNESTEPOP"</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionPruneStepOp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PARTITIONPRUNESTEPCOMBINE"</literal></expr></argument>, <argument><expr><literal type="number">25</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionPruneStepCombine</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"RTE"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRangeTblEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"RANGETBLFUNCTION"</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRangeTblFunction</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"TABLESAMPLECLAUSE"</literal></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTableSampleClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"NOTIFY"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNotifyStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"DEFELEM"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDefElem</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"DECLARECURSOR"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDeclareCursorStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PLANNEDSTMT"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPlannedStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PLAN"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPlan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"RESULT"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readResult</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PROJECTSET"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readProjectSet</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"MODIFYTABLE"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readModifyTable</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"APPEND"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAppend</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"MERGEAPPEND"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readMergeAppend</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"RECURSIVEUNION"</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRecursiveUnion</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"BITMAPAND"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readBitmapAnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"BITMAPOR"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readBitmapOr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SCAN"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SEQSCAN"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSeqScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SAMPLESCAN"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSampleScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"INDEXSCAN"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readIndexScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"INDEXONLYSCAN"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readIndexOnlyScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"BITMAPINDEXSCAN"</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readBitmapIndexScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"BITMAPHEAPSCAN"</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readBitmapHeapScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"TIDSCAN"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTidScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SUBQUERYSCAN"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSubqueryScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"FUNCTIONSCAN"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readFunctionScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"VALUESSCAN"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readValuesScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"TABLEFUNCSCAN"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTableFuncScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"CTESCAN"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCteScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"WORKTABLESCAN"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readWorkTableScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"FOREIGNSCAN"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readForeignScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"CUSTOMSCAN"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCustomScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"JOIN"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readJoin</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"NESTLOOP"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNestLoop</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"MERGEJOIN"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readMergeJoin</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"HASHJOIN"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readHashJoin</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"MATERIAL"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readMaterial</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SORT"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"GROUP"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGroup</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"AGG"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAgg</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"WINDOWAGG"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readWindowAgg</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"UNIQUE"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readUnique</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"GATHER"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGather</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"GATHERMERGE"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGatherMerge</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"HASH"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readHash</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SETOP"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSetOp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"LOCKROWS"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readLockRows</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"LIMIT"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readLimit</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"NESTLOOPPARAM"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNestLoopParam</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PLANROWMARK"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPlanRowMark</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PLANINVALITEM"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPlanInvalItem</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SUBPLAN"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSubPlan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"ALTERNATIVESUBPLAN"</literal></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlternativeSubPlan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"EXTENSIBLENODE"</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readExtensibleNode</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"REMOTESUBPLAN"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRemoteSubplan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"REMOTESTMT"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRemoteStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SIMPLESORT"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSimpleSort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PARTITIONBOUNDSPEC"</literal></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionBoundSpec</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PARTITIONRANGEDATUM"</literal></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionRangeDatum</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PARTITIONBY"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionBy</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"ADDDROPPARTITIONS"</literal></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAddDropPartitions</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PARTITIONFOREXPR"</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionForExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"AUDITFGAPOLICY"</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAuditFgaStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"REMOTEQUERY"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRemoteQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>    
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"EXEC_NODES"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readExecNodes</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PLACEHOLDERVAR"</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPlaceHolderVar</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PLACEHOLDERINFO"</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPlaceHolderInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"AUDIT"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAuditStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"CLEAN_AUDIT"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCleanAuditStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"badly formatted node string \"%.32s\"..."</literal></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>    <comment type="block">/* keep compiler quiet */</comment>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>return_value</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * readDatum
 *
 * Given a string representation of a constant, recreate the appropriate
 * Datum.  The string representation embeds length info, but not byValue,
 * so we must be told that.
 */</comment>
<function><type><name>Datum</name></type>
<name>readDatum</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>length</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>tokenLength</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

    <comment type="block">/*
     * read the actual length of the value
     */</comment>
    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tokenLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>atoui</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tokenLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* read the '[' */</comment>
    <if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'['</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected \"[\" to start datum, but got \"%s\"; length = %zu"</literal></expr></argument>,
             <argument><expr><ternary><condition><expr><name>token</name></expr> ?</condition><then> <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>token</name></expr> </then><else>: <expr><literal type="string">"[NULL]"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>typbyval</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <operator>(</operator><name>Size</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"byval datum but length = %zu"</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>res</name><operator>)</operator></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>Size</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tokenLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>length</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tokenLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tokenLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* read the ']' */</comment>
    <if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">']'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected \"]\" to end datum, but got \"%s\"; length = %zu"</literal></expr></argument>,
             <argument><expr><ternary><condition><expr><name>token</name></expr> ?</condition><then> <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>token</name></expr> </then><else>: <expr><literal type="string">"[NULL]"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<comment type="block">/*
 * scanDatum
 *
 * Recreate Datum from the text format understandable by the input function
 * of the specified data type.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>scanDatum</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>typInput</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>typioparam</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FmgrInfo</name></type>    <name>finfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FunctionCallInfoData</name></type> <name>fcinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>res</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>READ_TEMP_LOCALS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get input function for the type */</comment>
    <expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typInput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>typInput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>finfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Read the value */</comment>
    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The value can not be NULL, so we actually received empty string */</comment>
    <if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Invoke input function */</comment>
    <expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>finfo</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>fcinfo</name><operator>.</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fcinfo</name><operator>.</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fcinfo</name><operator>.</operator><name>arg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * readAttrNumberCols
 */</comment>
<function><type><name>AttrNumber</name> <modifier>*</modifier></type>
<name>readAttrNumberCols</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>tokenLength</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attr_vals</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>numCols</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>attr_vals</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numCols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tokenLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>attr_vals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>attr_vals</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * readOidCols
 */</comment>
<function><type><name>Oid</name> <modifier>*</modifier></type>
<name>readOidCols</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>tokenLength</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>oid_vals</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>numCols</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>oid_vals</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numCols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tokenLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>oid_vals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>oid_vals</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * readIntCols
 */</comment>
<function><type><name>int</name> <modifier>*</modifier></type>
<name>readIntCols</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>tokenLength</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>int_vals</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>numCols</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>int_vals</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numCols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tokenLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>int_vals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>int_vals</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * readBoolCols
 */</comment>
<function><type><name>bool</name> <modifier>*</modifier></type>
<name>readBoolCols</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>tokenLength</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>bool_vals</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>numCols</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>bool_vals</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numCols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tokenLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bool_vals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>strtobool</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>bool_vals</name></expr>;</return>
</block_content>}</block></function>
</unit>
