<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/commands/subscriptioncmds.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * subscriptioncmds.c
 *        subscription catalog manipulation functions
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *        subscriptioncmds.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaddress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_subscription.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_subscription_rel.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/subscriptioncmds.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicallauncher.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/origin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walreceiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/worker_internal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logical_statistic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_lsn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>g_tbase_subscription_extension</name> <init>= <expr><literal type="string">"tbase_subscription"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>g_tbase_subscription_relname</name> <init>= <expr><literal type="string">"tbase_subscription"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>g_tbase_subscription_parallel_relname</name> <init>= <expr><literal type="string">"tbase_subscription_parallel"</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>int32</name></type> <name>shardid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>  <modifier>*</modifier></type><name>pubname</name></decl>;</decl_stmt>
}</block></struct></type> <name>PubShard</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>fetch_table_list</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>wrconn</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>publications</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>fetch_shard_list</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>wrconn</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>publications</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>parse_tbase_subscription_options</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
                                 <parameter><decl><type><name>bool</name></type> <name>is_create_stmt</name></decl></parameter>,
                                 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>ignore_pk_conflict</name></decl></parameter>,
                                 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>manual_hot_date</name></decl></parameter>,
                                 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>temp_hot_date</name></decl></parameter>,
                                 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>temp_cold_date</name></decl></parameter>,
                                 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>parallel_number</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>copy_data</name></decl></parameter>,
								 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>slot_name</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>slot_name_given</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_tbase_subscription_ifexists</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>tbase_sub_rel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>check_subname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>tbase_subscription_parallelization</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type> <name>stmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>parallel_number</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>slot_name_given</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Common option parsing function for CREATE and ALTER SUBSCRIPTION commands.
 *
 * Since not all options can be specified in both commands, this function
 * will report an error on options if the target output pointer is NULL to
 * accommodate that.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_subscription_options</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>connect</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>enabled_given</name></decl></parameter>,
                           <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>enabled</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>create_slot</name></decl></parameter>,
                           <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>slot_name_given</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>slot_name</name></decl></parameter>,
                           <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>copy_data</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>synchronous_commit</name></decl></parameter>,
                           <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>refresh</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>connect_given</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>create_slot_given</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>copy_data_given</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>refresh_given</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If connect is specified, the others also need to be. */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>connect</name> <operator>||</operator> <operator>(</operator><name>enabled</name> <operator>&amp;&amp;</operator> <name>create_slot</name> <operator>&amp;&amp;</operator> <name>copy_data</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>connect</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>connect</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>enabled</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>enabled_given</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>enabled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>create_slot</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>create_slot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>slot_name</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>slot_name_given</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>slot_name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>copy_data</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>copy_data</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>synchronous_commit</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>synchronous_commit</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>refresh</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>refresh</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Parse options */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>options</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"connect"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>connect</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>connect_given</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>connect_given</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>connect</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"enabled"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>enabled</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>enabled_given</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><operator>*</operator><name>enabled_given</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>enabled</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"create_slot"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>create_slot</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>create_slot_given</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>create_slot_given</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>create_slot</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"slot_name"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>slot_name</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>slot_name_given</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><operator>*</operator><name>slot_name_given</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>slot_name</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Setting slot_name = NONE is treated as no slot name. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>slot_name</name></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>slot_name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"copy_data"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>copy_data</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>copy_data_given</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>copy_data_given</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>copy_data</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"synchronous_commit"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                 <name>synchronous_commit</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>synchronous_commit</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><operator>*</operator><name>synchronous_commit</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Test if the given value is valid for synchronous_commit GUC. */</comment>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><literal type="string">"synchronous_commit"</literal></expr></argument>, <argument><expr><operator>*</operator><name>synchronous_commit</name></expr></argument>,
                                     <argument><expr><name>PGC_BACKEND</name></expr></argument>, <argument><expr><name>PGC_S_TEST</name></expr></argument>, <argument><expr><name>GUC_ACTION_SET</name></expr></argument>,
                                     <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"refresh"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>refresh</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>refresh_given</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>refresh_given</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>refresh</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"ignore_pk_conflict"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"manual_hot_date"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"temp_hot_date"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"temp_cold_date"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"parallel_number"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* parse in parse_tbase_subscription_options */</comment>
        </block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized subscription parameter: %s"</literal></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * We've been explicitly asked to not connect, that requires some
     * additional processing.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>connect</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>connect</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Check for incompatible options from the user. */</comment>
        <if_stmt><if>if <condition>(<expr><name>enabled</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>enabled_given</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>enabled</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connect = false and enabled = true are mutually exclusive options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>create_slot</name> <operator>&amp;&amp;</operator> <name>create_slot_given</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>create_slot</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connect = false and create_slot = true are mutually exclusive options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>copy_data</name> <operator>&amp;&amp;</operator> <name>copy_data_given</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>copy_data</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connect = false and copy_data = true are mutually exclusive options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Change the defaults of other options. */</comment>
        <expr_stmt><expr><operator>*</operator><name>enabled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>create_slot</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>copy_data</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Do additional checking for disallowed combination when slot_name = NONE
     * was used.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>slot_name</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>slot_name_given</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>slot_name</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>enabled</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>enabled_given</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>enabled</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"slot_name = NONE and enabled = true are mutually exclusive options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>create_slot</name> <operator>&amp;&amp;</operator> <name>create_slot_given</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>create_slot</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"slot_name = NONE and create_slot = true are mutually exclusive options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>enabled</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>enabled_given</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>enabled</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"subscription with slot_name = NONE must also set enabled = false"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>create_slot</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>create_slot_given</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>create_slot</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"subscription with slot_name = NONE must also set create_slot = false"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Auxiliary function to return a text array out of a list of String nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>publicationListToArray</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>publist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>datums</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>memcxt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

    <comment type="block">/* Create memory context for temporary allocations. */</comment>
    <expr_stmt><expr><name>memcxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                   <argument><expr><literal type="string">"publicationListToArray to array"</literal></expr></argument>,
                                   <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
                                   <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
                                   <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>memcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>datums</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>text</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>publist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>publist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>pcell</name></decl>;</decl_stmt>

        <comment type="block">/* Check for duplicates. */</comment>
        <macro><name>foreach</name><argument_list>(<argument>pcell</argument>, <argument>publist</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>pname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>pcell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>pname</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>pname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"publication name \"%s\" used more than once"</literal></expr></argument>,
                                <argument><expr><name>pname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>

        <expr_stmt><expr><name><name>datums</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>datums</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>publist</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>memcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create new subscription.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
<decl_stmt><decl><type><name>ObjectAddress</name></type>
<name>CreateSubscription</name><argument_list>(<argument><expr><name>CreateSubscriptionStmt</name> <operator>*</operator><name>stmt</name></expr></argument>, <argument><expr><name>bool</name> <name>isTopLevel</name></expr></argument>, <argument><expr><name>bool</name> <name>force_to_disable</name></expr></argument>)</argument_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<name>ObjectAddress</name>
<name>CreateSubscription</name><argument_list>(<argument><expr><name>CreateSubscriptionStmt</name> <operator>*</operator><name>stmt</name></expr></argument>, <argument><expr><name>bool</name> <name>isTopLevel</name></expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>subid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>Natts_pg_subscription</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>Natts_pg_subscription</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>owner</name> <init>= <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>connect</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>enabled_given</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>enabled</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>copy_data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>synchronous_commit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>conninfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>slotname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>slotname_given</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>originname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>create_slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>publications</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Parse and check options.
     *
     * Connection and publication should not be specified here.
     */</comment>
    <expr_stmt><expr><call><name>parse_subscription_options</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>connect</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>enabled_given</name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name>enabled</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>create_slot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slotname_given</name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name>slotname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copy_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>synchronous_commit</name></expr></argument>,
                               <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Since creating a replication slot is not transactional, rolling back
     * the transaction leaves the created replication slot.  So we cannot run
     * CREATE SUBSCRIPTION inside a transaction block if creating a
     * replication slot.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>create_slot</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PreventTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"CREATE SUBSCRIPTION ... WITH (create_slot = true)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to create subscriptions"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>SubscriptionRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if name is used */</comment>
    <expr_stmt><expr><name>subid</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>SUBSCRIPTIONNAME</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>,
                            <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>subid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"subscription \"%s\" already exists"</literal></expr></argument>,
                        <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>slotname_given</name> <operator>&amp;&amp;</operator> <name>slotname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>slotname</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* The default for synchronous_commit of subscriptions is off. */</comment>
    <if_stmt><if>if <condition>(<expr><name>synchronous_commit</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>synchronous_commit</name> <operator>=</operator> <literal type="string">"off"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>conninfo</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>conninfo</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>publications</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>publication</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
    <comment type="block">/* add parallel info into conninfo */</comment>
    <if_stmt><if>if <condition>(<expr><name>conninfo</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>IsTbaseSubscription</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>stmt</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>StringInfoData</name></type> <name>conn_str</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conn_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conn_str</name></expr></argument>, 
            <argument><expr><literal type="string">"%s sub_parallel_number=%d sub_parallel_index=%d"</literal></expr></argument>,
            <argument><expr><name>conninfo</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>sub_parallel_number</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>sub_parallel_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>conninfo</name> <operator>=</operator> <name><name>conn_str</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>sub_parallel_number</name></name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>sub_parallel_index</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>sub_parallel_number</name></name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>sub_parallel_index</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>sub_parallel_number</name></name> <operator>&gt;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>sub_parallel_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>sub_parallel_number</name></name> <operator>&gt;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>sub_parallel_index</name></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Load the library providing us libpq calls. */</comment>
    <expr_stmt><expr><call><name>load_file</name><argument_list>(<argument><expr><literal type="string">"libpqwalreceiver"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check the connection info string. */</comment>
    <expr_stmt><expr><call><name>walrcv_check_conninfo</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Everything ok, form a new tuple. */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_subscription_subdbid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_subscription_subname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
        <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_subscription_subowner</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_subscription_subenabled</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>enabled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>force_to_disable</name> <operator>==</operator> <name>true</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_subscription_subenabled</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_subscription_subconninfo</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>conninfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_subscription_subconninfo</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
        <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>slotname</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_subscription_subslotname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
            <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>slotname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_subscription_subslotname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_subscription_subsynccommit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
        <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>synchronous_commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_subscription_subpublications</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
        <call><name>publicationListToArray</name><argument_list>(<argument><expr><name>publications</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Insert tuple into catalog. */</comment>
    <expr_stmt><expr><name>subid</name> <operator>=</operator> <call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>recordDependencyOnOwner</name><argument_list>(<argument><expr><name>SubscriptionRelationId</name></expr></argument>, <argument><expr><name>subid</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>originname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>originname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"pg_%u"</literal></expr></argument>, <argument><expr><name>subid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>replorigin_create</name><argument_list>(<argument><expr><name>originname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Connect to remote side to execute requested commands and fetch table
     * info.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>connect</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>lsn</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>err</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>wrconn</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tables</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>shards</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name>table_state</name></decl>;</decl_stmt>

        <comment type="block">/* Try to connect to the publisher. */</comment>
        <expr_stmt><expr><name>wrconn</name> <operator>=</operator> <call><name>walrcv_connect</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>wrconn</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not connect to the publisher: %s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>
            <comment type="block">/*
             * Set sync state based on if we were asked to do data copy or
             * not.
             */</comment>
            <expr_stmt><expr><name>table_state</name> <operator>=</operator> <ternary><condition><expr><name>copy_data</name></expr> ?</condition><then> <expr><name>SUBREL_STATE_INIT</name></expr> </then><else>: <expr><name>SUBREL_STATE_READY</name></expr></else></ternary></expr>;</expr_stmt>

            <comment type="block">/*
             * Get the table list from publisher and build local table status
             * info.
             */</comment>
            <expr_stmt><expr><name>tables</name> <operator>=</operator> <call><name>fetch_table_list</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><name>publications</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
            <expr_stmt><expr><name>shards</name> <operator>=</operator> <call><name>fetch_shard_list</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><name>publications</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tables</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rv</name> <init>= <expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Relation</name></type>    <name>relation</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
                <expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>shards</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>istbase</name></name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsSharded</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <continue>continue;</continue>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>istbase</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* only support shard table */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_locator_info</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
                        <name><name>relation</name><operator>-&gt;</operator><name>rd_locator_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>!=</operator> <name>LOCATOR_TYPE_SHARD</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TBase Subscripton currently only supports subscribing into the SHARD table, "</literal>
                                     <literal type="string">"but \"%s\" is not a SHARD table, skip it"</literal></expr></argument>, <argument><expr><call><name>RangeVarGetName</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <comment type="block">/* Check for supported relkind. */</comment>
                <expr_stmt><expr><call><name>CheckSubscriptionRelkind</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>SetSubscriptionRelState</name><argument_list>(<argument><expr><name>subid</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>table_state</name></expr></argument>,
                                        <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
                <comment type="block">/* add subscription / table mapping with publication */</comment>
                <expr_stmt><expr><call><name>subscription_add_table</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><name>subid</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>pubname</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
            <comment type="block">/*
             * Get the shard list from publisher and build local shard status
             * info.
             */</comment>
            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>shards</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PubShard</name>   <modifier>*</modifier></type><name>ps</name> <init>= <expr><operator>(</operator><name>PubShard</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>shardid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical replication target shard \"%d\" is invalid"</literal></expr></argument>,
                                    <argument><expr><name><name>ps</name><operator>-&gt;</operator><name>shardid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>subscription_add_shard</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><name>subid</name></expr></argument>, <argument><expr><name><name>ps</name><operator>-&gt;</operator><name>shardid</name></name></expr></argument>, <argument><expr><name><name>ps</name><operator>-&gt;</operator><name>pubname</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="block">/*
             * If requested, create permanent slot for the subscription. We
             * won't use the initial snapshot for anything, so no need to
             * export it.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>create_slot</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slotname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
                <comment type="block">/* send subscription's name and oid addition additionally */</comment>
				<if_stmt><if>if <condition>(<expr><name>shards</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>walrcv_create_slot</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><name>slotname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									   <argument><expr><name>CRS_NOEXPORT_SNAPSHOT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lsn</name></expr></argument>, <argument><expr><name>slotname</name></expr></argument>, <argument><expr><name>subid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>walrcv_create_slot</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><name>slotname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									   <argument><expr><name>CRS_NOEXPORT_SNAPSHOT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lsn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><call><name>walrcv_create_slot</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><name>slotname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                   <argument><expr><name>CRS_NOEXPORT_SNAPSHOT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"created replication slot \"%s\" on publisher"</literal></expr></argument>,
                                <argument><expr><name>slotname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>
            <comment type="block">/* Close the connection in case of failure. */</comment>
            <expr_stmt><expr><call><name>walrcv_disconnect</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* And we are done with the remote side. */</comment>
        <expr_stmt><expr><call><name>walrcv_disconnect</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tables were not subscribed, you will have to run "</literal>
                        <literal type="string">"ALTER SUBSCRIPTION ... REFRESH PUBLICATION to "</literal>
                        <literal type="string">"subscribe the tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>enabled</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ApplyLauncherWakeupAtCommit</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>myself</name></expr></argument>, <argument><expr><name>SubscriptionRelationId</name></expr></argument>, <argument><expr><name>subid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>InvokeObjectPostCreateHook</name><argument_list>(<argument><expr><name>SubscriptionRelationId</name></expr></argument>, <argument><expr><name>subid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>myself</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AlterSubscription_refresh</name><parameter_list>(<parameter><decl><type><name>Subscription</name> <modifier>*</modifier></type><name>sub</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>copy_data</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>pubrel_names</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subrel_states</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>subrel_local_oids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>pubrel_local_oids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>off</name></decl>;</decl_stmt>

    <comment type="block">/* Load the library providing us libpq calls. */</comment>
    <expr_stmt><expr><call><name>load_file</name><argument_list>(<argument><expr><literal type="string">"libpqwalreceiver"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Try to connect to the publisher. */</comment>
    <expr_stmt><expr><name>wrconn</name> <operator>=</operator> <call><name>walrcv_connect</name><argument_list>(<argument><expr><name><name>sub</name><operator>-&gt;</operator><name>conninfo</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>sub</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>wrconn</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not connect to the publisher: %s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Get the table list from publisher. */</comment>
    <expr_stmt><expr><name>pubrel_names</name> <operator>=</operator> <call><name>fetch_table_list</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><name><name>sub</name><operator>-&gt;</operator><name>publications</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We are done with the remote side, close connection. */</comment>
    <expr_stmt><expr><call><name>walrcv_disconnect</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shard_pubrel_names</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pubrel_names</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rv</name> <init>= <expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Relation</name></type>    <name>relation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"no local relation for remote relation %s"</literal></expr></argument>, <argument><expr><call><name>RangeVarGetName</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* only support shard table */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsSharded</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TBase Subscripton on COORDINATOR currently only supports subscribing into the SHARD table, "</literal>
                            <literal type="string">"but \"%s\" is not a SHARD table, skip it"</literal></expr></argument>, <argument><expr><call><name>RangeVarGetName</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>shard_pubrel_names</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>shard_pubrel_names</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><name>pubrel_names</name> <operator>=</operator> <name>shard_pubrel_names</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Get local table list. */</comment>
    <expr_stmt><expr><name>subrel_states</name> <operator>=</operator> <call><name>GetSubscriptionRelations</name><argument_list>(<argument><expr><name><name>sub</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Build qsorted array of local table oids for faster lookup. This can
     * potentially contain all tables in the database so speed of lookup is
     * important.
     */</comment>
    <expr_stmt><expr><name>subrel_local_oids</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>subrel_states</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>subrel_states</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SubscriptionRelState</name> <modifier>*</modifier></type><name>relstate</name> <init>= <expr><operator>(</operator><name>SubscriptionRelState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>subrel_local_oids</name><index>[<expr><name>off</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>relstate</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>subrel_local_oids</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>subrel_states</name></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>oid_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Walk over the remote tables and try to match them to locally known
     * tables. If the table is not known locally create a new state for it.
     *
     * Also builds array of local oids of remote tables for the next step.
     */</comment>
    <expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pubrel_local_oids</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>pubrel_names</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pubrel_names</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rv</name> <init>= <expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Check for supported relkind. */</comment>
        <expr_stmt><expr><call><name>CheckSubscriptionRelkind</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>pubrel_local_oids</name><index>[<expr><name>off</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>relid</name></expr></argument>, <argument><expr><name>subrel_local_oids</name></expr></argument>,
                     <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>subrel_states</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>oid_cmp</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>SetSubscriptionRelState</name><argument_list>(<argument><expr><name><name>sub</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>,
                                    <argument><expr><ternary><condition><expr><name>copy_data</name></expr> ?</condition><then> <expr><name>SUBREL_STATE_INIT</name></expr> </then><else>: <expr><name>SUBREL_STATE_READY</name></expr></else></ternary></expr></argument>,
                                    <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
            <comment type="block">/* add subscription / table mapping with publication */</comment>
            <expr_stmt><expr><call><name>subscription_add_table</name><argument_list>(<argument><expr><name><name>sub</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>sub</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>pubname</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s.%s\" added to subscription \"%s\""</literal></expr></argument>,
                            <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name><name>sub</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Next remove state for tables we should not care about anymore using the
     * data we collected above
     */</comment>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>pubrel_local_oids</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>pubrel_names</name></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>oid_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>off</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>subrel_states</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>off</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name> <init>= <expr><name><name>subrel_local_oids</name><index>[<expr><name>off</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>relid</name></expr></argument>, <argument><expr><name>pubrel_local_oids</name></expr></argument>,
                     <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>pubrel_names</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>oid_cmp</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>RemoveSubscriptionRel</name><argument_list>(<argument><expr><name><name>sub</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
            <comment type="block">/* remove subscription / table mapping with publication */</comment>
            <expr_stmt><expr><call><name>RemoveSubscriptionTable</name><argument_list>(<argument><expr><name><name>sub</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>logicalrep_worker_stop_at_commit</name><argument_list>(<argument><expr><name><name>sub</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s.%s\" removed from subscription \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name><name>sub</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Alter the existing subscription.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>AlterSubscription</name><parameter_list>(<parameter><decl><type><name>AlterSubscriptionStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>Natts_pg_subscription</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>replaces</name><index>[<expr><name>Natts_pg_subscription</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>Natts_pg_subscription</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>subid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>update_tuple</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Subscription</name> <modifier>*</modifier></type><name>sub</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>SubscriptionRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Fetch the existing tuple. */</comment>
    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCacheCopy2</name><argument_list>(<argument><expr><name>SUBSCRIPTIONNAME</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>,
                              <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"subscription \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* must be owner */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_subscription_ownercheck</name><argument_list>(<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_SUBSCRIPTION</name></expr></argument>,
                       <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>subid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sub</name> <operator>=</operator> <call><name>GetSubscription</name><argument_list>(<argument><expr><name>subid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Lock the subscription so nobody else can do anything with it. */</comment>
    <expr_stmt><expr><call><name>LockSharedObject</name><argument_list>(<argument><expr><name>SubscriptionRelationId</name></expr></argument>, <argument><expr><name>subid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Form a new tuple. */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>ALTER_SUBSCRIPTION_OPTIONS</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>slotname</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>        <name>slotname_given</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>synchronous_commit</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>parse_subscription_options</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                           <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slotname_given</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slotname</name></expr></argument>,
                                           <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>synchronous_commit</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>slotname_given</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>sub</name><operator>-&gt;</operator><name>enabled</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>slotname</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set slot_name = NONE for enabled subscription"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name>slotname</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_subscription_subslotname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
                            <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>slotname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_subscription_subslotname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    <expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_subscription_subslotname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>synchronous_commit</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_subscription_subsynccommit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
                        <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>synchronous_commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_subscription_subsynccommit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>update_tuple</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>ALTER_SUBSCRIPTION_ENABLED</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>bool</name></type>        <name>enabled</name></decl>,
                            <decl><type ref="prev"/><name>enabled_given</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>parse_subscription_options</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                           <argument><expr><operator>&amp;</operator><name>enabled_given</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>enabled</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                           <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>enabled_given</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sub</name><operator>-&gt;</operator><name>slotname</name></name> <operator>&amp;&amp;</operator> <name>enabled</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot enable subscription that does not have a slot name"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_subscription_subenabled</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
                    <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>enabled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_subscription_subenabled</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>enabled</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ApplyLauncherWakeupAtCommit</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>update_tuple</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>ALTER_SUBSCRIPTION_CONNECTION</name></expr>:</case>
            <comment type="block">/* Load the library providing us libpq calls. */</comment>
            <expr_stmt><expr><call><name>load_file</name><argument_list>(<argument><expr><literal type="string">"libpqwalreceiver"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Check the connection info string. */</comment>
            <expr_stmt><expr><call><name>walrcv_check_conninfo</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>conninfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_subscription_subconninfo</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
                <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>conninfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_subscription_subconninfo</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>update_tuple</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>ALTER_SUBSCRIPTION_PUBLICATION</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>bool</name></type>        <name>copy_data</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>        <name>refresh</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>parse_subscription_options</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                           <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copy_data</name></expr></argument>,
                                           <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>refresh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_subscription_subpublications</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
                    <call><name>publicationListToArray</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>publication</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_subscription_subpublications</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>update_tuple</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                <comment type="block">/* Refresh if user asked us to. */</comment>
                <if_stmt><if>if <condition>(<expr><name>refresh</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sub</name><operator>-&gt;</operator><name>enabled</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ALTER SUBSCRIPTION with refresh is not allowed for disabled subscriptions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER SUBSCRIPTION ... SET PUBLICATION ... WITH (refresh = false)."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="block">/* Make sure refresh sees the new list of publications. */</comment>
                    <expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>publications</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>publication</name></name></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>AlterSubscription_refresh</name><argument_list>(<argument><expr><name>sub</name></expr></argument>, <argument><expr><name>copy_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>ALTER_SUBSCRIPTION_REFRESH</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>bool</name></type>        <name>copy_data</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sub</name><operator>-&gt;</operator><name>enabled</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ALTER SUBSCRIPTION ... REFRESH is not allowed for disabled subscriptions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>parse_subscription_options</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                           <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copy_data</name></expr></argument>,
                                           <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>AlterSubscription_refresh</name><argument_list>(<argument><expr><name>sub</name></expr></argument>, <argument><expr><name>copy_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <break>break;</break>
            </block_content>}</block>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized ALTER SUBSCRIPTION kind %d"</literal></expr></argument>,
                 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <comment type="block">/* Update the catalog if needed. */</comment>
    <if_stmt><if>if <condition>(<expr><name>update_tuple</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>,
                                <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>myself</name></expr></argument>, <argument><expr><name>SubscriptionRelationId</name></expr></argument>, <argument><expr><name>subid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>SubscriptionRelationId</name></expr></argument>, <argument><expr><name>subid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>myself</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Drop a subscription
 */</comment>
<function><type><name>void</name></type>
<name>DropSubscription</name><parameter_list>(<parameter><decl><type><name>DropSubscriptionStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>subid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>datum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>subname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>conninfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>slotname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subworkers</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>originname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>err</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RepOriginId</name></type> <name>originid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>wrconn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>cmd</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Lock pg_subscription with AccessExclusiveLock to ensure that the
     * launcher doesn't restart new worker during dropping the subscription
     */</comment>
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>SubscriptionRelationId</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>SUBSCRIPTIONNAME</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>,
                          <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"subscription \"%s\" does not exist"</literal></expr></argument>,
                            <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"subscription \"%s\" does not exist, skipping"</literal></expr></argument>,
                            <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>subid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* must be owner */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_subscription_ownercheck</name><argument_list>(<argument><expr><name>subid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_SUBSCRIPTION</name></expr></argument>,
                       <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* DROP hook for the subscription being removed */</comment>
    <expr_stmt><expr><call><name>InvokeObjectDropHook</name><argument_list>(<argument><expr><name>SubscriptionRelationId</name></expr></argument>, <argument><expr><name>subid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Lock the subscription so nobody else can do anything with it (including
     * the replication workers).
     */</comment>
    <expr_stmt><expr><call><name>LockSharedObject</name><argument_list>(<argument><expr><name>SubscriptionRelationId</name></expr></argument>, <argument><expr><name>subid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get subname */</comment>
    <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>SUBSCRIPTIONOID</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>,
                            <argument><expr><name>Anum_pg_subscription_subname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>subname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>DatumGetName</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get conninfo */</comment>
    <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>SUBSCRIPTIONOID</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>,
                            <argument><expr><name>Anum_pg_subscription_subconninfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conninfo</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get slotname */</comment>
    <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>SUBSCRIPTIONOID</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>,
                            <argument><expr><name>Anum_pg_subscription_subslotname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>slotname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>DatumGetName</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>slotname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Since dropping a replication slot is not transactional, the replication
     * slot stays dropped even if the transaction rolls back.  So we cannot
     * run DROP SUBSCRIPTION inside a transaction block if dropping the
     * replication slot.
     *
     * XXX The command name should really be something like "DROP SUBSCRIPTION
     * of a subscription that is associated with a replication slot", but we
     * don't have the proper facilities for that.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>slotname</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PreventTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"DROP SUBSCRIPTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


    <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>myself</name></expr></argument>, <argument><expr><name>SubscriptionRelationId</name></expr></argument>, <argument><expr><name>subid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EventTriggerSQLDropAddObject</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Remove the tuple from catalog. */</comment>
    <expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we are dropping the replication slot, stop all the subscription
     * workers immediately, so that the slot becomes accessible.  Otherwise
     * just schedule the stopping for the end of the transaction.
     *
     * New workers won't be started because we hold an exclusive lock on the
     * subscription till the end of the transaction.
     */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>LogicalRepWorkerLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>subworkers</name> <operator>=</operator> <call><name>logicalrep_workers_find</name><argument_list>(<argument><expr><name>subid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>LogicalRepWorkerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>subworkers</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>LogicalRepWorker</name> <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>LogicalRepWorker</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>slotname</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>logicalrep_worker_stop</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>subid</name></name></expr></argument>, <argument><expr><name><name>w</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>logicalrep_worker_stop_at_commit</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>subid</name></name></expr></argument>, <argument><expr><name><name>w</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>subworkers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clean up dependencies */</comment>
    <expr_stmt><expr><call><name>deleteSharedDependencyRecordsFor</name><argument_list>(<argument><expr><name>SubscriptionRelationId</name></expr></argument>, <argument><expr><name>subid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Remove any associated relation synchronization states. */</comment>
    <expr_stmt><expr><call><name>RemoveSubscriptionRel</name><argument_list>(<argument><expr><name>subid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
    <comment type="block">/* Remove any associated shards/tables */</comment>
    <expr_stmt><expr><call><name>RemoveSubscriptionShard</name><argument_list>(<argument><expr><name>subid</name></expr></argument>, <argument><expr><name>InvalidShardID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RemoveSubscriptionTable</name><argument_list>(<argument><expr><name>subid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DirectFunctionCall1Coll</name><argument_list>(<argument><expr><name>tbase_remove_subtable_stat</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                            <argument><expr><call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name>subid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DirectFunctionCall1Coll</name><argument_list>(<argument><expr><name>tbase_remove_sub_stat</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                            <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Remove the origin tracking if exists. */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>originname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>originname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"pg_%u"</literal></expr></argument>, <argument><expr><name>subid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>originid</name> <operator>=</operator> <call><name>replorigin_by_name</name><argument_list>(<argument><expr><name>originname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>originid</name> <operator>!=</operator> <name>InvalidRepOriginId</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>replorigin_drop</name><argument_list>(<argument><expr><name>originid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If there is no slot associated with the subscription, we can finish
     * here.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>slotname</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Otherwise drop the replication slot at the publisher node using the
     * replication connection.
     */</comment>
    <expr_stmt><expr><call><name>load_file</name><argument_list>(<argument><expr><literal type="string">"libpqwalreceiver"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"DROP_REPLICATION_SLOT %s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>slotname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>wrconn</name> <operator>=</operator> <call><name>walrcv_connect</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>wrconn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not connect to publisher when attempting to "</literal>
                        <literal type="string">"drop the replication slot \"%s\""</literal></expr></argument>, <argument><expr><name>slotname</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The error was: %s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER SUBSCRIPTION ... SET (slot_name = NONE) "</literal>
                         <literal type="string">"to disassociate the subscription from the slot."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <decl_stmt><decl><type><name>WalRcvExecResult</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walrcv_exec</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>WALRCV_OK_COMMAND</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not drop the replication slot \"%s\" on publisher"</literal></expr></argument>,
                            <argument><expr><name>slotname</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The error was: %s"</literal></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>err</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"dropped replication slot \"%s\" on publisher"</literal></expr></argument>,
                            <argument><expr><name>slotname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name>walrcv_clear_result</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <comment type="block">/* Close the connection in case of failure */</comment>
        <expr_stmt><expr><call><name>walrcv_disconnect</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>walrcv_disconnect</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Internal workhorse for changing a subscription owner
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AlterSubscriptionOwner_internal</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Form_pg_subscription</name></type> <name>form</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_subscription</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>form</name><operator>-&gt;</operator><name>subowner</name></name> <operator>==</operator> <name>newOwnerId</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_subscription_ownercheck</name><argument_list>(<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_SUBSCRIPTION</name></expr></argument>,
                       <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>form</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* New owner must be a superuser */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser_arg</name><argument_list>(<argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied to change owner of subscription \"%s\""</literal></expr></argument>,
                        <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>form</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The owner of a subscription must be a superuser."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>form</name><operator>-&gt;</operator><name>subowner</name></name> <operator>=</operator> <name>newOwnerId</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Update owner dependency reference */</comment>
    <expr_stmt><expr><call><name>changeDependencyOnOwner</name><argument_list>(<argument><expr><name>SubscriptionRelationId</name></expr></argument>,
                            <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>SubscriptionRelationId</name></expr></argument>,
                              <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Change subscription owner -- by name
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>AlterSubscriptionOwner</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>subid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>SubscriptionRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCacheCopy2</name><argument_list>(<argument><expr><name>SUBSCRIPTIONNAME</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>,
                              <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"subscription \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>subid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>AlterSubscriptionOwner_internal</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>SubscriptionRelationId</name></expr></argument>, <argument><expr><name>subid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Change subscription owner -- by OID
 */</comment>
<function><type><name>void</name></type>
<name>AlterSubscriptionOwner_oid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>subid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>SubscriptionRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>SUBSCRIPTIONOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>subid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"subscription with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>subid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>AlterSubscriptionOwner_internal</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the list of tables which belong to specified publications on the
 * publisher connection.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>fetch_table_list</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>wrconn</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>publications</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>WalRcvExecResult</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>cmd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name><name>tableRow</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>TEXTOID</name></expr>, <expr><name>TEXTOID</name></expr>, <expr><name>TEXTOID</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>first</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tablelist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>publications</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"SELECT DISTINCT t.schemaname, t.tablename, t.pubname \n"</literal>
                     <literal type="string">"  FROM pg_catalog.pg_publication_tables t\n"</literal>
                     <literal type="string">" WHERE t.pubname IN ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>publications</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>pubname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>pubname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walrcv_exec</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>tableRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>WALRCV_OK_TUPLES</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not receive list of replicated tables from the publisher: %s"</literal></expr></argument>,
                        <argument><expr><name><name>res</name><operator>-&gt;</operator><name>err</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Process tables. */</comment>
    <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>tupledesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>tuplestore</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>pubname</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rv</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pubname</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rv</name><operator>-&gt;</operator><name>pubname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>pubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tablelist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tablelist</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>walrcv_clear_result</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>tablelist</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
<comment type="block">/*
 * Get the list of shards which belong to specified publications on the
 * publisher connection.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>fetch_shard_list</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>wrconn</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>publications</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>WalRcvExecResult</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>cmd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name><name>shardrow</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>INT4OID</name></expr>, <expr><name>TEXTOID</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>first</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>shardlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>publications</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"SELECT DISTINCT t.prshardid, p.pubname \n"</literal>
                     <literal type="string">" FROM pg_catalog.pg_publication_shard t, pg_catalog.pg_publication p \n"</literal>
                     <literal type="string">" WHERE t.prpubid = p.oid and p.pubname IN ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>publications</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>pubname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>pubname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walrcv_exec</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>shardrow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>WALRCV_OK_TUPLES</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not receive list of shards from the publisher: %s"</literal></expr></argument>,
                        <argument><expr><name><name>res</name><operator>-&gt;</operator><name>err</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Process tables. */</comment>
    <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>tupledesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>tuplestore</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int32</name></type>       <name>shardid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>pubname</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PubShard</name>   <modifier>*</modifier></type><name>ps</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>shardid</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pubname</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>ps</name> <operator>=</operator> <operator>(</operator><name>PubShard</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PubShard</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ps</name><operator>-&gt;</operator><name>shardid</name></name> <operator>=</operator> <name>shardid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ps</name><operator>-&gt;</operator><name>pubname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>pubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>shardlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>shardlist</name></expr></argument>, <argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>walrcv_clear_result</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>shardlist</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
<comment type="block">/*
 * Common option parsing function for CREATE and ALTER TBASE SUBSCRIPTION commands.
 *
 * Since not all options can be specified in both commands, this function
 * will report an error on options if the target output pointer is NULL to
 * accommodate that.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_tbase_subscription_options</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
                                 <parameter><decl><type><name>bool</name></type> <name>is_create_stmt</name></decl></parameter>,
                                 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>ignore_pk_conflict</name></decl></parameter>,
                                 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>manual_hot_date</name></decl></parameter>,
                                 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>temp_hot_date</name></decl></parameter>,
                                 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>temp_cold_date</name></decl></parameter>,
                                 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>parallel_number</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>copy_data</name></decl></parameter>,
								 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>slot_name</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>slot_name_given</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>copy_data_given</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>slot_name_given</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* This operation can only be performed on Coordinator */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IS_PGXC_COORDINATOR</name> <operator>||</operator> <operator>!</operator><call><name>IsConnFromApp</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"This operation can only be performed on Coordinator."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>copy_data</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>copy_data</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Parse options */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>options</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"ignore_pk_conflict"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ignore_pk_conflict</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>ignore_pk_conflict</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"manual_hot_date"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>manual_hot_date</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>manual_hot_date</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Test if the given value is valid for manual_hot_date GUC. */</comment>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><literal type="string">"manual_hot_date"</literal></expr></argument>, <argument><expr><operator>*</operator><name>manual_hot_date</name></expr></argument>,
                                     <argument><expr><name>PGC_BACKEND</name></expr></argument>, <argument><expr><name>PGC_S_TEST</name></expr></argument>, <argument><expr><name>GUC_ACTION_SET</name></expr></argument>,
                                     <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"temp_hot_date"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>temp_hot_date</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>temp_hot_date</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Test if the given value is valid for temp_hot_date GUC. */</comment>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><literal type="string">"temp_hot_date"</literal></expr></argument>, <argument><expr><operator>*</operator><name>temp_hot_date</name></expr></argument>,
                                     <argument><expr><name>PGC_BACKEND</name></expr></argument>, <argument><expr><name>PGC_S_TEST</name></expr></argument>, <argument><expr><name>GUC_ACTION_SET</name></expr></argument>,
                                     <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"temp_cold_date"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>temp_cold_date</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>temp_cold_date</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Test if the given value is valid for temp_cold_date GUC. */</comment>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><literal type="string">"temp_cold_date"</literal></expr></argument>, <argument><expr><operator>*</operator><name>temp_cold_date</name></expr></argument>,
                                     <argument><expr><name>PGC_BACKEND</name></expr></argument>, <argument><expr><name>PGC_S_TEST</name></expr></argument>, <argument><expr><name>GUC_ACTION_SET</name></expr></argument>,
                                     <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"parallel_number"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>parallel_number</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>parallel_number</name> <operator>=</operator> <call><name>defGetInt32</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>parallel_number</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid value %d of \"parallel_number\""</literal></expr></argument>, <argument><expr><operator>*</operator><name>parallel_number</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"slot_name"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
		    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>slot_name_given</name></expr>)</condition><block type="pseudo"><block_content>
		        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
		                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		    <expr_stmt><expr><operator>*</operator><name>slot_name_given</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		    <expr_stmt><expr><operator>*</operator><name>slot_name</name>       <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		    <comment type="block">/* Setting slot_name = NONE is treated as no slot name. */</comment>
		    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>slot_name</name></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		        <expr_stmt><expr><operator>*</operator><name>slot_name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"copy_data"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>is_create_stmt</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>copy_data_given</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>copy_data_given</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>copy_data</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>copy_data</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The \"copy_data\" option can not be specified in ALTER TBASE SUBSCRIPTION."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * check if tbase_subscription extension is installed
 */</comment>
<function><type><name>void</name></type> <name>check_tbase_subscription_extension</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type> <name>extOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>extOid</name> <operator>=</operator> <call><name>get_extension_oid</name><argument_list>(<argument><expr><name>g_tbase_subscription_extension</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>extOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"This operation is not allowed until the extension \"%s\" is installed."</literal></expr></argument>,
                        <argument><expr><name>g_tbase_subscription_extension</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* check if already exists a same name */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>check_tbase_subscription_ifexists</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>tbase_sub_rel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>check_subname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapScanDesc</name></type>    <name>scan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>       <name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>        <name>desc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>bool</name></type>            <name>exists</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>tbase_sub_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>tbase_sub_rel</name></expr></argument>, <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Name</name></type> <name>subname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>isnull</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>subname</name> <operator>=</operator> <call><name>DatumGetName</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_tbase_subscription_sub_name</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>isnull</name> <operator>&amp;&amp;</operator> <name>subname</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>==</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>check_subname</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>subname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>exists</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>        
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>exists</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transform tbase subscription into parallel sub-subscriptions list
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>tbase_subscription_parallelization</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type> <name>stmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>parallel_number</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>slot_name_given</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type> <name>lstmt</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parallel_number</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>parallel_number</name> <operator>&gt;=</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>parallel_number</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type> <name>stmt_parallel</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>lstmt</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>lstmt</name></expr></argument>, <argument><expr><name>stmt_parallel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>stmt_parallel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>CreateSubscriptionStmt</name> <modifier>*</modifier></type> <name>stmt_create</name> <init>= <expr><operator>(</operator><name>CreateSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>stmt_parallel</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>new_subname</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>new_slot_name</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="block">/* rename subname a parallel one */</comment>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>new_subname</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%s_%d_%d"</literal></expr></argument>, <argument><expr><name><name>stmt_create</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><name>parallel_number</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>stmt_create</name><operator>-&gt;</operator><name>subname</name></name> <operator>=</operator> <name>new_subname</name></expr>;</expr_stmt>

				<comment type="block">/* construct slotname for a parallel one */</comment>
				<if_stmt><if>if <condition>(<expr><name>slot_name_given</name></expr>)</condition>
				<block>{<block_content>
				    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type> 	<name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt_create-&gt;options</argument>)</argument_list></macro>
				    <block>{<block_content>
				        <decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type> <name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"slot_name"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				        <block>{<block_content>
				            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>slot_name_pre</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>slot_name_pre</name></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>new_slot_name</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>slot_name_pre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				            <else>else<block type="pseudo"><block_content>
				                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>new_slot_name</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%s_%d_%d"</literal></expr></argument>, <argument><expr><name>slot_name_pre</name></expr></argument>, <argument><expr><name>parallel_number</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				            <expr_stmt><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>makeString</name><argument_list>(<argument><expr><name>new_slot_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				        </block_content>}</block></if></if_stmt>
				    </block_content>}</block>
				</block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * Only the first sub-subscription of all parallel sub-subscriptions is allowed
                 * to perform the copy_data operation. Other sub-subscriptions must wait until the
                 * first sub-subscription completes the copy_data before starting the incremental
                 * subscription, so only the first sub-subscription's copy_data is retained,
                 * while the copy_data option of other subsubscriptions will be emptied here.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type>     <name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name></type>        <name>copy_data_given</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

                    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt_create-&gt;options</argument>)</argument_list></macro>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type> <name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"copy_data"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>bool</name></type> <name>bool_value</name> <init>= <expr><call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><name>bool_value</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                            <expr_stmt><expr><name>copy_data_given</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block>

                    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>copy_data_given</name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type> <name>copy_data</name> <init>= <expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"copy_data"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name><name>stmt_create</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>stmt_create</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>copy_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <do>do
                <block>{<block_content>
                    <expr_stmt><expr><name><name>stmt_create</name><operator>-&gt;</operator><name>sub_parallel_number</name></name> <operator>=</operator> <name>parallel_number</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stmt_create</name><operator>-&gt;</operator><name>sub_parallel_index</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                </block_content>}</block> while <condition>(<expr><literal type="number">0</literal></expr>)</condition>;</do>
                <break>break;</break>
            </block_content>}</block>
            <case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AlterSubscriptionStmt</name> <modifier>*</modifier></type> <name>stmt_alter</name> <init>= <expr><operator>(</operator><name>AlterSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>stmt_parallel</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>new_subname</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>new_slot_name</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="block">/* rename subname a parallel one */</comment>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>new_subname</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%s_%d_%d"</literal></expr></argument>, <argument><expr><name><name>stmt_alter</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><name>parallel_number</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>stmt_alter</name><operator>-&gt;</operator><name>subname</name></name> <operator>=</operator> <name>new_subname</name></expr>;</expr_stmt>

				<comment type="block">/*construct a new parallel slot_name */</comment>
				<if_stmt><if>if <condition>(<expr><name>slot_name_given</name></expr>)</condition>
				<block>{<block_content>
				    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type> 	<name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt_alter-&gt;options</argument>)</argument_list></macro>
				    <block>{<block_content>
				        <decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type> <name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"slot_name"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				        <block>{<block_content>
				            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>slot_name_pre</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>slot_name_pre</name></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>new_slot_name</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>slot_name_pre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				            <else>else<block type="pseudo"><block_content>
				                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>new_slot_name</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%s_%d_%d"</literal></expr></argument>, <argument><expr><name>slot_name_pre</name></expr></argument>, <argument><expr><name>parallel_number</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				            <expr_stmt><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>makeString</name><argument_list>(<argument><expr><name>new_slot_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				        </block_content>}</block></if></if_stmt>
				    </block_content>}</block>
				</block_content>}</block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>
            <case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>DropSubscriptionStmt</name> <modifier>*</modifier></type> <name>stmt_drop</name> <init>= <expr><operator>(</operator><name>DropSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>stmt_parallel</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>new_subname</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="block">/* rename subname a parallel one */</comment>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>new_subname</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%s_%d_%d"</literal></expr></argument>, <argument><expr><name><name>stmt_drop</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><name>parallel_number</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>stmt_drop</name><operator>-&gt;</operator><name>subname</name></name> <operator>=</operator> <name>new_subname</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
            <default>default:</default>
            <block>{<block_content>
                <break>break;</break>
            </block_content>}</block>
        </block_content>}</block></switch>
    </block_content>}</block></for>

    <return>return <expr><name>lstmt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create new Tbase subscription.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>CreateTbaseSubscription</name><parameter_list>(<parameter><decl><type><name>CreateSubscriptionStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>ignore_pk_conflict</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>manual_hot_date</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>temp_hot_date</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>temp_cold_date</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>parallel_number</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>copy_data</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>slot_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>slot_name_given</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>Relation</name></type> <name>tbase_sub_rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>    <name>tbase_sub_parent_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type> <name>stmt_create_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name> <init>= <expr><name>InvalidObjectAddress</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* check if tbase_subscription is installed */</comment>
    <expr_stmt><expr><call><name>check_tbase_subscription_extension</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* parse options */</comment>
    <expr_stmt><expr><call><name>parse_tbase_subscription_options</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>ignore_pk_conflict</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>manual_hot_date</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>temp_hot_date</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>temp_cold_date</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>parallel_number</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>copy_data</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>slot_name</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>slot_name_given</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check if parallel_number is not greater than max_logical_replication_workers parameter */</comment>
	<if_stmt><if>if <condition>(<expr><name>parallel_number</name> <operator>&gt;</operator> <name>max_logical_replication_workers</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIGURATION_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"options parallel_number %d is greater than max_logical_replication_workers %d"</literal></expr></argument>,
                     <argument><expr><name>parallel_number</name></expr></argument>, <argument><expr><name>max_logical_replication_workers</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to increase max_logical_replication_workers or decrease parallel_number."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetLocalTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check if already exists a same name */</comment>
    <expr_stmt><expr><name>tbase_sub_rel</name> <operator>=</operator> <call><name>relation_openrv</name><argument_list>(<argument><expr><call><name>makeRangeVar</name><argument_list>(<argument><expr><literal type="string">"public"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>g_tbase_subscription_relname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>check_tbase_subscription_ifexists</name><argument_list>(<argument><expr><name>tbase_sub_rel</name></expr></argument>,  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>tbase_sub_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tbase subscription \"%s\" already exists"</literal></expr></argument>,
                        <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* create an item in tbase_subscription */</comment>
    <do>do
    <block>{<block_content>
        <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tup_desc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>Natts_tbase_subscription</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>Natts_tbase_subscription</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>tup_desc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>tbase_sub_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_tbase_subscription_sub_name</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_tbase_subscription_sub_ignore_pk_conflict</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>ignore_pk_conflict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>manual_hot_date</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_tbase_subscription_sub_manual_hot_date</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>manual_hot_date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_tbase_subscription_sub_manual_hot_date</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>temp_hot_date</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_tbase_subscription_sub_temp_hot_date</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>temp_hot_date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_tbase_subscription_sub_temp_hot_date</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>temp_cold_date</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_tbase_subscription_sub_temp_cold_date</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>temp_cold_date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_tbase_subscription_sub_temp_cold_date</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_tbase_subscription_sub_parallel_number</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>parallel_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If there are some parallel tbase-sub-subscriptions, 
         * other tbase-sub-subscriptions can be activated only after 
         * the first tbase-sub-subscription has completed the data COPY.
         * And other tbase-sub-subscriptions can only be activated by 
         * the first tbase-sub-subscription.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>parallel_number</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>copy_data</name> <operator>==</operator> <name>true</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_tbase_subscription_sub_is_all_actived</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_tbase_subscription_sub_is_all_actived</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tup_desc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tbase_sub_parent_oid</name> <operator>=</operator> <call><name>simple_heap_insert</name><argument_list>(<argument><expr><name>tbase_sub_rel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><literal type="number">0</literal></expr>)</condition>;</do>

    <comment type="block">/* transform to CreateSubscriptionStmt list, and rename each item */</comment>
	<expr_stmt><expr><name>stmt_create_list</name> <operator>=</operator> <call><name>tbase_subscription_parallelization</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>stmt</name></expr></argument>, <argument><expr><name>parallel_number</name></expr></argument>, <argument><expr><name>slot_name_given</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* call CreateSubscription for each item */</comment>
    <do>do
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type> <name>tbase_sub_parallel_rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>        
        
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type> <name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>tbase_sub_parallel_rel</name> <operator>=</operator> <call><name>relation_openrv</name><argument_list>(<argument><expr><call><name>makeRangeVar</name><argument_list>(<argument><expr><literal type="string">"public"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>g_tbase_subscription_parallel_relname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt_create_list</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>pg_sub_tup_addr</name> <init>= <expr><name>InvalidObjectAddress</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>CreateSubscriptionStmt</name> <modifier>*</modifier></type> <name>stmt_create</name> <init>= <expr><operator>(</operator><name>CreateSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tup_desc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>Natts_tbase_subscription_parallel</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>Natts_tbase_subscription_parallel</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>bool</name></type>        <name>force_to_disable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>parallel_number</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>copy_data</name> <operator>==</operator> <name>true</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * Here we only activate the first tbase-sub-subscription. 
                     * When the first tbase-sub-subscription completes the data COPY, 
                     * it will activate the other tbase-sub-subscriptions.
                     */</comment>
                    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_tbase_subscription_parallel_sub_active_state</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>force_to_disable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_tbase_subscription_parallel_sub_active_state</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_tbase_subscription_parallel_sub_active_state</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_tbase_subscription_parallel_sub_active_lsn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>LSNGetDatum</name><argument_list>(<argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* create each sub-subscription by CREATE SUBSCRIPTION */</comment>
            <expr_stmt><expr><name>pg_sub_tup_addr</name> <operator>=</operator> <call><name>CreateSubscription</name><argument_list>(<argument><expr><name>stmt_create</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><name>force_to_disable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* record each sub-subscription into tbase_subscription_parallel */</comment>
            <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_tbase_subscription_parallel_sub_parent</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tbase_sub_parent_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_tbase_subscription_parallel_sub_child</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>pg_sub_tup_addr</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_tbase_subscription_parallel_sub_index</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>tup_desc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>tbase_sub_parallel_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tup_desc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>simple_heap_insert</name><argument_list>(<argument><expr><name>tbase_sub_parallel_rel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;=</operator> <name>parallel_number</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>==</operator> <name><name>stmt_create</name><operator>-&gt;</operator><name>sub_parallel_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>i</name> <operator>&lt;=</operator> <name>parallel_number</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>==</operator> <name><name>stmt_create</name><operator>-&gt;</operator><name>sub_parallel_index</name></name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt> 
        </block_content>}</block>

        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>tbase_sub_parallel_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><literal type="number">0</literal></expr>)</condition>;</do>

    <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>myself</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>tbase_sub_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tbase_sub_parent_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>tbase_sub_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>myself</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Alter the existing Tbase subscription.
 */</comment>
<function><type><name>void</name></type> <name>AlterTbaseSubscription</name><parameter_list>(<parameter><decl><type><name>AlterSubscriptionStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>parallel_number</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_all_actived</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>slot_name_given</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>slot_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>check_tbase_subscription_extension</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* first check TBase subscprition exists and get parallel_number */</comment>
    <do>do
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>        <name>tbase_sub_rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapScanDesc</name></type>    <name>scan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>       <name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleDesc</name></type>        <name>desc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>            <name>exists</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetLocalTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>tbase_sub_rel</name> <operator>=</operator> <call><name>relation_openrv</name><argument_list>(<argument><expr><call><name>makeRangeVar</name><argument_list>(<argument><expr><literal type="string">"public"</literal></expr></argument>, 
                                        <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>g_tbase_subscription_relname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, 
                                        <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>tbase_sub_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>tbase_sub_rel</name></expr></argument>, <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>exists</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Name</name></type> <name>subname</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>subname</name> <operator>=</operator> <call><name>DatumGetName</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_tbase_subscription_sub_name</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>isnull</name> <operator>&amp;&amp;</operator> <name>subname</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>==</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>subname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>exists</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>parallel_number</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_tbase_subscription_sub_parallel_number</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>is_all_actived</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_tbase_subscription_sub_is_all_actived</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>        
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>tbase_sub_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>exists</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"TBase subscription \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block> while<condition>(<expr><literal type="number">0</literal></expr>)</condition>;</do>

    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>is_all_actived</name> <operator>&amp;&amp;</operator> <name>parallel_number</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
        <name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>ALTER_SUBSCRIPTION_REFRESH</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"TBase Subscription '%s' is not allowed to refresh until all its sub-subscriptions have been activated"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
	<comment type="block">/* check if slot_name is given*/</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>ALTER_SUBSCRIPTION_OPTIONS</name></expr>)</condition>
	<block>{<block_content>
	    <expr_stmt><expr><call><name>parse_tbase_subscription_options</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
	            <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slot_name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slot_name_given</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <do>do
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>    <modifier>*</modifier></type> <name>stmt_list</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name><modifier>*</modifier></type> <name>lc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>stmt_list</name> <operator>=</operator> <call><name>tbase_subscription_parallelization</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>stmt</name></expr></argument>, <argument><expr><name>parallel_number</name></expr></argument>, <argument><expr><name>slot_name_given</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt_list</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>AlterSubscriptionStmt</name> <modifier>*</modifier></type> <name>stmt</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ObjectAddress</name></type>           <name>address</name></decl>;</decl_stmt>
            
            <expr_stmt><expr><name>stmt</name>    <operator>=</operator> <operator>(</operator><name>AlterSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterSubscription</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* do commandCollected inside */</comment>
            <expr_stmt><expr><call><name>EventTriggerCollectSimpleCommand</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>InvalidObjectAddress</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block> while <condition>(<expr><literal type="number">0</literal></expr>)</condition>;</do>

    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Drop a Tbase subscription
 */</comment>
<function><type><name>void</name></type>
<name>DropTbaseSubscription</name><parameter_list>(<parameter><decl><type><name>DropSubscriptionStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>    <name>sub_parent_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>parallel_number</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><call><name>check_tbase_subscription_extension</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetLocalTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check if subscription exists */</comment>
    <do>do
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>         <name>tbase_sub_rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapScanDesc</name></type>    <name>scan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>       <name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleDesc</name></type>        <name>desc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>bool</name></type>            <name>exists</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>tbase_sub_rel</name> <operator>=</operator> <call><name>relation_openrv</name><argument_list>(<argument><expr><call><name>makeRangeVar</name><argument_list>(<argument><expr><literal type="string">"public"</literal></expr></argument>, 
                                        <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>g_tbase_subscription_relname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, 
                                        <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>tbase_sub_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>tbase_sub_rel</name></expr></argument>, <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Name</name></type> <name>subname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>isnull</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>subname</name> <operator>=</operator> <call><name>DatumGetName</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_tbase_subscription_sub_name</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>isnull</name> <operator>&amp;&amp;</operator> <name>subname</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>==</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>subname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>exists</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>sub_parent_oid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>parallel_number</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_tbase_subscription_sub_parallel_number</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>simple_heap_delete</name><argument_list>(<argument><expr><name>tbase_sub_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>        
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>tbase_sub_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>exists</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tbase subscription \"%s\" does not exist"</literal></expr></argument>,
                                <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tbase subscription \"%s\" does not exist, skipping"</literal></expr></argument>,
                                <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parallel_number</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>sub_parent_oid</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>parallel_number</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>sub_parent_oid</name> <operator>!=</operator> <name>InvalidOid</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block> while <condition>(<expr><literal type="number">0</literal></expr>)</condition>;</do>

    <comment type="block">/* scan tbase_subscription_parallel, and delete related tuple by sub_parent */</comment>
    <do>do
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>         <name>tbase_sub_parallel_rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapScanDesc</name></type>    <name>scan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>       <name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleDesc</name></type>        <name>desc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int32</name></type>             <name>i_assert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>tbase_sub_parallel_rel</name> <operator>=</operator> <call><name>relation_openrv</name><argument_list>(<argument><expr><call><name>makeRangeVar</name><argument_list>(<argument><expr><literal type="string">"public"</literal></expr></argument>,
                                                    <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>g_tbase_subscription_parallel_relname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
                                                    <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>tbase_sub_parallel_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>tbase_sub_parallel_rel</name></expr></argument>, <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>     <name>sub_parent</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>isnull</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>sub_parent</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_tbase_subscription_parallel_sub_parent</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>isnull</name> <operator>&amp;&amp;</operator> <name>sub_parent</name> <operator>==</operator> <name>sub_parent_oid</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>i_assert</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i_assert</name> <operator>&lt;=</operator> <name>parallel_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>simple_heap_delete</name><argument_list>(<argument><expr><name>tbase_sub_parallel_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>tbase_sub_parallel_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i_assert</name> <operator>==</operator> <name>parallel_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>i_assert</name> <operator>==</operator> <name>parallel_number</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block> while <condition>(<expr><literal type="number">0</literal></expr>)</condition>;</do>

    <comment type="block">/* parallelization drop stmt, and drop each parallel sub-subscritions by DropSubscription  */</comment>
    <do>do
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type> <name>stmt_drop_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type> <name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type> <name>i_assert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>stmt_drop_list</name> <operator>=</operator> <call><name>tbase_subscription_parallelization</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>stmt</name></expr></argument>, <argument><expr><name>parallel_number</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt_drop_list</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>DropSubscriptionStmt</name> <modifier>*</modifier></type> <name>stmt_drop</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>stmt_drop</name> <operator>=</operator> <operator>(</operator><name>DropSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
			<expr_stmt><expr><call><name>DropSubscription</name><argument_list>(<argument><expr><name>stmt_drop</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>i_assert</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i_assert</name> <operator>&lt;=</operator> <name>parallel_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>i_assert</name> <operator>&lt;=</operator> <name>parallel_number</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block> while <condition>(<expr><literal type="number">0</literal></expr>)</condition>;</do>

    <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>IsTbaseSubscription</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type> <name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>CreateSubscriptionStmt</name> <modifier>*</modifier></type> <name>stmt_create</name> <init>= <expr><operator>(</operator><name>CreateSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>
            <return>return <expr><name><name>stmt_create</name><operator>-&gt;</operator><name>istbase</name></name></expr>;</return>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>AlterSubscriptionStmt</name> <modifier>*</modifier></type> <name>stmt_alter</name> <init>= <expr><operator>(</operator><name>AlterSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>
            <return>return <expr><name><name>stmt_alter</name><operator>-&gt;</operator><name>istbase</name></name></expr>;</return>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>DropSubscriptionStmt</name> <modifier>*</modifier></type> <name>stmt_drop</name> <init>= <expr><operator>(</operator><name>DropSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>
            <return>return <expr><name><name>stmt_drop</name><operator>-&gt;</operator><name>istbase</name></name></expr>;</return>
            <break>break;</break>
        </block_content>}</block>
        <default>default:</default>
        <block>{<block_content>
            <return>return <expr><name>false</name></expr>;</return>
            <break>break;</break>
        </block_content>}</block>
    </block_content>}</block></switch>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
