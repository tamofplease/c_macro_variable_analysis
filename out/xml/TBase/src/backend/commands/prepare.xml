<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/commands/prepare.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * prepare.c
 *      Prepareable SQL statements via PREPARE, EXECUTE and DEALLOCATE
 *
 * This module also implements storage of prepared statements that are
 * accessed via the extended FE/BE query protocol.
 *
 *
 * Copyright (c) 2002-2017, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *      src/backend/commands/prepare.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/createas.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/nodemgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner_private.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * The hash table in which prepared queries are stored. This is
 * per-backend: query plans are not shared between backends.
 * The keys for this hash table are the arguments to PREPARE and EXECUTE
 * (statement names); the entries are PreparedStatement structs.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>prepared_queries</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<comment type="block">/*
 * The hash table where Datanode prepared statements are stored.
 * The keys are statement names referenced from cached RemoteQuery nodes; the
 * entries are DatanodeStatement structs
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>datanode_queries</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitQueryHashTable</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParamListInfo</name></type> <name>EvaluateParams</name><parameter_list>(<parameter><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
               <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>build_regtype_array</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>param_types</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_params</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Implements the 'PREPARE' utility statement.
 */</comment>
<function><type><name>void</name></type>
<name>PrepareQuery</name><parameter_list>(<parameter><decl><type><name>PrepareStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
             <parameter><decl><type><name>int</name></type> <name>stmt_location</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stmt_len</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>rawstmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>argtypes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>query_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Disallow empty-string statement name (conflicts with protocol-level
     * unnamed statement).
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PSTATEMENT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid statement name: must not be empty"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Need to wrap the contained statement in a RawStmt node to pass it to
     * parse analysis.
     *
     * Because parse analysis scribbles on the raw querytree, we must make a
     * copy to ensure we don't modify the passed-in tree.  FIXME someday.
     */</comment>
    <expr_stmt><expr><name>rawstmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rawstmt</name><operator>-&gt;</operator><name>stmt</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rawstmt</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name>stmt_location</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rawstmt</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name>stmt_len</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Create the CachedPlanSource before we do parse analysis, since it needs
     * to see the unmodified raw parse tree.
     */</comment>
    <expr_stmt><expr><name>plansource</name> <operator>=</operator> <call><name>CreateCachedPlan</name><argument_list>(<argument><expr><name>rawstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
                                  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                  <argument><expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Transform list of TypeNames to array of type OIDs */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>argtypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>nargs</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

        <comment type="block">/*
         * typenameTypeId wants a ParseState to carry the source query string.
         * Is it worth refactoring its API to avoid this?
         */</comment>
        <expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>argtypes</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>stmt-&gt;argtypes</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>tn</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>toid</name> <init>= <expr><call><name>typenameTypeId</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>tn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>toid</name></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Analyze the statement using these parameter types (any parameters
     * passed in from above us will not be visible to it), allowing
     * information about unknown parameters to be deduced from context.
     */</comment>
    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>parse_analyze_varparams</name><argument_list>(<argument><expr><name>rawstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>argtypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check that all parameter types were determined.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>argtype</name> <init>= <expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>argtype</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator> <name>argtype</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDETERMINATE_DATATYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine data type of parameter $%d"</literal></expr></argument>,
                            <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * grammar only allows OptimizableStmt, so this check should be redundant
     */</comment>
    <switch>switch <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>CMD_SELECT</name></expr>:</case>
        <case>case <expr><name>CMD_INSERT</name></expr>:</case>
        <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
        <case>case <expr><name>CMD_DELETE</name></expr>:</case>
            <comment type="block">/* OK */</comment>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PSTATEMENT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"utility statements cannot be prepared"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/* Rewrite the query. The result could be 0, 1, or many queries. */</comment>
    <expr_stmt><expr><name>query_list</name> <operator>=</operator> <call><name>QueryRewrite</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Finish filling in the CachedPlanSource */</comment>
    <expr_stmt><expr><call><name>CompleteCachedPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>,
                       <argument><expr><name>query_list</name></expr></argument>,
                       <argument><expr><name>NULL</name></expr></argument>,
                       <argument><expr><name>argtypes</name></expr></argument>,
                       <argument><expr><name>nargs</name></expr></argument>,
                       <argument><expr><name>NULL</name></expr></argument>,
                       <argument><expr><name>NULL</name></expr></argument>,
                       <argument><expr><name>CURSOR_OPT_PARALLEL_OK</name></expr></argument>,    <comment type="block">/* allow parallel mode */</comment>
                       <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* fixed result */</comment>

    <comment type="block">/*
     * Save the results.
     */</comment>
    <expr_stmt><expr><call><name>StorePreparedStatement</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                           <argument><expr><name>plansource</name></expr></argument>,
                           <argument><expr><name>true</name></expr></argument>,
						   <argument><expr><name>false</name></expr></argument>,
						   <argument><expr><literal type="char">'N'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecuteQuery --- implement the 'EXECUTE' utility statement.
 *
 * This code also supports CREATE TABLE ... AS EXECUTE.  That case is
 * indicated by passing a non-null intoClause.  The DestReceiver is already
 * set up correctly for CREATE TABLE AS, but we still have to make a few
 * other adjustments here.
 *
 * Note: this is one of very few places in the code that needs to deal with
 * two query strings at once.  The passed-in queryString is that of the
 * EXECUTE, which we might need for error reporting while processing the
 * parameter expressions.  The query_string that we copy from the plan
 * source is that of the original PREPARE.
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteQuery</name><parameter_list>(<parameter><decl><type><name>ExecuteStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>intoClause</name></decl></parameter>,
             <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
             <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>cplan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>plan_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EState</name>       <modifier>*</modifier></type><name>estate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Portal</name></type>        <name>portal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>query_string</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>eflags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>count</name></decl>;</decl_stmt>

    <comment type="block">/* Look it up in the hash table */</comment>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Shouldn't find a non-fixed-result cached plan */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>fixed_result</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"EXECUTE does not support variable-result cached plans"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Evaluate parameters, if any */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>num_params</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Need an EState to evaluate parameters; must not delete it till end
         * of query, in case parameters are pass-by-reference.  Note that the
         * passed-in "params" could possibly be referenced in the parameter
         * expressions.
         */</comment>
        <expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name> <operator>=</operator> <name>params</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>EvaluateParams</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>params</name></name></expr></argument>,
                                 <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Create a new portal to run the query in */</comment>
    <expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>CreateNewPortal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Don't display the portal in pg_cursors, it is for internal use only */</comment>
    <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>visible</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* Copy the plan's saved query string into the portal's memory */</comment>
    <expr_stmt><expr><name>query_string</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><call><name>PortalGetHeapMemory</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Replan if needed, and increment plan refcount for portal */</comment>
    <expr_stmt><expr><name>cplan</name> <operator>=</operator> <call><name>GetCachedPlan</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>plansource</name></name></expr></argument>, <argument><expr><name>paramLI</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>plan_list</name> <operator>=</operator> <name><name>cplan</name><operator>-&gt;</operator><name>stmt_list</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * For CREATE TABLE ... AS EXECUTE, we must verify that the prepared
     * statement is one that produces tuples.  Currently we insist that it be
     * a plain old SELECT.  In future we might consider supporting other
     * things such as INSERT ... RETURNING, but there are a couple of issues
     * to be settled first, notably how WITH NO DATA should be handled in such
     * a case (do we really want to suppress execution?) and how to pass down
     * the OID-determining eflags (PortalStart won't handle them in such a
     * case, and for that matter it's not clear the executor will either).
     *
     * For CREATE TABLE ... AS EXECUTE, we also have to ensure that the proper
     * eflags and fetch count are passed to PortalStart/PortalRun.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>intoClause</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>plan_list</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"prepared statement is not a SELECT"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>pstmt</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>plan_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"prepared statement is not a SELECT"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Set appropriate eflags */</comment>
        <expr_stmt><expr><name>eflags</name> <operator>=</operator> <call><name>GetIntoRelEFlags</name><argument_list>(<argument><expr><name>intoClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* And tell PortalRun whether to run to completion or not */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>intoClause</name><operator>-&gt;</operator><name>skipData</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>count</name> <operator>=</operator> <name>FETCH_ALL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Plain old EXECUTE */</comment>
        <expr_stmt><expr><name>eflags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <name>FETCH_ALL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PortalDefineQuery</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
                      <argument><expr><name>NULL</name></expr></argument>,
                      <argument><expr><name>query_string</name></expr></argument>,
                      <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>commandTag</name></name></expr></argument>,
                      <argument><expr><name>plan_list</name></expr></argument>,
                      <argument><expr><name>cplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Run the portal as appropriate.
     */</comment>
    <expr_stmt><expr><call><name>PortalStart</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>paramLI</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>, <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>PortalRun</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PortalDrop</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>estate</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* No need to pfree other memory, MemoryContext will be reset */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * EvaluateParams: evaluate a list of parameters.
 *
 * pstmt: statement we are getting parameters for.
 * params: list of given parameter expressions (raw parser output!)
 * queryString: source text for error messages.
 * estate: executor state to use.
 *
 * Returns a filled-in ParamListInfo -- this can later be passed to
 * CreateQueryDesc(), which allows the executor to make use of the parameters
 * during query execution.
 */</comment>
<function><type><specifier>static</specifier> <name>ParamListInfo</name></type>
<name>EvaluateParams</name><parameter_list>(<parameter><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
               <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>param_types</name> <init>= <expr><name><name>pstmt</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>param_types</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_params</name> <init>= <expr><name><name>pstmt</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>num_params</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nparams</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>exprstates</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>nparams</name> <operator>!=</operator> <name>num_params</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong number of parameters for prepared statement \"%s\""</literal></expr></argument>,
                        <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected %d parameters but got %d."</literal></expr></argument>,
                           <argument><expr><name>num_params</name></expr></argument>, <argument><expr><name>nparams</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Quick exit if no parameters */</comment>
    <if_stmt><if>if <condition>(<expr><name>num_params</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We have to run parse analysis for the expressions.  Since the parser is
     * not cool about scribbling on its input, copy first.
     */</comment>
    <expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>params</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>expected_type_id</name> <init>= <expr><name><name>param_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>given_type_id</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>EXPR_KIND_EXECUTE_PARAMETER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>given_type_id</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>given_type_id</name></expr></argument>,
                                     <argument><expr><name>expected_type_id</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                                     <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
                                     <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
                                     <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter $%d of type %s cannot be coerced to the expected type %s"</literal></expr></argument>,
                            <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                            <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>given_type_id</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>expected_type_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You will need to rewrite or cast the expression."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Take care of collations in the finished expression. */</comment>
        <expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Prepare the expressions for execution */</comment>
    <expr_stmt><expr><name>exprstates</name> <operator>=</operator> <call><name>ExecPrepareExprList</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>paramLI</name> <operator>=</operator> <operator>(</operator><name>ParamListInfo</name><operator>)</operator>
        <call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ParamListInfoData</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call> <operator>+</operator>
               <name>num_params</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParamExternData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* we have static list of params, so no hooks needed */</comment>
    <expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>paramFetch</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>paramFetchArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>parserSetup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>parserSetupArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>numParams</name></name> <operator>=</operator> <name>num_params</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>paramMask</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>exprstates</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><name><name>paramLI</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name> <operator>=</operator> <name><name>param_types</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>pflags</name></name> <operator>=</operator> <name>PARAM_FLAG_CONST</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name>n</name></expr></argument>,
                                               <argument><expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>,
                                               <argument><expr><operator>&amp;</operator><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>paramLI</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Initialize query hash table upon first use.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitQueryHashTable</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASHCTL</name></type>        <name>hash_ctl</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <name>NAMEDATALEN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PreparedStatement</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <expr_stmt><expr><name>prepared_queries</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Prepared Queries"</literal></expr></argument>,
                                   <argument><expr><literal type="number">32</literal></expr></argument>,
                                   <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
                                   <argument><expr><name>HASH_ELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <name>NAMEDATALEN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DatanodeStatement</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>NumDataNodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

        <expr_stmt><expr><name>datanode_queries</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Datanode Queries"</literal></expr></argument>,
                                       <argument><expr><literal type="number">64</literal></expr></argument>,
                                       <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
                                       <argument><expr><name>HASH_ELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Rebuild query hash table.
 */</comment>
<function><type><name>void</name></type>
<name>RebuildDatanodeQueryHashTable</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>seq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DatanodeStatement</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DatanodeStatement</name> <modifier>*</modifier></type><name>entry_tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>               <name>original_entry_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>        <modifier>*</modifier></type><name>datanode_queries_tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IS_PGXC_COORDINATOR</name> <operator>||</operator> <operator>!</operator><name>datanode_queries</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <name>NAMEDATALEN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DatanodeStatement</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>NumDataNodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>original_entry_size</name> <operator>=</operator> <call><name>hash_get_entry_size</name><argument_list>(<argument><expr><name>datanode_queries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* node number not changed, no need to rebuild */</comment>
	<if_stmt><if>if <condition>(<expr><name>original_entry_size</name> <operator>==</operator> <name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return ;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>datanode_queries_tmp</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Datanode Queries"</literal></expr></argument>,
	                               <argument><expr><literal type="number">64</literal></expr></argument>,
	                               <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
	                               <argument><expr><name>HASH_ELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* walk over cache */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seq</name></expr></argument>, <argument><expr><name>datanode_queries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Now we can copy the hash table entry */</comment>
		<expr_stmt><expr><name>entry_tmp</name> <operator>=</operator> <operator>(</operator><name>DatanodeStatement</name>  <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>datanode_queries_tmp</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>stmt_name</name></name></expr></argument>,
		                                               <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>entry_tmp</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>original_entry_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>datanode_queries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>datanode_queries</name> <operator>=</operator> <name>datanode_queries_tmp</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<comment type="block">/*
 * Assign the statement name for all the RemoteQueries in the plan tree, so
 * they use Datanode statements
 */</comment>
<function><type><name>int</name></type>
<name>SetRemoteStatementName</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_params</name></decl></parameter>,
                        <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>param_types</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* If no plan simply return */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>plan</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Leave if no parameters */</comment>
    <if_stmt><if>if <condition>(<expr><name>num_params</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name>param_types</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>remotequery</name> <init>= <expr><operator>(</operator><name>RemoteQuery</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DatanodeStatement</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>exists</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

        <comment type="block">/* Nothing to do if parameters are already set for this query */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>remotequery</name><operator>-&gt;</operator><name>rq_num_params</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>stmt_name</name></expr>)</condition>
        <block>{<block_content>
                <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>stmt_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/*
                 * Append modifier. If resulting string is going to be truncated,
                 * truncate better the base string, otherwise we may enter endless
                 * loop
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name></type> <name><name>modifier</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>modifier</name></expr></argument>, <argument><expr><literal type="string">"__%d"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/*
                     * if position NAMEDATALEN - strlen(modifier) - 1 is beyond the
                     * base string this is effectively noop, otherwise it truncates
                     * the base string
                     */</comment>
                    <expr_stmt><expr><name><name>name</name><index>[<expr><name>NAMEDATALEN</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>modifier</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>modifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>datanode_queries</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* If it already exists, that means this plan has just been revalidated. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>exists</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>DatanodeStatement</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>datanode_queries</name></expr></argument>,
                                                  <argument><expr><name>name</name></expr></argument>,
                                                  <argument><expr><name>HASH_ENTER</name></expr></argument>,
                                                  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>number_of_nodes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>remotequery</name><operator>-&gt;</operator><name>statement</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>remotequery</name><operator>-&gt;</operator><name>statement</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Passing parameters in PREPARE statement is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>remotequery</name><operator>-&gt;</operator><name>rq_num_params</name></name> <operator>=</operator> <name>num_params</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>remotequery</name><operator>-&gt;</operator><name>rq_param_types</name></name> <operator>=</operator> <name>param_types</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>ModifyTable</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ModifyTable</name>    <modifier>*</modifier></type><name>mt_plan</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator><name>plan</name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* For ModifyTable plan recurse into each of the plans underneath */</comment>
        <decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>mt_plan-&gt;plans</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>SetRemoteStatementName</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>num_params</name></expr></argument>,
                                        <argument><expr><name>param_types</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>innerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>SetRemoteStatementName</name><argument_list>(<argument><expr><call><name>innerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>num_params</name></expr></argument>,
                                    <argument><expr><name>param_types</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>SetRemoteStatementName</name><argument_list>(<argument><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>num_params</name></expr></argument>,
                                    <argument><expr><name>param_types</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Store all the data pertaining to a query in the hash table using
 * the specified key.  The passed CachedPlanSource should be "unsaved"
 * in case we get an error here; we'll save it once we've created the hash
 * table entry.
 */</comment>
<function><type><name>void</name></type>
<name>StorePreparedStatement</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl></parameter>,
                       <parameter><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl></parameter>,
                       <parameter><decl><type><name>bool</name></type> <name>from_sql</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>use_resowner</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name>need_rewrite</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>cur_ts</name> <init>= <expr><call><name>GetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize the hash table, if necessary */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>prepared_queries</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InitQueryHashTable</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Add entry to hash table */</comment>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>PreparedStatement</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>prepared_queries</name></expr></argument>,
											  <argument><expr><name>stmt_name</name></expr></argument>,
											  <argument><expr><name>HASH_ENTER</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Shouldn't get a duplicate entry */</comment>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>need_rewrite</name> <operator>==</operator> <literal type="char">'Y'</literal> <operator>&amp;&amp;</operator>
			<name><name>plansource</name><operator>-&gt;</operator><name>commandTag</name></name> <operator>==</operator> <name><name>entry</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>commandTag</name></name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name> <operator>=</operator> <name><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>plansource</name><operator>-&gt;</operator><name>commandTag</name></name> <operator>==</operator> <name><name>entry</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>commandTag</name></name> <operator>&amp;&amp;</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_PSTATEMENT</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"prepared statement \"%s\" already exists, and plansource is not the same."</literal></expr></argument>,
					<argument><expr><name>stmt_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">" \"%s\" already exists in prepared_queries, skip it."</literal></expr></argument>, <argument><expr><name>stmt_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return ;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Fill in the hash table entry */</comment>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>plansource</name></name> <operator>=</operator> <name>plansource</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>from_sql</name></name> <operator>=</operator> <name>from_sql</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>prepare_time</name></name> <operator>=</operator> <name>cur_ts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>use_resowner</name></name> <operator>=</operator> <name>use_resowner</name></expr>;</expr_stmt>

	<comment type="block">/* Now it's safe to move the CachedPlanSource to permanent memory */</comment>
	<expr_stmt><expr><call><name>SaveCachedPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>	
	<if_stmt><if>if <condition>(<expr><name>use_resowner</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ResourceOwnerEnlargePreparedStmts</name><argument_list>(<argument><expr><name>CurTransactionResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResourceOwnerRememberPreparedStmt</name><argument_list>(<argument><expr><name>CurTransactionResourceOwner</name></expr></argument>,
				<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>stmt_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>		
</block_content>}</block></function>

<comment type="block">/*
 * Lookup an existing query in the hash table. If the query does not
 * actually exist, throw ereport(ERROR) or return NULL per second parameter.
 *
 * Note: this does not force the referenced plancache entry to be valid,
 * since not all callers care.
 */</comment>
<function><type><name>PreparedStatement</name> <modifier>*</modifier></type>
<name>FetchPreparedStatement</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>throwError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If the hash table hasn't been initialized, it can't be storing
     * anything, therefore it couldn't possibly store our plan.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>prepared_queries</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>PreparedStatement</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>prepared_queries</name></expr></argument>,
                                                  <argument><expr><name>stmt_name</name></expr></argument>,
                                                  <argument><expr><name>HASH_FIND</name></expr></argument>,
                                                  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>entry</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name> <operator>&amp;&amp;</operator> <name>throwError</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_PSTATEMENT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"prepared statement \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name>stmt_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a prepared statement, determine the result tupledesc it will
 * produce.  Returns NULL if the execution will not return tuples.
 *
 * Note: the result is created or copied into current memory context.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>FetchPreparedStatementResultDesc</name><parameter_list>(<parameter><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * Since we don't allow prepared statements' result tupdescs to change,
     * there's no need to worry about revalidating the cached plan here.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>fixed_result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>resultDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>resultDesc</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Given a prepared statement that returns tuples, extract the query
 * targetlist.  Returns NIL if the statement doesn't have a determinable
 * targetlist.
 *
 * Note: this is pretty ugly, but since it's only used in corner cases like
 * Describe Statement on an EXECUTE command, we don't worry too much about
 * efficiency.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>FetchPreparedStatementTargetList</name><parameter_list>(<parameter><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>

    <comment type="block">/* Get the plan's primary targetlist */</comment>
    <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>CachedPlanGetTargetList</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>plansource</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Copy into caller's context in case plan gets invalidated */</comment>
    <return>return <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Implements the 'DEALLOCATE' utility statement: deletes the
 * specified plan from storage.
 */</comment>
<function><type><name>void</name></type>
<name>DeallocateQuery</name><parameter_list>(<parameter><decl><type><name>DeallocateStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DropPreparedStatement</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DropAllPreparedStatements</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Internal version of DEALLOCATE
 *
 * If showError is false, dropping a nonexistent statement is a no-op.
 */</comment>
<function><type><name>void</name></type>
<name>DropPreparedStatement</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <comment type="block">/* Find the query's hash table entry; raise error if wanted */</comment>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>showError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
	    <comment type="block">/* if a process SharedQueueRelease in DropCachedPlan, this SharedQueue
	     * Can be created by another process, and SharedQueueDisconnectConsumer
	     * will change the SharedQueue of another process's status,
	     * so let SharedQueueDisconnectConsumer be in front of DropCachedPlan */</comment>
        <expr_stmt><expr><call><name>SharedQueueDisconnectConsumer</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>stmt_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Release the plancache entry */</comment>
        <expr_stmt><expr><call><name>DropCachedPlan</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>plansource</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Now we can remove the hash table entry */</comment>
        <expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>prepared_queries</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>stmt_name</name></name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <expr_stmt><expr><call><name>DropDatanodeStatement</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>stmt_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>use_resowner</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ResourceOwnerForgetPreparedStmt</name><argument_list>(<argument><expr><name>CurTransactionResourceOwner</name></expr></argument>,
                    <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>stmt_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>distributed_query_analyze</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>DropQueryAnalyzeInfo</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Drop all cached statements.
 */</comment>
<function><type><name>void</name></type>
<name>DropAllPreparedStatements</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>seq</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <comment type="block">/* nothing cached */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>prepared_queries</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* walk over cache */</comment>
    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seq</name></expr></argument>, <argument><expr><name>prepared_queries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Release the plancache entry */</comment>
        <expr_stmt><expr><call><name>DropCachedPlan</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>plansource</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Now we can remove the hash table entry */</comment>
        <expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>prepared_queries</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>stmt_name</name></name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>use_resowner</name></name> <operator>&amp;&amp;</operator> <name>CurTransactionResourceOwner</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>use_resowner</name></name></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>ResourceOwnerForgetPreparedStmt</name><argument_list>(<argument><expr><name>CurTransactionResourceOwner</name></expr></argument>,
                    <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>stmt_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>        
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Implements the 'EXPLAIN EXECUTE' utility statement.
 *
 * "into" is NULL unless we are doing EXPLAIN CREATE TABLE AS EXECUTE,
 * in which case executing the query should result in creating that table.
 *
 * Note: the passed-in queryString is that of the EXPLAIN EXECUTE,
 * not the original PREPARE; we get the latter string from the plancache.
 */</comment>
<function><type><name>void</name></type>
<name>ExplainExecuteQuery</name><parameter_list>(<parameter><decl><type><name>ExecuteStmt</name> <modifier>*</modifier></type><name>execstmt</name></decl></parameter>, <parameter><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
                    <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>cplan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>plan_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EState</name>       <modifier>*</modifier></type><name>estate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>instr_time</name></type>    <name>planstart</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>instr_time</name></type>    <name>planduration</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>planstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Look it up in the hash table */</comment>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name><name>execstmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Shouldn't find a non-fixed-result cached plan */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>fixed_result</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"EXPLAIN EXECUTE does not support variable-result cached plans"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>query_string</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name></expr>;</expr_stmt>

    <comment type="block">/* Evaluate parameters, if any */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>num_params</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Need an EState to evaluate parameters; must not delete it till end
         * of query, in case parameters are pass-by-reference.  Note that the
         * passed-in "params" could possibly be referenced in the parameter
         * expressions.
         */</comment>
        <expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name> <operator>=</operator> <name>params</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>EvaluateParams</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>execstmt</name><operator>-&gt;</operator><name>params</name></name></expr></argument>,
                                 <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Replan if needed, and acquire a transient refcount */</comment>
    <expr_stmt><expr><name>cplan</name> <operator>=</operator> <call><name>GetCachedPlan</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>plansource</name></name></expr></argument>, <argument><expr><name>paramLI</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>planduration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>planduration</name></expr></argument>, <argument><expr><name>planstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>plan_list</name> <operator>=</operator> <name><name>cplan</name><operator>-&gt;</operator><name>stmt_list</name></name></expr>;</expr_stmt>

    <comment type="block">/* Explain each query */</comment>
    <macro><name>foreach</name><argument_list>(<argument>p</argument>, <argument>plan_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ExplainOnePlan</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>into</name></expr></argument>, <argument><expr><name>es</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>paramLI</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name>planduration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ExplainOneUtility</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>into</name></expr></argument>, <argument><expr><name>es</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>,
                              <argument><expr><name>paramLI</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* No need for CommandCounterIncrement, as ExplainOnePlan did it */</comment>

        <comment type="block">/* Separate plans with an appropriate separator */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ExplainSeparatePlans</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><name>estate</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>ReleaseCachedPlan</name><argument_list>(<argument><expr><name>cplan</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This set returning function reads all the prepared statements and
 * returns a set of (name, statement, prepare_time, param_types, from_sql).
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_prepared_statement</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
    <if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal> \
                        <literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* need to build tuplestore in query context */</comment>
    <expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * build tupdesc for result tuples. This must match the definition of the
     * pg_prepared_statements view in system_views.sql
     */</comment>
    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>,
                       <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"statement"</literal></expr></argument>,
                       <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"prepare_time"</literal></expr></argument>,
                       <argument><expr><name>TIMESTAMPTZOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"parameter_types"</literal></expr></argument>,
                       <argument><expr><name>REGTYPEARRAYOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"from_sql"</literal></expr></argument>,
                       <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We put all the tuples into a tuplestore in one scan of the hashtable.
     * This avoids any issue of the hashtable possibly changing between calls.
     */</comment>
    <expr_stmt><expr><name>tupstore</name> <operator>=</operator>
        <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize_Random</name></expr></argument>,
                              <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* generate junk in short-term context */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* hash table might be uninitialized */</comment>
    <if_stmt><if>if <condition>(<expr><name>prepared_queries</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>prep_stmt</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>prepared_queries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>prep_stmt</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>prep_stmt</name><operator>-&gt;</operator><name>stmt_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>prep_stmt</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>prep_stmt</name><operator>-&gt;</operator><name>prepare_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>build_regtype_array</name><argument_list>(<argument><expr><name><name>prep_stmt</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>param_types</name></name></expr></argument>,
                                            <argument><expr><name><name>prep_stmt</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>num_params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>prep_stmt</name><operator>-&gt;</operator><name>from_sql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* clean up and return the tuplestore */</comment>
    <expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This utility function takes a C array of Oids, and returns a Datum
 * pointing to a one-dimensional Postgres array of regtypes. An empty
 * array is returned as a zero-element array, not NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>build_regtype_array</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>param_types</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>tmp_ary</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tmp_ary</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_params</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_params</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>tmp_ary</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>param_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* XXX: this hardcodes assumptions about the regtype type */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>tmp_ary</name></expr></argument>, <argument><expr><name>num_params</name></expr></argument>, <argument><expr><name>REGTYPEOID</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<function><type><name>DatanodeStatement</name> <modifier>*</modifier></type>
<name>FetchDatanodeStatement</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>throwError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DatanodeStatement</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If the hash table hasn't been initialized, it can't be storing
     * anything, therefore it couldn't possibly store our plan.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>datanode_queries</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>DatanodeStatement</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>datanode_queries</name></expr></argument>, <argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>entry</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Report error if entry is not found */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name> <operator>&amp;&amp;</operator> <name>throwError</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_PSTATEMENT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"datanode statement \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name>stmt_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Drop Datanode statement and close it on nodes if active
 */</comment>
<function><type><name>void</name></type>
<name>DropDatanodeStatement</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DatanodeStatement</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>FetchDatanodeStatement</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodelist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* make a List of integers from node numbers */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>entry</name><operator>-&gt;</operator><name>number_of_nodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name>nodelist</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>dns_node_indices</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>number_of_nodes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ExecCloseRemoteStatement</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>nodelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>datanode_queries</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>stmt_name</name></name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Return true if there is at least one active Datanode statement, so acquired
 * Datanode connections should not be released
 */</comment>
<function><type><name>bool</name></type>
<name>HaveActiveDatanodeStatements</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>seq</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DatanodeStatement</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <comment type="block">/* nothing cached */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>datanode_queries</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* walk over cache */</comment>
    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seq</name></expr></argument>, <argument><expr><name>datanode_queries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Stop walking and return true */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>number_of_nodes</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>hash_seq_term</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <comment type="block">/* nothing found */</comment>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Mark Datanode statement as active on specified node
 * Return true if statement has already been active on the node and can be used
 * Returns false if statement has not been active on the node and should be
 * prepared on the node
 */</comment>
<function><type><name>bool</name></type>
<name>ActivateDatanodeStatementOnNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodeidx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DatanodeStatement</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* find the statement in cache */</comment>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>FetchDatanodeStatement</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* see if statement already active on the node */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>entry</name><operator>-&gt;</operator><name>number_of_nodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>dns_node_indices</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>nodeidx</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

    <comment type="block">/* statement is not active on the specified node append item to the list */</comment>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>dns_node_indices</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>number_of_nodes</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>nodeidx</name></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Mark datanode statement as inactive on specified node
 */</comment>
<function><type><name>void</name></type>
<name>InactivateDatanodeStatementOnNode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nodeidx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>seq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DatanodeStatement</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<comment type="block">/* nothing cached */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>datanode_queries</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* walk over cache */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seq</name></expr></argument>, <argument><expr><name>datanode_queries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* see if statement already active on the node */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>entry</name><operator>-&gt;</operator><name>number_of_nodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>dns_node_indices</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>nodeidx</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"InactivateDatanodeStatementOnNode: node index %d, "</literal>
						<literal type="string">"number_of_nodes %d, statement name %s"</literal></expr></argument>, <argument><expr><name>nodeidx</name></expr></argument>,
						<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>number_of_nodes</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>stmt_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* remove nodeidx from list */</comment>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>number_of_nodes</name></name><operator>--</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>entry</name><operator>-&gt;</operator><name>number_of_nodes</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>dns_node_indices</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
						<name><name>entry</name><operator>-&gt;</operator><name>dns_node_indices</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>number_of_nodes</name></name></expr>]</index></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></while>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/* prepare remoteDML statement on coordinator */</comment>
<function><type><name>void</name></type>
<name>PrepareRemoteDMLStatement</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>upsert</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, 
                                    <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>select_stmt</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>update_stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>exists</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DatanodeStatement</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    
    <comment type="block">/* Initialize the hash table, if necessary */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>prepared_queries</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>InitQueryHashTable</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>datanode_queries</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>exists</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>DatanodeStatement</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>datanode_queries</name></expr></argument>,
                                  <argument><expr><name>stmt</name></expr></argument>,
                                  <argument><expr><name>HASH_ENTER</name></expr></argument>,
                                  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>number_of_nodes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>upsert</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>select_stmt</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>datanode_queries</name></expr></argument>, <argument><expr><name>select_stmt</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>exists</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>DatanodeStatement</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>datanode_queries</name></expr></argument>,
                                          <argument><expr><name>select_stmt</name></expr></argument>,
                                          <argument><expr><name>HASH_ENTER</name></expr></argument>,
                                          <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>number_of_nodes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>update_stmt</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>datanode_queries</name></expr></argument>, <argument><expr><name>update_stmt</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>exists</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>DatanodeStatement</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>datanode_queries</name></expr></argument>,
                                          <argument><expr><name>update_stmt</name></expr></argument>,
                                          <argument><expr><name>HASH_ENTER</name></expr></argument>,
                                          <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>number_of_nodes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>DropRemoteDMLStatement</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>update_stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>datanode_queries</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>stmt</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>datanode_queries</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>update_stmt</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>datanode_queries</name></expr></argument>, <argument><expr><name>update_stmt</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
