<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/commands/matview.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * matview.c
 *      materialized view support
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/commands/matview.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/cluster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/matview.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>DestReceiver</name></type> <name>pub</name></decl>;</decl_stmt>            <comment type="block">/* publicly-known function pointers */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>transientoid</name></decl>;</decl_stmt>    <comment type="block">/* OID of new heap into which to store */</comment>
    <comment type="block">/* These fields are filled by transientrel_startup: */</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>transientrel</name></decl>;</decl_stmt>    <comment type="block">/* relation to write to */</comment>
    <decl_stmt><decl><type><name>CommandId</name></type>    <name>output_cid</name></decl>;</decl_stmt>        <comment type="block">/* cmin to insert in output tuples */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>hi_options</name></decl>;</decl_stmt>        <comment type="block">/* heap_insert performance options */</comment>
    <decl_stmt><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl>;</decl_stmt>    <comment type="block">/* bulk insert state */</comment>
}</block></struct></type> <name>DR_transientrel</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>matview_maintenance_depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transientrel_startup</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>operation</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>typeinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>transientrel_receive</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transientrel_shutdown</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transientrel_destroy</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>refresh_matview_datafill</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>make_temptable_name_n</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tempname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mv_GenerateOper</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opoid</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>refresh_by_match_merge</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>matviewOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>tempOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relowner</name></decl></parameter>,
                       <parameter><decl><type><name>int</name></type> <name>save_sec_context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>refresh_by_heap_swap</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>matviewOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>OIDNewHeap</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>OpenMatViewIncrementalMaintenance</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CloseMatViewIncrementalMaintenance</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * SetMatViewPopulatedState
 *        Mark a materialized view as populated, or not.
 *
 * NOTE: caller must be holding an appropriate lock on the relation.
 */</comment>
<function><type><name>void</name></type>
<name>SetMatViewPopulatedState</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>newstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>pgrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Update relation's pg_class entry.  Crucial side-effect: other backends
     * (and this one too!) are sent SI message to make them rebuild relcache
     * entries.
     */</comment>
    <expr_stmt><expr><name>pgrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>,
                                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>,
             <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relispopulated</name> <operator>=</operator> <name>newstate</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pgrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pgrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Advance command counter to make the updated pg_class row locally
     * visible.
     */</comment>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecRefreshMatView -- execute a REFRESH MATERIALIZED VIEW command
 *
 * This refreshes the materialized view by creating a new table and swapping
 * the relfilenodes of the new table and the old materialized view, so the OID
 * of the original materialized view is preserved. Thus we do not lose GRANT
 * nor references to this materialized view.
 *
 * If WITH NO DATA was specified, this is effectively like a TRUNCATE;
 * otherwise it is like a TRUNCATE followed by an INSERT using the SELECT
 * statement associated with the materialized view.  The statement node's
 * skipData field shows whether the clause was used.
 *
 * Indexes are rebuilt too, via REINDEX. Since we are effectively bulk-loading
 * the new heap, it's better to create the indexes afterwards than to fill them
 * incrementally while we load.
 *
 * The matview's "populated" state is changed based on whether the contents
 * reflect the result set of the materialized view's query.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>ExecRefreshMatView</name><parameter_list>(<parameter><decl><type><name>RefreshMatViewStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
                   <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>matviewOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>matviewRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RewriteRule</name> <modifier>*</modifier></type><name>rule</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>actions</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>dataQuery</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>tableSpace</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relowner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>OIDNewHeap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>processed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>concurrent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKMODE</name></type>    <name>lockmode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>relpersistence</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>save_userid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_sec_context</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_nestlevel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

    <comment type="block">/* Determine strength of lock needed. */</comment>
    <expr_stmt><expr><name>concurrent</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>lockmode</name> <operator>=</operator> <ternary><condition><expr><name>concurrent</name></expr> ?</condition><then> <expr><name>ExclusiveLock</name></expr> </then><else>: <expr><name>AccessExclusiveLock</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/*
     * Get a lock until end of transaction.
     */</comment>
    <expr_stmt><expr><name>matviewOid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
                                          <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                          <argument><expr><name>RangeVarCallbackOwnsTable</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>matviewRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>matviewOid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make sure it is a materialized view. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>matviewRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a materialized view"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>matviewRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check that CONCURRENTLY is not specified if not populated. */</comment>
    <if_stmt><if>if <condition>(<expr><name>concurrent</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RelationIsPopulated</name><argument_list>(<argument><expr><name>matviewRel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CONCURRENTLY cannot be used when the materialized view is not populated"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check that conflicting options have not been specified. */</comment>
    <if_stmt><if>if <condition>(<expr><name>concurrent</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>skipData</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CONCURRENTLY and WITH NO DATA options cannot be used together"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We don't allow an oid column for a materialized view. */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>matviewRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check that everything is correct for a refresh. Problems at this point
     * are internal errors, so elog is sufficient.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>matviewRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasrules</name></name> <operator>==</operator> <name>false</name> <operator>||</operator>
        <name><name>matviewRel</name><operator>-&gt;</operator><name>rd_rules</name><operator>-&gt;</operator><name>numLocks</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
             <argument><expr><literal type="string">"materialized view \"%s\" is missing rewrite information"</literal></expr></argument>,
             <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>matviewRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>matviewRel</name><operator>-&gt;</operator><name>rd_rules</name><operator>-&gt;</operator><name>numLocks</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
             <argument><expr><literal type="string">"materialized view \"%s\" has too many rules"</literal></expr></argument>,
             <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>matviewRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>rule</name> <operator>=</operator> <name><name>matviewRel</name><operator>-&gt;</operator><name>rd_rules</name><operator>-&gt;</operator><name>rules</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>rule</name><operator>-&gt;</operator><name>event</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name><name>rule</name><operator>-&gt;</operator><name>isInstead</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
             <argument><expr><literal type="string">"the rule for materialized view \"%s\" is not a SELECT INSTEAD OF rule"</literal></expr></argument>,
             <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>matviewRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>actions</name> <operator>=</operator> <name><name>rule</name><operator>-&gt;</operator><name>actions</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>actions</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
             <argument><expr><literal type="string">"the rule for materialized view \"%s\" is not a single action"</literal></expr></argument>,
             <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>matviewRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Check that there is a unique index with no WHERE clause on one or more
     * columns of the materialized view if CONCURRENTLY is specified.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>concurrent</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>indexoidlist</name> <init>= <expr><call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>matviewRel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexoidscan</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>hasUniqueIndex</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>indexoidscan</argument>, <argument>indexoidlist</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>indexoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>indexoidscan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Relation</name></type>    <name>indexRel</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexStruct</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>indexRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>indexStruct</name> <operator>=</operator> <name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name></name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indisunique</name></name> <operator>&amp;&amp;</operator>
                <call><name>IndexIsValid</name><argument_list>(<argument><expr><name>indexStruct</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                <call><name>RelationGetIndexExpressions</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
                <call><name>RelationGetIndexPredicate</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
                <name><name>indexStruct</name><operator>-&gt;</operator><name>indnatts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>hasUniqueIndex</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>hasUniqueIndex</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot refresh materialized view \"%s\" concurrently"</literal></expr></argument>,
                            <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>matviewRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                                       <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>matviewRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Create a unique index with no WHERE clause on one or more columns of the materialized view."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * The stored query was rewritten at the time of the MV definition, but
     * has not been scribbled on by the planner.
     */</comment>
    <expr_stmt><expr><name>dataQuery</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>actions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check for active uses of the relation in the current transaction, such
     * as open scans.
     *
     * NB: We count on this to protect us against problems with refreshing the
     * data using HEAP_INSERT_FROZEN.
     */</comment>
    <expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>matviewRel</name></expr></argument>, <argument><expr><literal type="string">"REFRESH MATERIALIZED VIEW"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Tentatively mark the matview as populated or not (this will roll back
     * if we fail later).
     */</comment>
    <expr_stmt><expr><call><name>SetMatViewPopulatedState</name><argument_list>(<argument><expr><name>matviewRel</name></expr></argument>, <argument><expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>skipData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>relowner</name> <operator>=</operator> <name><name>matviewRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Switch to the owner's userid, so that any functions are run as that
     * user.  Also arrange to make GUC variable changes local to this command.
     * Don't lock it down too tight to create a temporary table just yet.  We
     * will switch modes when we are about to execute user code.
     */</comment>
    <expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>save_userid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>relowner</name></expr></argument>,
                           <argument><expr><name>save_sec_context</name> <operator>|</operator> <name>SECURITY_LOCAL_USERID_CHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>save_nestlevel</name> <operator>=</operator> <call><name>NewGUCNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Concurrent refresh builds new data in temp tablespace, and does diff. */</comment>
    <if_stmt><if>if <condition>(<expr><name>concurrent</name></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><name>tableSpace</name> <operator>=</operator> <call><name>GetDefaultTablespace</name><argument_list>(<argument><expr><name>RELPERSISTENCE_TEMP</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>relpersistence</name> <operator>=</operator> <name>RELPERSISTENCE_TEMP</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>tableSpace</name> <operator>=</operator> <name><name>matviewRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>relpersistence</name> <operator>=</operator> <name><name>matviewRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Create the transient table that will receive the regenerated data. Lock
     * it against access by any other process until commit (by which time it
     * will be gone).
     */</comment>
    <expr_stmt><expr><name>OIDNewHeap</name> <operator>=</operator> <call><name>make_new_heap</name><argument_list>(<argument><expr><name>matviewOid</name></expr></argument>, <argument><expr><name>tableSpace</name></expr></argument>, <argument><expr><name>relpersistence</name></expr></argument>,
                               <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>OIDNewHeap</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>CreateTransientRelDestReceiver</name><argument_list>(<argument><expr><name>OIDNewHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now lock down security-restricted operations.
     */</comment>
    <expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>relowner</name></expr></argument>,
                           <argument><expr><name>save_sec_context</name> <operator>|</operator> <name>SECURITY_RESTRICTED_OPERATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Generate the data, if wanted. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>skipData</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>processed</name> <operator>=</operator> <call><name>refresh_matview_datafill</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>dataQuery</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Make the matview match the newly generated data. */</comment>
    <if_stmt><if>if <condition>(<expr><name>concurrent</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>old_depth</name> <init>= <expr><name>matview_maintenance_depth</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>refresh_by_match_merge</name><argument_list>(<argument><expr><name>matviewOid</name></expr></argument>, <argument><expr><name>OIDNewHeap</name></expr></argument>, <argument><expr><name>relowner</name></expr></argument>,
                                   <argument><expr><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>
            <expr_stmt><expr><name>matview_maintenance_depth</name> <operator>=</operator> <name>old_depth</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>matview_maintenance_depth</name> <operator>==</operator> <name>old_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>refresh_by_heap_swap</name><argument_list>(<argument><expr><name>matviewOid</name></expr></argument>, <argument><expr><name>OIDNewHeap</name></expr></argument>, <argument><expr><name>relpersistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Inform stats collector about our activity: basically, we truncated
         * the matview and inserted some new data.  (The concurrent code path
         * above doesn't need to worry about this because the inserts and
         * deletes it issues get counted by lower-level code.)
         */</comment>
        <expr_stmt><expr><call><name>pgstat_count_truncate</name><argument_list>(<argument><expr><name>matviewRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>skipData</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pgstat_count_heap_insert</name><argument_list>(<argument><expr><name>matviewRel</name></expr></argument>, <argument><expr><name>processed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>matviewRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Roll back any GUC changes */</comment>
    <expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>save_nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Restore userid and security context */</comment>
    <expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>save_userid</name></expr></argument>, <argument><expr><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>matviewOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * refresh_matview_datafill
 *
 * Execute the given query, sending result rows to "dest" (which will
 * insert them into the target matview).
 *
 * Returns number of rows inserted.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>refresh_matview_datafill</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>rewritten</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>queryDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>copied_query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>processed</name></decl>;</decl_stmt>

    <comment type="block">/* Lock and rewrite, using a copy to preserve the original query. */</comment>
    <expr_stmt><expr><name>copied_query</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AcquireRewriteLocks</name><argument_list>(<argument><expr><name>copied_query</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rewritten</name> <operator>=</operator> <call><name>QueryRewrite</name><argument_list>(<argument><expr><name>copied_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* SELECT should never rewrite to more or less than one SELECT query */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>rewritten</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected rewrite result for REFRESH MATERIALIZED VIEW"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>query</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>rewritten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check for user-requested abort. */</comment>
    <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Plan the query which will generate data for the refresh. */</comment>
    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>pg_plan_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Use a snapshot with an updated command ID to ensure this query sees
     * results of any previously executed queries.  (This could only matter if
     * the planner executed an allegedly-stable function that changed the
     * database contents, but let's do it anyway to be safe.)
     */</comment>
    <expr_stmt><expr><call><name>PushCopiedSnapshot</name><argument_list>(<argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UpdateActiveSnapshotCommandId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create a QueryDesc, redirecting output to our tuple receiver */</comment>
    <expr_stmt><expr><name>queryDesc</name> <operator>=</operator> <call><name>CreateQueryDesc</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
                                <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>,
                                <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* call ExecutorStart to prepare the plan for execution */</comment>
    <expr_stmt><expr><call><name>ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>EXEC_FLAG_WITHOUT_OIDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* run the plan */</comment>
    <expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>processed</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr>;</expr_stmt>

    <comment type="block">/* and clean up */</comment>
    <expr_stmt><expr><call><name>ExecutorFinish</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecutorEnd</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FreeQueryDesc</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>processed</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>DestReceiver</name> <modifier>*</modifier></type>
<name>CreateTransientRelDestReceiver</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>transientoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DR_transientrel</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><operator>(</operator><name>DR_transientrel</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DR_transientrel</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>receiveSlot</name></name> <operator>=</operator> <name>transientrel_receive</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rStartup</name></name> <operator>=</operator> <name>transientrel_startup</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rShutdown</name></name> <operator>=</operator> <name>transientrel_shutdown</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rDestroy</name></name> <operator>=</operator> <name>transientrel_destroy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>mydest</name></name> <operator>=</operator> <name>DestTransientRel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>transientoid</name></name> <operator>=</operator> <name>transientoid</name></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>DestReceiver</name> <operator>*</operator><operator>)</operator> <name>self</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transientrel_startup --- executor startup
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transientrel_startup</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>operation</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>typeinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DR_transientrel</name> <modifier>*</modifier></type><name>myState</name> <init>= <expr><operator>(</operator><name>DR_transientrel</name> <operator>*</operator><operator>)</operator> <name>self</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>transientrel</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>transientrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>myState</name><operator>-&gt;</operator><name>transientoid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Fill private fields of myState for use by later routines
     */</comment>
    <expr_stmt><expr><name><name>myState</name><operator>-&gt;</operator><name>transientrel</name></name> <operator>=</operator> <name>transientrel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myState</name><operator>-&gt;</operator><name>output_cid</name></name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We can skip WAL-logging the insertions, unless PITR or streaming
     * replication is in use. We can skip the FSM in any case.
     */</comment>
    <expr_stmt><expr><name><name>myState</name><operator>-&gt;</operator><name>hi_options</name></name> <operator>=</operator> <name>HEAP_INSERT_SKIP_FSM</name> <operator>|</operator> <name>HEAP_INSERT_FROZEN</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogIsNeeded</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>myState</name><operator>-&gt;</operator><name>hi_options</name></name> <operator>|=</operator> <name>HEAP_INSERT_SKIP_WAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>myState</name><operator>-&gt;</operator><name>bistate</name></name> <operator>=</operator> <call><name>GetBulkInsertState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Not using WAL requires smgr_targblock be initially invalid */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationGetTargetBlock</name><argument_list>(<argument><expr><name>transientrel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * transientrel_receive --- receive one tuple
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>transientrel_receive</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DR_transientrel</name> <modifier>*</modifier></type><name>myState</name> <init>= <expr><operator>(</operator><name>DR_transientrel</name> <operator>*</operator><operator>)</operator> <name>self</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>

    <comment type="block">/*
     * get the heap tuple out of the tuple table slot, making sure we have a
     * writable copy
     */</comment>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_insert</name><argument_list>(<argument><expr><name><name>myState</name><operator>-&gt;</operator><name>transientrel</name></name></expr></argument>,
                <argument><expr><name>tuple</name></expr></argument>,
                <argument><expr><name><name>myState</name><operator>-&gt;</operator><name>output_cid</name></name></expr></argument>,
                <argument><expr><name><name>myState</name><operator>-&gt;</operator><name>hi_options</name></name></expr></argument>,
                <argument><expr><name><name>myState</name><operator>-&gt;</operator><name>bistate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We know this is a newly created relation, so there are no indexes */</comment>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transientrel_shutdown --- executor end
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transientrel_shutdown</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DR_transientrel</name> <modifier>*</modifier></type><name>myState</name> <init>= <expr><operator>(</operator><name>DR_transientrel</name> <operator>*</operator><operator>)</operator> <name>self</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>FreeBulkInsertState</name><argument_list>(<argument><expr><name><name>myState</name><operator>-&gt;</operator><name>bistate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If we skipped using WAL, must heap_sync before commit */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>myState</name><operator>-&gt;</operator><name>hi_options</name></name> <operator>&amp;</operator> <name>HEAP_INSERT_SKIP_WAL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>heap_sync</name><argument_list>(<argument><expr><name><name>myState</name><operator>-&gt;</operator><name>transientrel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* close transientrel, but keep lock until commit */</comment>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name><name>myState</name><operator>-&gt;</operator><name>transientrel</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myState</name><operator>-&gt;</operator><name>transientrel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * transientrel_destroy --- release DestReceiver object
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transientrel_destroy</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Given a qualified temporary table name, append an underscore followed by
 * the given integer, to make a new table name based on the old one.
 *
 * This leaks memory through palloc(), which won't be cleaned up until the
 * current memory context is freed.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>make_temptable_name_n</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tempname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>namebuf</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>namebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>namebuf</name></expr></argument>, <argument><expr><name>tempname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>namebuf</name></expr></argument>, <argument><expr><literal type="string">"_%d"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>namebuf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>mv_GenerateOper</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>opertup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>operform</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>opertup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name>opoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>operform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprkind</name></name> <operator>==</operator> <literal type="char">'b'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"OPERATOR(%s.%s)"</literal></expr></argument>,
                     <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * refresh_by_match_merge
 *
 * Refresh a materialized view with transactional semantics, while allowing
 * concurrent reads.
 *
 * This is called after a new version of the data has been created in a
 * temporary table.  It performs a full outer join against the old version of
 * the data, producing "diff" results.  This join cannot work if there are any
 * duplicated rows in either the old or new versions, in the sense that every
 * column would compare as equal between the two rows.  It does work correctly
 * in the face of rows which have at least one NULL value, with all non-NULL
 * columns equal.  The behavior of NULLs on equality tests and on UNIQUE
 * indexes turns out to be quite convenient here; the tests we need to make
 * are consistent with default behavior.  If there is at least one UNIQUE
 * index on the materialized view, we have exactly the guarantee we need.
 *
 * The temporary table used to hold the diff results contains just the TID of
 * the old record (if matched) and the ROW from the new table as a single
 * column of complex record type (if matched).
 *
 * Once we have the diff table, we perform set-based DELETE and INSERT
 * operations against the materialized view, and discard both temporary
 * tables.
 *
 * Everything from the generation of the new data to applying the differences
 * takes place under cover of an ExclusiveLock, since it seems as though we
 * would want to prohibit not only concurrent REFRESH operations, but also
 * incremental maintenance.  It also doesn't seem reasonable or safe to allow
 * SELECT FOR UPDATE or SELECT FOR SHARE on rows being updated or deleted by
 * this command.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>refresh_by_match_merge</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>matviewOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>tempOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relowner</name></decl></parameter>,
                       <parameter><decl><type><name>int</name></type> <name>save_sec_context</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>querybuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>matviewRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>tempRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>matviewname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>tempname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>diffname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>foundUniqueIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>indexoidlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexoidscan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>        <name>relnatts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>usedForQual</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>matviewRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>matviewOid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>matviewname</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>matviewRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>matviewRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tempRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>tempOid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tempname</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>tempRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>tempRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>diffname</name> <operator>=</operator> <call><name>make_temptable_name_n</name><argument_list>(<argument><expr><name>tempname</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>relnatts</name> <operator>=</operator> <name><name>matviewRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnatts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>usedForQual</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>relnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Open SPI context. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>SPI_connect</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_connect failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PGXC</name></cpp:ifndef>    
    <comment type="block">/* Analyze the temp table with the new contents. */</comment>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="string">"ANALYZE %s"</literal></expr></argument>, <argument><expr><name>tempname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>SPI_exec</name><argument_list>(<argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SPI_OK_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_exec failed: %s"</literal></expr></argument>, <argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <block>{<block_content>
        <comment type="block">/*
         * Don't want to send down the ANALYZE on the remote nodes because the
         * temporary table was not created there to start with. We could have
         * invented a special option for ANALYZE to only run locally. But we
         * could instead just cook up a VacuumStmt and call vacuum (with
         * VACOPT_ANALYZE option of course) directly
         */</comment>
        <decl_stmt><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>VacuumStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rv</name> <init>= <expr><call><name>makeRangeVar</name><argument_list>(
                <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>tempRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>tempRel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>rv</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>VACOPT_ANALYZE</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExecVacuum</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * We need to ensure that there are not duplicate rows without NULLs in
     * the new data set before we can count on the "diff" results.  Check for
     * that in a way that allows showing the first duplicated row found.  Even
     * after we pass this test, a unique index on the materialized view may
     * find a duplicate key problem.
     */</comment>
    <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>,
                     <argument><expr><literal type="string">"SELECT newdata FROM %s newdata "</literal>
                     <literal type="string">"WHERE newdata IS NOT NULL AND EXISTS "</literal>
                     <literal type="string">"(SELECT * FROM %s newdata2 WHERE newdata2 IS NOT NULL "</literal>
                     <literal type="string">"AND newdata2 OPERATOR(pg_catalog.*=) newdata "</literal>
                     <literal type="string">"AND newdata2.ctid OPERATOR(pg_catalog.&lt;&gt;) "</literal>
                     <literal type="string">"newdata.ctid) LIMIT 1"</literal></expr></argument>,
                     <argument><expr><name>tempname</name></expr></argument>, <argument><expr><name>tempname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>SPI_execute</name><argument_list>(<argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SPI_OK_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_exec failed: %s"</literal></expr></argument>, <argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>SPI_processed</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Note that this ereport() is returning data to the user.  Generally,
         * we would want to make sure that the user has been granted access to
         * this data.  However, REFRESH MAT VIEW is only able to be run by the
         * owner of the mat view (or a superuser) and therefore there is no
         * need to check for access to data in the mat view.
         */</comment>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CARDINALITY_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new data for materialized view \"%s\" contains duplicate rows without any null columns"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>matviewRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Row: %s"</literal></expr></argument>,
                           <argument><expr><call><name>SPI_getvalue</name><argument_list>(<argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>relowner</name></expr></argument>,
                           <argument><expr><name>save_sec_context</name> <operator>|</operator> <name>SECURITY_LOCAL_USERID_CHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Start building the query for creating the diff table. */</comment>
    <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/*
     * In Postgres-XL we use LOCAL TEMP table to define a table that gets
     * created only on the coordinator. In this case, we need the local table
     * only 
     *
     * XXX Are we breaking SQL standard compatibility?
     */</comment> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
                    <argument><expr><literal type="string">"CREATE LOCAL TEMP TABLE %s AS "</literal>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>                     
                     <literal type="string">"CREATE TEMP TABLE %s AS "</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                     
                     <literal type="string">"SELECT mv.ctid AS tid, newdata "</literal>
                     <literal type="string">"FROM %s mv FULL JOIN %s newdata ON ("</literal></expr></argument>,
                     <argument><expr><name>diffname</name></expr></argument>, <argument><expr><name>matviewname</name></expr></argument>, <argument><expr><name>tempname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Get the list of index OIDs for the table from the relcache, and look up
     * each one in the pg_index syscache.  We will test for equality on all
     * columns present in all unique indexes which only reference columns and
     * include all rows.
     */</comment>
    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>matviewRel</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>foundUniqueIndex</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>indexoidlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>matviewRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>indexoidscan</argument>, <argument>indexoidlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>indexoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>indexoidscan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>indexRel</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexStruct</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>indexRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>indexStruct</name> <operator>=</operator> <name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * We're only interested if it is unique, valid, contains no
         * expressions, and is not partial.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indisunique</name></name> <operator>&amp;&amp;</operator>
            <call><name>IndexIsValid</name><argument_list>(<argument><expr><name>indexStruct</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>RelationGetIndexExpressions</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
            <call><name>RelationGetIndexPredicate</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NIL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>numatts</name> <init>= <expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indnatts</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

            <comment type="block">/* Add quals for all columns from this index. */</comment>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name> <init>= <expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>type</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>op</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * Only include the column once regardless of how many times
                 * it shows up in how many indexes.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>usedForQual</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>usedForQual</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Actually add the qual, ANDed with any others.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>foundUniqueIndex</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="string">" AND "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>(</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="string">"newdata.%s "</literal></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>attnumTypeId</name><argument_list>(<argument><expr><name>matviewRel</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>TYPECACHE_EQ_OPR</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>eq_opr</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>mv_GenerateOper</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="string">" mv.%s"</literal></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>foundUniqueIndex</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Keep the locks, since we're about to run DML which needs them. */</comment>
        <expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * There must be at least one unique index on the matview.
     *
     * ExecRefreshMatView() checks that after taking the exclusive lock on the
     * matview. So at least one unique index is guaranteed to exist here
     * because the lock is still being held.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>foundUniqueIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>,
                           <argument><expr><literal type="string">" AND newdata OPERATOR(pg_catalog.*=) mv) "</literal>
                           <literal type="string">"WHERE newdata IS NULL OR mv IS NULL "</literal>
                           <literal type="string">"ORDER BY tid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create the temporary "diff" table. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>    
    <if_stmt><if>if <condition>(<expr><call><name>SPI_exec</name><argument_list>(<argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SPI_OK_INSERT</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>        
    <if_stmt><if>if <condition>(<expr><call><name>SPI_exec</name><argument_list>(<argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SPI_OK_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>        
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_exec failed: %s"</literal></expr></argument>, <argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>relowner</name></expr></argument>,
                           <argument><expr><name>save_sec_context</name> <operator>|</operator> <name>SECURITY_RESTRICTED_OPERATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We have no further use for data from the "full-data" temp table, but we
     * must keep it around because its type is referenced from the diff table.
     */</comment>

    <comment type="block">/* Analyze the diff table. */</comment>
    <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* 
     * Materialized view is stored on CN, use "(COORDINATOR)" option to force
     * vacuum analyzing "diff table" on CN.
     */</comment>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="string">"ANALYZE (COORDINATOR) %s"</literal></expr></argument>, <argument><expr><name>diffname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>SPI_exec</name><argument_list>(<argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SPI_OK_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_exec failed: %s"</literal></expr></argument>, <argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt><empty_stmt>;</empty_stmt>

    <expr_stmt><expr><call><name>OpenMatViewIncrementalMaintenance</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Deletes must come before inserts; do them first. */</comment>
    <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>,
                     <argument><expr><literal type="string">"DELETE FROM %s mv WHERE ctid OPERATOR(pg_catalog.=) ANY "</literal>
                     <literal type="string">"(SELECT diff.tid FROM %s diff "</literal>
                     <literal type="string">"WHERE diff.tid IS NOT NULL "</literal>
                     <literal type="string">"AND diff.newdata IS NULL)"</literal></expr></argument>,
                     <argument><expr><name>matviewname</name></expr></argument>, <argument><expr><name>diffname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>SPI_exec</name><argument_list>(<argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SPI_OK_DELETE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_exec failed: %s"</literal></expr></argument>, <argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Inserts go last. */</comment>
    <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>,
                     <argument><expr><literal type="string">"INSERT INTO %s SELECT (diff.newdata).* "</literal>
                     <literal type="string">"FROM %s diff WHERE tid IS NULL"</literal></expr></argument>,
                     <argument><expr><name>matviewname</name></expr></argument>, <argument><expr><name>diffname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>SPI_exec</name><argument_list>(<argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SPI_OK_INSERT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_exec failed: %s"</literal></expr></argument>, <argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We're done maintaining the materialized view. */</comment>
    <expr_stmt><expr><call><name>CloseMatViewIncrementalMaintenance</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>tempRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>matviewRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clean up temp tables. */</comment>
    <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="string">"DROP TABLE %s, %s"</literal></expr></argument>, <argument><expr><name>diffname</name></expr></argument>, <argument><expr><name>tempname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>SPI_exec</name><argument_list>(<argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SPI_OK_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_exec failed: %s"</literal></expr></argument>, <argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Close SPI context. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Swap the physical files of the target and transient tables, then rebuild
 * the target's indexes and throw away the transient table.  Security context
 * swapping is handled by the called function, so it is not needed here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>refresh_by_heap_swap</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>matviewOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>OIDNewHeap</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>finish_heap_swap</name><argument_list>(<argument><expr><name>matviewOid</name></expr></argument>, <argument><expr><name>OIDNewHeap</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                     <argument><expr><name>RecentXmin</name></expr></argument>, <argument><expr><call><name>ReadNextMultiXactId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>relpersistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * This should be used to test whether the backend is in a context where it is
 * OK to allow DML statements to modify materialized views.  We only want to
 * allow that for internal code driven by the materialized view definition,
 * not for arbitrary user-supplied code.
 *
 * While the function names reflect the fact that their main intended use is
 * incremental maintenance of materialized views (in response to changes to
 * the data in referenced relations), they are initially used to allow REFRESH
 * without blocking concurrent reads.
 */</comment>
<function><type><name>bool</name></type>
<name>MatViewIncrementalMaintenanceIsEnabled</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>matview_maintenance_depth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>OpenMatViewIncrementalMaintenance</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>matview_maintenance_depth</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CloseMatViewIncrementalMaintenance</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>matview_maintenance_depth</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>matview_maintenance_depth</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
