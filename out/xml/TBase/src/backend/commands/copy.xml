<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/commands/copy.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * copy.c
 *        Implements the COPY utility command
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/commands/copy.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execPartition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/locator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/remotecopy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/poolmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_node.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pgxcship.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/portal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logical_statistic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/slot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/mls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datamask.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/relcryptcommand.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/shardmap.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISOCTAL</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((c) &gt;= '0') &amp;&amp; ((c) &lt;= '7'))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OCTVALUE</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((c) - '0')</cpp:value></cpp:define>

<comment type="block">/*
 * Represents the different source/dest cases we need to worry about at
 * the bottom level
 */</comment>
<typedef>typedef <type><enum>enum <name>CopyDest</name>
<block>{
    <decl><name>COPY_FILE</name></decl>,                    <comment type="block">/* to/from file (or a piped program) */</comment>
    <decl><name>COPY_OLD_FE</name></decl>,                <comment type="block">/* to/from frontend (2.0 protocol) */</comment>
    <decl><name>COPY_NEW_FE</name></decl>,                    <comment type="block">/* to/from frontend (3.0 protocol) */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <decl><name>COPY_BUFFER</name></decl>,                <comment type="block">/* Do not send, just prepare */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl><name>COPY_CALLBACK</name></decl>                <comment type="block">/* to/from callback function */</comment>
}</block></enum></type> <name>CopyDest</name>;</typedef>

<comment type="block">/*
 *    Represents the end-of-line terminator type of the input
 */</comment>
<typedef>typedef <type><enum>enum <name>EolType</name>
<block>{
    <decl><name>EOL_UNKNOWN</name></decl>,
    <decl><name>EOL_NL</name></decl>,
    <decl><name>EOL_CR</name></decl>,
    <decl><name>EOL_CRNL</name></decl>
}</block></enum></type> <name>EolType</name>;</typedef>

<comment type="block">/*
 * This struct contains all the state variables used throughout a COPY
 * operation. For simplicity, we use the same struct for all variants of COPY,
 * even though some fields are used in only some cases.
 *
 * Multi-byte encodings: all supported client-side encodings encode multi-byte
 * characters by having the first byte's high bit set. Subsequent bytes of the
 * character can have the high bit not set. When scanning data in such an
 * encoding to look for a match to a single-byte (ie ASCII) character, we must
 * use the full pg_encoding_mblen() machinery to skip over multibyte
 * characters, else we might find a false match to a trailing byte. In
 * supported server encodings, there is no possibility of a false match, and
 * it's faster to make useless comparisons to trailing bytes than it is to
 * invoke pg_encoding_mblen() to skip over them. encoding_embeds_ascii is TRUE
 * when we have to do it the hard way.
 */</comment>
<typedef>typedef <type><struct>struct <name>CopyStateData</name>
<block>{
    <comment type="block">/* low-level state data */</comment>
    <decl_stmt><decl><type><name>CopyDest</name></type>    <name>copy_dest</name></decl>;</decl_stmt>        <comment type="block">/* type of copy source/destination */</comment>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>copy_file</name></decl>;</decl_stmt>        <comment type="block">/* used if copy_dest == COPY_FILE */</comment>
    <decl_stmt><decl><type><name>StringInfo</name></type>    <name>fe_msgbuf</name></decl>;</decl_stmt>        <comment type="block">/* used for all dests during COPY TO, only for
                                 * dest == COPY_NEW_FE in COPY FROM */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>fe_eof</name></decl>;</decl_stmt>            <comment type="block">/* true if detected end of copy data */</comment>
    <decl_stmt><decl><type><name>EolType</name></type>        <name>eol_type</name></decl>;</decl_stmt>        <comment type="block">/* EOL type of input */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>file_encoding</name></decl>;</decl_stmt>    <comment type="block">/* file or remote side's character encoding */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>need_transcoding</name></decl>;</decl_stmt>    <comment type="block">/* file encoding diff from server? */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>encoding_embeds_ascii</name></decl>;</decl_stmt>    <comment type="block">/* ASCII can be non-first byte? */</comment>

    <comment type="block">/* parameters from the COPY command */</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>            <comment type="block">/* relation to copy to or from */</comment>
    <decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>queryDesc</name></decl>;</decl_stmt>        <comment type="block">/* executable query to copy from */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>attnumlist</name></decl>;</decl_stmt>        <comment type="block">/* integer list of attnums to copy */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>        <comment type="block">/* filename, or NULL for STDIN/STDOUT */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_program</name></decl>;</decl_stmt>        <comment type="block">/* is 'filename' a program to popen? */</comment>
    <decl_stmt><decl><type><name>copy_data_source_cb</name></type> <name>data_source_cb</name></decl>;</decl_stmt> <comment type="block">/* function for reading data */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>binary</name></decl>;</decl_stmt>            <comment type="block">/* binary format? */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>oids</name></decl>;</decl_stmt>            <comment type="block">/* include OIDs? */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>freeze</name></decl>;</decl_stmt>            <comment type="block">/* freeze rows on loading? */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>csv_mode</name></decl>;</decl_stmt>        <comment type="block">/* Comma Separated Value format? */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type>        <name>internal_mode</name></decl>;</decl_stmt>  <comment type="block">/* internal format? */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>bool</name></type>        <name>header_line</name></decl>;</decl_stmt>    <comment type="block">/* CSV header line? */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>null_print</name></decl>;</decl_stmt>        <comment type="block">/* NULL marker string (server encoding!) */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>null_print_len</name></decl>;</decl_stmt> <comment type="block">/* length of same */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>null_print_client</name></decl>;</decl_stmt>    <comment type="block">/* same converted to file encoding */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>delim</name></decl>;</decl_stmt>            <comment type="block">/* column delimiter (must be 1 byte) */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>quote</name></decl>;</decl_stmt>            <comment type="block">/* CSV quote char (must be 1 byte) */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>escape</name></decl>;</decl_stmt>            <comment type="block">/* CSV escape char (must be 1 byte) */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>force_quote</name></decl>;</decl_stmt>    <comment type="block">/* list of column names */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>force_quote_all</name></decl>;</decl_stmt>    <comment type="block">/* FORCE_QUOTE *? */</comment>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>force_quote_flags</name></decl>;</decl_stmt>    <comment type="block">/* per-column CSV FQ flags */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>force_notnull</name></decl>;</decl_stmt>    <comment type="block">/* list of column names */</comment>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>force_notnull_flags</name></decl>;</decl_stmt>    <comment type="block">/* per-column CSV FNN flags */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>force_null</name></decl>;</decl_stmt>        <comment type="block">/* list of column names */</comment>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>force_null_flags</name></decl>;</decl_stmt>    <comment type="block">/* per-column CSV FN flags */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>convert_selectively</name></decl>;</decl_stmt>    <comment type="block">/* do selective binary conversion? */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>convert_select</name></decl>;</decl_stmt> <comment type="block">/* list of column names (can be NIL) */</comment>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>convert_select_flags</name></decl>;</decl_stmt>    <comment type="block">/* per-column CSV/TEXT CS flags */</comment>

    <comment type="block">/* these are just for error messages, see CopyFromErrorCallback */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cur_relname</name></decl>;</decl_stmt>    <comment type="block">/* table name for error messages */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>cur_lineno</name></decl>;</decl_stmt>        <comment type="block">/* line number for error messages */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cur_attname</name></decl>;</decl_stmt>    <comment type="block">/* current att for error messages */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cur_attval</name></decl>;</decl_stmt>        <comment type="block">/* current att value for error messages */</comment>

    <comment type="block">/*
     * Working state for COPY TO/FROM
     */</comment>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>copycontext</name></decl>;</decl_stmt>    <comment type="block">/* per-copy execution context */</comment>

    <comment type="block">/*
     * Working state for COPY TO
     */</comment>
    <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>out_functions</name></decl>;</decl_stmt>    <comment type="block">/* lookup info for output functions */</comment>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>rowcontext</name></decl>;</decl_stmt>    <comment type="block">/* per-row evaluation context */</comment>

    <comment type="block">/*
     * Working state for COPY FROM
     */</comment>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>num_defaults</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>file_has_oids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FmgrInfo</name></type>    <name>oid_in_function</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>oid_typioparam</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>in_functions</name></decl>;</decl_stmt>    <comment type="block">/* array of input functions for each attrs */</comment>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>typioparams</name></decl>;</decl_stmt>    <comment type="block">/* array of element types for in_functions */</comment>
    <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>defmap</name></decl>;</decl_stmt>            <comment type="block">/* array of default att numbers */</comment>
    <decl_stmt><decl><type><name>ExprState</name> <modifier>*</modifier><modifier>*</modifier></type><name>defexprs</name></decl>;</decl_stmt>        <comment type="block">/* array of default att expressions */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>volatile_defexprs</name></decl>;</decl_stmt>    <comment type="block">/* is any of defexprs volatile? */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>range_table</name></decl>;</decl_stmt>

	<comment type="block">/* Tuple-routing support info */</comment>
	<decl_stmt><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>partition_tuple_routing</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>TransitionCaptureState</name> <modifier>*</modifier></type><name>transition_capture</name></decl>;</decl_stmt>

    <comment type="block">/*
     * These variables are used to reduce overhead in textual COPY FROM.
     *
     * attribute_buf holds the separated, de-escaped text for each field of
     * the current line.  The CopyReadAttributes functions return arrays of
     * pointers into this buffer.  We avoid palloc/pfree overhead by re-using
     * the buffer on each cycle.
     */</comment>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>attribute_buf</name></decl>;</decl_stmt>

    <comment type="block">/* field raw data pointers found by COPY FROM */</comment>

    <decl_stmt><decl><type><name>int</name></type>            <name>max_fields</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>raw_fields</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Similarly, line_buf holds the whole input line being processed. The
     * input cycle is first to read the whole line into line_buf, convert it
     * to server encoding there, and then extract the individual attribute
     * fields into attribute_buf.  line_buf is preserved unmodified so that we
     * can display it in error messages if appropriate.
     */</comment>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>line_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>line_buf_converted</name></decl>;</decl_stmt> <comment type="block">/* converted to server encoding? */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>line_buf_valid</name></decl>;</decl_stmt> <comment type="block">/* contains the row being processed? */</comment>

    <comment type="block">/*
     * Finally, raw_buf holds raw data read from the data source (file or
     * client connection).  CopyReadLine parses this data sufficiently to
     * locate line boundaries, then transfers the data to line_buf and
     * converts it.  Note: we guarantee that there is a \0 at
     * raw_buf[raw_buf_len].
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RAW_BUF_SIZE</name></cpp:macro> <cpp:value>65536</cpp:value></cpp:define>        <comment type="block">/* we palloc RAW_BUF_SIZE+1 bytes */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>raw_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>raw_buf_index</name></decl>;</decl_stmt>    <comment type="block">/* next byte to process */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>raw_buf_len</name></decl>;</decl_stmt>    <comment type="block">/* total # of bytes stored */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/* Remote COPY state data */</comment>
    <decl_stmt><decl><type><name>RemoteCopyData</name> <modifier>*</modifier></type><name>remoteCopyState</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type> <name>shard_array</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Relation</name>    <modifier>*</modifier></type><name>partrels</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nparts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>insert_into</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>data_index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>data_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>data_ncolumns</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>ndatarows</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>       <name>whole_line</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>CopyStateData</name>;</typedef>

<comment type="block">/* DestReceiver for COPY (query) TO */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>DestReceiver</name></type> <name>pub</name></decl>;</decl_stmt>            <comment type="block">/* publicly-known function pointers */</comment>
    <decl_stmt><decl><type><name>CopyState</name></type>    <name>cstate</name></decl>;</decl_stmt>            <comment type="block">/* CopyStateData for the command */</comment>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>processed</name></decl>;</decl_stmt>        <comment type="block">/* # of tuples processed */</comment>
}</block></struct></type> <name>DR_copy</name>;</typedef>


<comment type="block">/*
 * These macros centralize code used to process line_buf and raw_buf buffers.
 * They are macros because they often do continue/break control and to avoid
 * function call overhead in tight COPY loops.
 *
 * We must use "if (1)" because the usual "do {...} while(0)" wrapper would
 * prevent the continue/break processing from working.  We end the "if (1)"
 * with "else ((void) 0)" to ensure the "if" does not unintentionally match
 * any "else" in the calling code, and to avoid any compiler warnings about
 * empty statements.  See http://www.cit.gu.edu.au/~anthony/info/C/C.macros.
 */</comment>

<comment type="block">/*
 * This keeps the character read at the top of the loop in the buffer
 * even if there is more than one read-ahead.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IF_NEED_REFILL_AND_NOT_EOF_CONTINUE</name><parameter_list>(<parameter><type><name>extralen</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>if (1) \
{ \
    if (raw_buf_ptr + (extralen) &gt;= copy_buf_len &amp;&amp; !hit_eof) \
    { \
        raw_buf_ptr = prev_raw_ptr; <comment type="block">/* undo fetch */</comment> \
        need_data = true; \
        continue; \
    } \
} else ((void) 0)</cpp:value></cpp:define>

<comment type="block">/* This consumes the remainder of the buffer and breaks */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IF_NEED_REFILL_AND_EOF_BREAK</name><parameter_list>(<parameter><type><name>extralen</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>if (1) \
{ \
    if (raw_buf_ptr + (extralen) &gt;= copy_buf_len &amp;&amp; hit_eof) \
    { \
        if (extralen) \
            raw_buf_ptr = copy_buf_len; <comment type="block">/* consume the partial character */</comment> \
        <comment type="block">/* backslash just before EOF, treat as data char */</comment> \
        result = true; \
        break; \
    } \
} else ((void) 0)</cpp:value></cpp:define>

<comment type="block">/*
 * Transfer any approved data to line_buf; must do this to be sure
 * there is some room in raw_buf.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REFILL_LINEBUF</name></cpp:macro> \
<cpp:value>if (1) \
{ \
    if (raw_buf_ptr &gt; cstate-&gt;raw_buf_index) \
    { \
        appendBinaryStringInfo(&amp;cstate-&gt;line_buf, \
                             cstate-&gt;raw_buf + cstate-&gt;raw_buf_index, \
                               raw_buf_ptr - cstate-&gt;raw_buf_index); \
        cstate-&gt;raw_buf_index = raw_buf_ptr; \
    } \
} else ((void) 0)</cpp:value></cpp:define>

<comment type="block">/* Undo any read-ahead and jump out of the block. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_END_OF_COPY_GOTO</name></cpp:macro> \
<cpp:value>if (1) \
{ \
    raw_buf_ptr = prev_raw_ptr + 1; \
    goto not_end_of_copy; \
} else ((void) 0)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>BinarySignature</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <init>= <expr><literal type="string">"PGCOPY\n\377\r\n\0"</literal></expr></init></decl>;</decl_stmt>


<comment type="block">/* non-export function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>CopyState</name></type> <name>BeginCopy</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_from</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
          <parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>raw_query</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>queryRelId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attnamelist</name></decl></parameter>,
          <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
          <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type> <name>shards</name></decl></parameter>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            )</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EndCopy</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ClosePipeToProgram</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CopyState</name></type> <name>BeginCopyTo</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
            <parameter><decl><type><name>Oid</name></type> <name>queryRelId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_program</name></decl></parameter>,
            <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attnamelist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
            <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type> <name>shards</name></decl></parameter>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    
            )</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EndCopyTo</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>DoCopyTo</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>CopyTo</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopyOneRowTo</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>tupleOid</name></decl></parameter>,
             <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopyFromInsertBatch</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                    <parameter><decl><type><name>CommandId</name></type> <name>mycid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hi_options</name></decl></parameter>,
                    <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>myslot</name></decl></parameter>,
                    <parameter><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl></parameter>,
                    <parameter><decl><type><name>int</name></type> <name>nBufferedTuples</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>bufferedTuples</name></decl></parameter>,
                    <parameter><decl><type><name>int</name></type> <name>firstBufferedLineNo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CopyReadLine</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CopyReadLineText</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>CopyReadAttributesInternal</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>CopyReadAttributesText</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>CopyReadAttributesCSV</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>CopyReadBinaryAttribute</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>,
                        <parameter><decl><type><name>int</name></type> <name>column_no</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>,
                        <parameter><decl><type><name>Oid</name></type> <name>typioparam</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopyAttributeOutText</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopyAttributeOutCSV</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>,
                    <parameter><decl><type><name>bool</name></type> <name>use_quote</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>single_attr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>CopyGetAttnums</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
               <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attnamelist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>limit_printout_length</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Low-level communications functions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendCopyBegin</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReceiveCopyBegin</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendCopyEnd</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopySendData</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>databuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>datasize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopySendString</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopySendChar</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopySendEndOfRow</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>CopyGetData</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>databuf</name></decl></parameter>,
            <parameter><decl><type><name>int</name></type> <name>minread</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxread</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopySendInt32</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CopyGetInt32</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopySendInt16</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CopyGetInt16</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>;</function_decl>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>RemoteCopyOptions</name> <modifier>*</modifier></type><name>GetRemoteCopyOptions</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>append_defvals</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Send copy start/stop messages for frontend copies.  These have changed
 * in past protocol redesigns.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendCopyBegin</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* new way */</comment>
        <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>natts</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int16</name></type>        <name>format</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'H'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* overall format */</comment>
        <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>natts</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>    <comment type="block">/* per-column formats */</comment>
        <expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>=</operator> <name>COPY_NEW_FE</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* old way */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY BINARY is not supported to stdout or from stdin"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'H'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* grottiness needed for old COPY OUT protocol */</comment>
        <expr_stmt><expr><call><name>pq_startcopyout</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>=</operator> <name>COPY_OLD_FE</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReceiveCopyBegin</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* new way */</comment>
        <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>natts</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int16</name></type>        <name>format</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'G'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* overall format */</comment>
        <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>natts</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>    <comment type="block">/* per-column formats */</comment>
        <expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>=</operator> <name>COPY_NEW_FE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* old way */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY BINARY is not supported to stdout or from stdin"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'G'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* any error in old protocol will make us lose sync */</comment>
        <expr_stmt><expr><call><name>pq_startmsgread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>=</operator> <name>COPY_OLD_FE</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* We *must* flush here to ensure FE knows it can send. */</comment>
    <expr_stmt><expr><call><name>pq_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendCopyEnd</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>==</operator> <name>COPY_NEW_FE</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Shouldn't have any unsent data */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Send Copy Done message */</comment>
        <expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'c'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"\\."</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Need to flush out the trailer (this also appends a newline) */</comment>
        <expr_stmt><expr><call><name>CopySendEndOfRow</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pq_endcopyout</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*----------
 * CopySendData sends output data to the destination (file or frontend)
 * CopySendString does the same for null-terminated strings
 * CopySendChar does the same for single characters
 * CopySendEndOfRow does the appropriate thing at end of each data row
 *    (data is not actually flushed except by CopySendEndOfRow)
 *
 * NB: no data conversion is applied by these functions
 *----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopySendData</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>databuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>datasize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>, <argument><expr><name>databuf</name></expr></argument>, <argument><expr><name>datasize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopySendString</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopySendChar</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopySendEndOfRow</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>StringInfo</name></type>    <name>fe_msgbuf</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>COPY_FILE</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Default line termination depends on platform */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
                <expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><call><name>CopySendString</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
                       <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
                <call><name>ferror</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>is_program</name></name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EPIPE</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * The pipe will be closed automatically on error at
                         * the end of transaction, but we might get a better
                         * error message from the subprocess' exit code than
                         * just "Broken Pipe"
                         */</comment>
                        <expr_stmt><expr><call><name>ClosePipeToProgram</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/*
                         * If ClosePipeToProgram() didn't throw an error, the
                         * program terminated normally, but closed the pipe
                         * first. Restore errno, and throw an error.
                         */</comment>
                        <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EPIPE</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to COPY program: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to COPY file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>COPY_OLD_FE</name></expr>:</case>
            <comment type="block">/* The FE/BE protocol uses \n as newline for all platforms */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>pq_putbytes</name><argument_list>(<argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* no hope of recovering connection sync, so FATAL */</comment>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection lost during COPY to stdout"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>COPY_NEW_FE</name></expr>:</case>
            <comment type="block">/* The FE/BE protocol uses \n as newline for all platforms */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* Dump the accumulated row as one CopyData message */</comment>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pq_putmessage</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <case>case <expr><name>COPY_BUFFER</name></expr>:</case>
            <comment type="block">/* Do not send yet anywhere, just return */</comment>
            <return>return;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>COPY_CALLBACK</name></expr>:</case>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* Not yet supported. */</comment>
            <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>fe_msgbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CopyGetData reads data from the source (file or frontend)
 *
 * We attempt to read at least minread, and at most maxread, bytes from
 * the source.  The actual number of bytes read is returned; if this is
 * less than minread, EOF was detected.
 *
 * Note: when copying from the frontend, we expect a proper EOF mark per
 * protocol; if the frontend simply drops the connection, we raise error.
 * It seems unwise to allow the COPY IN to complete normally in that case.
 *
 * NB: no data conversion is applied here.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CopyGetData</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>databuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minread</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxread</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>bytesread</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>whole_line</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>COPY_FILE</name></expr>:</case>
            <expr_stmt><expr><name>bytesread</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>databuf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>maxread</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from COPY file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>COPY_OLD_FE</name></expr>:</case>

            <comment type="block">/*
             * We cannot read more than minread bytes (which in practice is 1)
             * because old protocol doesn't have any clear way of separating
             * the COPY stream from following data.  This is slow, but not any
             * slower than the code path was originally, and we don't care
             * much anymore about the performance of old protocol.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>pq_getbytes</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>databuf</name></expr></argument>, <argument><expr><name>minread</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Only a \. terminator is legal EOF in old protocol */</comment>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection with an open transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>bytesread</name> <operator>=</operator> <name>minread</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>COPY_NEW_FE</name></expr>:</case>
            <while>while <condition>(<expr><name>maxread</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bytesread</name> <operator>&lt;</operator> <name>minread</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>fe_eof</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>            <name>avail</name></decl>;</decl_stmt>

                <while>while <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name><operator>-&gt;</operator><name>cursor</name></name> <operator>&gt;=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Try to receive another message */</comment>
                    <decl_stmt><decl><type><name>int</name></type>            <name>mtype</name></decl>;</decl_stmt>

            <label><name>readmessage</name>:</label>
                    <expr_stmt><expr><call><name>HOLD_CANCEL_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pq_startmsgread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>mtype</name> <operator>=</operator> <call><name>pq_getbyte</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>mtype</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection with an open transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>pq_getmessage</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection with an open transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>RESUME_CANCEL_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <switch>switch <condition>(<expr><name>mtype</name></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><literal type="char">'d'</literal></expr>:</case>    <comment type="block">/* CopyData */</comment>
                            <break>break;</break>
                        <case>case <expr><literal type="char">'c'</literal></expr>:</case>    <comment type="block">/* CopyDone */</comment>
                            <comment type="block">/* COPY IN correctly terminated by frontend */</comment>
                            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_eof</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            <return>return <expr><name>bytesread</name></expr>;</return>
                        <case>case <expr><literal type="char">'f'</literal></expr>:</case>    <comment type="block">/* CopyFail */</comment>
                            <if_stmt><if>if <condition>(<expr><name>g_enable_copy_silence</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_QUERY_CANCELED</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"receive copyfail from cn, msg:%s"</literal></expr></argument>,
                                            <argument><expr><call><name>pq_getmsgstring</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_QUERY_CANCELED</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY from stdin failed: %s"</literal></expr></argument>,
                                            <argument><expr><call><name>pq_getmsgstring</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>
                            <break>break;</break>
                        <case>case <expr><literal type="char">'H'</literal></expr>:</case>    <comment type="block">/* Flush */</comment>
                        <case>case <expr><literal type="char">'S'</literal></expr>:</case>    <comment type="block">/* Sync */</comment>

                            <comment type="block">/*
                             * Ignore Flush/Sync for the convenience of client
                             * libraries (such as libpq) that may send those
                             * without noticing that the command they just
                             * sent was COPY.
                             */</comment>
                            <goto>goto <name>readmessage</name>;</goto>
                        <default>default:</default>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected message type 0x%02X during COPY from stdin"</literal></expr></argument>,
                                            <argument><expr><name>mtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                    </block_content>}</block></switch>
                </block_content>}</block></while>
                <expr_stmt><expr><name>avail</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name><operator>-&gt;</operator><name>cursor</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><name>avail</name> <operator>&gt;</operator> <name>maxread</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>whole_line</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>whole_line</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <if_stmt><if>if <condition>(<expr><name>avail</name> <operator>&gt;</operator> <name>maxread</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>avail</name> <operator>=</operator> <name>maxread</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>pq_copymsgbytes</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>, <argument><expr><name>databuf</name></expr></argument>, <argument><expr><name>avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>databuf</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>databuf</name> <operator>+</operator> <name>avail</name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>maxread</name> <operator>-=</operator> <name>avail</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>bytesread</name> <operator>+=</operator> <name>avail</name></expr>;</expr_stmt>
            </block_content>}</block></while>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <case>case <expr><name>COPY_BUFFER</name></expr>:</case>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"COPY_BUFFER not allowed in this context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>COPY_CALLBACK</name></expr>:</case>
            <expr_stmt><expr><name>bytesread</name> <operator>=</operator> <call><name><name>cstate</name><operator>-&gt;</operator><name>data_source_cb</name></name><argument_list>(<argument><expr><name>databuf</name></expr></argument>, <argument><expr><name>minread</name></expr></argument>, <argument><expr><name>maxread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>bytesread</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * These functions do apply some data conversion
 */</comment>

<comment type="block">/*
 * CopySendInt32 sends an int32 in network byte order
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopySendInt32</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>buf</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CopyGetInt32 reads an int32 that appears in network byte order
 *
 * Returns true if OK, false if EOF
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CopyGetInt32</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>buf</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                <comment type="block">/* suppress compiler warning */</comment>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CopySendInt16 sends an int16 in network byte order
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopySendInt16</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint16</name></type>        <name>buf</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><operator>(</operator><name>uint16</name><operator>)</operator> <name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CopyGetInt16 reads an int16 that appears in network byte order
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CopyGetInt16</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint16</name></type>        <name>buf</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                <comment type="block">/* suppress compiler warning */</comment>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <operator>(</operator><name>int16</name><operator>)</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CopyLoadRawBuf loads some more data into raw_buf
 *
 * Returns TRUE if able to obtain at least one more byte, else FALSE.
 *
 * If raw_buf_index &lt; raw_buf_len, the unprocessed bytes are transferred
 * down to the start of the buffer and then we load more data after that.
 * This case is used only when a frontend multibyte character crosses a
 * bufferload boundary.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CopyLoadRawBuf</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>nbytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>inbytes</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name> <operator>&lt;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Copy down the unprocessed data */</comment>
        <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name> <operator>-</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name></expr></argument>,
                <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>                <comment type="block">/* no data need be saved */</comment>

    <expr_stmt><expr><name>inbytes</name> <operator>=</operator> <call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf</name></name> <operator>+</operator> <name>nbytes</name></expr></argument>,
                          <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>RAW_BUF_SIZE</name> <operator>-</operator> <name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nbytes</name> <operator>+=</operator> <name>inbytes</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf</name><index>[<expr><name>nbytes</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>inbytes</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *     DoCopy executes the SQL COPY statement
 *
 * Either unload or reload contents of table &lt;relation&gt;, depending on &lt;from&gt;.
 * (&lt;from&gt; = TRUE means we are inserting into the table.)  In the "TO" case
 * we also support copying the output of an arbitrary SELECT, INSERT, UPDATE
 * or DELETE query.
 *
 * If &lt;pipe&gt; is false, transfer is between the table and the file named
 * &lt;filename&gt;.  Otherwise, transfer is between the table and our regular
 * input/output stream. The latter could be either stdin/stdout or a
 * socket, depending on whether we're running under Postmaster control.
 *
 * Do not allow a Postgres user without superuser privilege to read from
 * or write to a file.
 *
 * Do not allow the copy if user doesn't have proper permission to access
 * the table or the specifically requested columns.
 */</comment>
<function><type><name>void</name></type>
<name>DoCopy</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CopyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
       <parameter><decl><type><name>int</name></type> <name>stmt_location</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stmt_len</name></decl></parameter>,
       <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>processed</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CopyState</name></type>    <name>cstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_from</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>is_from</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>pipe</name> <init>= <expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>filename</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>query</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Disallow COPY to/from file or program except to superusers. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pipe</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>is_program</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to COPY to or from an external program"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Anyone can COPY to stdout or from stdin. "</literal>
                             <literal type="string">"psql's \\copy command also works for anyone."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <block>{<block_content>
            <comment type="block">/* 
             * if transformed from insert into multi-values, 
             * non-superuser permitted to do copy 
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>insert_into</name></name></expr>)</condition>
            <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to COPY to or from a file"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Anyone can COPY to stdout or from stdin. "</literal>
                             <literal type="string">"psql's \\copy command also works for anyone."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>stmt</name></name> <operator>=</operator> <name>stmt</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupDesc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>attnums</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Open and lock the relation, using the appropriate lock type. */</comment>
        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
                          <argument><expr><operator>(</operator><ternary><condition><expr><name>is_from</name></expr> ?</condition><then> <expr><name>RowExclusiveLock</name></expr> </then><else>: <expr><name>AccessShareLock</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>is_from</name></expr> ?</condition><then> <expr><name>ACL_INSERT</name></expr> </then><else>: <expr><name>ACL_SELECT</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

        <expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>CopyGetAttnums</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>attlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>attnums</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>attno</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call> <operator>-</operator>
            <name>FirstLowInvalidHeapAttributeNumber</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>is_from</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>ExecCheckRTPerms</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Permission check for row security policies.
         *
         * check_enable_rls will ereport(ERROR) if the user has requested
         * something invalid and will otherwise indicate if we should enable
         * RLS (returns RLS_ENABLED) or not for this COPY statement.
         *
         * If the relation has a row security policy and we are to apply it
         * then perform a "query" copy and allow the normal query processing
         * to handle the policies.
         *
         * If RLS is not enabled for this, then just fall through to the
         * normal non-filtering relation handling.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>check_enable_rls</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RLS_ENABLED</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>select</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>cr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>from</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>targetList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>is_from</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY FROM not supported with row-level security"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use INSERT statements instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Build target list
             *
             * If no columns are specified in the attribute list of the COPY
             * command, then the target list is 'all' columns. Therefore, '*'
             * should be used as the target list for the resulting SELECT
             * statement.
             *
             * In the case that columns are specified in the attribute list,
             * create a ColumnRef and ResTarget for each column and add them
             * to the target list for the resulting SELECT statement.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>attlist</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>cr</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeNode</name><argument_list>(<argument><expr><name>A_Star</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>cr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

                <expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ResTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>indirection</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cr</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

                <expr_stmt><expr><name>targetList</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;attlist</argument>)</argument_list></macro>
                <block>{<block_content>
                    <comment type="block">/*
                     * Build the ColumnRef for each column.  The ColumnRef
                     * 'fields' property is a String 'Value' node (see
                     * nodes/value.h) that corresponds to the column name
                     * respectively.
                     */</comment>
                    <expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cr</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

                    <comment type="block">/* Build the ResTarget and add the ColumnRef to it. */</comment>
                    <expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ResTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>indirection</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cr</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

                    <comment type="block">/* Add each column to the SELECT statement's target list */</comment>
                    <expr_stmt><expr><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/*
             * Build RangeVar for from clause, fully qualified based on the
             * relation which we have opened and locked.
             */</comment>
            <expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Build query */</comment>
            <expr_stmt><expr><name>select</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>select</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>targetList</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>select</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>stmt</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>select</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name>stmt_location</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name>stmt_len</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Close the relation for now, but keep the lock on it to prevent
             * changes between now and when we start the query-based COPY.
             *
             * We'll reopen it later as part of the query-based COPY.
             */</comment>
            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>stmt</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name>stmt_location</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name>stmt_len</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>relid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>is_from</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* check read-only transaction,gtm read-only flag and parallel mode */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>XactReadOnly</name>  <operator>||</operator> <name>GTM_ReadOnly</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>rel</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PreventCommandIfReadOnly</name><argument_list>(<argument><expr><literal type="string">"COPY FROM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>PreventCommandIfParallelMode</name><argument_list>(<argument><expr><literal type="string">"COPY FROM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>cstate</name> <operator>=</operator> <call><name>BeginCopyFrom</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_program</name></name></expr></argument>,
                               <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>attlist</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>processed</name> <operator>=</operator> <call><name>CopyFrom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* copy from file to database */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <comment type="block">/*
         * We should record insert to distributed table.
         * Bulk inserts into local tables are recorded when heap tuples are
         * written.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pgstat_count_remote_insert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>*</operator><name>processed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>EndCopyFrom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type> <name>bms_shards</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if<condition>(<expr><name>rel</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RelationIsSharded</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>shards</name></name></expr>)</condition>
        <block>{<block_content>            
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"relation %d is not a sharded table, so it can not be export by specifed shardid."</literal></expr></argument>, 
                        <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <if_stmt><if>if<condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>shards</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>shardid</name></decl>;</decl_stmt>
            
            <macro><name>foreach</name><argument_list>(<argument>lc</argument>,<argument>stmt-&gt;shards</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>A_Const</name> <modifier>*</modifier></type> <name>cons</name> <init>= <expr><operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if<condition>(<expr><name><name>cons</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>T_Integer</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"shard must be a integer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                
                <expr_stmt><expr><name>shardid</name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cons</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name>shardid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"shardid %d is invalid."</literal></expr></argument>, <argument><expr><name>shardid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>bms_shards</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>bms_shards</name></expr></argument>, <argument><expr><name>shardid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>cstate</name> <operator>=</operator> <call><name>BeginCopyTo</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>,
                             <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_program</name></name></expr></argument>,
                             <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>attlist</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
                            <argument><expr><name>bms_shards</name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                             
                             )</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>processed</name> <operator>=</operator> <call><name>DoCopyTo</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* copy from database to file */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>shard_array</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>shard_array</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>am_walsender</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AmTbaseSubscriptionWalSender</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyReplicationSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>MyReplicationSlot</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>subid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>UpdatePubStatistics</name><argument_list>(<argument><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>subname</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><operator>*</operator><name>processed</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>UpdatePubTableStatistics</name><argument_list>(<argument><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>subid</name></name></expr></argument>, <argument><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><operator>*</operator><name>processed</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        
        <expr_stmt><expr><call><name>EndCopyTo</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Close the relation. If reading, we can release the AccessShareLock we
     * got; if writing, we should hold the lock until end of transaction to
     * ensure that updates will be committed before lock is released.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>rel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>is_from</name></expr> ?</condition><then> <expr><name>NoLock</name></expr> </then><else>: <expr><name>AccessShareLock</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process the statement option list for COPY.
 *
 * Scan the options list (a list of DefElem) and transpose the information
 * into cstate, applying appropriate error checking.
 *
 * cstate is assumed to be filled with zeroes initially.
 *
 * This is exported so that external users of the COPY API can sanity-check
 * a list of options.  In that usage, cstate should be passed as NULL
 * (since external users don't know sizeof(CopyStateData)) and the collected
 * data is just leaked until CurrentMemoryContext is reset.
 *
 * Note that additional checking, such as whether column names listed in FORCE
 * QUOTE actually exist, has to be applied later.  This just checks for
 * self-consistency of the options list.
 */</comment>
<function><type><name>void</name></type>
<name>ProcessCopyOptions</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
                   <parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>,
                   <parameter><decl><type><name>bool</name></type> <name>is_from</name></decl></parameter>,
                   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>format_specified</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>

    <comment type="block">/* Support external use for option sanity checking */</comment>
    <if_stmt><if>if <condition>(<expr><name>cstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>cstate</name> <operator>=</operator> <operator>(</operator><name>CopyStateData</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CopyStateData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* Extract options from the statement node tree */</comment>
    <macro><name>foreach</name><argument_list>(<argument>option</argument>, <argument>options</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"format"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>fmt</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>format_specified</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>format_specified</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><literal type="string">"text"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                 <comment type="block">/* default format */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><literal type="string">"csv"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><literal type="string">"binary"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><literal type="string">"internal"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>internal_mode</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"COPY format \"%s\" not recognized"</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY format \"%s\" not recognized"</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"oids"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>oids</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>oids</name></name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"freeze"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>freeze</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>freeze</name></name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"delimiter"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"header"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>header_line</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>header_line</name></name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"quote"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>quote</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>quote</name></name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"escape"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"force_quote"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote</name></name> <operator>||</operator> <name><name>cstate</name><operator>-&gt;</operator><name>force_quote_all</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>A_Star</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote_all</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote</name></name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument to option \"%s\" must be a list of column names"</literal></expr></argument>,
                                <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"force_not_null"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_notnull</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_notnull</name></name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument to option \"%s\" must be a list of column names"</literal></expr></argument>,
                                <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"force_null"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_null</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_null</name></name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument to option \"%s\" must be a list of column names"</literal></expr></argument>,
                                <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"convert_selectively"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Undocumented, not-accessible-from-SQL option: convert only the
             * named columns to binary form, storing the rest as NULLs. It's
             * allowed for the column list to be NIL.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>convert_selectively</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>convert_selectively</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>convert_select</name></name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument to option \"%s\" must be a list of column names"</literal></expr></argument>,
                                <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"encoding"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name> <operator>=</operator> <call><name>pg_char_to_encoding</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument to option \"%s\" must be a valid encoding name"</literal></expr></argument>,
                                <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"option \"%s\" not recognized"</literal></expr></argument>,
                            <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Check for incompatible options (must do these two before inserting
     * defaults)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot specify DELIMITER in BINARY mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot specify NULL in BINARY mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Set defaults for omitted options */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name> <operator>=</operator> <ternary><condition><expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr> ?</condition><then> <expr><literal type="string">","</literal></expr> </then><else>: <expr><literal type="string">"\t"</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name> <operator>=</operator> <ternary><condition><expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"\\N"</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print_len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>quote</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>quote</name></name> <operator>=</operator> <literal type="string">"\""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>quote</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Only single-byte delimiter strings are supported. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY delimiter must be a single one-byte character"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Disallow end-of-line characters */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name></expr></argument>, <argument><expr><literal type="char">'\r'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
        <call><name>strchr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY delimiter cannot be newline or carriage return"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>, <argument><expr><literal type="char">'\r'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
        <call><name>strchr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY null representation cannot use newline or carriage return"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Disallow unsafe delimiter characters in non-CSV mode.  We can't allow
     * backslash because it would be ambiguous.  We can't allow the other
     * cases because data characters matching the delimiter must be
     * backslashed, and certain backslash combinations are interpreted
     * non-literally by COPY IN.  Disallowing all lower case ASCII letters is
     * more than strictly necessary, but seems best for consistency and
     * future-proofing.  Likewise we disallow all digits though only octal
     * digits are actually dangerous.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator>
        <call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"\\.abcdefghijklmnopqrstuvwxyz0123456789"</literal></expr></argument>,
               <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY delimiter cannot be \"%s\""</literal></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check header */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>header_line</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY HEADER available only in CSV mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check quote */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>quote</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY quote available only in CSV mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>quote</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY quote must be a single one-byte character"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>cstate</name><operator>-&gt;</operator><name>quote</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY delimiter and quote must be different"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check escape */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY escape available only in CSV mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY escape must be a single one-byte character"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check force_quote */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>force_quote</name></name> <operator>||</operator> <name><name>cstate</name><operator>-&gt;</operator><name>force_quote_all</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY force quote available only in CSV mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>force_quote</name></name> <operator>||</operator> <name><name>cstate</name><operator>-&gt;</operator><name>force_quote_all</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <name>is_from</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY force quote only available using COPY TO"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check force_notnull */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>force_notnull</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY force not null available only in CSV mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_notnull</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_from</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY force not null only available using COPY FROM"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check force_null */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>force_null</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY force null available only in CSV mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_null</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_from</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY force null only available using COPY FROM"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Don't allow the delimiter to appear in the null string. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY delimiter must not appear in the NULL specification"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Don't allow the CSV quote char to appear in the null string. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>&amp;&amp;</operator>
        <call><name>strchr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>quote</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CSV quote character must not appear in the NULL specification"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Common setup routines used by BeginCopyFrom and BeginCopyTo.
 *
 * Iff &lt;binary&gt;, unload or reload in the binary format, as opposed to the
 * more wasteful but more robust and portable text format.
 *
 * Iff &lt;oids&gt;, unload or reload the format that includes OID information.
 * On input, we accept OIDs whether or not the table has an OID column,
 * but silently drop them if it does not.  On output, we report an error
 * if the user asks for OIDs in a table that has none (not providing an
 * OID column might seem friendlier, but could seriously confuse programs).
 *
 * If in the text format, delimit columns with delimiter &lt;delim&gt; and print
 * NULL values as &lt;null_print&gt;.
 */</comment>
<function><type><specifier>static</specifier> <name>CopyState</name></type>
<name>BeginCopy</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
          <parameter><decl><type><name>bool</name></type> <name>is_from</name></decl></parameter>,
          <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
          <parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>raw_query</name></decl></parameter>,
          <parameter><decl><type><name>Oid</name></type> <name>queryRelId</name></decl></parameter>,
          <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attnamelist</name></decl></parameter>,
          <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
          <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type> <name>shards</name></decl></parameter>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CopyState</name></type>    <name>cstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_phys_attrs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <comment type="block">/* Allocate workspace and zero all fields */</comment>
    <expr_stmt><expr><name>cstate</name> <operator>=</operator> <operator>(</operator><name>CopyStateData</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CopyStateData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We allocate everything used by a cstate in a new memory context. This
     * avoids memory leaks during repeated use of COPY in a query.
     */</comment>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copycontext</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                                <argument><expr><literal type="string">"COPY"</literal></expr></argument>,
                                                <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copycontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Extract options from the statement node tree */</comment>
    <expr_stmt><expr><call><name>ProcessCopyOptions</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>is_from</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>shard_array</name></name> <operator>=</operator> <name>shards</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>insert_into</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Process the source/target relation or query */</comment>
    <if_stmt><if>if <condition>(<expr><name>rel</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>raw_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Don't allow COPY w/ OIDs to or from a table without them */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>oids</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" does not have OIDs"</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * If there are any triggers with transition tables on the named
         * relation, we need to be prepared to capture transition tuples.
         */</comment>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>transition_capture</name></name> <operator>=</operator> <call><name>MakeTransitionCaptureState</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Initialize state for CopyFrom tuple routing. */</comment>
        <if_stmt><if>if <condition>(<expr><name>is_from</name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>proute</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>partition_tuple_routing</name></name> <operator>=</operator>
			<call><name>ExecSetupPartitionTupleRouting</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If we are capturing transition tuples, they may need to be
             * converted from partition format back to partitioned table
             * format (this is only ever necessary if a BEFORE trigger
             * modifies the tuple).
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>transition_capture</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecSetupChildParentMapForLeaf</name><argument_list>(<argument><expr><name>proute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <comment type="block">/* Get copy statement and execution node information */</comment>
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RemoteCopyData</name> <modifier>*</modifier></type><name>remoteCopyState</name> <init>= <expr><operator>(</operator><name>RemoteCopyData</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RemoteCopyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>attnums</name> <init>= <expr><call><name>CopyGetAttnums</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>attnamelist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Setup correct COPY FROM/TO flag */</comment>
            <expr_stmt><expr><name><name>remoteCopyState</name><operator>-&gt;</operator><name>is_from</name></name> <operator>=</operator> <name>is_from</name></expr>;</expr_stmt>

            <comment type="block">/* Get execution node list */</comment>
            <expr_stmt><expr><call><name>RemoteCopy_GetRelationLoc</name><argument_list>(<argument><expr><name>remoteCopyState</name></expr></argument>,
                                      <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>,
                                      <argument><expr><name>attnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>pstate</name> <operator>&amp;&amp;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>stmt</name></name> <operator>&amp;&amp;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>stmt</name><operator>-&gt;</operator><name>insert_into</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>insert_into</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/* Build remote query */</comment>
            <expr_stmt><expr><call><name>RemoteCopy_BuildStatement</name><argument_list>(<argument><expr><name>remoteCopyState</name></expr></argument>,
                                      <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>,
                                      <argument><expr><call><name>GetRemoteCopyOptions</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>attnamelist</name></expr></argument>,
                                      <argument><expr><name>attnums</name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
                                        <argument><expr><name>shards</name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                        )</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Then assign built structure */</comment>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>remoteCopyState</name></name> <operator>=</operator> <name>remoteCopyState</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>rewritten</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <comment type="block">/* Don't allow COPY w/ OIDs from a query */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>oids</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY (query) WITH OIDS is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * The grammar allows SELECT INTO, but we don't support that. We do
         * this check before transforming the query since QueryRewriteCTAS will
         * transform the statemet into a CREATE TABLE followed by INSERT INTO.
         * The CREATE TABLE is processed separately by QueryRewriteCTAS and
         * what we get back is just the INSERT statement. Not doing a check
         * will ultimately lead to an error, but doing it here allows us to
         * throw a more friendly and PG-compatible error.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>raw_query</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>, <argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>SelectStmt</name> <operator>*</operator><operator>)</operator> <name><name>raw_query</name><operator>-&gt;</operator><name>stmt</name></name></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * If it's a set-operation tree, drilldown to leftmost SelectStmt
             */</comment>
            <while>while <condition>(<expr><name>stmt</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>op</name></name> <operator>!=</operator> <name>SETOP_NONE</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>stmt</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>larg</name></name></expr>;</expr_stmt></block_content></block></while>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>stmt</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>larg</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>stmt</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>intoClause</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY (SELECT INTO) is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Run parse analysis and rewrite.  Note this also acquires sufficient
         * locks on the source table(s).
         *
         * Because the parser and planner tend to scribble on their input, we
         * make a preliminary copy of the source querytree.  This prevents
         * problems in the case that the COPY is in a portal or plpgsql
         * function and is executed repeatedly.  (See also the same hack in
         * DECLARE CURSOR and PREPARE.)  XXX FIXME someday.
         */</comment>
        <expr_stmt><expr><name>rewritten</name> <operator>=</operator> <call><name>pg_analyze_and_rewrite</name><argument_list>(<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>raw_query</name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                           <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* check that we got back something we can work with */</comment>
        <if_stmt><if>if <condition>(<expr><name>rewritten</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DO INSTEAD NOTHING rules are not supported for COPY"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>rewritten</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

            <comment type="block">/* examine queries to determine which error message to issue */</comment>
            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rewritten</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>q</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>q</name><operator>-&gt;</operator><name>querySource</name></name> <operator>==</operator> <name>QSRC_QUAL_INSTEAD_RULE</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conditional DO INSTEAD rules are not supported for COPY"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>q</name><operator>-&gt;</operator><name>querySource</name></name> <operator>==</operator> <name>QSRC_NON_INSTEAD_RULE</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DO ALSO rules are not supported for the COPY"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block>

            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multi-statement DO INSTEAD rules are not supported for COPY"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>rewritten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Similarly the grammar doesn't enforce the presence of a RETURNING
         * clause, but this is required here.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator>
            <name><name>query</name><operator>-&gt;</operator><name>returningList</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>||</operator>
                   <name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator>
                   <name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY query must have a RETURNING clause"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* plan the query */</comment>
        <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>pg_plan_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>CURSOR_OPT_PARALLEL_OK</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * With row level security and a user using "COPY relation TO", we
         * have to convert the "COPY relation TO" to a query-based COPY (eg:
         * "COPY (SELECT * FROM relation) TO"), to allow the rewriter to add
         * in any RLS clauses.
         *
         * When this happens, we are passed in the relid of the originally
         * found relation (which we have locked).  As the planner will look up
         * the relation again, we double-check here to make sure it found the
         * same one that we have locked.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>queryRelId</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Note that with RLS involved there may be multiple relations,
             * and while the one we need is almost certainly first, we don't
             * make any guarantees of that in the planner, so check the whole
             * list and make sure we find the original relation.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>relationOids</name></name></expr></argument>, <argument><expr><name>queryRelId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation referenced by COPY statement has changed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Use a snapshot with an updated command ID to ensure this query sees
         * results of any previously executed queries.
         */</comment>
        <expr_stmt><expr><call><name>PushCopiedSnapshot</name><argument_list>(<argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UpdateActiveSnapshotCommandId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Create dest receiver for COPY OUT */</comment>
        <expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>DestCopyOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>DR_copy</name> <operator>*</operator><operator>)</operator> <name>dest</name><operator>)</operator><operator>-&gt;</operator><name>cstate</name> <operator>=</operator> <name>cstate</name></expr>;</expr_stmt>

        <comment type="block">/* Create a QueryDesc requesting no output */</comment>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name></name> <operator>=</operator> <call><name>CreateQueryDesc</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name></expr></argument>,
                                            <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>,
                                            <argument><expr><name>InvalidSnapshot</name></expr></argument>,
                                            <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Call ExecutorStart to prepare the plan for execution.
         *
         * ExecutorStart computes a result tupdesc for us
         */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecutorStart</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name></name></expr></argument>, <argument><expr><name>EXEC_FLAG_RETURNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecutorStart</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Generate or convert list of attributes to process */</comment>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name> <operator>=</operator> <call><name>CopyGetAttnums</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>attnamelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>num_phys_attrs</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

    <comment type="block">/* Convert FORCE_QUOTE name list to per-column flags, check validity */</comment>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote_flags</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote_all</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_phys_attrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote_flags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>attnums</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>CopyGetAttnums</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>attnums</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_int</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FORCE_QUOTE column \"%s\" not referenced by COPY"</literal></expr></argument>,
                                <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote_flags</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Convert FORCE_NOT_NULL name list to per-column flags, check validity */</comment>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_notnull_flags</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_notnull</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>attnums</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>CopyGetAttnums</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_notnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>attnums</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_int</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FORCE_NOT_NULL column \"%s\" not referenced by COPY"</literal></expr></argument>,
                                <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_notnull_flags</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Convert FORCE_NULL name list to per-column flags, check validity */</comment>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_null_flags</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_null</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>attnums</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>CopyGetAttnums</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_null</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>attnums</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_int</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FORCE_NULL column \"%s\" not referenced by COPY"</literal></expr></argument>,
                                <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_null_flags</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Convert convert_selectively name list to per-column flags */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>convert_selectively</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>attnums</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>convert_select_flags</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>CopyGetAttnums</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>convert_select</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>attnums</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_int</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"selected column \"%s\" not referenced by COPY"</literal></expr></argument>,
                                         <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>convert_select_flags</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Use client encoding when ENCODING option is not specified. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name> <operator>=</operator> <call><name>pg_get_client_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Set up encoding conversion info.  Even if the file and server encodings
     * are the same, we must apply pg_any_to_server() to validate data in
     * multibyte encodings.
     */</comment>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>need_transcoding</name></name> <operator>=</operator>
        <operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name> <operator>!=</operator> <call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call> <operator>||</operator>
         <call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <comment type="block">/* See Multibyte encoding comment above */</comment>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>encoding_embeds_ascii</name></name> <operator>=</operator> <call><name>PG_ENCODING_IS_CLIENT_ONLY</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>=</operator> <name>COPY_FILE</name></expr>;</expr_stmt>    <comment type="block">/* default */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/*
     * We are here just at copy begin process,
     * so only pick up the list of connections.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RemoteCopyData</name> <modifier>*</modifier></type><name>remoteCopyState</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>remoteCopyState</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * In the case of CopyOut, it is just necessary to pick up one node randomly.
         * This is done when rel_loc is found.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>remoteCopyState</name> <operator>&amp;&amp;</operator> <name><name>remoteCopyState</name><operator>-&gt;</operator><name>rel_loc</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>DataNodeCopyBegin</name><argument_list>(<argument><expr><name>remoteCopyState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>remoteCopyState</name><operator>-&gt;</operator><name>locator</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to initialize Datanodes for COPY"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>cstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Closes the pipe to an external program, checking the pclose() return code.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ClosePipeToProgram</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>pclose_rc</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>is_program</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pclose_rc</name> <operator>=</operator> <call><name>ClosePipeStream</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>pclose_rc</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close pipe to external command: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>pclose_rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"program \"%s\" failed"</literal></expr></argument>,
                        <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>wait_result_to_str</name><argument_list>(<argument><expr><name>pclose_rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Release resources allocated in a cstate for COPY TO/FROM.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EndCopy</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>is_program</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ClosePipeToProgram</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>&amp;&amp;</operator> <call><name>FreeFile</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>FreeFile</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copycontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Setup CopyState to read tuples from a table or a query for COPY TO.
 */</comment>
<function><type><specifier>static</specifier> <name>CopyState</name></type>
<name>BeginCopyTo</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
            <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
            <parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
            <parameter><decl><type><name>Oid</name></type> <name>queryRelId</name></decl></parameter>,
            <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
            <parameter><decl><type><name>bool</name></type> <name>is_program</name></decl></parameter>,
            <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attnamelist</name></decl></parameter>,
            <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
            <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type> <name>shards</name></decl></parameter>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>            
            )</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CopyState</name></type>    <name>cstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>pipe</name> <init>= <expr><operator>(</operator><name>filename</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>rel</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy from view \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try the COPY (SELECT ...) TO variant."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy from materialized view \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try the COPY (SELECT ...) TO variant."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy from foreign table \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try the COPY (SELECT ...) TO variant."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy from sequence \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy from partitioned table \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try the COPY (SELECT ...) TO variant."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy from non-table relation \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>cstate</name> <operator>=</operator> <call><name>BeginCopy</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>queryRelId</name></expr></argument>, <argument><expr><name>attnamelist</name></expr></argument>,
                       <argument><expr><name>options</name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
                        <argument><expr><name>shards</name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copycontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>pipe</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_program</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* the grammar does not allow this */</comment>
        <if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>!=</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>is_program</name></name> <operator>=</operator> <name>is_program</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>is_program</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>=</operator> <call><name>OpenPipeStream</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not execute command \"%s\": %m"</literal></expr></argument>,
                                <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>mode_t</name></type>        <name>oumask</name></decl>;</decl_stmt> <comment type="block">/* Pre-existing umask value */</comment>
            <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

            <comment type="block">/*
             * Prevent write to relative path ... too easy to shoot oneself in
             * the foot by overwriting a database file ...
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_absolute_path</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relative path not allowed for COPY to file"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>oumask</name> <operator>=</operator> <call><name>umask</name><argument_list>(<argument><expr><name>S_IWGRP</name> <operator>|</operator> <name>S_IWOTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>oumask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* copy errno because ereport subfunctions might change it */</comment>
                <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\" for writing: %m"</literal></expr></argument>,
                                <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                         <ternary><condition><expr><operator>(</operator><name>save_errno</name> <operator>==</operator> <name>ENOENT</name> <operator>||</operator> <name>save_errno</name> <operator>==</operator> <name>EACCES</name><operator>)</operator></expr> ?</condition><then>
                         <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"COPY TO instructs the PostgreSQL server process to write a file. "</literal>
                                 <literal type="string">"You may want a client-side facility such as psql's \\copy."</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>,
                                <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a directory"</literal></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>cstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This intermediate routine exists mainly to localize the effects of setjmp
 * so we don't need to plaster a lot of variables with "volatile".
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>DoCopyTo</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>pipe</name> <init>= <expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>fe_copy</name> <init>= <expr><operator>(</operator><name>pipe</name> <operator>&amp;&amp;</operator> <name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>processed</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>fe_copy</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>SendCopyBegin</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>processed</name> <operator>=</operator> <call><name>CopyTo</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>fe_copy</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>SendCopyEnd</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <comment type="block">/*
         * Make sure we turn off old-style COPY OUT mode upon error. It is
         * okay to do this in all cases, since it does nothing if the mode is
         * not on.
         */</comment>
        <expr_stmt><expr><call><name>pq_endcopyout</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>processed</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Clean up storage and release resources for COPY TO.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EndCopyTo</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Close down the query and free resources. */</comment>
        <expr_stmt><expr><call><name>ExecutorFinish</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExecutorEnd</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FreeQueryDesc</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Clean up storage */</comment>
    <expr_stmt><expr><call><name>EndCopy</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Copy from relation or query TO file.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>CopyTo</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_phys_attrs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>attr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>processed</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name>attr</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>num_phys_attrs</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print_client</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr>;</expr_stmt> <comment type="block">/* default */</comment>

    <comment type="block">/* We use fe_msgbuf as a per-row buffer regardless of copy_dest */</comment>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get info about the columns we need to process. */</comment>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>out_functions</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>cstate-&gt;attnumlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>out_func_oid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isvarlena</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>getTypeBinaryOutputInfo</name><argument_list>(<argument><expr><name><name>attr</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>out_func_oid</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>attr</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>out_func_oid</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>out_func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>out_functions</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Create a temporary memory context that we can reset once per row to
     * recover palloc'd memory.  This avoids any problems with leaks inside
     * datatype output routines, and should be faster than retail pfree's
     * anyway.  (We don't need a whole econtext as CopyFrom does.)
     */</comment>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>rowcontext</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                               <argument><expr><literal type="string">"COPY TO"</literal></expr></argument>,
                                               <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Generate header for a binary copy */</comment>
        <decl_stmt><decl><type><name>int32</name></type>        <name>tmp</name></decl>;</decl_stmt>

        <comment type="block">/* Signature */</comment>
        <expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BinarySignature</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Flags field */</comment>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>oids</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>tmp</name> <operator>|=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>CopySendInt32</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* No header extension */</comment>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CopySendInt32</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <comment type="block">/* Need to flush out the trailer */</comment>
        <expr_stmt><expr><call><name>CopySendEndOfRow</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * For non-binary copy, we need to convert null_print to file
         * encoding, because it will be sent directly with CopySendString.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>need_transcoding</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print_client</name></name> <operator>=</operator> <call><name>pg_server_to_any</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>,
                                                         <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print_len</name></name></expr></argument>,
                                                         <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* if a header has been requested send the line */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>header_line</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type>        <name>hdr_delim</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

            <macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>cstate-&gt;attnumlist</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>hdr_delim</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>hdr_delim</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>CopyAttributeOutCSV</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                    <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>

            <expr_stmt><expr><call><name>CopySendEndOfRow</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator>
        <name><name>cstate</name><operator>-&gt;</operator><name>remoteCopyState</name></name> <operator>&amp;&amp;</operator>
        <name><name>cstate</name><operator>-&gt;</operator><name>remoteCopyState</name><operator>-&gt;</operator><name>rel_loc</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RemoteCopyData</name> <modifier>*</modifier></type><name>rcstate</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>remoteCopyState</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>processed</name> <operator>=</operator> <call><name>DataNodeCopyOut</name><argument_list>(
                    <argument><expr><operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>getLocatorNodeMap</name><argument_list>(<argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>getLocatorNodeCount</name><argument_list>(<argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><ternary><condition><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>==</operator> <name>COPY_FILE</name></expr> ?</condition><then> <expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scandesc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <decl_stmt><decl><type><name>int</name></type>         <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>       <name>nchildren</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Bitmapset</name>   <modifier>*</modifier></type><name>children</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>partoid</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
        <decl_stmt><decl><type><name>int16</name></type>       <name>cls_attnum</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>         <name>parent_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>has_datamask</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <decl_stmt><decl><type><name>ShardID</name></type>        <name>shardid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>diskey</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>secdiskey</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>error_shards</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if<condition>(<expr><call><name>RelationIsSharded</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>diskey</name> <operator>=</operator> <call><name>RelationGetDisKey</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><name>diskey</name> <operator>&gt;</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"AttrNum[%d] of distribute key is invalid, "</literal></expr></argument>,<argument><expr><name>diskey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>secdiskey</name> <operator>=</operator> <call><name>RelationGetSecDisKey</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_cls_struct</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>cls_attnum</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_cls_struct</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="line">//partitioned table</comment>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>nparts</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>partrels</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        
        <comment type="block">/* open partitions */</comment>
        <if_stmt><if>if<condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>            
            <expr_stmt><expr><name>parent_oid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/* skip patitions by cold data strategy */</comment>
            <expr_stmt><expr><name>nchildren</name> <operator>=</operator> <call><name>RelationGetNParts</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>children</name>  <operator>=</operator> <call><name>bms_init_set</name><argument_list>(<argument><expr><name>nchildren</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
            <expr_stmt><expr><call><name>PruneHotData</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>partrels</name></name> <operator>=</operator> <operator>(</operator><name>Relation</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>nchildren</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Relation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>nparts</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nchildren</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>partoid</name> <operator>=</operator> <call><name>RelationGetPartition</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>partoid</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="line">//elog(ERROR, "internal error: relation has not this partition[%d]", i);</comment>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>partrels</name><index>[<expr><name><name>cstate</name><operator>-&gt;</operator><name>nparts</name></name></expr>]</index></name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>partoid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    
                    <comment type="block">/* increase partition number */</comment>
                    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>nparts</name></name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>parent_oid</name>   <operator>=</operator> <call><name>mls_get_parent_oid</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        
        <expr_stmt><expr><name>has_datamask</name> <operator>=</operator> <call><name>datamask_check_table_has_datamask</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if<condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>nparts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>shardid</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>processed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            
            <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name>scandesc</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>partrels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>bool</name></type> <name>isdeformed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* this tuple is belong shard group?*/</comment>
                    <if_stmt><if>if<condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>shard_array</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>shardid</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>HeapTupleGetShardId</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    
                                    
                        <if_stmt><if>if<condition>(<expr><name>shardid</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>shardid</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>shard_array</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <continue>continue;</continue></block_content></block></if></if_stmt>
                        
                        <comment type="line">//recoumpute shardid</comment>
                        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name>shardid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RelationIsSharded</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>Datum</name></type> <name>value</name></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>bool</name></type>  <name>isdisnull</name></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>Oid</name></type>   <name>typeOfDistCol</name></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>Datum</name></type> <name>secValue</name></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>bool</name></type>  <name>issecnull</name></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>Oid</name></type>   <name>typeOfSecDistCol</name></decl>;</decl_stmt>
                            
                            <comment type="line">//elog(INFO, "[shardiderror] shardid cannot be invalid in shard tables %s.", RelationGetRelationName(cstate-&gt;partrels[i]));</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
                            <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>transp_crypt</name></name></expr>)</condition>
                            <block>{<block_content>
                            	<expr_stmt><expr><call><name>trsprt_crypt_dcrpt_all_col_vale_cp</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                                
                                <expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
                            </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            
                            <expr_stmt><expr><name>isdeformed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            
                            <comment type="block">/* process sharding maping */</comment>
                            <if_stmt><if>if <condition>(<expr><name>diskey</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition> 
                            <block>{<block_content>
                                <expr_stmt><expr><name>typeOfDistCol</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>attrs</name><index>[<expr><name>diskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>value</name>          <operator>=</operator> <name><name>values</name><index>[<expr><name>diskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>isdisnull</name>      <operator>=</operator> <name><name>nulls</name><index>[<expr><name>diskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <expr_stmt><expr><name>typeOfDistCol</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>value</name>          <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name>isdisnull</name>      <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>
                            
                            <if_stmt><if>if <condition>(<expr><name>secdiskey</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>typeOfSecDistCol</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>attrs</name><index>[<expr><name>secdiskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>secValue</name>         <operator>=</operator> <name><name>values</name><index>[<expr><name>secdiskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>issecnull</name>         <operator>=</operator> <name><name>nulls</name><index>[<expr><name>secdiskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <expr_stmt><expr><name>typeOfSecDistCol</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>secValue</name>          <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name>issecnull</name>      <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>
                            
        
                            <expr_stmt><expr><name>shardid</name> <operator>=</operator> <call><name>EvaluateShardId</name><argument_list>(<argument><expr><name>typeOfDistCol</name></expr></argument>, <argument><expr><name>isdisnull</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
                                                      <argument><expr><name>typeOfSecDistCol</name></expr></argument>, <argument><expr><name>issecnull</name></expr></argument>, <argument><expr><name>secValue</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <comment type="line">//HeapTupleHeaderSetShardId(tuple, shardId);        </comment>

                            <if_stmt><if>if<condition>(<expr><name>shardid</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>shardid</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>shard_array</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                <continue>continue;</continue></block_content></block></if></if_stmt>
        
                            <if_stmt><if>if<condition>(<expr><name>shardid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"recompute shardid failed. shardid is %d"</literal></expr></argument>, <argument><expr><name>shardid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>

                    </block_content>}</block></if></if_stmt>
                    <comment type="block">/* Deconstruct the tuple ... faster than repeated heap_getattr */</comment>
                    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>isdeformed</name></expr>)</condition>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>                        
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>transp_crypt</name></name></expr>)</condition>
                        <block>{<block_content>
                        	<expr_stmt><expr><call><name>trsprt_crypt_dcrpt_all_col_vale_cp</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>       
                            <expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                        

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
                    <if_stmt><if>if <condition>(<expr><name>has_datamask</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>dmask_exchg_all_cols_value_copy</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>parent_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name>InvalidAttrNumber</name> <operator>!=</operator> <name>cls_attnum</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>mls_cls_check_row_validation_in_cp</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>cls_attnum</name> <operator>-</operator><literal type="number">1</literal></expr> ]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <continue>continue;</continue>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                    <comment type="block">/* Format and send the data */</comment>
                    <expr_stmt><expr><call><name>CopyOneRowTo</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>processed</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></while>
                <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>scandesc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></for>

            <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>partrels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>partrels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>partrels</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

        <expr_stmt><expr><name>scandesc</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>processed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>transp_crypt</name></name></expr>)</condition>
            <block>{<block_content>
            	<expr_stmt><expr><call><name>trsprt_crypt_dcrpt_all_col_vale_cp</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/* Deconstruct the tuple ... faster than repeated heap_getattr */</comment>
                <expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
            </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>            
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
            <if_stmt><if>if<condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>shard_array</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>shardid</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>HeapTupleGetShardId</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if<condition>(<expr><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name>shardid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>shardid</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>shard_array</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                
                <comment type="line">//recoumpute shardid</comment>
                <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name>shardid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RelationIsSharded</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Datum</name></type> <name>value</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name></type>  <name>isdisnull</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Oid</name></type>   <name>typeOfDistCol</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Datum</name></type> <name>secValue</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name></type>  <name>issecnull</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Oid</name></type>   <name>typeOfSecDistCol</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>error_shards</name><operator>++</operator></expr>;</expr_stmt>

                    <comment type="block">/* process sharding maping */</comment>
                    <expr_stmt><expr><name>typeOfDistCol</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>attrs</name><index>[<expr><name>diskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>value</name>           <operator>=</operator> <name><name>values</name><index>[<expr><name>diskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>isdisnull</name>      <operator>=</operator> <name><name>nulls</name><index>[<expr><name>diskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>secdiskey</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>typeOfSecDistCol</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>attrs</name><index>[<expr><name>secdiskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>secValue</name>         <operator>=</operator> <name><name>values</name><index>[<expr><name>secdiskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>issecnull</name>         <operator>=</operator> <name><name>nulls</name><index>[<expr><name>secdiskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>typeOfSecDistCol</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>secValue</name>          <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>issecnull</name>      <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>

                    <expr_stmt><expr><name>shardid</name> <operator>=</operator> <call><name>EvaluateShardId</name><argument_list>(<argument><expr><name>typeOfDistCol</name></expr></argument>, <argument><expr><name>isdisnull</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
                                              <argument><expr><name>typeOfSecDistCol</name></expr></argument>, <argument><expr><name>issecnull</name></expr></argument>, <argument><expr><name>secValue</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if<condition>(<expr><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name>shardid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>shardid</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>shard_array</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <continue>continue;</continue></block_content></block></if></if_stmt>
                    
                    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name>shardid</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"recompute shardid failed. shardid is %d"</literal></expr></argument>, <argument><expr><name>shardid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>has_datamask</name></expr>)</condition>
            <block>{<block_content>
            	<expr_stmt><expr><call><name>dmask_exchg_all_cols_value_copy</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>parent_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>InvalidAttrNumber</name> <operator>!=</operator> <name>cls_attnum</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>mls_cls_check_row_validation_in_cp</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>cls_attnum</name> <operator>-</operator><literal type="number">1</literal></expr> ]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/* Format and send the data */</comment>
            <expr_stmt><expr><call><name>CopyOneRowTo</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>processed</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if_stmt><if>if<condition>(<expr><name>error_shards</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"there are %d tuples's shardid which shardis in invalid in relation %s(%d)."</literal></expr></argument>, 
                    <argument><expr><name>error_shards</name></expr></argument>,
                    <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* run the plan --- the dest receiver will send tuples */</comment>
        <expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name></name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>processed</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>DR_copy</name> <operator>*</operator><operator>)</operator> <name><name>cstate</name><operator>-&gt;</operator><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name><operator>)</operator><operator>-&gt;</operator><name>processed</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/*
     * In PGXC, it is not necessary for a Datanode to generate
     * the trailer as Coordinator is in charge of it
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name> <operator>&amp;&amp;</operator> <name>IS_PGXC_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
        <comment type="block">/* Generate trailer for a binary copy */</comment>
        <expr_stmt><expr><call><name>CopySendInt16</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Need to flush out the trailer */</comment>
        <expr_stmt><expr><call><name>CopySendEndOfRow</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rowcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>processed</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Emit one row during CopyTo().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopyOneRowTo</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>tupleOid</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>need_delim</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>out_functions</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>out_functions</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>string</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rowcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rowcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Binary per-tuple header */</comment>
        <expr_stmt><expr><call><name>CopySendInt16</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Send OID if wanted --- note attnumlist doesn't include it */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>oids</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Hack --- assume Oid is same size as int32 */</comment>
            <expr_stmt><expr><call><name>CopySendInt32</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CopySendInt32</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>tupleOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Text format has no per-tuple header, but send OID if wanted */</comment>
        <comment type="block">/* Assume digits don't need any quoting or encoding conversion */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>oids</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>oidout</name></expr></argument>,
                                                         <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tupleOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CopySendString</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>need_delim</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>cstate-&gt;attnumlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>value</name> <init>= <expr><name><name>values</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name> <init>= <expr><name><name>nulls</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>need_delim</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>need_delim</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>CopySendString</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print_client</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>CopySendInt32</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>OutputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out_functions</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                            <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>CopyAttributeOutCSV</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>string</name></expr></argument>,
                                        <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote_flags</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                        <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>CopyAttributeOutText</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>bytea</name>       <modifier>*</modifier></type><name>outputbytes</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>outputbytes</name> <operator>=</operator> <call><name>SendFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out_functions</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                               <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CopySendInt32</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>outputbytes</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>outputbytes</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>outputbytes</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>CopySendEndOfRow</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * error context callback for COPY FROM
 *
 * The argument for the error context must be CopyState.
 */</comment>
<function><type><name>void</name></type>
<name>CopyFromErrorCallback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CopyState</name></type>    <name>cstate</name> <init>= <expr><operator>(</operator><name>CopyState</name><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* can't usefully display the data */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"COPY %s, line %d, column %s, nodetype:%d(1:cn,0:dn)"</literal></expr></argument>,
                       <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_relname</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name></expr></argument>,
                       <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name></expr></argument>, <argument><expr><name>IS_PGXC_COORDINATOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"COPY %s, line %d, nodetype:%d(1:cn,0:dn)"</literal></expr></argument>,
                       <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_relname</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name></expr></argument>, <argument><expr><name>IS_PGXC_COORDINATOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cur_attval</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* error is relevant to a particular column */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>attval</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>attval</name> <operator>=</operator> <call><name>limit_printout_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"COPY %s, line %d, column %s: \"%s\", nodetype:%d(1:cn,0:dn)"</literal></expr></argument>,
                       <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_relname</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name></expr></argument>,
                       <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name></expr></argument>, <argument><expr><name>attval</name></expr></argument>, <argument><expr><name>IS_PGXC_COORDINATOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>attval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* error is relevant to a particular column, value is NULL */</comment>
            <expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"COPY %s, line %d, column %s: null input, nodetype:%d(1:cn,0:dn)"</literal></expr></argument>,
                       <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_relname</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name></expr></argument>,
                       <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name></expr></argument>, <argument><expr><name>IS_PGXC_COORDINATOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Error is relevant to a particular line.
             *
             * If line_buf still contains the correct line, and it's already
             * transcoded, print it. If it's still in a foreign encoding, it's
             * quite likely that the error is precisely a failure to do
             * encoding conversion (ie, bad data). We dare not try to convert
             * it, and at present there's no way to regurgitate it without
             * conversion. So we have to punt and just report the line number.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf_valid</name></name> <operator>&amp;&amp;</operator>
                <operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf_converted</name></name> <operator>||</operator> <operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>need_transcoding</name></name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>lineval</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>lineval</name> <operator>=</operator> <call><name>limit_printout_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"COPY %s, line %d: \"%s\", nodetype:%d(1:cn,0:dn)"</literal></expr></argument>,
                           <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_relname</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name></expr></argument>, <argument><expr><name>lineval</name></expr></argument>, <argument><expr><name>IS_PGXC_COORDINATOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>lineval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"COPY %s, line %d, nodetype:%d(1:cn,0:dn)"</literal></expr></argument>,
                           <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_relname</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name></expr></argument>, <argument><expr><name>IS_PGXC_COORDINATOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Make sure we don't print an unreasonable amount of COPY data in a message.
 *
 * It would seem a lot easier to just use the sprintf "precision" limit to
 * truncate the string.  However, some versions of glibc have a bug/misfeature
 * that vsnprintf will always fail (return -1) if it is asked to truncate
 * a string that contains invalid byte sequences for the current encoding.
 * So, do our own truncation.  We return a pstrdup'd copy of the input.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>limit_printout_length</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_COPY_DATA_DISPLAY</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>

    <decl_stmt><decl><type><name>int</name></type>            <name>slen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

    <comment type="block">/* Fast path if definitely okay */</comment>
    <if_stmt><if>if <condition>(<expr><name>slen</name> <operator>&lt;=</operator> <name>MAX_COPY_DATA_DISPLAY</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Apply encoding-dependent truncation */</comment>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>, <argument><expr><name>MAX_COPY_DATA_DISPLAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Truncate, and add "..." to show we truncated the input.
     */</comment>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>res</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy FROM file to relation.
 */</comment>
<function><type><name>uint64</name></type>
<name>CopyFrom</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>saved_resultRelInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EState</name>       <modifier>*</modifier></type><name>estate</name> <init>= <expr><call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* for ExecConstraints() */</comment>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>myslot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>errcallback</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CommandId</name></type>    <name>mycid</name> <init>= <expr><call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>hi_options</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* start with default heap_insert options */</comment>
    <decl_stmt><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>processed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>useHeapMultiInsert</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nBufferedTuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>prev_leaf_part_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BUFFERED_TUPLES</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>HeapTuple</name>  <modifier>*</modifier></type><name>bufferedTuples</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* initialize to silence warning */</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>bufferedTuplesSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>firstBufferedLineNo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>BulkInsertState</name> <modifier>*</modifier></type><name>part_bistates</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name>    <modifier>*</modifier><modifier>*</modifier></type><name>part_bufferedTuples</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>         <modifier>*</modifier></type><name>part_nBufferedTuples</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name>        <modifier>*</modifier></type><name>part_bufferedTuplesSize</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>AttrNumber</name></type> <name>partkey</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>partvalue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>partidx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResultRelInfo</name>    <modifier>*</modifier></type><name>partRel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>tempRelInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>        <name>tempparent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>npart</name>             <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>need_to_reset</name>     <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>nomore</name>            <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The target must be a plain relation or have an INSTEAD OF INSERT row
     * trigger.  (Currently, such triggers are only allowed on views, so we
     * only hint about them in the view case.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
        <name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
        <operator>!</operator><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>&amp;&amp;</operator>
          <name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>trigdesc</name><operator>-&gt;</operator><name>trig_insert_instead_row</name></name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy to view \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To enable copying to a view, provide an INSTEAD OF INSERT trigger."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy to materialized view \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy to foreign table \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy to sequence \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy to non-table relation \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    if ((cstate-&gt;rel-&gt;rd_rel-&gt;relkind == RELKIND_RELATION ||
        cstate-&gt;rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE) &amp;&amp;
        (cstate-&gt;rel-&gt;trigdesc &amp;&amp; (cstate-&gt;rel-&gt;trigdesc-&gt;trig_insert_instead_row ||
        cstate-&gt;rel-&gt;trigdesc-&gt;trig_insert_before_row || cstate-&gt;rel-&gt;trigdesc-&gt;trig_insert_after_row ||
        cstate-&gt;rel-&gt;trigdesc-&gt;trig_insert_before_statement || cstate-&gt;rel-&gt;trigdesc-&gt;trig_insert_after_statement ||
        cstate-&gt;rel-&gt;trigdesc-&gt;trig_insert_new_table)))
    {
        elog(ERROR, "cannot copy to table \"%s\" with trigger", RelationGetRelationName(cstate-&gt;rel));
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*----------
     * Check to see if we can avoid writing WAL
     *
     * If archive logging/streaming is not enabled *and* either
     *    - table was created in same transaction as this COPY
     *    - data is being written to relfilenode created in this transaction
     * then we can skip writing WAL.  It's safe because if the transaction
     * doesn't commit, we'll discard the table (or the new relfilenode file).
     * If it does commit, we'll have done the heap_sync at the bottom of this
     * routine first.
     *
     * As mentioned in comments in utils/rel.h, the in-same-transaction test
     * is not always set correctly, since in rare cases rd_newRelfilenodeSubid
     * can be cleared before the end of the transaction. The exact case is
     * when a relation sets a new relfilenode twice in same transaction, yet
     * the second one fails in an aborted subtransaction, e.g.
     *
     * BEGIN;
     * TRUNCATE t;
     * SAVEPOINT save;
     * TRUNCATE t;
     * ROLLBACK TO save;
     * COPY ...
     *
     * Also, if the target file is new-in-transaction, we assume that checking
     * FSM for free space is a waste of time, even if we must use WAL because
     * of archiving.  This could possibly be wrong, but it's unlikely.
     *
     * The comments for heap_insert and RelationGetBufferForTuple specify that
     * skipping WAL logging is only safe if we ensure that our tuples do not
     * go into pages containing tuples from any other transactions --- but this
     * must be the case if we have a new table or new relfilenode, so we need
     * no additional work to enforce that.
	 *
	 * We currently don't support this optimization if the COPY target is a
	 * partitioned table as we currently only lazily initialize partition
	 * information when routing the first tuple to the partition.  We cannot
	 * know at this stage if we can perform this optimization.  It should be
	 * possible to improve on this, but it does mean maintaining heap insert
	 * option flags per partition and setting them when we first open the
	 * partition.
     *----------
     */</comment>
    <comment type="block">/* createSubid is creation check, newRelfilenodeSubid is truncation check */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_createSubid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name> <operator>||</operator>
		 <name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_newRelfilenodeSubid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>hi_options</name> <operator>|=</operator> <name>HEAP_INSERT_SKIP_FSM</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogIsNeeded</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>hi_options</name> <operator>|=</operator> <name>HEAP_INSERT_SKIP_WAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Optimize if new relfilenode was created in this subxact or one of its
     * committed children and we won't see those rows later as part of an
     * earlier scan or command. This ensures that if this subtransaction
     * aborts then the frozen rows won't be visible after xact cleanup. Note
     * that the stronger test of exactly which subtransaction created it is
     * crucial for correctness of this optimization.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>freeze</name></name></expr>)</condition>
    <block>{<block_content>
		<comment type="block">/*
		* We currently disallow COPY FREEZE on partitioned tables.  The
		* reason for this is that we've simply not yet opened the partitions
		* to determine if the optimization can be applied to them.  We could
		* go and open them all here, but doing so may be quite a costly
		* overhead for small copies.  In any case, we may just end up routing
		* tuples to a small number of partitions.  It seems better just to
		* raise an ERROR for partitioned tables.
		*/</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
		<block>{<block_content>
		   <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		       <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		           <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform FREEZE on a partitioned table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ThereAreNoPriorRegisteredSnapshots</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>ThereAreNoReadyPortals</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform FREEZE because of prior transaction activity"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_createSubid</name></name> <operator>!=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
            <name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_newRelfilenodeSubid</name></name> <operator>!=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform FREEZE because the table was not created or truncated in the current subtransaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>hi_options</name> <operator>|=</operator> <name>HEAP_INSERT_FROZEN</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We need a ResultRelInfo so we can use the regular executor's
     * index-entry-making machinery.  (There used to be a huge amount of code
     * here that basically duplicated execUtils.c ...)
     */</comment>
    <expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ispartparent</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>partpruning</name></name> <operator>=</operator> <call><name>RelationGetPartitionsByQuals</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ispartparent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>partpruning</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>InitResultRelInfo</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>,
                      <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>,
                      <argument><expr><literal type="number">1</literal></expr></argument>,        <comment type="block">/* dummy rangetable index */</comment>
                      <argument><expr><name>NULL</name></expr></argument>,
                      <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ExecOpenIndices</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>range_table</name></name></expr>;</expr_stmt>

    <comment type="block">/* Set up a tuple slot too */</comment>
    <expr_stmt><expr><name>myslot</name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name>myslot</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Triggers might need a slot as well */</comment>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_trig_tuple_slot</name></name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * It's more efficient to prepare a bunch of tuples for insertion, and
     * insert them in one heap_multi_insert() call, than call heap_insert()
     * separately for every tuple. However, we can't do that if there are
     * BEFORE/INSTEAD OF triggers, or we need to evaluate volatile default
     * expressions. Such triggers or expressions might query the table we're
     * inserting to, and act differently if the tuples that have already been
     * processed and prepared for insertion are not there.  We also can't do
     * it if the table is partitioned.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
         <operator>(</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_before_row</name></name> <operator>||</operator>
          <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_instead_row</name></name><operator>)</operator><operator>)</operator> <operator>||</operator>
		<name><name>cstate</name><operator>-&gt;</operator><name>partition_tuple_routing</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
        <name><name>cstate</name><operator>-&gt;</operator><name>volatile_defexprs</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>useHeapMultiInsert</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>useHeapMultiInsert</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if<condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>part_bufferedTuples</name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><call><name>RelationGetNParts</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>HeapTuple</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RelationGetNParts</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>part_bufferedTuples</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>MAX_BUFFERED_TUPLES</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><name>part_bufferedTuplesSize</name> <operator>=</operator> <operator>(</operator><name>Size</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><call><name>RelationGetNParts</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>part_nBufferedTuples</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><call><name>RelationGetNParts</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>npart</name> <operator>=</operator> <call><name>RelationGetNParts</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>bufferedTuples</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MAX_BUFFERED_TUPLES</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Prepare to catch AFTER triggers. */</comment>
    <expr_stmt><expr><call><name>AfterTriggerBeginQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check BEFORE STATEMENT insertion triggers. It's debatable whether we
     * should do this for COPY, since it's not really an "INSERT" statement as
     * such. However, executing these triggers maintains consistency with the
     * EACH ROW triggers that we already fire on COPY.
     */</comment>
    <expr_stmt><expr><call><name>ExecBSInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>part_bistates</name> <operator>=</operator> <operator>(</operator><name>BulkInsertState</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><call><name>RelationGetNParts</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BulkInsertState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RelationGetNParts</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>part_bistates</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>GetBulkInsertState_part</name><argument_list>(<argument><expr><name>npart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <comment type="block">/* for default partition */</comment>
        <expr_stmt><expr><name>bistate</name> <operator>=</operator> <call><name>GetBulkInsertState_part</name><argument_list>(<argument><expr><name>npart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>bistate</name> <operator>=</operator> <call><name>GetBulkInsertState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set up callback to identify error line number */</comment>
    <expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>CopyFromErrorCallback</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>cstate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>errcallback</name></expr>;</expr_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>skip_tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>loaded_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if<condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>useHeapMultiInsert</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><name>need_to_reset</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ResetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>need_to_reset</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if_stmt><if>if <condition>(<expr><name>nBufferedTuples</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Reset the per-tuple exprcontext. We can only do this if the
             * tuple buffer is empty. (Calling the context the per-tuple
             * memory context is a bit of a misnomer now.)
             */</comment>
            <expr_stmt><expr><call><name>ResetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* Switch into its memory context */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/* skip error line when copy from */</comment>

        <if_stmt><if>if <condition>(<expr><name>g_enable_copy_silence</name></expr>)</condition>
        <block>{<block_content>
<label><name>readnextline</name>:</label>            
            <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NextCopyFrom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loaded_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>nomore</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <block>{<block_content>    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <comment type="block">/* 
                 * errors occured in copy from transformed from insert into multi-values,
                 * should throw the errors
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>insert_into</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/*
                 * omit errors from input files, PG_exception_stack has been reset.
                 */</comment>
                <goto>goto <name>readnextline</name>;</goto>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block>
            <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>    

            <comment type="block">/*
             * after PG_END_TRY(), break action would be allowed.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>nomore</name></expr>)</condition>
            <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>            
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                    
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NextCopyFrom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loaded_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <comment type="block">/*
         * Send the data row as-is to the Datanodes. If default values
         * are to be inserted, append them onto the data row.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>remoteCopyState</name><operator>-&gt;</operator><name>rel_loc</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Datum</name></type>                 <name>value</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>                <name>isnull</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RemoteCopyData</name>        <modifier>*</modifier></type><name>rcstate</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>remoteCopyState</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>AttrNumber</name></type>            <name>dist_col</name> <init>= <expr><name><name>rcstate</name><operator>-&gt;</operator><name>rel_loc</name><operator>-&gt;</operator><name>partAttrNum</name></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
            <decl_stmt><decl><type><name>Datum</name></type>                 <name>secValue</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>                <name>secisnull</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if_stmt><if>if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name>dist_col</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>values</name><index>[<expr><name>dist_col</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>isnull</name> <operator>=</operator> <name><name>nulls</name><index>[<expr><name>dist_col</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>rel_loc</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>secValue</name> <operator>=</operator> <name><name>values</name><index>[<expr><name><name>rcstate</name><operator>-&gt;</operator><name>rel_loc</name><operator>-&gt;</operator><name>secAttrNum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>secisnull</name> <operator>=</operator> <name><name>nulls</name><index>[<expr><name><name>rcstate</name><operator>-&gt;</operator><name>rel_loc</name><operator>-&gt;</operator><name>secAttrNum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if_stmt><if>if <condition>(<expr><call><name>DataNodeCopyIn</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name></expr></argument>,
                               <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                               <argument><expr><call><name>GET_NODES</name><argument_list>(<argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>secValue</name></expr></argument>, <argument><expr><name>secisnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                               <argument><expr><call><name>GET_NODES</name><argument_list>(<argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                               <argument><expr><operator>(</operator><name>PGXCNodeHandle</name><operator>*</operator><operator>*</operator><operator>)</operator> <call><name>getLocatorResults</name><argument_list>(<argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                               <argument><expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name> <operator>||</operator> <name><name>cstate</name><operator>-&gt;</operator><name>insert_into</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                                  <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr></expr_stmt></block_content></block></if></if_stmt>)</block_content></block></if></if_stmt>)</block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>conn_count</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>loop</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PGXCNodeHandle</name><modifier>*</modifier><modifier>*</modifier></type> <name>copy_connections</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>StringInfoData</name></type>   <name>sqldata</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>StringInfo</name></type>       <name>sql</name></decl>;</decl_stmt> 

                <expr_stmt><expr><name>sql</name> <operator>=</operator> <operator>&amp;</operator><name>sqldata</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                <expr_stmt><expr><name>conn_count</name> <operator>=</operator> <call><name>GET_NODES</name><argument_list>(<argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>secValue</name></expr></argument>, <argument><expr><name>secisnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><name>conn_count</name> <operator>=</operator> <call><name>GET_NODES</name><argument_list>(<argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><name>copy_connections</name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>getLocatorResults</name><argument_list>(<argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for<control>(<init><expr><name>loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>loop</name> <operator>&lt;</operator> <name>conn_count</name></expr>;</condition> <incr><expr><name>loop</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name><name>copy_connections</name><index>[<expr><name>loop</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><literal type="char">'\0'</literal> <operator>!=</operator> <name><name>handle</name><operator>-&gt;</operator><name>error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%s;"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>

                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Copy failed on a data node:%s"</literal></expr></argument>, <argument><expr><name><name>sql</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            processed++</block><empty_stmt>;</empty_stmt></for>
        </block_content>}</block></function>
        <if_stmt><else>else
        <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* And now we can form the input tuple. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <if_stmt><if>if<condition>(<expr><call><name>RelationIsSharded</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>            
            <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple_plain</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>,<argument><expr><name>values</name></expr></argument>,<argument><expr><name>nulls</name></expr></argument>,<argument><expr><call><name>RelationGetDisKey</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><call><name>RelationGetSecDisKey</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><call><name>IsShardBarriered</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><call><name>HeapTupleGetShardId</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"shard is be vacuuming now, so it is forbidden to write."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if <condition>(<expr><name>loaded_oid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>HeapTupleSetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>loaded_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Constraints might reference the tableoid column, so initialize
         * t_tableOid before evaluating them.
         */</comment>
        <expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Triggers and stuff need to be invoked in query context. */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Place tuple in tuple slot --- but slot shouldn't free it */</comment>
        <expr_stmt><expr><name>slot</name> <operator>=</operator> <name>myslot</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Determine the partition to heap_insert the tuple into */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>partition_tuple_routing</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>leaf_part_index</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>partition_tuple_routing</name></name></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * Away we go ... If we end up not finding a partition after all,
             * ExecFindPartition() does not return and errors out instead.
             * Otherwise, the returned value is to be used as an index into
             * arrays mt_partitions[] and mt_partition_tupconv_maps[] that
             * will get us the ResultRelInfo and TupleConversionMap for the
             * partition, respectively.
             */</comment>
            <expr_stmt><expr><name>leaf_part_index</name> <operator>=</operator> <call><name>ExecFindPartition</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>,
												<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>partition_dispatch_info</name></name></expr></argument>,
                                                <argument><expr><name>slot</name></expr></argument>,
                                                <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leaf_part_index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				   <name>leaf_part_index</name> <operator>&lt;</operator> <name><name>proute</name><operator>-&gt;</operator><name>num_partitions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If this tuple is mapped to a partition that is not same as the
             * previous one, we'd better make the bulk insert mechanism gets a
             * new buffer.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>prev_leaf_part_index</name> <operator>!=</operator> <name>leaf_part_index</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ReleaseBulkInsertStatePin</name><argument_list>(<argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>prev_leaf_part_index</name> <operator>=</operator> <name>leaf_part_index</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Save the old ResultRelInfo and switch to the one corresponding
             * to the selected partition.
             */</comment>
            <expr_stmt><expr><name>saved_resultRelInfo</name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>proute</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>leaf_part_index</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>resultRelInfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <call><name>ExecInitPartitionInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
													  <argument><expr><name>saved_resultRelInfo</name></expr></argument>,
													  <argument><expr><name>proute</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>,
													  <argument><expr><name>leaf_part_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>resultRelInfo</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

            <comment type="block">/* We do not yet have a way to insert into a foreign partition */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot route inserted tuples to a foreign table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * For ExecInsertIndexTuples() to work on the partition's indexes
             */</comment>
            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>

            <comment type="block">/*
             * If we're capturing transition tuples, we might need to convert
             * from the partition rowtype to parent rowtype.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>transition_capture</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
					<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_before_row</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
					 * If there are any BEFORE triggers on the partition,
					 * we'll have to be ready to convert their result back to
					 * tuplestore format.
                     */</comment>
                    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>transition_capture</name><operator>-&gt;</operator><name>tcs_original_insert_tuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name> <operator>=</operator>
						<call><name>TupConvMapForLeaf</name><argument_list>(<argument><expr><name>proute</name></expr></argument>, <argument><expr><name>saved_resultRelInfo</name></expr></argument>,
										  <argument><expr><name>leaf_part_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/*
                     * Otherwise, just remember the original unconverted
                     * tuple, to avoid a needless round trip conversion.
                     */</comment>
                    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>transition_capture</name><operator>-&gt;</operator><name>tcs_original_insert_tuple</name></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * We might need to convert from the parent rowtype to the
             * partition rowtype.
             */</comment>
            <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ConvertPartitionTupleSlot</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name><name>proute</name><operator>-&gt;</operator><name>parent_child_tupconv_maps</name><index>[<expr><name>leaf_part_index</name></expr>]</index></name></expr></argument>,
                                              <argument><expr><name>tuple</name></expr></argument>,
                                              <argument><expr><name><name>proute</name><operator>-&gt;</operator><name>partition_tuple_slot</name></name></expr></argument>,
                                              <argument><expr><operator>&amp;</operator><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>skip_tuple</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <comment type="block">/* BEFORE ROW INSERT Triggers */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
            <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_before_row</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecBRInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* "do nothing" */</comment>
                <expr_stmt><expr><name>skip_tuple</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>                <comment type="block">/* trigger might have changed tuple */</comment>
                <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip_tuple</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
                <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_instead_row</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Pass the data to the INSTEAD ROW INSERT trigger */</comment>
                <expr_stmt><expr><call><name>ExecIRInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
				<comment type="block">/* Check the constraints of the tuple */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name></expr>)</condition><block type="pseudo"><block_content>
				   <expr_stmt><expr><call><name>ExecConstraints</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/*
				* Also check the tuple against the partition constraint, if
				* there is one; except that if we got here via tuple-routing,
				* we don't need to if there's no BR trigger defined on the
				* partition.
                 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionCheck</name></name> <operator>&amp;&amp;</operator>
				   <operator>(</operator><name>saved_resultRelInfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
				    <operator>(</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
				     <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_before_row</name></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				   <expr_stmt><expr><call><name>ExecPartitionCheck</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><call><name>is_mls_user</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>CheckMlsTableUserAcl</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>,<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <if_stmt><if>if<condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* router for tuple */</comment>
                    <expr_stmt><expr><name>partkey</name> <operator>=</operator> <call><name>RelationGetPartitionColumnIndex</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>partvalue</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>partkey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if<condition>(<expr><name>isnull</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>partidx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>partidx</name> <operator>=</operator> <call><name>RelationGetPartitionIdxByValue</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>,<argument><expr><name>partvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>                        
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <if_stmt><if>if <condition>(<expr><name>useHeapMultiInsert</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Add this tuple to the tuple buffer */</comment>
                    <if_stmt><if>if <condition>(<expr><name>nBufferedTuples</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>firstBufferedLineNo</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <if_stmt><if>if<condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>partidx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>part_bufferedTuples</name><index>[<expr><name>partidx</name></expr>]</index><index>[<expr><name><name>part_nBufferedTuples</name><index>[<expr><name>partidx</name></expr>]</index></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>part_bufferedTuplesSize</name><index>[<expr><name>partidx</name></expr>]</index></name> <operator>+=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <expr_stmt><expr><name><name>bufferedTuples</name><index>[<expr><name>nBufferedTuples</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>bufferedTuplesSize</name> <operator>+=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                    <comment type="block">/*
                     * If the buffer filled up, flush it.  Also flush if the
                     * total size of all the tuples in the buffer becomes
                     * large, to avoid using large amounts of memory for the
                     * buffer when the tuples are exceptionally wide.
                     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <if_stmt><if>if<condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if<condition>(<expr><name><name>part_nBufferedTuples</name><index>[<expr><name>partidx</name></expr>]</index></name> <operator>==</operator> <name>MAX_BUFFERED_TUPLES</name> <operator>||</operator>
                            <name><name>part_bufferedTuplesSize</name><index>[<expr><name>partidx</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">65535</literal> <operator>||</operator>
                            <name>nBufferedTuples</name> <operator>==</operator> <name>MAX_BUFFERED_TUPLES</name> <operator>||</operator>
                            <name>bufferedTuplesSize</name> <operator>&gt;</operator> <literal type="number">65535</literal></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>Oid</name></type> <name>partoid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>int</name></type> <name>part_rel_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                            <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npart</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                            <block>{<block_content>
								<if_stmt><if>if<condition>(<expr><name><name>part_nBufferedTuples</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
								<block>{<block_content>
                                    <comment type="block">/* the child table have data to be inserted */</comment>
									<expr_stmt><expr><name>partname</name> <operator>=</operator> <call><name>GetPartitionName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><name>partoid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>partname</name></expr></argument>, <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<if_stmt><if>if<condition>(<expr><name>partoid</name></expr>)</condition>
									<block>{<block_content>
										<comment type="block">/* Find the corresponding partition child table info that has not been dropped */</comment>
										<for>for<control>(<init><expr><name>part_rel_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>part_rel_index</name> <operator>&lt;</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>partarraysize</name></name></expr>;</condition> <incr><expr><name>part_rel_index</name><operator>++</operator></expr></incr>)</control>
										<block>{<block_content>
											<if_stmt><if>if<condition>(<expr><name>i</name> <operator>==</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>part_relinfo</name><index>[<expr><name>part_rel_index</name></expr>]</index></name><operator>-&gt;</operator><name>part_index</name></expr>)</condition>
											<block>{<block_content>
												<comment type="block">/* insert data into corresponding partition child table */</comment>
												<expr_stmt><expr><name>partRel</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>part_relinfo</name><index>[<expr><name>part_rel_index</name></expr>]</index></name></expr>;</expr_stmt>
												<expr_stmt><expr><name>tempparent</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr>;</expr_stmt>
												<expr_stmt><expr><name>tempRelInfo</name> <operator>=</operator>  <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>
												<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>partRel</name></expr>;</expr_stmt>
												<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name><name>partRel</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>


				                                <expr_stmt><expr><call><name>CopyFromInsertBatch</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>mycid</name></expr></argument>, <argument><expr><name>hi_options</name></expr></argument>,
				        													<argument><expr><name>partRel</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>, <argument><expr><name><name>part_bistates</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
				        													<argument><expr><name><name>part_nBufferedTuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>part_bufferedTuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
				        													<argument><expr><name>firstBufferedLineNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

												<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>tempRelInfo</name></expr>;</expr_stmt>
												<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>tempparent</name></expr>;</expr_stmt>

												<expr_stmt><expr><name><name>part_nBufferedTuples</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
												<expr_stmt><expr><name><name>part_bufferedTuplesSize</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
												<break>break;</break>
											</block_content>}</block></if></if_stmt>
										</block_content>}</block></for>
									</block_content>}</block></if>
									<else>else
									<block>{<block_content>
										<comment type="block">/* The data of the dropped child table is classified into the default partition */</comment>
		                                <expr_stmt><expr><call><name>CopyFromInsertBatch</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>mycid</name></expr></argument>, <argument><expr><name>hi_options</name></expr></argument>,
														<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>, <argument><expr><name>bistate</name></expr></argument>,
														<argument><expr><name><name>part_nBufferedTuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>part_bufferedTuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
														<argument><expr><name>firstBufferedLineNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		                                <expr_stmt><expr><name><name>part_nBufferedTuples</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		                                <expr_stmt><expr><name><name>part_bufferedTuplesSize</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
									</block_content>}</block></else></if_stmt>
								</block_content>}</block></if></if_stmt>
                            </block_content>}</block></for>

                            <if_stmt><if>if<condition>(<expr><name>nBufferedTuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                            <block>{<block_content>
								<comment type="block">/* The data of &gt; npart table is classified into the default partition */</comment>
                                <expr_stmt><expr><call><name>CopyFromInsertBatch</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>mycid</name></expr></argument>, <argument><expr><name>hi_options</name></expr></argument>,
                                                <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>, <argument><expr><name>bistate</name></expr></argument>,
                                                <argument><expr><name>nBufferedTuples</name></expr></argument>, <argument><expr><name>bufferedTuples</name></expr></argument>,
                                                <argument><expr><name>firstBufferedLineNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><name>nBufferedTuples</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name>bufferedTuplesSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>

                            <expr_stmt><expr><name>need_to_reset</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                    <if_stmt><if>if <condition>(<expr><name>nBufferedTuples</name> <operator>==</operator> <name>MAX_BUFFERED_TUPLES</name> <operator>||</operator>
                        <name>bufferedTuplesSize</name> <operator>&gt;</operator> <literal type="number">65535</literal></expr>)</condition>
                    <block>{<block_content>

                        <expr_stmt><expr><call><name>CopyFromInsertBatch</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>mycid</name></expr></argument>, <argument><expr><name>hi_options</name></expr></argument>,
                                        <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>, <argument><expr><name>bistate</name></expr></argument>,
                                        <argument><expr><name>nBufferedTuples</name></expr></argument>, <argument><expr><name>bufferedTuples</name></expr></argument>,
                                        <argument><expr><name>firstBufferedLineNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name>nBufferedTuples</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>bufferedTuplesSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>recheckIndexes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <if_stmt><if>if<condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>partidx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>partRel</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>part_relinfo</name><index>[<expr><name>partidx</name></expr>]</index></name></expr>;</expr_stmt>         

                        <expr_stmt><expr><call><name>heap_insert</name><argument_list>(<argument><expr><name><name>partRel</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
                                                <argument><expr><name>mycid</name></expr></argument>, <argument><expr><name>hi_options</name></expr></argument>, <argument><expr><name><name>part_bistates</name><index>[<expr><name>partidx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        
                        <if_stmt><if>if <condition>(<expr><name><name>partRel</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>tempRelInfo</name> <operator>=</operator>  <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>partRel</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>recheckIndexes</name> <operator>=</operator> <call><name>ExecInsertIndexTuples</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>,
                                                                   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                                                   <argument><expr><name>NULL</name></expr></argument>,
                                                                   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>tempRelInfo</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                    <comment type="block">/* OK, store the tuple and create index entries for it */</comment>
                    <expr_stmt><expr><call><name>heap_insert</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>mycid</name></expr></argument>,
                                <argument><expr><name>hi_options</name></expr></argument>, <argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>recheckIndexes</name> <operator>=</operator> <call><name>ExecInsertIndexTuples</name><argument_list>(<argument><expr><name>slot</name></expr></argument>,
                                                               <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>,
                                                               <argument><expr><name>estate</name></expr></argument>,
                                                               <argument><expr><name>false</name></expr></argument>,
                                                               <argument><expr><name>NULL</name></expr></argument>,
                                                               <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <comment type="block">/* AFTER ROW INSERT Triggers */</comment>
                    <expr_stmt><expr><call><name>ExecARInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
                                         <argument><expr><name>recheckIndexes</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>recheckIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/*
             * We count only tuples not suppressed by a BEFORE INSERT trigger;
             * this is the same definition used by execMain.c for counting
             * tuples inserted by an INSERT command.
             */</comment>
            <expr_stmt><expr><name>processed</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

        <comment type="block">/* Restore the saved ResultRelInfo */</comment>
            <if_stmt><if>if <condition>(<expr><name>saved_resultRelInfo</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name>saved_resultRelInfo</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }
    <comment type="block">/* Flush any remaining buffered tuples */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    if<expr_stmt><expr><operator>(</operator><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <name>npart</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator>
    <block>{
        <expr><name>int</name> <name>partcur</name> <operator>=</operator> <literal type="number">0</literal></expr>;
		<expr><name>char</name> <operator>*</operator><name>partname</name> <operator>=</operator> <name>NULL</name></expr>;
		<expr><name>Oid</name> <name>partoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;
		<expr><name>int</name> <name>part_rel_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;

        <for>for<control>(<init><expr><name>partcur</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>partcur</name> <operator>&lt;</operator> <name>npart</name></expr>;</condition> <incr><expr><name>partcur</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><name><name>part_nBufferedTuples</name><index>[<expr><name>partcur</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
				<comment type="block">/* the child table have data to be inserted */</comment>
				<expr_stmt><expr><name>partname</name> <operator>=</operator> <call><name>GetPartitionName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>partcur</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>partoid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>partname</name></expr></argument>, <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>(<expr><name>partoid</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Find the corresponding partition child table info that has not been dropped */</comment>
					<for>for<control>(<init><expr><name>part_rel_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>part_rel_index</name> <operator>&lt;</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>partarraysize</name></name></expr>;</condition> <incr><expr><name>part_rel_index</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if<condition>(<expr><name>partcur</name> <operator>==</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>part_relinfo</name><index>[<expr><name>part_rel_index</name></expr>]</index></name><operator>-&gt;</operator><name>part_index</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* insert data into corresponding partition child table */</comment>
							<expr_stmt><expr><name>partRel</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>part_relinfo</name><index>[<expr><name>part_rel_index</name></expr>]</index></name></expr>;</expr_stmt>
							<expr_stmt><expr><name>tempparent</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr>;</expr_stmt>
							<expr_stmt><expr><name>tempRelInfo</name> <operator>=</operator>  <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>partRel</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name><name>partRel</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>


			                <expr_stmt><expr><call><name>CopyFromInsertBatch</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>mycid</name></expr></argument>, <argument><expr><name>hi_options</name></expr></argument>,
										<argument><expr><name>partRel</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>, <argument><expr><name><name>part_bistates</name><index>[<expr><name>partcur</name></expr>]</index></name></expr></argument>,
										<argument><expr><name><name>part_nBufferedTuples</name><index>[<expr><name>partcur</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>part_bufferedTuples</name><index>[<expr><name>partcur</name></expr>]</index></name></expr></argument>,
										<argument><expr><name>firstBufferedLineNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


							<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>tempRelInfo</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>tempparent</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>part_nBufferedTuples</name><index>[<expr><name>partcur</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>part_bufferedTuplesSize</name><index>[<expr><name>partcur</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
							<break>break;</break>
						<expr_stmt/></block_content></block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></for>}</block></expr></expr_stmt>
					}
				}
				<if_stmt><else>else
				<block>{<block_content>
					<comment type="block">/* The data of the dropped child table is classified into the default partition */</comment>
			        <expr_stmt><expr><call><name>CopyFromInsertBatch</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>mycid</name></expr></argument>, <argument><expr><name>hi_options</name></expr></argument>,
										<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>, <argument><expr><name>bistate</name></expr></argument>,
										<argument><expr><name><name>part_nBufferedTuples</name><index>[<expr><name>partcur</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>part_bufferedTuples</name><index>[<expr><name>partcur</name></expr>]</index></name></expr></argument>,
										<argument><expr><name>firstBufferedLineNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			        <expr_stmt><expr><name><name>part_nBufferedTuples</name><index>[<expr><name>partcur</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			        <expr_stmt><expr><name><name>part_bufferedTuplesSize</name><index>[<expr><name>partcur</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
            }
        }
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    if <expr_stmt><expr><operator>(</operator><name>nBufferedTuples</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator>
    <block>{
		<comment type="block">/* The data of &gt; npart table is classified into the default partition */</comment>
        <expr><call><name>CopyFromInsertBatch</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>mycid</name></expr></argument>, <argument><expr><name>hi_options</name></expr></argument>,
                            <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>, <argument><expr><name>bistate</name></expr></argument>,
                            <argument><expr><name>nBufferedTuples</name></expr></argument>, <argument><expr><name>bufferedTuples</name></expr></argument>,
                            <argument><expr><name>firstBufferedLineNo</name></expr></argument>)</argument_list></call></expr>;

        <expr><name>nBufferedTuples</name> <operator>=</operator> <literal type="number">0</literal></expr>;
        <expr><name>bufferedTuplesSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;
    }</block></expr></expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/*
     * Now if line buffer contains some data that is an EOF marker. We should
     * send it to all the participating datanodes
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RemoteCopyData</name>        <modifier>*</modifier></type><name>rcstate</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>remoteCopyState</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>DataNodeCopyIn</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name></expr></argument>,
                           <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr></argument>,
                           <argument><expr><call><name>getLocatorNodeCount</name><argument_list>(<argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>getLocatorNodeMap</name><argument_list>(<argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>conn_count</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>loop</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PGXCNodeHandle</name><modifier>*</modifier><modifier>*</modifier></type> <name>copy_connections</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>StringInfoData</name></type>   <name>sqldata</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>StringInfo</name></type>       <name>sql</name></decl>;</decl_stmt> 

            <expr_stmt><expr><name>sql</name> <operator>=</operator> <operator>&amp;</operator><name>sqldata</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>conn_count</name>       <operator>=</operator> <call><name>getLocatorNodeCount</name><argument_list>(<argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>copy_connections</name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name><operator>*</operator><operator>*</operator><operator>)</operator> <call><name>getLocatorNodeMap</name><argument_list>(<argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <for>for<control>(<init><expr><name>loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>loop</name> <operator>&lt;</operator> <name>conn_count</name></expr>;</condition> <incr><expr><name>loop</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name><name>copy_connections</name><index>[<expr><name>loop</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><literal type="char">'\0'</literal> <operator>!=</operator> <name><name>handle</name><operator>-&gt;</operator><name>error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%s;"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Copy failed on a data node:%s"</literal></expr></argument>, <argument><expr><name><name>sql</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Done, clean up */</comment>
    <expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>errcallback</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <call><name>RelationGetNParts</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call><operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RelationGetNParts</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FreeBulkInsertState</name><argument_list>(<argument><expr><name><name>part_bistates</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>FreeBulkInsertState</name><argument_list>(<argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <name>npart</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name>part_nBufferedTuples</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>part_nBufferedTuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>(<expr><name>part_bufferedTuplesSize</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>part_bufferedTuplesSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name>part_bufferedTuples</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
            <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name>npart</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if<condition>(<expr><name><name>part_bufferedTuples</name><index>[<expr><name>ii</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>part_bufferedTuples</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>part_bufferedTuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * In the old protocol, tell pqcomm that we can process normal protocol
     * messages again.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>==</operator> <name>COPY_OLD_FE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pq_endmsgread</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Execute AFTER STATEMENT insertion triggers */</comment>
    <expr_stmt><expr><call><name>ExecASInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Handle queued AFTER triggers */</comment>
    <expr_stmt><expr><call><name>AfterTriggerEndQuery</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ExecResetTupleTable</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ispartparent</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>partrel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>partarraysize</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>partrel</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>part_relinfo</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>partrel</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ExecCloseIndices</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name><name>partrel</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>ExecCloseIndices</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Close all the partitioned tables, leaf partitions, and their indices */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>partition_tuple_routing</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecCleanupTupleRouting</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>partition_tuple_routing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Close any trigger target relations */</comment>
    <expr_stmt><expr><call><name>ExecCleanUpTriggerState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we skipped writing WAL, then we need to sync the heap (but not
     * indexes since those use WAL anyway)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>hi_options</name> <operator>&amp;</operator> <name>HEAP_INSERT_SKIP_WAL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>heap_sync</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>processed</name></expr>;</return>
}

<comment type="block">/*
 * A subroutine of CopyFrom, to write the current batch of buffered heap
 * tuples to the heap. Also updates indexes and runs AFTER ROW INSERT
 * triggers.
 */</comment>
static <function><type><name>void</name></type>
<name>CopyFromInsertBatch</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>mycid</name></decl></parameter>,
                    <parameter><decl><type><name>int</name></type> <name>hi_options</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
                    <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>myslot</name></decl></parameter>, <parameter><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl></parameter>,
                    <parameter><decl><type><name>int</name></type> <name>nBufferedTuples</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>bufferedTuples</name></decl></parameter>,
                    <parameter><decl><type><name>int</name></type> <name>firstBufferedLineNo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_cur_lineno</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Print error context information correctly, if one of the operations
     * below fail.
     */</comment>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>save_cur_lineno</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * heap_multi_insert leaks memory, so switch to short-lived memory context
     * before calling it.
     */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_multi_insert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>,
                      <argument><expr><name>bufferedTuples</name></expr></argument>,
                      <argument><expr><name>nBufferedTuples</name></expr></argument>,
                      <argument><expr><name>mycid</name></expr></argument>,
                      <argument><expr><name>hi_options</name></expr></argument>,
                      <argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If there are any indexes, update them for all the inserted tuples, and
     * run AFTER ROW INSERT triggers.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nBufferedTuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>recheckIndexes</name></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name> <operator>=</operator> <name>firstBufferedLineNo</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name><name>bufferedTuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>recheckIndexes</name> <operator>=</operator>
                <call><name>ExecInsertIndexTuples</name><argument_list>(<argument><expr><name>myslot</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>bufferedTuples</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>t_self</name><operator>)</operator></expr></argument>,
                                      <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExecARInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
                                 <argument><expr><name><name>bufferedTuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                 <argument><expr><name>recheckIndexes</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>recheckIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>

    <comment type="block">/*
     * There's no indexes, but see if we need to run AFTER ROW INSERT triggers
     * anyway.
     */</comment>
    <if type="elseif">else if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
             <operator>(</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_after_row</name></name> <operator>||</operator>
              <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_new_table</name></name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nBufferedTuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name> <operator>=</operator> <name>firstBufferedLineNo</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExecARInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
                                 <argument><expr><name><name>bufferedTuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                 <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* reset cur_lineno to where we were */</comment>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name> <operator>=</operator> <name>save_cur_lineno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Setup to read tuples from a file for COPY FROM.
 *
 * 'rel': Used as a template for the tuples
 * 'filename': Name of server-local file to read
 * 'attnamelist': List of char *, columns to include. NIL selects all cols.
 * 'options': List of DefElem. See copy_opt_item in gram.y for selections.
 *
 * Returns a CopyState, to be passed to NextCopyFrom and related functions.
 */</comment>
<function><type><name>CopyState</name></type>
<name>BeginCopyFrom</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
              <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
              <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
              <parameter><decl><type><name>bool</name></type> <name>is_program</name></decl></parameter>,
              <parameter><decl><type><name>copy_data_source_cb</name></type> <name>data_source_cb</name></decl></parameter>,
              <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attnamelist</name></decl></parameter>,
              <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CopyState</name></type>    <name>cstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>pipe</name> <init>= <expr><operator>(</operator><name>filename</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>attr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>num_phys_attrs</name></decl>,
                <decl><type ref="prev"/><name>num_defaults</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>in_functions</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>typioparams</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>in_func_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>defmap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprState</name> <modifier>*</modifier><modifier>*</modifier></type><name>defexprs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>volatile_defexprs</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cstate</name> <operator>=</operator> <call><name>BeginCopy</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>attnamelist</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copycontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Initialize state variables */</comment>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_eof</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>=</operator> <name>EOL_UNKNOWN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_relname</name></name> <operator>=</operator> <call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attval</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>data_list</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>data_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>data_ncolumns</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>ndatarows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>pstate</name> <operator>&amp;&amp;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>stmt</name></name> <operator>&amp;&amp;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>stmt</name><operator>-&gt;</operator><name>insert_into</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>data_list</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>stmt</name><operator>-&gt;</operator><name>data_list</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>data_ncolumns</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>stmt</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>ndatarows</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>stmt</name><operator>-&gt;</operator><name>ndatarows</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Set up variables to avoid per-attribute overhead. */</comment>
    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf_converted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>RAW_BUF_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Assign range table, we'll need it in CopyFrom. */</comment>
    <if_stmt><if>if <condition>(<expr><name>pstate</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>range_table</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>attr</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>num_phys_attrs</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>num_defaults</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>volatile_defexprs</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Pick up the required catalog information for each attribute in the
     * relation, including the input function, the element type (to pass to
     * the input function), and info about defaults and constraints. (Which
     * input function we use depends on text/binary format choice.)
     */</comment>
    <expr_stmt><expr><name>in_functions</name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>typioparams</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>defmap</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>defexprs</name> <operator>=</operator> <operator>(</operator><name>ExprState</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ExprState</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/* Output functions are required to convert default values to output form */</comment>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>out_functions</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name>num_phys_attrs</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* We don't need info for dropped attributes */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>attr</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Fetch the input function and typioparam info */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>getTypeBinaryInputInfo</name><argument_list>(<argument><expr><name><name>attr</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr></argument>,
                                   <argument><expr><operator>&amp;</operator><name>in_func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typioparams</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name><name>attr</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr></argument>,
                             <argument><expr><operator>&amp;</operator><name>in_func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typioparams</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>in_func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>in_functions</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Get default info if needed */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_int</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* attribute is NOT to be copied from input */</comment>
            <comment type="block">/* use default value if one exists */</comment>
            <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>defexpr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>build_column_default</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>,
                                                                <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>defexpr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * If default expr is shippable to Datanode, don't include
                     * default values in the data row sent to the Datanode; let
                     * the Datanode insert the default values.
                     */</comment>
                    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>planned_defexpr</name> <init>= <expr><call><name>expression_planner</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>defexpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>defexpr</name> <operator>=</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><name>defexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <comment type="block">/* treat distributed column as defaults too */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgxc_is_expr_shippable</name><argument_list>(<argument><expr><name>planned_defexpr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>||</operator>
                        <call><name>IsDistributedColumn</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgxc_is_expr_shippable</name><argument_list>(<argument><expr><name>planned_defexpr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>Oid</name></type>    <name>out_func_oid</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>bool</name></type>   <name>isvarlena</name></decl>;</decl_stmt>
                        <comment type="block">/* Initialize expressions in copycontext. */</comment>
                        <expr_stmt><expr><name><name>defexprs</name><index>[<expr><name>num_defaults</name></expr>]</index></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>planned_defexpr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>defmap</name><index>[<expr><name>num_defaults</name></expr>]</index></name> <operator>=</operator> <name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>num_defaults</name><operator>++</operator></expr>;</expr_stmt>

                        <comment type="block">/*
                         * Initialize output functions needed to convert default
                         * values into output form before appending to data row.
                         */</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>getTypeBinaryOutputInfo</name><argument_list>(<argument><expr><name><name>attr</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr></argument>,
                                                    <argument><expr><operator>&amp;</operator><name>out_func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>attr</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr></argument>,
                                              <argument><expr><operator>&amp;</operator><name>out_func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                        <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>out_func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>out_functions</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>
                <comment type="block">/* Run the expression through planner */</comment>
                <expr_stmt><expr><name>defexpr</name> <operator>=</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><name>defexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Initialize executable expression in copycontext */</comment>
                <expr_stmt><expr><name><name>defexprs</name><index>[<expr><name>num_defaults</name></expr>]</index></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>defexpr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>defmap</name><index>[<expr><name>num_defaults</name></expr>]</index></name> <operator>=</operator> <name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>num_defaults</name><operator>++</operator></expr>;</expr_stmt>

                <comment type="block">/*
                 * If a default expression looks at the table being loaded,
                 * then it could give the wrong answer when using
                 * multi-insert. Since database access can be dynamic this is
                 * hard to test for exactly, so we use the much wider test of
                 * whether the default expression is volatile. We allow for
                 * the special case of when the default expression is the
                 * nextval() of a sequence which in this specific case is
                 * known to be safe for use with the multi-insert
                 * optimization. Hence we use this special case function
                 * checker rather than the standard check for
                 * contain_volatile_functions().
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>volatile_defexprs</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>volatile_defexprs</name> <operator>=</operator> <call><name>contain_volatile_functions_not_nextval</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>defexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
                </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* We keep those variables in cstate. */</comment>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>in_functions</name></name> <operator>=</operator> <name>in_functions</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>typioparams</name></name> <operator>=</operator> <name>typioparams</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>defmap</name></name> <operator>=</operator> <name>defmap</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>defexprs</name></name> <operator>=</operator> <name>defexprs</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>volatile_defexprs</name></name> <operator>=</operator> <name>volatile_defexprs</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>num_defaults</name></name> <operator>=</operator> <name>num_defaults</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>is_program</name></name> <operator>=</operator> <name>is_program</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>data_source_cb</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>=</operator> <name>COPY_CALLBACK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>data_source_cb</name></name> <operator>=</operator> <name>data_source_cb</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>pipe</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_program</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* the grammar does not allow this */</comment>
        <if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ReceiveCopyBegin</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>=</operator> <name>stdin</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>is_program</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>=</operator> <call><name>OpenPipeStream</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not execute command \"%s\": %m"</literal></expr></argument>,
                                <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>pstate</name> <operator>&amp;&amp;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>stmt</name></name> <operator>&amp;&amp;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>stmt</name><operator>-&gt;</operator><name>insert_into</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* insert_into to copy_from */</comment>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* copy errno because ereport subfunctions might change it */</comment>
                <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\" for reading: %m"</literal></expr></argument>,
                                <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                         <ternary><condition><expr><operator>(</operator><name>save_errno</name> <operator>==</operator> <name>ENOENT</name> <operator>||</operator> <name>save_errno</name> <operator>==</operator> <name>EACCES</name><operator>)</operator></expr> ?</condition><then>
                         <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"COPY FROM instructs the PostgreSQL server process to read a file. "</literal>
                                 <literal type="string">"You may want a client-side facility such as psql's \\copy."</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>,
                                <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a directory"</literal></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* must rely on user to tell us... */</comment>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_has_oids</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>oids</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Read and verify binary header */</comment>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>readSig</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>tmp</name></decl>;</decl_stmt>

        <comment type="block">/* Signature */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>readSig</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">11</literal> <operator>||</operator>
            <call><name>memcmp</name><argument_list>(<argument><expr><name>readSig</name></expr></argument>, <argument><expr><name>BinarySignature</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY file signature not recognized"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* Flags field */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CopyGetInt32</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid COPY file header (missing flags)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_has_oids</name></name> <operator>=</operator> <operator>(</operator><name>tmp</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>tmp</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmp</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized critical flags in COPY file header"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* Header extension length */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CopyGetInt32</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <name>tmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid COPY file header (missing length)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* Skip extension header, if present */</comment>
        <while>while <condition>(<expr><name>tmp</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>readSig</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid COPY file header (wrong length)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></while>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <comment type="block">/* This is done at the beginning of COPY FROM from Coordinator to Datanodes */</comment>
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RemoteCopyData</name> <modifier>*</modifier></type><name>remoteCopyState</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>remoteCopyState</name></name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Empty buffer info and send header to all the backends involved in COPY */</comment>
            <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><name>BinarySignature</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>oids</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>tmp</name> <operator>|=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>DataNodeCopyInBinaryForAll</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>,
                    <argument><expr><call><name>getLocatorNodeCount</name><argument_list>(<argument><expr><name><name>remoteCopyState</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>getLocatorNodeMap</name><argument_list>(<argument><expr><name><name>remoteCopyState</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid COPY file header (COPY SEND)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>file_has_oids</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>getTypeBinaryInputInfo</name><argument_list>(<argument><expr><name>OIDOID</name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name>in_func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>oid_typioparam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>in_func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>oid_in_function</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* create workspace for CopyReadAttributes results */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attr_count</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>nfields</name> <init>= <expr><ternary><condition><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_has_oids</name></name></expr> ?</condition><then> <expr><operator>(</operator><name>attr_count</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><name>attr_count</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>max_fields</name></name> <operator>=</operator> <name>nfields</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nfields</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>cstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read raw fields in the next line for COPY FROM in text or csv mode.
 * Return false if no more lines.
 *
 * An internal temporary buffer is returned via 'fields'. It is valid until
 * the next call of the function. Since the function returns all raw fields
 * in the input file, 'nfields' could be different from the number of columns
 * in the relation.
 *
 * NOTE: force_not_null option are not applied to the returned fields.
 */</comment>
<function><type><name>bool</name></type>
<name>NextCopyFromRawFields</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nfields</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>fldct</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>done</name></decl>;</decl_stmt>

    <comment type="block">/* only available for text or csv input */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* on input just throw the header line away */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>header_line</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>CopyReadLine</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>        <comment type="block">/* done */</comment>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* Actually read the line into memory here */</comment>
    <expr_stmt><expr><name>done</name> <operator>=</operator> <call><name>CopyReadLine</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * EOF at start of line means we're done.  If we see EOF after some
     * characters, we act as though it was newline followed by EOF, ie,
     * process the line and then exit loop on next iteration.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>done</name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Parse the line into de-escaped field values */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>fldct</name> <operator>=</operator> <call><name>CopyReadAttributesCSV</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>internal_mode</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>fldct</name> <operator>=</operator> <call><name>CopyReadAttributesInternal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>fldct</name> <operator>=</operator> <call><name>CopyReadAttributesText</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>fields</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>nfields</name> <operator>=</operator> <name>fldct</name></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read next tuple from file for COPY FROM. Return false if no more tuples.
 *
 * 'econtext' is used to evaluate default expression for each columns not
 * read from the file. It can be NULL when no default values are used, i.e.
 * when all columns are read from the file.
 *
 * 'values' and 'nulls' arrays must be the same length as columns of the
 * relation passed to BeginCopyFrom. This function fills the arrays.
 * Oid of the tuple is returned with 'tupleOid' separately.
 */</comment>
<function><type><name>bool</name></type>
<name>NextCopyFrom</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
             <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>tupleOid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>attr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>num_phys_attrs</name></decl>,
                <decl><type ref="prev"/><name>attr_count</name></decl>,
                <decl><type ref="prev"/><name>num_defaults</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>num_defaults</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>in_functions</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>in_functions</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>typioparams</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>typioparams</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nfields</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>file_has_oids</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>file_has_oids</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>defmap</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>defmap</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprState</name> <modifier>*</modifier><modifier>*</modifier></type><name>defexprs</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>defexprs</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>attr</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>num_phys_attrs</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>attr_count</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nfields</name> <operator>=</operator> <ternary><condition><expr><name>file_has_oids</name></expr> ?</condition><then> <expr><operator>(</operator><name>attr_count</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><name>attr_count</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* Initialize all values for row to NULL */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>field_strings</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>fldct</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>fieldno</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>string</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>insert_into</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>data_list</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* send data in datarow format to remote datanode */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>data_index</name></name> <operator>&lt;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>ndatarows</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>uint16</name></type>     <name>n16</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>total_columns</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>field_strings</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>data_list</name><index>[<expr><name><name>cstate</name><operator>-&gt;</operator><name>data_index</name></name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>data_index</name></name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>fldct</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>data_ncolumns</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>total_columns</name> <operator>=</operator> <name>fldct</name> <operator>+</operator> <name>num_defaults</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>n16</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>total_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n16</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <for>for<control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>fldct</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>field_strings</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>field_strings</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>uint32</name></type> <name>n32</name> <init>= <expr><call><name>htonl</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><name><name>field_strings</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>uint32</name></type> <name>n32</name> <init>= <expr><call><name>htonl</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/* read raw fields in the next line */</comment>
            if <condition>(<expr><operator>!</operator><call><name>NextCopyFromRawFields</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>field_strings</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fldct</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* check for overflowing fields */</comment>
        <if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>fldct</name> <operator>&gt;</operator> <name>nfields</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extra data after last expected column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>fieldno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/* Read the OID field if present */</comment>
        <if_stmt><if>if <condition>(<expr><name>file_has_oids</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>fieldno</name> <operator>&gt;=</operator> <name>fldct</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"missing data for OID column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <name><name>field_strings</name><index>[<expr><name>fieldno</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>string</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"null OID in COPY data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>oids</name></name> <operator>&amp;&amp;</operator> <name>tupleOid</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name> <operator>=</operator> <literal type="string">"oid"</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attval</name></name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>tupleOid</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>oidin</name></expr></argument>,
                                                                 <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>*</operator><name>tupleOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid OID in COPY data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attval</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Loop to read the user attributes on the line. */</comment>
        <macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>cstate-&gt;attnumlist</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>m</name> <init>= <expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>fieldno</name> <operator>&gt;=</operator> <name>fldct</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"missing data for column \"%s\""</literal></expr></argument>,
                                <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><index>[<expr><name>m</name></expr>]</index></name><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <name><name>field_strings</name><index>[<expr><name>fieldno</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>convert_select_flags</name></name> <operator>&amp;&amp;</operator>
                <operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>convert_select_flags</name><index>[<expr><name>m</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* ignore input field, leaving column as NULL */</comment>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>string</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                    <name><name>cstate</name><operator>-&gt;</operator><name>force_notnull_flags</name><index>[<expr><name>m</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * FORCE_NOT_NULL option is set and column is NULL -
                     * convert it to the NULL string.
                     */</comment>
                    <expr_stmt><expr><name>string</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>string</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>force_null_flags</name><index>[<expr><name>m</name></expr>]</index></name>
                         <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * FORCE_NULL option is set and column matches the NULL
                     * string. It must have been quoted, or otherwise the
                     * string would already have been set to NULL. Convert it
                     * to NULL as specified.
                     */</comment>
                    <expr_stmt><expr><name>string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><index>[<expr><name>m</name></expr>]</index></name><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attval</name></name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>values</name><index>[<expr><name>m</name></expr>]</index></name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>in_functions</name><index>[<expr><name>m</name></expr>]</index></name></expr></argument>,
                                          <argument><expr><name>string</name></expr></argument>,
                                          <argument><expr><name><name>typioparams</name><index>[<expr><name>m</name></expr>]</index></name></expr></argument>,
                                          <argument><expr><name><name>attr</name><index>[<expr><name>m</name></expr>]</index></name><operator>-&gt;</operator><name>atttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>string</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>m</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attval</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fieldno</name> <operator>==</operator> <name>nfields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* binary */</comment>
        <decl_stmt><decl><type><name>int16</name></type>        <name>fld_count</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name><operator>++</operator></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CopyGetInt16</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fld_count</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Empty buffer */</comment>
                <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Receive field count directly from Datanodes */</comment>
                <expr_stmt><expr><name>fld_count</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>fld_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>fld_count</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="block">/* EOF detected (end of file, or protocol-level EOF) */</comment>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>fld_count</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Received EOF marker.  In a V3-protocol copy, wait for the
             * protocol-level EOF, and complain if it doesn't come
             * immediately.  This ensures that we correctly handle CopyFail,
             * if client chooses to send that now.
             *
             * Note that we MUST NOT try to read more data in an old-protocol
             * copy, since there is no protocol-level EOF marker then.  We
             * could go either way for copy from file, but choose to throw
             * error if there's data after the EOF marker, for consistency
             * with the new-protocol case.
             */</comment>
            <decl_stmt><decl><type><name>char</name></type>        <name>dummy</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Empty buffer */</comment>
                <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Receive field count directly from Datanodes */</comment>
                <expr_stmt><expr><name>fld_count</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>fld_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>fld_count</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>!=</operator> <name>COPY_OLD_FE</name> <operator>&amp;&amp;</operator>
                <call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"received copy data after EOF marker"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>fld_count</name> <operator>!=</operator> <name>attr_count</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"row field count is %d, expected %d"</literal></expr></argument>,
                            <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>fld_count</name></expr></argument>, <argument><expr><name>attr_count</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Include the default value count also, because we are going to
             * append default values to the user-supplied attributes.
             */</comment>
            <decl_stmt><decl><type><name>int16</name></type> <name>total_fld_count</name> <init>= <expr><name>fld_count</name> <operator>+</operator> <name>num_defaults</name></expr></init></decl>;</decl_stmt>
            <comment type="block">/* Empty buffer */</comment>
            <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>total_fld_count</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>total_fld_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>total_fld_count</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if_stmt><if>if <condition>(<expr><name>file_has_oids</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>loaded_oid</name></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name> <operator>=</operator> <literal type="string">"oid"</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>loaded_oid</name> <operator>=</operator>
                <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>CopyReadBinaryAttribute</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>,
                                                         <argument><expr><literal type="number">0</literal></expr></argument>,
                                                         <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>oid_in_function</name></name></expr></argument>,
                                                         <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>oid_typioparam</name></name></expr></argument>,
                                                         <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                                                         <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>isnull</name> <operator>||</operator> <name>loaded_oid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid OID in COPY data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>oids</name></name> <operator>&amp;&amp;</operator> <name>tupleOid</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>tupleOid</name> <operator>=</operator> <name>loaded_oid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>cstate-&gt;attnumlist</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>m</name> <init>= <expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><index>[<expr><name>m</name></expr>]</index></name><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>values</name><index>[<expr><name>m</name></expr>]</index></name> <operator>=</operator> <call><name>CopyReadBinaryAttribute</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>,
                                                <argument><expr><name>i</name></expr></argument>,
                                                <argument><expr><operator>&amp;</operator><name><name>in_functions</name><index>[<expr><name>m</name></expr>]</index></name></expr></argument>,
                                                <argument><expr><name><name>typioparams</name><index>[<expr><name>m</name></expr>]</index></name></expr></argument>,
                                                <argument><expr><name><name>attr</name><index>[<expr><name>m</name></expr>]</index></name><operator>-&gt;</operator><name>atttypmod</name></expr></argument>,
                                                <argument><expr><operator>&amp;</operator><name><name>nulls</name><index>[<expr><name>m</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Now compute and insert any defaults available for the columns not
     * provided by the input data.  Anything not processed here or above will
     * remain NULL.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_defaults</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * The caller must supply econtext and have switched into the
         * per-tuple memory context in it.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>econtext</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name> <operator>==</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><name><name>defmap</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>defexprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name><name>nulls</name><index>[<expr><name><name>defmap</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Append default values to the data-row in output format. */</comment>
        <expr_stmt><expr><call><name>append_defvals</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<comment type="block">/*
 * append_defvals:
 * Append default values in output form onto the data-row.
 * 1. scans the default values with the help of defmap,
 * 2. converts each default value into its output form,
 * 3. then appends it into cstate-&gt;defval_buf buffer.
 * This buffer would later be appended into the final data row that is sent to
 * the Datanodes.
 * So for e.g., for a table :
 * tab (id1 int, v varchar, id2 default nextval('tab_id2_seq'::regclass), id3 )
 * with the user-supplied data  : "2 | abcd",
 * and the COPY command such as:
 * copy tab (id1, v) FROM '/tmp/a.txt' (delimiter '|');
 * Here, cstate-&gt;defval_buf will be populated with something like : "| 1"
 * and the final data row will be : "2 | abcd | 1"
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>append_defvals</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CopyStateData</name></type> <name>new_cstate</name> <init>= <expr><operator>*</operator><name>cstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>new_cstate</name><operator>.</operator><name>fe_msgbuf</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>num_defaults</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>attindex</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>defmap</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type> <name>defvalue</name> <init>= <expr><name><name>values</name><index>[<expr><name>attindex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_cstate</name></expr></argument>, <argument><expr><name><name>new_cstate</name><operator>.</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * For using the values in their output form, it is not sufficient
         * to just call its output function. The format should match
         * that of COPY because after all we are going to send this value as
         * an input data row to the Datanode using COPY FROM syntax. So we call
         * exactly those functions that are used to output the values in case
         * of COPY TO. For instace, CopyAttributeOutText() takes care of
         * escaping, CopySendInt32 take care of byte ordering, etc. All these
         * functions use cstate-&gt;fe_msgbuf to copy the data. But this field
         * already has the input data row. So, we need to use a separate
         * temporary cstate for this purpose. All the COPY options remain the
         * same, so new cstate will have all the fields copied from the original
         * cstate, except fe_msgbuf.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bytea</name>       <modifier>*</modifier></type><name>outputbytes</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>outputbytes</name> <operator>=</operator> <call><name>SendFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>out_functions</name><index>[<expr><name>attindex</name></expr>]</index></name></expr></argument>, <argument><expr><name>defvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CopySendInt32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_cstate</name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>outputbytes</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_cstate</name></expr></argument>, <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>outputbytes</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>outputbytes</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>OutputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>out_functions</name><index>[<expr><name>attindex</name></expr>]</index></name></expr></argument>, <argument><expr><name>defvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>CopyAttributeOutCSV</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_cstate</name></expr></argument>, <argument><expr><name>string</name></expr></argument>,
                                    <argument><expr><name>false</name></expr></argument> <comment type="block">/* don't force quote */</comment>,
                                    <argument><expr><name>false</name></expr></argument> <comment type="block">/* there's at least one user-supplied attribute */</comment> )</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>CopyAttributeOutText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_cstate</name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>insert_into</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>data_list</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>uint32</name></type> <name>n32</name> <init>= <expr><call><name>htonl</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>insert_into</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>data_list</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* do nothing, default values have been appended before */</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Append the generated default values to the user-supplied data-row */</comment>
    <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><name><name>new_cstate</name><operator>.</operator><name>fe_msgbuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
                                              <argument><expr><name><name>new_cstate</name><operator>.</operator><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * Clean up storage and release resources for COPY FROM.
 */</comment>
<function><type><name>void</name></type>
<name>EndCopyFrom</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <decl_stmt><decl><type><name>RemoteCopyData</name> <modifier>*</modifier></type><name>remoteCopyState</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>remoteCopyState</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* For PGXC related COPY, free also relation location data */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <name><name>remoteCopyState</name><operator>-&gt;</operator><name>rel_loc</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>DataNodeCopyFinish</name><argument_list>(<argument><expr><call><name>getLocatorNodeCount</name><argument_list>(<argument><expr><name><name>remoteCopyState</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>getLocatorNodeMap</name><argument_list>(<argument><expr><name><name>remoteCopyState</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FreeRemoteCopyData</name><argument_list>(<argument><expr><name>remoteCopyState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* No COPY FROM related resources except memory. */</comment>

    <expr_stmt><expr><call><name>EndCopy</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read the next input line and stash it in line_buf, with conversion to
 * server encoding.
 *
 * Result is true if read was terminated by EOF, false if terminated
 * by newline.  The terminating newline or EOF marker is not included
 * in the final value of line_buf.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CopyReadLine</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/* Mark that encoding conversion hasn't occurred yet */</comment>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf_converted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* Parse data and transfer into line_buf */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>CopyReadLineText</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Reached EOF.  In protocol version 3, we should ignore anything
         * after \. up to the protocol end of copy data.  (XXX maybe better
         * not to treat \. as special?)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>==</operator> <name>COPY_NEW_FE</name></expr>)</condition>
        <block>{<block_content>
            <do>do
            <block>{<block_content>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name></expr>;</expr_stmt>
            </block_content>}</block> while <condition>(<expr><call><name>CopyLoadRawBuf</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * If we didn't hit EOF, then we must have transferred the EOL marker
         * to line_buf along with the data.  Get rid of it.
         */</comment>
        <switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>EOL_NL</name></expr>:</case>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name><index>[<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name><operator>--</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name><index>[<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>EOL_CR</name></expr>:</case>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name><index>[<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name><operator>--</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name><index>[<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>EOL_CRNL</name></expr>:</case>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name><index>[<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name><index>[<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name><index>[<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>EOL_UNKNOWN</name></expr>:</case>
                <comment type="block">/* shouldn't get here */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Done reading the line.  Convert it to server encoding. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>need_transcoding</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cvt</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>cvt</name> <operator>=</operator> <call><name>pg_any_to_server</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name></expr></argument>,
                               <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr></argument>,
                               <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cvt</name> <operator>!=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* transfer converted data back to line_buf */</comment>
            <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><name>cvt</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cvt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cvt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Now it's safe to use the buffer in error messages */</comment>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf_converted</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CopyReadLineText - inner loop of CopyReadLine for text mode
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CopyReadLineText</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>copy_raw_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>raw_buf_ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>copy_buf_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>need_data</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>hit_eof</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>mblen_str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* CSV variables */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>first_char_in_line</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>in_quote</name> <init>= <expr><name>false</name></expr></init></decl>,
                <decl><type ref="prev"/><name>last_was_esc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>quotec</name> <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>escapec</name> <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>quotec</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>quote</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>escapec</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>escape</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <comment type="block">/* ignore special escape processing if it's the same as quotec */</comment>
        <if_stmt><if>if <condition>(<expr><name>quotec</name> <operator>==</operator> <name>escapec</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>escapec</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>mblen_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * The objective of this loop is to transfer the entire next input line
     * into line_buf.  Hence, we only care for detecting newlines (\r and/or
     * \n) and the end-of-copy marker (\.).
     *
     * In CSV mode, \r and \n inside a quoted field are just part of the data
     * value and are put in line_buf.  We keep just enough state to know if we
     * are currently in a quoted field or not.
     *
     * These four characters, and the CSV escape and quote characters, are
     * assumed the same in frontend and backend encodings.
     *
     * For speed, we try to move data from raw_buf to line_buf in chunks
     * rather than one character at a time.  raw_buf_ptr points to the next
     * character to examine; any characters from raw_buf_index to raw_buf_ptr
     * have been determined to be part of the line, but not yet transferred to
     * line_buf.
     *
     * For a little extra speed within the loop, we copy raw_buf and
     * raw_buf_len into local variables.
     */</comment>
    <expr_stmt><expr><name>copy_raw_buf</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>raw_buf_ptr</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>copy_buf_len</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name></expr>;</expr_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>prev_raw_ptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name>c</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Load more data if needed.  Ideally we would just force four bytes
         * of read-ahead and avoid the many calls to
         * IF_NEED_REFILL_AND_NOT_EOF_CONTINUE(), but the COPY_OLD_FE protocol
         * does not allow us to read too far ahead or we might read into the
         * next data, so we read-ahead only as far we know we can.  One
         * optimization would be to read-ahead four byte here if
         * cstate-&gt;copy_dest != COPY_OLD_FE, but it hardly seems worth it,
         * considering the size of the buffer.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>raw_buf_ptr</name> <operator>&gt;=</operator> <name>copy_buf_len</name> <operator>||</operator> <name>need_data</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>REFILL_LINEBUF</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Try to read some more data.  This will certainly reset
             * raw_buf_index to zero, and raw_buf_ptr must go with it.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CopyLoadRawBuf</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>hit_eof</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>raw_buf_ptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>copy_buf_len</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name></expr>;</expr_stmt>

            <comment type="block">/*
             * If we are completely out of data, break out of the loop,
             * reporting EOF.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>copy_buf_len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>need_data</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>internal_mode</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>whole_line</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>raw_buf_ptr</name> <operator>=</operator> <name>copy_buf_len</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>=</operator> <name>EOL_UNKNOWN</name></expr>;</expr_stmt>
                <return>return <expr><name>result</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* OK to fetch a character */</comment>
        <expr_stmt><expr><name>prev_raw_ptr</name> <operator>=</operator> <name>raw_buf_ptr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>copy_raw_buf</name><index>[<expr><name>raw_buf_ptr</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If character is '\\' or '\r', we may need to look ahead below.
             * Force fetch of the next character if we don't already have it.
             * We need to do this before changing CSV state, in case one of
             * these characters is also the quote or escape character.
             *
             * Note: old-protocol does not like forced prefetch, but it's OK
             * here since we cannot validly be at EOF.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>IF_NEED_REFILL_AND_NOT_EOF_CONTINUE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Dealing with quotes and escapes here is mildly tricky. If the
             * quote char is also the escape char, there's no problem - we
             * just use the char as a toggle. If they are different, we need
             * to ensure that we only take account of an escape inside a
             * quoted field and immediately preceding a quote char, and not
             * the second in an escape-escape sequence.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>in_quote</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <name>escapec</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>last_was_esc</name> <operator>=</operator> <operator>!</operator><name>last_was_esc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>quotec</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>last_was_esc</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>in_quote</name> <operator>=</operator> <operator>!</operator><name>in_quote</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>escapec</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>last_was_esc</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Updating the line count for embedded CR and/or LF chars is
             * necessarily a little fragile - this test is probably about the
             * best we can do.  (XXX it's arguable whether we should do this
             * at all --- is cur_lineno a physical or logical count?)
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>in_quote</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <operator>(</operator><ternary><condition><expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_NL</name></expr> ?</condition><then> <expr><literal type="char">'\n'</literal></expr> </then><else>: <expr><literal type="char">'\r'</literal></expr></else></ternary><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Process \r */</comment>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>||</operator> <operator>!</operator><name>in_quote</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Check for \r\n on first line, _and_ handle \r\n. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_UNKNOWN</name> <operator>||</operator>
                <name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_CRNL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * If need more data, go back to loop top to load it.
                 *
                 * Note that if we are at EOF, c will wind up as '\0' because
                 * of the guaranteed pad of raw_buf.
                 */</comment>
                <expr_stmt><expr><call><name>IF_NEED_REFILL_AND_NOT_EOF_CONTINUE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* get next char */</comment>
                <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>copy_raw_buf</name><index>[<expr><name>raw_buf_ptr</name></expr>]</index></name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>raw_buf_ptr</name><operator>++</operator></expr>;</expr_stmt>    <comment type="block">/* eat newline */</comment>
                    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>=</operator> <name>EOL_CRNL</name></expr>;</expr_stmt>    <comment type="block">/* in case not set yet */</comment>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* found \r, but no \n */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_CRNL</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <ternary><condition><expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr> ?</condition><then>
                                 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"literal carriage return found in data"</literal></expr></argument>)</argument_list></call></expr> </then><else>:
                                 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unquoted carriage return found in data"</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
                                 <ternary><condition><expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr> ?</condition><then>
                                 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use \"\\r\" to represent carriage return."</literal></expr></argument>)</argument_list></call></expr> </then><else>:
                                 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use quoted CSV field to represent carriage return."</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="block">/*
                     * if we got here, it is the first line and we didn't find
                     * \n, so don't consume the peeked character
                     */</comment>
                    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>=</operator> <name>EOL_CR</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_NL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <ternary><condition><expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr> ?</condition><then>
                         <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"literal carriage return found in data"</literal></expr></argument>)</argument_list></call></expr> </then><else>:
                         <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unquoted carriage return found in data"</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
                         <ternary><condition><expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr> ?</condition><then>
                         <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use \"\\r\" to represent carriage return."</literal></expr></argument>)</argument_list></call></expr> </then><else>:
                         <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use quoted CSV field to represent carriage return."</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* If reach here, we have found the line terminator */</comment>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Process \n */</comment>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>||</operator> <operator>!</operator><name>in_quote</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_CR</name> <operator>||</operator> <name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_CRNL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <ternary><condition><expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr> ?</condition><then>
                         <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"literal newline found in data"</literal></expr></argument>)</argument_list></call></expr> </then><else>:
                         <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unquoted newline found in data"</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
                         <ternary><condition><expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr> ?</condition><then>
                         <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use \"\\n\" to represent newline."</literal></expr></argument>)</argument_list></call></expr> </then><else>:
                         <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use quoted CSV field to represent newline."</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>=</operator> <name>EOL_NL</name></expr>;</expr_stmt>    <comment type="block">/* in case not set yet */</comment>
            <comment type="block">/* If reach here, we have found the line terminator */</comment>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * In CSV mode, we only recognize \. alone on a line.  This is because
         * \. is a valid CSV data value.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name> <operator>||</operator> <name>first_char_in_line</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type>        <name>c2</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>IF_NEED_REFILL_AND_NOT_EOF_CONTINUE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>IF_NEED_REFILL_AND_EOF_BREAK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* -----
             * get next character
             * Note: we do not change c so if it isn't \., we can fall
             * through and continue processing for file encoding.
             * -----
             */</comment>
            <expr_stmt><expr><name>c2</name> <operator>=</operator> <name><name>copy_raw_buf</name><index>[<expr><name>raw_buf_ptr</name></expr>]</index></name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>c2</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>raw_buf_ptr</name><operator>++</operator></expr>;</expr_stmt>    <comment type="block">/* consume the '.' */</comment>

                <comment type="block">/*
                 * Note: if we loop back for more data here, it does not
                 * matter that the CSV state change checks are re-executed; we
                 * will come back here with no important state changed.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_CRNL</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Get the next character */</comment>
                    <expr_stmt><expr><call><name>IF_NEED_REFILL_AND_NOT_EOF_CONTINUE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* if hit_eof, c2 will become '\0' */</comment>
                    <expr_stmt><expr><name>c2</name> <operator>=</operator> <name><name>copy_raw_buf</name><index>[<expr><name>raw_buf_ptr</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>c2</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"end-of-copy marker does not match previous newline style"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><name>NO_END_OF_COPY_GOTO</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>c2</name> <operator>!=</operator> <literal type="char">'\r'</literal></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"end-of-copy marker corrupt"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><name>NO_END_OF_COPY_GOTO</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* Get the next character */</comment>
                <expr_stmt><expr><call><name>IF_NEED_REFILL_AND_NOT_EOF_CONTINUE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* if hit_eof, c2 will become '\0' */</comment>
                <expr_stmt><expr><name>c2</name> <operator>=</operator> <name><name>copy_raw_buf</name><index>[<expr><name>raw_buf_ptr</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>c2</name> <operator>!=</operator> <literal type="char">'\r'</literal> <operator>&amp;&amp;</operator> <name>c2</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"end-of-copy marker corrupt"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>NO_END_OF_COPY_GOTO</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_NL</name> <operator>&amp;&amp;</operator> <name>c2</name> <operator>!=</operator> <literal type="char">'\n'</literal><operator>)</operator> <operator>||</operator>
                    <operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_CRNL</name> <operator>&amp;&amp;</operator> <name>c2</name> <operator>!=</operator> <literal type="char">'\n'</literal><operator>)</operator> <operator>||</operator>
                    <operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name> <operator>==</operator> <name>EOL_CR</name> <operator>&amp;&amp;</operator> <name>c2</name> <operator>!=</operator> <literal type="char">'\r'</literal><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"end-of-copy marker does not match previous newline style"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * Transfer only the data before the \. into line_buf, then
                 * discard the data and the \. sequence.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>prev_raw_ptr</name> <operator>&gt;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>,
                                           <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name></expr></argument>,
                                           <argument><expr><name>prev_raw_ptr</name> <operator>-</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name> <operator>=</operator> <name>raw_buf_ptr</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>    <comment type="block">/* report EOF */</comment>
                <break>break;</break>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>)</condition><block type="pseudo"><block_content>

                <comment type="block">/*
                 * If we are here, it means we found a backslash followed by
                 * something other than a period.  In non-CSV mode, anything
                 * after a backslash is special, so we skip over that second
                 * character too.  If we didn't do that \\. would be
                 * considered an eof-of copy, while in non-CSV mode it is a
                 * literal backslash followed by a period.  In CSV mode,
                 * backslashes are not special, so we want to process the
                 * character after the backslash just like a normal character,
                 * so we don't increment in those cases.
                 */</comment>
                <expr_stmt><expr><name>raw_buf_ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * This label is for CSV cases where \. appears at the start of a
         * line, but there is more text after it, meaning it was a data value.
         * We are more strict for \. in CSV mode because \. could be a data
         * value, while in non-CSV mode, \. cannot be a data value.
         */</comment>
<label><name>not_end_of_copy</name>:</label>

        <comment type="block">/*
         * Process all bytes of a multi-byte character as a group.
         *
         * We only support multi-byte sequences where the first byte has the
         * high-bit set, so as an optimization we can avoid this block
         * entirely if it is not set.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>encoding_embeds_ascii</name></name> <operator>&amp;&amp;</operator> <call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>mblen</name></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>mblen_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
            <comment type="block">/* All our encodings only read the first byte to get the length */</comment>
            <expr_stmt><expr><name>mblen</name> <operator>=</operator> <call><name>pg_encoding_mblen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>, <argument><expr><name>mblen_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>IF_NEED_REFILL_AND_NOT_EOF_CONTINUE</name><argument_list>(<argument><expr><name>mblen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>IF_NEED_REFILL_AND_EOF_BREAK</name><argument_list>(<argument><expr><name>mblen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>raw_buf_ptr</name> <operator>+=</operator> <name>mblen</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>first_char_in_line</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></for>                            <comment type="block">/* end of outer loop */</comment>

    <comment type="block">/*
     * Transfer any still-uncopied data to line_buf.
     */</comment>
    <expr_stmt><expr><name>REFILL_LINEBUF</name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *    Return decimal value for a hexadecimal digit
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>GetDecimalFromHex</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>hex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>hex</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>hex</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>hex</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="char">'a'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CopyReadAttributesInternal</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>fieldno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16</name></type>        <name>n16</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>n32</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>col_count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>data_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <comment type="line">//char *cur = cstate-&gt;raw_buf + cstate-&gt;raw_buf_index;</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n16</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cur</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <comment type="line">//cstate-&gt;raw_buf_index += 2;</comment>
    <expr_stmt><expr><name>data_len</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>col_count</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name>n16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>fieldno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>col_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

        <comment type="block">/* get size */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cur</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        <comment type="line">//cstate-&gt;raw_buf_index += 4;</comment>
        <expr_stmt><expr><name>data_len</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>max_fields</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>max_fields</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name></name> <operator>=</operator>
                <call><name>repalloc</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>max_fields</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
                
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name><index>[<expr><name>fieldno</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name><index>[<expr><name>fieldno</name></expr>]</index></name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>cur</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            <comment type="line">//cstate-&gt;raw_buf_index += len;</comment>
            <expr_stmt><expr><name>data_len</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>fieldno</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_index</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>data_len</name> <operator>!=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"copy datarow corrupted, expected data_length %d, result data_length %d"</literal></expr></argument>,
                     <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>data_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>fieldno</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Parse the current line into separate attributes (fields),
 * performing de-escaping as needed.
 *
 * The input is in line_buf.  We use attribute_buf to hold the result
 * strings.  cstate-&gt;raw_fields[k] is set to point to the k'th attribute
 * string, or NULL when the input matches the null marker string.
 * This array is expanded as necessary.
 *
 * (Note that the caller cannot check for nulls since the returned
 * string would be the post-de-escaping equivalent, which may look
 * the same as some valid data string.)
 *
 * delim is the column delimiter string (must be just one byte for now).
 * null_print is the null marker string.  Note that this is compared to
 * the pre-de-escaped input string.
 *
 * The return value is the number of fields actually read.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CopyReadAttributesText</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name>delimc</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>fieldno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>output_ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cur_ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>line_end_ptr</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We need a special case for zero-column tables: check that the input
     * line is empty, and return.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>max_fields</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extra data after last expected column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The de-escaped attributes will certainly not be longer than the input
     * data line, so we can just force attribute_buf to be large enough and
     * then transfer data without any checks for enough space.  We need to do
     * it this way because enlarging attribute_buf mid-stream would invalidate
     * pointers already stored into cstate-&gt;raw_fields[].
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>maxlen</name></name> <operator>&lt;=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>output_ptr</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

    <comment type="block">/* set pointer variables for loop */</comment>
    <expr_stmt><expr><name>cur_ptr</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>line_end_ptr</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

    <comment type="block">/* Outer loop iterates over fields */</comment>
    <expr_stmt><expr><name>fieldno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>        <name>found_delim</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>start_ptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>end_ptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>input_len</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>saw_non_ascii</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Make sure there is enough space for the next value */</comment>
        <if_stmt><if>if <condition>(<expr><name>fieldno</name> <operator>&gt;=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>max_fields</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>max_fields</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name></name> <operator>=</operator>
                <call><name>repalloc</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>max_fields</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Remember start of field on both input and output sides */</comment>
        <expr_stmt><expr><name>start_ptr</name> <operator>=</operator> <name>cur_ptr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name><index>[<expr><name>fieldno</name></expr>]</index></name> <operator>=</operator> <name>output_ptr</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Scan data for field.
         *
         * Note that in this loop, we are scanning to locate the end of field
         * and also speculatively performing de-escaping.  Once we find the
         * end-of-field, we can match the raw field contents against the null
         * marker string.  Only after that comparison fails do we know that
         * de-escaping is actually the right thing to do; therefore we *must
         * not* throw any syntax errors before we've done the null-marker
         * check.
         */</comment>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type>        <name>c</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>end_ptr</name> <operator>=</operator> <name>cur_ptr</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&gt;=</operator> <name>line_end_ptr</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>delimc</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>found_delim</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&gt;=</operator> <name>line_end_ptr</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><literal type="char">'0'</literal></expr>:</case>
                    <case>case <expr><literal type="char">'1'</literal></expr>:</case>
                    <case>case <expr><literal type="char">'2'</literal></expr>:</case>
                    <case>case <expr><literal type="char">'3'</literal></expr>:</case>
                    <case>case <expr><literal type="char">'4'</literal></expr>:</case>
                    <case>case <expr><literal type="char">'5'</literal></expr>:</case>
                    <case>case <expr><literal type="char">'6'</literal></expr>:</case>
                    <case>case <expr><literal type="char">'7'</literal></expr>:</case>
                        <block>{<block_content>
                            <comment type="block">/* handle \013 */</comment>
                            <decl_stmt><decl><type><name>int</name></type>            <name>val</name></decl>;</decl_stmt>

                            <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>OCTVALUE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&lt;</operator> <name>line_end_ptr</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cur_ptr</name></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><call><name>ISOCTAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>
                                    <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <call><name>OCTVALUE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&lt;</operator> <name>line_end_ptr</name></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cur_ptr</name></expr>;</expr_stmt>
                                        <if_stmt><if>if <condition>(<expr><call><name>ISOCTAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
                                        <block>{<block_content>
                                            <expr_stmt><expr><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>
                                            <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <call><name>OCTVALUE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        </block_content>}</block></if></if_stmt>
                                    </block_content>}</block></if></if_stmt>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block></if></if_stmt>
                            <expr_stmt><expr><name>c</name> <operator>=</operator> <name>val</name> <operator>&amp;</operator> <literal type="number">0377</literal></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>saw_non_ascii</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        </block_content>}</block>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'x'</literal></expr>:</case>
                        <comment type="block">/* Handle \x3F */</comment>
                        <if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&lt;</operator> <name>line_end_ptr</name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>char</name></type>        <name>hexchar</name> <init>= <expr><operator>*</operator><name>cur_ptr</name></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><call><name>isxdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>hexchar</name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>int</name></type>            <name>val</name> <init>= <expr><call><name>GetDecimalFromHex</name><argument_list>(<argument><expr><name>hexchar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                <expr_stmt><expr><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&lt;</operator> <name>line_end_ptr</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>hexchar</name> <operator>=</operator> <operator>*</operator><name>cur_ptr</name></expr>;</expr_stmt>
                                    <if_stmt><if>if <condition>(<expr><call><name>isxdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>hexchar</name></expr></argument>)</argument_list></call></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>
                                        <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator> <call><name>GetDecimalFromHex</name><argument_list>(<argument><expr><name>hexchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>
                                </block_content>}</block></if></if_stmt>
                                <expr_stmt><expr><name>c</name> <operator>=</operator> <name>val</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><name>saw_non_ascii</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'b'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\b'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'f'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\f'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'n'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'r'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\r'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'t'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\t'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'v'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\v'</literal></expr>;</expr_stmt>
                        <break>break;</break>

                        <comment type="block">/*
                         * in all other cases, take the char after '\'
                         * literally
                         */</comment>
                </block_content>}</block></switch>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Add c to output string */</comment>
            <expr_stmt><expr><operator>*</operator><name>output_ptr</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Check whether raw input matched null marker */</comment>
        <expr_stmt><expr><name>input_len</name> <operator>=</operator> <name>end_ptr</name> <operator>-</operator> <name>start_ptr</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>input_len</name> <operator>==</operator> <name><name>cstate</name><operator>-&gt;</operator><name>null_print_len</name></name> <operator>&amp;&amp;</operator>
            <call><name>strncmp</name><argument_list>(<argument><expr><name>start_ptr</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>, <argument><expr><name>input_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name><index>[<expr><name>fieldno</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * At this point we know the field is supposed to contain data.
             *
             * If we de-escaped any non-7-bit-ASCII chars, make sure the
             * resulting string is valid data for the db encoding.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>saw_non_ascii</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>fld</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name><index>[<expr><name>fieldno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>pg_verifymbstr</name><argument_list>(<argument><expr><name>fld</name></expr></argument>, <argument><expr><name>output_ptr</name> <operator>-</operator> <name>fld</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Terminate attribute value in output area */</comment>
        <expr_stmt><expr><operator>*</operator><name>output_ptr</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name>fieldno</name><operator>++</operator></expr>;</expr_stmt>
        <comment type="block">/* Done if we hit EOL instead of a delim */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_delim</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Clean up state of attribute_buf */</comment>
    <expr_stmt><expr><name>output_ptr</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>output_ptr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <operator>(</operator><name>output_ptr</name> <operator>-</operator> <name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>data</name></name><operator>)</operator></expr>;</expr_stmt>

    <return>return <expr><name>fieldno</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse the current line into separate attributes (fields),
 * performing de-escaping as needed.  This has exactly the same API as
 * CopyReadAttributesText, except we parse the fields according to
 * "standard" (i.e. common) CSV usage.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CopyReadAttributesCSV</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name>delimc</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>quotec</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>quote</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>escapec</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>fieldno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>output_ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cur_ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>line_end_ptr</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We need a special case for zero-column tables: check that the input
     * line is empty, and return.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>max_fields</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extra data after last expected column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The de-escaped attributes will certainly not be longer than the input
     * data line, so we can just force attribute_buf to be large enough and
     * then transfer data without any checks for enough space.  We need to do
     * it this way because enlarging attribute_buf mid-stream would invalidate
     * pointers already stored into cstate-&gt;raw_fields[].
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>maxlen</name></name> <operator>&lt;=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>output_ptr</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

    <comment type="block">/* set pointer variables for loop */</comment>
    <expr_stmt><expr><name>cur_ptr</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>line_end_ptr</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

    <comment type="block">/* Outer loop iterates over fields */</comment>
    <expr_stmt><expr><name>fieldno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>        <name>found_delim</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>saw_quote</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>start_ptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>end_ptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>input_len</name></decl>;</decl_stmt>

        <comment type="block">/* Make sure there is enough space for the next value */</comment>
        <if_stmt><if>if <condition>(<expr><name>fieldno</name> <operator>&gt;=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>max_fields</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>max_fields</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name></name> <operator>=</operator>
                <call><name>repalloc</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>max_fields</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Remember start of field on both input and output sides */</comment>
        <expr_stmt><expr><name>start_ptr</name> <operator>=</operator> <name>cur_ptr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name><index>[<expr><name>fieldno</name></expr>]</index></name> <operator>=</operator> <name>output_ptr</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Scan data for field,
         *
         * The loop starts in "not quote" mode and then toggles between that
         * and "in quote" mode. The loop exits normally if it is in "not
         * quote" mode and a delimiter or line end is seen.
         */</comment>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type>        <name>c</name></decl>;</decl_stmt>

            <comment type="block">/* Not in quote */</comment>
            <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name>end_ptr</name> <operator>=</operator> <name>cur_ptr</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&gt;=</operator> <name>line_end_ptr</name></expr>)</condition><block type="pseudo"><block_content>
                    <goto>goto <name>endfield</name>;</goto></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>
                <comment type="block">/* unquoted field delimiter */</comment>
                <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>delimc</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>found_delim</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <goto>goto <name>endfield</name>;</goto>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* start of quoted field (or part of field) */</comment>
                <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>quotec</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>saw_quote</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* Add c to output string */</comment>
                <expr_stmt><expr><operator>*</operator><name>output_ptr</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
            </block_content>}</block></for>

            <comment type="block">/* In quote */</comment>
            <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name>end_ptr</name> <operator>=</operator> <name>cur_ptr</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&gt;=</operator> <name>line_end_ptr</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unterminated CSV quoted field"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>

                <comment type="block">/* escape within a quoted field */</comment>
                <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>escapec</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * peek at the next char if available, and escape it if it
                     * is an escape char or a quote char
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&lt;</operator> <name>line_end_ptr</name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>char</name></type>        <name>nextc</name> <init>= <expr><operator>*</operator><name>cur_ptr</name></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><name>nextc</name> <operator>==</operator> <name>escapec</name> <operator>||</operator> <name>nextc</name> <operator>==</operator> <name>quotec</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><operator>*</operator><name>output_ptr</name><operator>++</operator> <operator>=</operator> <name>nextc</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * end of quoted field. Must do this test after testing for
                 * escape in case quote char and escape char are the same
                 * (which is the common case).
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>quotec</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>

                <comment type="block">/* Add c to output string */</comment>
                <expr_stmt><expr><operator>*</operator><name>output_ptr</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>
<label><name>endfield</name>:</label>

        <comment type="block">/* Terminate attribute value in output area */</comment>
        <expr_stmt><expr><operator>*</operator><name>output_ptr</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

        <comment type="block">/* Check whether raw input matched null marker */</comment>
        <expr_stmt><expr><name>input_len</name> <operator>=</operator> <name>end_ptr</name> <operator>-</operator> <name>start_ptr</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>saw_quote</name> <operator>&amp;&amp;</operator> <name>input_len</name> <operator>==</operator> <name><name>cstate</name><operator>-&gt;</operator><name>null_print_len</name></name> <operator>&amp;&amp;</operator>
            <call><name>strncmp</name><argument_list>(<argument><expr><name>start_ptr</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>, <argument><expr><name>input_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>raw_fields</name><index>[<expr><name>fieldno</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>fieldno</name><operator>++</operator></expr>;</expr_stmt>
        <comment type="block">/* Done if we hit EOL instead of a delim */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_delim</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Clean up state of attribute_buf */</comment>
    <expr_stmt><expr><name>output_ptr</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>output_ptr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <operator>(</operator><name>output_ptr</name> <operator>-</operator> <name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>data</name></name><operator>)</operator></expr>;</expr_stmt>

    <return>return <expr><name>fieldno</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Read a binary attribute
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>CopyReadBinaryAttribute</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>,
                        <parameter><decl><type><name>int</name></type> <name>column_no</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>,
                        <parameter><decl><type><name>Oid</name></type> <name>typioparam</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int32</name></type>        <name>fld_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>         <name>nSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CopyGetInt32</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fld_size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF in COPY data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Add field size to the data row, unless it is invalid. */</comment>
        <if_stmt><if>if <condition>(<expr><name>fld_size</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <comment type="block">/* -1 is valid; it means NULL value */</comment>
        <block>{<block_content>
            <expr_stmt><expr><name>nSize</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>fld_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>,
                                   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>nSize</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>fld_size</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <return>return <expr><call><name>ReceiveFunctionCall</name><argument_list>(<argument><expr><name>flinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>fld_size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid field size"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* reset attribute_buf to empty, and load raw data in it */</comment>
    <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name></name></expr></argument>, <argument><expr><name>fld_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>CopyGetData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>data</name></name></expr></argument>,
                    <argument><expr><name>fld_size</name></expr></argument>, <argument><expr><name>fld_size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>fld_size</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_BAD_COPY_FILE_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF in COPY data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>fld_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>data</name><index>[<expr><name>fld_size</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* add the binary attribute value to the data row */</comment>
        <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>fld_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Call the column type's binary input converter */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ReceiveFunctionCall</name><argument_list>(<argument><expr><name>flinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name></name></expr></argument>,
                                 <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Trouble if it didn't eat the whole buffer */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>cursor</name></name> <operator>!=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"incorrect binary data format"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send text representation of one attribute, with conversion and escaping
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMPSOFAR</name><parameter_list>()</parameter_list></cpp:macro> \
    <cpp:value>do { \
        if (ptr &gt; start) \
            CopySendData(cstate, start, ptr - start); \
    } while (0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopyAttributeOutText</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>delimc</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>need_transcoding</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>pg_server_to_any</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>string</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * We have to grovel through the string searching for control characters
     * and instances of the delimiter character.  In most cases, though, these
     * are infrequent.  To avoid overhead from calling CopySendData once per
     * character, we dump out all characters between escaped characters in a
     * single call.  The loop invariant is that the data from "start" to "ptr"
     * can be sent literally, but hasn't yet been.
     *
     * We can skip pg_encoding_mblen() overhead when encoding is safe, because
     * in valid backend encodings, extra bytes of a multibyte character never
     * look like ASCII.  This loop is sufficiently performance-critical that
     * it's worth making two copies of it to get the IS_HIGHBIT_SET() test out
     * of the normal safe-encoding path.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>encoding_embeds_ascii</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>start</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>ptr</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <literal type="number">0x20</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * \r and \n must be escaped, the others are traditional. We
                 * prefer to dump these using the C-like notation, rather than
                 * a backslash and the literal character, because it makes the
                 * dump file a bit more proof against Microsoftish data
                 * mangling.
                 */</comment>
                <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><literal type="char">'\b'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'b'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'\f'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'\n'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'n'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'\r'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'r'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'\t'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'\v'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'v'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <default>default:</default>
                        <comment type="block">/* If it's the delimiter, must backslash it */</comment>
                        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>delimc</name></expr>)</condition><block type="pseudo"><block_content>
                            <break>break;</break></block_content></block></if></if_stmt>
                        <comment type="block">/* All ASCII control chars are length 1 */</comment>
                        <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
                        <continue>continue;</continue>    <comment type="block">/* fall to end of loop */</comment>
                </block_content>}</block></switch>
                <comment type="block">/* if we get here, we need to convert the control char */</comment>
                <expr_stmt><expr><call><name>DUMPSOFAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>start</name> <operator>=</operator> <operator>++</operator><name>ptr</name></expr>;</expr_stmt>    <comment type="block">/* do not include char in next run */</comment>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <name>delimc</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>DUMPSOFAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>start</name> <operator>=</operator> <name>ptr</name><operator>++</operator></expr>;</expr_stmt>    <comment type="block">/* we include char in next run */</comment>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>pg_encoding_mblen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>start</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>ptr</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <literal type="number">0x20</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * \r and \n must be escaped, the others are traditional. We
                 * prefer to dump these using the C-like notation, rather than
                 * a backslash and the literal character, because it makes the
                 * dump file a bit more proof against Microsoftish data
                 * mangling.
                 */</comment>
                <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><literal type="char">'\b'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'b'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'\f'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'\n'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'n'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'\r'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'r'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'\t'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'\v'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'v'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <default>default:</default>
                        <comment type="block">/* If it's the delimiter, must backslash it */</comment>
                        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>delimc</name></expr>)</condition><block type="pseudo"><block_content>
                            <break>break;</break></block_content></block></if></if_stmt>
                        <comment type="block">/* All ASCII control chars are length 1 */</comment>
                        <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
                        <continue>continue;</continue>    <comment type="block">/* fall to end of loop */</comment>
                </block_content>}</block></switch>
                <comment type="block">/* if we get here, we need to convert the control char */</comment>
                <expr_stmt><expr><call><name>DUMPSOFAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>start</name> <operator>=</operator> <operator>++</operator><name>ptr</name></expr>;</expr_stmt>    <comment type="block">/* do not include char in next run */</comment>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <name>delimc</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>DUMPSOFAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>start</name> <operator>=</operator> <name>ptr</name><operator>++</operator></expr>;</expr_stmt>    <comment type="block">/* we include char in next run */</comment>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>DUMPSOFAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Send text representation of one attribute, with conversion and
 * CSV-style escaping
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopyAttributeOutCSV</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>,
                    <parameter><decl><type><name>bool</name></type> <name>use_quote</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>single_attr</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>delimc</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>quotec</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>quote</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>escapec</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* force quoting if it matches null_print (before conversion!) */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_quote</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>use_quote</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>need_transcoding</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>pg_server_to_any</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>string</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Make a preliminary pass to discover if it needs quoting
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_quote</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Because '\.' can be a data value, quote it if it appears alone on a
         * line so it is not interpreted as the end-of-data marker.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>single_attr</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"\\."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>use_quote</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>tptr</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>tptr</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>delimc</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>quotec</name> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>use_quote</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>encoding_embeds_ascii</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>tptr</name> <operator>+=</operator> <call><name>pg_encoding_mblen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>, <argument><expr><name>tptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>tptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></while>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>use_quote</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>quotec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We adopt the same optimization strategy as in CopyAttributeOutText
         */</comment>
        <expr_stmt><expr><name>start</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>ptr</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>quotec</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>escapec</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>DUMPSOFAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>escapec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>start</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>    <comment type="block">/* we include char in next run */</comment>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>encoding_embeds_ascii</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>pg_encoding_mblen</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>DUMPSOFAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>quotec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* If it doesn't need quoting, we can just dump it as-is */</comment>
        <expr_stmt><expr><call><name>CopySendString</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CopyGetAttnums - build an integer list of attnums to be copied
 *
 * The input attnamelist is either the user-specified column list,
 * or NIL if there was none (in which case we want all the non-dropped
 * columns).
 *
 * rel can be NULL ... it's only used for error reports.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>CopyGetAttnums</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attnamelist</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>attnums</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>attnamelist</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Generate default column list */</comment>
        <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>attr</name> <init>= <expr><name><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>attr_count</name> <init>= <expr><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>attr</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Validate the user-supplied list and extract attnums */</comment>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>attnamelist</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

            <comment type="block">/* Lookup column name */</comment>
            <expr_stmt><expr><name>attnum</name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attname</name><operator>)</operator></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attnum</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>rel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
                                    <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" does not exist"</literal></expr></argument>,
                                    <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* Check for duplicates */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>list_member_int</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" specified more than once"</literal></expr></argument>,
                                <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>attnums</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * copy_dest_startup --- executor startup
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_dest_startup</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>operation</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>typeinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* no-op */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * copy_dest_receive --- receive one tuple
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>copy_dest_receive</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DR_copy</name>    <modifier>*</modifier></type><name>myState</name> <init>= <expr><operator>(</operator><name>DR_copy</name> <operator>*</operator><operator>)</operator> <name>self</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CopyState</name></type>    <name>cstate</name> <init>= <expr><name><name>myState</name><operator>-&gt;</operator><name>cstate</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Make sure the tuple is fully deconstructed */</comment>
    <expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* And send the data */</comment>
    <expr_stmt><expr><call><name>CopyOneRowTo</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myState</name><operator>-&gt;</operator><name>processed</name></name><operator>++</operator></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * copy_dest_shutdown --- executor end
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_dest_shutdown</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* no-op */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * copy_dest_destroy --- release DestReceiver object
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_dest_destroy</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CreateCopyDestReceiver -- create a suitable DestReceiver object
 */</comment>
<function><type><name>DestReceiver</name> <modifier>*</modifier></type>
<name>CreateCopyDestReceiver</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DR_copy</name>    <modifier>*</modifier></type><name>self</name> <init>= <expr><operator>(</operator><name>DR_copy</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DR_copy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>receiveSlot</name></name> <operator>=</operator> <name>copy_dest_receive</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rStartup</name></name> <operator>=</operator> <name>copy_dest_startup</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rShutdown</name></name> <operator>=</operator> <name>copy_dest_shutdown</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rDestroy</name></name> <operator>=</operator> <name>copy_dest_destroy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>mydest</name></name> <operator>=</operator> <name>DestCopyOut</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>cstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>        <comment type="block">/* will be set later */</comment>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>DestReceiver</name> <operator>*</operator><operator>)</operator> <name>self</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>RemoteCopyOptions</name> <modifier>*</modifier></type>
<name>GetRemoteCopyOptions</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>RemoteCopyOptions</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>makeRemoteCopyOptions</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Then fill in structure */</comment>
    <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>rco_binary</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>rco_oids</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>oids</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>rco_csv_mode</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>rco_delim</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>rco_null_print</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>quote</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>rco_quote</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>quote</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>rco_escape</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>rco_force_quote</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_notnull</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>rco_force_notnull</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_notnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>rco_insert_into</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>insert_into</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
